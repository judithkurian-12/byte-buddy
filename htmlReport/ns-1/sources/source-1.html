


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ByteBuddy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy</a>
</div>

<h1>Coverage Summary for Class: ByteBuddy (net.bytebuddy)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ByteBuddy</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (40/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.3%
  </span>
  <span class="absValue">
    (109/141)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ByteBuddy$EnumerationImplementation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$EnumerationImplementation$InitializationAppender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (26/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$EnumerationImplementation$ValuesMethodAppender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$0FtGNe7k</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$0gYk6ZDv</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$0oGu2jY8</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$0SMIs7mZ</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$3dTIrRVC</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$3eYfosvM</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$492YmlpA</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$6ggXJptl</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$99tfRE1Q</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$AvVc0SWA</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$cakqi82U</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Ci4bGO1P</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$DVvrH964</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$DWnTQGSY</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$E19zBDWO</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$E82ivi1A</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$fpwpHsbz</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$GjNUpDlP</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Gr4XvVqI</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$ICI68djJ</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Ja2B6B1Y</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Jlh3Qkfb</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$jpxSWQbV</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$KBy3HJH5</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$mfbIBh6v</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Mlq7D6WH</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$nUKNRKDm</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$P8eK2RhC</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$ptPdrZgW</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$rquJJAzx</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$S8tiIGKj</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$SroUDoDc</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$suitz0kh</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$uDaEpMxg</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Wddab37S</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$wEJXHs5N</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$WHUXvnsb</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$x3CABoL5</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$X4kClIlY</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$XPtQRNOd</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$YIHAxSL6</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$ytyYS9tg</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$Z86axtbH</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$ZeHjlYfc</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$MockitoMock$2146964618$auxiliary$ZHpDqvIL</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$RecordConstructorStrategy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (30/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$RecordConstructorStrategy$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddy$RecordObjectMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.9%
  </span>
  <span class="absValue">
    (31/32)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (60/68)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.8%
  </span>
  <span class="absValue">
    (238/271)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy;
&nbsp;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.modifier.*;
&nbsp;import net.bytebuddy.description.type.*;
&nbsp;import net.bytebuddy.dynamic.*;
&nbsp;import net.bytebuddy.dynamic.scaffold.*;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.DecoratingDynamicTypeBuilder;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.RebaseDynamicTypeBuilder;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.RedefinitionDynamicTypeBuilder;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.SubclassDynamicTypeBuilder;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodCall;
&nbsp;import net.bytebuddy.implementation.SuperMethodCall;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationRetention;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.TextConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.LatentMatcher;
&nbsp;import net.bytebuddy.utility.*;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * Instances of this class serve as a focus point for configuration of the library&#39;s behavior and as an entry point
&nbsp; * to any form of code generation using the library. For this purpose, Byte Buddy offers a fluent API which allows
&nbsp; * for the step-wise generation of a new Java type. A type is generated either by:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;&lt;b&gt;Subclassing&lt;/b&gt; some type: A subclass - as the name suggests - extends another, existing Java type. Virtual
&nbsp; * members of the generated type&#39;s super types can be overridden. Subclasses can also be interface extensions of one
&nbsp; * or several interfaces.&lt;/li&gt;
&nbsp; * &lt;li&gt;&lt;b&gt;Redefining&lt;/b&gt; a type: By redefining a type, it is not only possible to override virtual methods of the
&nbsp; * redefined type but also to redefine existing methods. This way, it is also possible to change the behavior of
&nbsp; * non-virtual methods and constructors of the redefined type.&lt;/li&gt;
&nbsp; * &lt;li&gt;&lt;b&gt;Rebasing&lt;/b&gt; a type: Rebasing a type works similar to creating a subclass, i.e. any method being overridden
&nbsp; * is still capable of invoking any original code of the rebased type. Any rebased method is however inlined into the
&nbsp; * rebased type and any original code is preserved automatically. This way, the type&#39;s identity does not change.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * Byte Buddy&#39;s API does not change when a type is rebased, redefined or subclassed. All types are created via the
&nbsp; * {@link net.bytebuddy.dynamic.DynamicType.Builder} interface. Byte Buddy&#39;s API is expressed by fully immutable
&nbsp; * components and is therefore thread-safe. As a consequence, method calls must be chained for all of Byte Buddy&#39;s
&nbsp; * component, e.g. a method call like the following has no effect:
&nbsp; * &lt;pre&gt;
&nbsp; * ByteBuddy byteBuddy = new ByteBuddy();
&nbsp; * byteBuddy.foo()&lt;/pre&gt;
&nbsp; * Instead, the following method chain is correct use of the API:
&nbsp; * &lt;pre&gt;
&nbsp; * ByteBuddy byteBuddy = new ByteBuddy().foo();&lt;/pre&gt;
&nbsp; * &lt;p&gt;
&nbsp; * For the creation of Java agents, Byte Buddy offers a convenience API implemented by the
&nbsp; * {@link net.bytebuddy.agent.builder.AgentBuilder}. The API wraps a {@link ByteBuddy} instance and offers agent-specific
&nbsp; * configuration opportunities by integrating against the {@link java.lang.instrument.Instrumentation} API.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @see net.bytebuddy.agent.builder.AgentBuilder
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class ByteBuddy {
&nbsp;
&nbsp;    /**
&nbsp;     * A property that controls the default naming strategy. If not set, Byte Buddy is generating
&nbsp;     * random names for types that are not named explicitly. If set to {@code fixed}, Byte Buddy is
&nbsp;     * setting names deterministically without any random element, or to {@code caller}, if a name
&nbsp;     * should be fixed but contain the name of the caller class and method. If set to a numeric
&nbsp;     * value, Byte Buddy is generating random names, using the number as a seed.
&nbsp;     */
&nbsp;    public static final String DEFAULT_NAMING_PROPERTY = &quot;net.bytebuddy.naming&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The default prefix for the default {@link net.bytebuddy.NamingStrategy}.
&nbsp;     */
&nbsp;    private static final String BYTE_BUDDY_DEFAULT_PREFIX = &quot;ByteBuddy&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The default suffix when defining a {@link AuxiliaryType.NamingStrategy}.
&nbsp;     */
&nbsp;    private static final String BYTE_BUDDY_DEFAULT_SUFFIX = &quot;auxiliary&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The default name of a fixed context name for synthetic fields and methods.
&nbsp;     */
&nbsp;    private static final String BYTE_BUDDY_DEFAULT_CONTEXT_NAME = &quot;synthetic&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The default naming strategy or {@code null} if no such strategy is set.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    private static final NamingStrategy DEFAULT_NAMING_STRATEGY;
&nbsp;
&nbsp;    /**
&nbsp;     * The default auxiliary naming strategy or {@code null} if no such strategy is set.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    private static final AuxiliaryType.NamingStrategy DEFAULT_AUXILIARY_NAMING_STRATEGY;
&nbsp;
&nbsp;    /**
&nbsp;     * The default implementation context factory or {@code null} if no such factory is set.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    private static final Implementation.Context.Factory DEFAULT_IMPLEMENTATION_CONTEXT_FACTORY;
&nbsp;
&nbsp;    /*
&nbsp;     * Resolves the default naming strategy.
&nbsp;     */
&nbsp;    static {
<b class="fc">&nbsp;        String value = doPrivileged(new GetSystemPropertyAction(DEFAULT_NAMING_PROPERTY));</b>
&nbsp;        NamingStrategy namingStrategy;
&nbsp;        AuxiliaryType.NamingStrategy auxiliaryNamingStrategy;
&nbsp;        Implementation.Context.Factory implementationContextFactory;
<b class="fc">&nbsp;        if (value == null) {</b>
<b class="fc">&nbsp;            if (GraalImageCode.getCurrent().isDefined()) {</b>
<b class="nc">&nbsp;                namingStrategy = new NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_PREFIX,</b>
&nbsp;                        new NamingStrategy.Suffixing.BaseNameResolver.WithCallerSuffix(NamingStrategy.Suffixing.BaseNameResolver.ForUnnamedType.INSTANCE),
&nbsp;                        NamingStrategy.BYTE_BUDDY_RENAME_PACKAGE);
<b class="nc">&nbsp;                auxiliaryNamingStrategy = new AuxiliaryType.NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_SUFFIX);</b>
<b class="nc">&nbsp;                implementationContextFactory = new Implementation.Context.Default.Factory.WithFixedSuffix(BYTE_BUDDY_DEFAULT_CONTEXT_NAME);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                namingStrategy = null;</b>
<b class="fc">&nbsp;                auxiliaryNamingStrategy = null;</b>
<b class="fc">&nbsp;                implementationContextFactory = null;</b>
&nbsp;            }
<b class="nc">&nbsp;        } else if (value.equalsIgnoreCase(&quot;fixed&quot;)) {</b>
<b class="nc">&nbsp;            namingStrategy = new NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_PREFIX,</b>
&nbsp;                    NamingStrategy.Suffixing.BaseNameResolver.ForUnnamedType.INSTANCE,
&nbsp;                    NamingStrategy.BYTE_BUDDY_RENAME_PACKAGE);
<b class="nc">&nbsp;            auxiliaryNamingStrategy = new AuxiliaryType.NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_SUFFIX);</b>
<b class="nc">&nbsp;            implementationContextFactory = new Implementation.Context.Default.Factory.WithFixedSuffix(BYTE_BUDDY_DEFAULT_CONTEXT_NAME);</b>
<b class="nc">&nbsp;        } else if (value.equalsIgnoreCase(&quot;caller&quot;)) {</b>
<b class="nc">&nbsp;            namingStrategy = new NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_PREFIX,</b>
&nbsp;                    new NamingStrategy.Suffixing.BaseNameResolver.WithCallerSuffix(NamingStrategy.Suffixing.BaseNameResolver.ForUnnamedType.INSTANCE),
&nbsp;                    NamingStrategy.BYTE_BUDDY_RENAME_PACKAGE);
<b class="nc">&nbsp;            auxiliaryNamingStrategy = new AuxiliaryType.NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_SUFFIX);</b>
<b class="nc">&nbsp;            implementationContextFactory = new Implementation.Context.Default.Factory.WithFixedSuffix(BYTE_BUDDY_DEFAULT_CONTEXT_NAME);</b>
&nbsp;        } else {
&nbsp;            long seed;
&nbsp;            try {
<b class="nc">&nbsp;                seed = Long.parseLong(value);</b>
<b class="nc">&nbsp;            } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;&#39;net.bytebuddy.naming&#39; is set to an unknown, non-numeric value: &quot; + value);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            namingStrategy = new NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_PREFIX,</b>
&nbsp;                    NamingStrategy.Suffixing.BaseNameResolver.ForUnnamedType.INSTANCE,
&nbsp;                    NamingStrategy.BYTE_BUDDY_RENAME_PACKAGE,
&nbsp;                    new RandomString(RandomString.DEFAULT_LENGTH, new Random(seed)));
<b class="nc">&nbsp;            auxiliaryNamingStrategy = new AuxiliaryType.NamingStrategy.Suffixing(BYTE_BUDDY_DEFAULT_SUFFIX);</b>
<b class="nc">&nbsp;            implementationContextFactory = new Implementation.Context.Default.Factory.WithFixedSuffix(BYTE_BUDDY_DEFAULT_CONTEXT_NAME);</b>
&nbsp;        }
<b class="fc">&nbsp;        DEFAULT_NAMING_STRATEGY = namingStrategy;</b>
<b class="fc">&nbsp;        DEFAULT_AUXILIARY_NAMING_STRATEGY = auxiliaryNamingStrategy;</b>
<b class="fc">&nbsp;        DEFAULT_IMPLEMENTATION_CONTEXT_FACTORY = implementationContextFactory;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;     *
&nbsp;     * @param action The action to execute from a privileged context.
&nbsp;     * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;     * @return The action&#39;s resolved value.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @AccessControllerPlugin.Enhance
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;        return action.run();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The class file version to use for types that are not based on an existing class file.
&nbsp;     */
&nbsp;    protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;    /**
&nbsp;     * The naming strategy to use.
&nbsp;     */
&nbsp;    protected final NamingStrategy namingStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * The naming strategy to use for naming auxiliary types.
&nbsp;     */
&nbsp;    protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * The annotation value filter factory to use.
&nbsp;     */
&nbsp;    protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * The annotation retention strategy to use.
&nbsp;     */
&nbsp;    protected final AnnotationRetention annotationRetention;
&nbsp;
&nbsp;    /**
&nbsp;     * The implementation context factory to use.
&nbsp;     */
&nbsp;    protected final Implementation.Context.Factory implementationContextFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * The method graph compiler to use.
&nbsp;     */
&nbsp;    protected final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;    /**
&nbsp;     * The instrumented type factory to use.
&nbsp;     */
&nbsp;    protected final InstrumentedType.Factory instrumentedTypeFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;     */
&nbsp;    protected final LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if a type should be explicitly validated.
&nbsp;     */
&nbsp;    protected final TypeValidation typeValidation;
&nbsp;
&nbsp;    /**
&nbsp;     * The visibility bridge strategy to apply.
&nbsp;     */
&nbsp;    protected final VisibilityBridgeStrategy visibilityBridgeStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * The class writer strategy to use.
&nbsp;     */
&nbsp;    protected final ClassWriterStrategy classWriterStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new Byte Buddy instance with a default configuration that is suitable for most use cases.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When creating this configuration, Byte Buddy attempts to discover the current JVM&#39;s version. If this
&nbsp;     * is not possible, class files are created Java 6-compatible.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see ClassFileVersion#ofThisVm(ClassFileVersion)
&nbsp;     */
&nbsp;    public ByteBuddy() {
<b class="fc">&nbsp;        this(ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new Byte Buddy instance with a default configuration that is suitable for most use cases.
&nbsp;     *
&nbsp;     * @param classFileVersion The class file version to use for types that are not based on an existing class file.
&nbsp;     */
&nbsp;    public ByteBuddy(ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;        this(classFileVersion,</b>
<b class="fc">&nbsp;                DEFAULT_NAMING_STRATEGY == null</b>
<b class="fc">&nbsp;                        ? new NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_PREFIX)</b>
<b class="nc">&nbsp;                        : DEFAULT_NAMING_STRATEGY,</b>
<b class="fc">&nbsp;                DEFAULT_AUXILIARY_NAMING_STRATEGY == null</b>
<b class="fc">&nbsp;                        ? new AuxiliaryType.NamingStrategy.SuffixingRandom(BYTE_BUDDY_DEFAULT_SUFFIX)</b>
<b class="nc">&nbsp;                        : DEFAULT_AUXILIARY_NAMING_STRATEGY,</b>
&nbsp;                AnnotationValueFilter.Default.APPEND_DEFAULTS,
&nbsp;                AnnotationRetention.ENABLED,
<b class="fc">&nbsp;                DEFAULT_IMPLEMENTATION_CONTEXT_FACTORY == null</b>
<b class="fc">&nbsp;                        ? Implementation.Context.Default.Factory.INSTANCE</b>
<b class="nc">&nbsp;                        : DEFAULT_IMPLEMENTATION_CONTEXT_FACTORY,</b>
&nbsp;                MethodGraph.Compiler.DEFAULT,
&nbsp;                InstrumentedType.Factory.Default.MODIFIABLE,
&nbsp;                TypeValidation.ENABLED,
&nbsp;                VisibilityBridgeStrategy.Default.ALWAYS,
&nbsp;                ClassWriterStrategy.Default.CONSTANT_POOL_RETAINING,
<b class="fc">&nbsp;                new LatentMatcher.Resolved&lt;MethodDescription&gt;(isSynthetic().or(isDefaultFinalizer())));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new Byte Buddy instance.
&nbsp;     *
&nbsp;     * @param classFileVersion             The class file version to use for types that are not based on an existing class file.
&nbsp;     * @param namingStrategy               The naming strategy to use.
&nbsp;     * @param auxiliaryTypeNamingStrategy  The naming strategy to use for naming auxiliary types.
&nbsp;     * @param annotationValueFilterFactory The annotation value filter factory to use.
&nbsp;     * @param annotationRetention          The annotation retention strategy to use.
&nbsp;     * @param implementationContextFactory The implementation context factory to use.
&nbsp;     * @param methodGraphCompiler          The method graph compiler to use.
&nbsp;     * @param instrumentedTypeFactory      The instrumented type factory to use.
&nbsp;     * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;     * @param visibilityBridgeStrategy     The visibility bridge strategy to apply.
&nbsp;     * @param classWriterStrategy          The class writer strategy to use.
&nbsp;     * @param ignoredMethods               A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;     */
&nbsp;    protected ByteBuddy(ClassFileVersion classFileVersion,
&nbsp;                        NamingStrategy namingStrategy,
&nbsp;                        AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                        AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                        AnnotationRetention annotationRetention,
&nbsp;                        Implementation.Context.Factory implementationContextFactory,
&nbsp;                        MethodGraph.Compiler methodGraphCompiler,
&nbsp;                        InstrumentedType.Factory instrumentedTypeFactory,
&nbsp;                        TypeValidation typeValidation,
&nbsp;                        VisibilityBridgeStrategy visibilityBridgeStrategy,
&nbsp;                        ClassWriterStrategy classWriterStrategy,
<b class="fc">&nbsp;                        LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {</b>
<b class="fc">&nbsp;        this.classFileVersion = classFileVersion;</b>
<b class="fc">&nbsp;        this.namingStrategy = namingStrategy;</b>
<b class="fc">&nbsp;        this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;</b>
<b class="fc">&nbsp;        this.annotationValueFilterFactory = annotationValueFilterFactory;</b>
<b class="fc">&nbsp;        this.annotationRetention = annotationRetention;</b>
<b class="fc">&nbsp;        this.implementationContextFactory = implementationContextFactory;</b>
<b class="fc">&nbsp;        this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;        this.instrumentedTypeFactory = instrumentedTypeFactory;</b>
<b class="fc">&nbsp;        this.typeValidation = typeValidation;</b>
<b class="fc">&nbsp;        this.visibilityBridgeStrategy = visibilityBridgeStrategy;</b>
<b class="fc">&nbsp;        this.classWriterStrategy = classWriterStrategy;</b>
<b class="fc">&nbsp;        this.ignoredMethods = ignoredMethods;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new builder for subclassing the provided type. If the provided type is an interface, a new class implementing
&nbsp;     * this interface type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When extending a class, Byte Buddy imitates all visible constructors of the subclassed type. Any constructor is implemented
&nbsp;     * to only invoke its super type constructor of equal signature. Another behavior can be specified by supplying an explicit
&nbsp;     * {@link ConstructorStrategy} by {@link ByteBuddy#subclass(Class, ConstructorStrategy)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types in a generified state if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param superType The super class or interface type to extend.
&nbsp;     * @param &lt;T&gt;       A loaded type that the generated class is guaranteed to inherit.
&nbsp;     * @return A type builder for creating a new class extending the provided class or interface.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; subclass(Class&lt;T&gt; superType) {
<b class="fc">&nbsp;        return (DynamicType.Builder&lt;T&gt;) subclass(TypeDescription.ForLoadedType.of(superType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new builder for subclassing the provided type. If the provided type is an interface, a new class implementing
&nbsp;     * this interface type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types in a generified state if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param superType           The super class or interface type to extend.
&nbsp;     * @param constructorStrategy A constructor strategy that determines the
&nbsp;     * @param &lt;T&gt;                 A loaded type that the generated class is guaranteed to inherit.
&nbsp;     * @return A type builder for creating a new class extending the provided class or interface.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; subclass(Class&lt;T&gt; superType, ConstructorStrategy constructorStrategy) {
<b class="fc">&nbsp;        return (DynamicType.Builder&lt;T&gt;) subclass(TypeDescription.ForLoadedType.of(superType), constructorStrategy);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new builder for subclassing the provided type. If the provided type is an interface, a new class implementing
&nbsp;     * this interface type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When extending a class, Byte Buddy imitates all visible constructors of the subclassed type. Any constructor is implemented
&nbsp;     * to only invoke its super type constructor of equal signature. Another behavior can be specified by supplying an explicit
&nbsp;     * {@link ConstructorStrategy} by {@link ByteBuddy#subclass(Type, ConstructorStrategy)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;     * as raw types if they declare type variables.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param superType The super class or interface type to extend. The type must be a raw type or parameterized type. All type
&nbsp;     *                  variables that are referenced by the generic type must be declared by the generated subclass before creating
&nbsp;     *                  the type.
&nbsp;     * @return A type builder for creating a new class extending the provided class or interface.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; subclass(Type superType) {
<b class="nc">&nbsp;        return subclass(TypeDefinition.Sort.describe(superType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new builder for subclassing the provided type. If the provided type is an interface, a new class implementing
&nbsp;     * this interface type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;     * as raw types if they declare type variables.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param superType           The super class or interface type to extend. The type must be a raw type or parameterized
&nbsp;     *                            type. All type variables that are referenced by the generic type must be declared by the
&nbsp;     *                            generated subclass before creating the type.
&nbsp;     * @param constructorStrategy A constructor strategy that determines the
&nbsp;     * @return A type builder for creating a new class extending the provided class or interface.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; subclass(Type superType, ConstructorStrategy constructorStrategy) {
<b class="nc">&nbsp;        return subclass(TypeDefinition.Sort.describe(superType), constructorStrategy);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new builder for subclassing the provided type. If the provided type is an interface, a new class implementing
&nbsp;     * this interface type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When extending a class, Byte Buddy imitates all visible constructors of the subclassed type and sets them to be {@code public}.
&nbsp;     * Any constructor is implemented to only invoke its super type constructor of equal signature. Another behavior can be specified by
&nbsp;     * supplying an explicit {@link ConstructorStrategy} by {@link ByteBuddy#subclass(TypeDefinition, ConstructorStrategy)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are implemented
&nbsp;     * as raw types if they declare type variables.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param superType The super class or interface type to extend. The type must be a raw type or parameterized type. All type
&nbsp;     *                  variables that are referenced by the generic type must be declared by the generated subclass before creating
&nbsp;     *                  the type.
&nbsp;     * @return A type builder for creating a new class extending the provided class or interface.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; subclass(TypeDefinition superType) {
<b class="fc">&nbsp;        return subclass(superType, ConstructorStrategy.Default.IMITATE_SUPER_CLASS_OPENING);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new builder for subclassing the provided type. If the provided type is an interface, a new class implementing
&nbsp;     * this interface type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are implemented
&nbsp;     * as raw types if they declare type variables.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param superType           The super class or interface type to extend. The type must be a raw type or parameterized
&nbsp;     *                            type. All type variables that are referenced by the generic type must be declared by the
&nbsp;     *                            generated subclass before creating the type.
&nbsp;     * @param constructorStrategy A constructor strategy that determines the
&nbsp;     * @return A type builder for creating a new class extending the provided class or interface.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; subclass(TypeDefinition superType, ConstructorStrategy constructorStrategy) {
&nbsp;        TypeDescription.Generic actualSuperType;
&nbsp;        TypeList.Generic interfaceTypes;
<b class="fc">&nbsp;        if (superType.isPrimitive() || superType.isArray() || superType.isFinal()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot subclass primitive, array or final types: &quot; + superType);</b>
<b class="fc">&nbsp;        } else if (superType.isInterface()) {</b>
<b class="fc">&nbsp;            actualSuperType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
<b class="fc">&nbsp;            interfaceTypes = new TypeList.Generic.Explicit(superType);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            actualSuperType = superType.asGenericType();</b>
<b class="fc">&nbsp;            interfaceTypes = new TypeList.Generic.Empty();</b>
&nbsp;        }
<b class="fc">&nbsp;        return new SubclassDynamicTypeBuilder&lt;Object&gt;(instrumentedTypeFactory.subclass(namingStrategy.subclass(superType.asGenericType()),</b>
<b class="fc">&nbsp;                ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.PLAIN).resolve(superType.getModifiers()),</b>
<b class="fc">&nbsp;                actualSuperType).withInterfaces(interfaceTypes),</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                constructorStrategy);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new, plain interface type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A type builder that creates a new interface type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makeInterface() {
<b class="fc">&nbsp;        return makeInterface(Collections.&lt;TypeDescription&gt;emptyList());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new interface type that extends the provided interface.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types in a generified state if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param interfaceType An interface type that the generated interface implements.
&nbsp;     * @param &lt;T&gt;           A loaded type that the generated interface is guaranteed to inherit.
&nbsp;     * @return A type builder that creates a new interface type.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; makeInterface(Class&lt;T&gt; interfaceType) {
<b class="fc">&nbsp;        return (DynamicType.Builder&lt;T&gt;) makeInterface(Collections.&lt;Type&gt;singletonList(interfaceType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new interface type that extends the provided interface.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;     * as raw types if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param interfaceType The interface types to implement. The types must be raw or parameterized types. All type
&nbsp;     *                      variables that are referenced by a parameterized type must be declared by the generated
&nbsp;     *                      subclass before creating the type.
&nbsp;     * @return A type builder that creates a new interface type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makeInterface(Type... interfaceType) {
<b class="nc">&nbsp;        return makeInterface(Arrays.asList(interfaceType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new interface type that extends the provided interface.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;     * as raw types if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param interfaceTypes The interface types to implement. The types must be raw or parameterized types. All
&nbsp;     *                       type variables that are referenced by a parameterized type must be declared by the
&nbsp;     *                       generated subclass before creating the type.
&nbsp;     * @return A type builder that creates a new interface type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makeInterface(List&lt;? extends Type&gt; interfaceTypes) {
<b class="fc">&nbsp;        return makeInterface(new TypeList.Generic.ForLoadedTypes(interfaceTypes));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new interface type that extends the provided interface.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are implemented
&nbsp;     * as raw types if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param interfaceType The interface types to implement. The types must be raw or parameterized types. All
&nbsp;     *                      type variables that are referenced by a parameterized type must be declared by the
&nbsp;     *                      generated subclass before creating the type.
&nbsp;     * @return A type builder that creates a new interface type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makeInterface(TypeDefinition... interfaceType) {
<b class="nc">&nbsp;        return makeInterface(Arrays.asList(interfaceType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new interface type that extends the provided interface.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are implemented
&nbsp;     * as raw types if they declare type variables or an owner type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param interfaceTypes The interface types to implement. The types must be raw or parameterized types. All
&nbsp;     *                       type variables that are referenced by a parameterized type must be declared by the
&nbsp;     *                       generated subclass before creating the type.
&nbsp;     * @return A type builder that creates a new interface type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makeInterface(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
<b class="fc">&nbsp;        return subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS).implement(interfaceTypes).modifiers(TypeManifestation.INTERFACE, Visibility.PUBLIC);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new package definition. Package definitions are defined by classes named {@code package-info}
&nbsp;     * without any methods or fields but permit annotations. Any field or method definition will cause an
&nbsp;     * {@link IllegalStateException} to be thrown when the type is created.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param name The fully qualified name of the package.
&nbsp;     * @return A type builder that creates a {@code package-info} class file.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makePackage(String name) {
<b class="fc">&nbsp;        return new SubclassDynamicTypeBuilder&lt;Object&gt;(instrumentedTypeFactory.subclass(name + &quot;.&quot; + PackageDescription.PACKAGE_CLASS_NAME,</b>
&nbsp;                PackageDescription.PACKAGE_MODIFIERS,
<b class="fc">&nbsp;                TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)),</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                ConstructorStrategy.Default.NO_CONSTRUCTORS);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new Java record. This builder automatically defines fields for record members, standard accessors and a record constructor for any
&nbsp;     * defined record component.
&nbsp;     *
&nbsp;     * @return A dynamic type builder that creates a record.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; makeRecord() {
<b class="fc">&nbsp;        TypeDescription.Generic record = InstrumentedType.Default.of(JavaType.RECORD.getTypeStub().getName(), TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                .withMethod(new MethodDescription.Token(Opcodes.ACC_PROTECTED))</b>
<b class="fc">&nbsp;                .withMethod(new MethodDescription.Token(&quot;hashCode&quot;,</b>
&nbsp;                        Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
<b class="fc">&nbsp;                        TypeDescription.ForLoadedType.of(int.class).asGenericType()))</b>
<b class="fc">&nbsp;                .withMethod(new MethodDescription.Token(&quot;equals&quot;,</b>
&nbsp;                        Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
<b class="fc">&nbsp;                        TypeDescription.ForLoadedType.of(boolean.class).asGenericType(),</b>
<b class="fc">&nbsp;                        Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class))))</b>
<b class="fc">&nbsp;                .withMethod(new MethodDescription.Token(&quot;toString&quot;,</b>
&nbsp;                        Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
<b class="fc">&nbsp;                        TypeDescription.ForLoadedType.of(String.class).asGenericType()))</b>
<b class="fc">&nbsp;                .asGenericType();</b>
<b class="fc">&nbsp;        return new SubclassDynamicTypeBuilder&lt;Object&gt;(instrumentedTypeFactory.subclass(namingStrategy.subclass(record), Opcodes.ACC_PUBLIC | Opcodes.ACC_FINAL, record).withRecord(true),</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                RecordConstructorStrategy.INSTANCE)
<b class="fc">&nbsp;                .method(isHashCode()).intercept(RecordObjectMethod.HASH_CODE)</b>
<b class="fc">&nbsp;                .method(isEquals()).intercept(RecordObjectMethod.EQUALS)</b>
<b class="fc">&nbsp;                .method(isToString()).intercept(RecordObjectMethod.TO_STRING);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new {@link Annotation} type. Annotation properties are implemented as non-static, public methods with the
&nbsp;     * property type being defined as the return type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A type builder that creates a new {@link Annotation} type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;? extends Annotation&gt; makeAnnotation() {
<b class="fc">&nbsp;        return new SubclassDynamicTypeBuilder&lt;Annotation&gt;(instrumentedTypeFactory.subclass(namingStrategy.subclass(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Annotation.class)),</b>
<b class="fc">&nbsp;                ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.ANNOTATION).resolve(),</b>
<b class="fc">&nbsp;                TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)).withInterfaces(new TypeList.Generic.Explicit(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Annotation.class))),</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                ConstructorStrategy.Default.NO_CONSTRUCTORS);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new {@link Enum} type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param value The names of the type&#39;s enumeration constants
&nbsp;     * @return A type builder for creating an enumeration type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;? extends Enum&lt;?&gt;&gt; makeEnumeration(String... value) {
<b class="fc">&nbsp;        return makeEnumeration(Arrays.asList(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new {@link Enum} type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not cache previous subclasses but will attempt the generation of a new subclass. For caching
&nbsp;     * types, a external cache or {@link TypeCache} should be used.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param values The names of the type&#39;s enumeration constants
&nbsp;     * @return A type builder for creating an enumeration type.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;? extends Enum&lt;?&gt;&gt; makeEnumeration(Collection&lt;? extends String&gt; values) {
<b class="fc">&nbsp;        if (values.isEmpty()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Require at least one enumeration constant&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        TypeDescription.Generic enumType = TypeDescription.Generic.Builder.parameterizedType(Enum.class, TargetType.class).build();</b>
<b class="fc">&nbsp;        return new SubclassDynamicTypeBuilder&lt;Enum&lt;?&gt;&gt;(instrumentedTypeFactory.subclass(namingStrategy.subclass(enumType),</b>
<b class="fc">&nbsp;                ModifierContributor.Resolver.of(Visibility.PUBLIC, TypeManifestation.FINAL, EnumerationState.ENUMERATION).resolve(),</b>
&nbsp;                enumType),
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                ConstructorStrategy.Default.NO_CONSTRUCTORS)
<b class="fc">&nbsp;                .defineConstructor(Visibility.PRIVATE).withParameters(String.class, int.class)</b>
<b class="fc">&nbsp;                .intercept(SuperMethodCall.INSTANCE)</b>
<b class="fc">&nbsp;                .defineMethod(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME,</b>
&nbsp;                        TargetType.class,
<b class="fc">&nbsp;                        Visibility.PUBLIC, Ownership.STATIC).withParameters(String.class)</b>
<b class="fc">&nbsp;                .intercept(MethodCall.invoke(enumType.getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(named(EnumerationImplementation.ENUM_VALUE_OF_METHOD_NAME).and(takesArguments(Class.class, String.class))).getOnly())</b>
<b class="fc">&nbsp;                        .withOwnType().withArgument(0)</b>
<b class="fc">&nbsp;                        .withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC))</b>
<b class="fc">&nbsp;                .defineMethod(EnumerationImplementation.ENUM_VALUES_METHOD_NAME,</b>
&nbsp;                        TargetType[].class,
&nbsp;                        Visibility.PUBLIC, Ownership.STATIC)
<b class="fc">&nbsp;                .intercept(new EnumerationImplementation(new ArrayList&lt;String&gt;(values)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Redefines the given type where any intercepted method that is declared by the redefined type is fully replaced
&nbsp;     * by the new implementation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * The class file of the redefined type is located by querying the redefined type&#39;s class loader by name. For specifying an
&nbsp;     * alternative {@link ClassFileLocator}, use {@link ByteBuddy#redefine(Class, ClassFileLocator)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When a user redefines a class with the purpose of reloading this class using a {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy},
&nbsp;     * it is important that no fields or methods are added to the redefined class. Note that some {@link Implementation}s implicitly add fields or methods.
&nbsp;     * Finally, Byte Buddy might be forced to add a method if a redefined class already defines a class initializer. This can be disabled by setting
&nbsp;     * {@link ByteBuddy#with(Implementation.Context.Factory)} to use a {@link net.bytebuddy.implementation.Implementation.Context.Disabled.Factory}
&nbsp;     * where the class initializer is retained &lt;i&gt;as is&lt;/i&gt;.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type The type that is being redefined.
&nbsp;     * @param &lt;T&gt;  The loaded type of the redefined type.
&nbsp;     * @return A type builder for redefining the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; redefine(Class&lt;T&gt; type) {
<b class="fc">&nbsp;        return redefine(type, ClassFileLocator.ForClassLoader.of(type.getClassLoader()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Redefines the given type where any intercepted method that is declared by the redefined type is fully replaced
&nbsp;     * by the new implementation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When a user redefines a class with the purpose of reloading this class using a {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy},
&nbsp;     * it is important that no fields or methods are added to the redefined class. Note that some {@link Implementation}s implicitly add fields or methods.
&nbsp;     * Finally, Byte Buddy might be forced to add a method if a redefined class already defines a class initializer. This can be disabled by setting
&nbsp;     * {@link ByteBuddy#with(Implementation.Context.Factory)} to use a {@link net.bytebuddy.implementation.Implementation.Context.Disabled.Factory}
&nbsp;     * where the class initializer is retained &lt;i&gt;as is&lt;/i&gt;.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type             The type that is being redefined.
&nbsp;     * @param classFileLocator The class file locator that is queried for the redefined type&#39;s class file.
&nbsp;     * @param &lt;T&gt;              The loaded type of the redefined type.
&nbsp;     * @return A type builder for redefining the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; redefine(Class&lt;T&gt; type, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return redefine(TypeDescription.ForLoadedType.of(type), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Redefines the given type where any intercepted method that is declared by the redefined type is fully replaced
&nbsp;     * by the new implementation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When a user redefines a class with the purpose of reloading this class using a {@link net.bytebuddy.dynamic.loading.ClassReloadingStrategy},
&nbsp;     * it is important that no fields or methods are added to the redefined class. Note that some {@link Implementation}s implicitly add fields or methods.
&nbsp;     * Finally, Byte Buddy might be forced to add a method if a redefined class already defines a class initializer. This can be disabled by setting
&nbsp;     * {@link ByteBuddy#with(Implementation.Context.Factory)} to use a {@link net.bytebuddy.implementation.Implementation.Context.Disabled.Factory}
&nbsp;     * where the class initializer is retained &lt;i&gt;as is&lt;/i&gt;.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type             The type that is being redefined.
&nbsp;     * @param classFileLocator The class file locator that is queried for the redefined type&#39;s class file.
&nbsp;     * @param &lt;T&gt;              The loaded type of the redefined type.
&nbsp;     * @return A type builder for redefining the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; redefine(TypeDescription type, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        if (type.isArray() || type.isPrimitive()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot redefine array or primitive type: &quot; + type);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new RedefinitionDynamicTypeBuilder&lt;T&gt;(instrumentedTypeFactory.represent(type),</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                type,
&nbsp;                classFileLocator);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Rebases the given type where any intercepted method that is declared by the redefined type is preserved within the
&nbsp;     * rebased type&#39;s class such that the class&#39;s original can be invoked from the new method implementations. Rebasing a
&nbsp;     * type can be seen similarly to creating a subclass where the subclass is later merged with the original class file.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * The class file of the rebased type is located by querying the rebased type&#39;s class loader by name. For specifying an
&nbsp;     * alternative {@link ClassFileLocator}, use {@link ByteBuddy#redefine(Class, ClassFileLocator)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type The type that is being rebased.
&nbsp;     * @param &lt;T&gt;  The loaded type of the rebased type.
&nbsp;     * @return A type builder for rebasing the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; rebase(Class&lt;T&gt; type) {
<b class="fc">&nbsp;        return rebase(type, ClassFileLocator.ForClassLoader.of(type.getClassLoader()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Rebases the given type where any intercepted method that is declared by the redefined type is preserved within the
&nbsp;     * rebased type&#39;s class such that the class&#39;s original can be invoked from the new method implementations. Rebasing a
&nbsp;     * type can be seen similarly to creating a subclass where the subclass is later merged with the original class file.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When a method is rebased, the original method is copied into a new method with a different name. These names are
&nbsp;     * generated automatically by Byte Buddy unless a {@link MethodNameTransformer} is specified explicitly.
&nbsp;     * Use {@link ByteBuddy#rebase(Class, ClassFileLocator, MethodNameTransformer)} for doing so.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type             The type that is being rebased.
&nbsp;     * @param classFileLocator The class file locator that is queried for the rebased type&#39;s class file.
&nbsp;     * @param &lt;T&gt;              The loaded type of the rebased type.
&nbsp;     * @return A type builder for rebasing the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; rebase(Class&lt;T&gt; type, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return rebase(TypeDescription.ForLoadedType.of(type), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebases the given type where any intercepted method that is declared by the redefined type is preserved within the
&nbsp;     * rebased type&#39;s class such that the class&#39;s original can be invoked from the new method implementations. Rebasing a
&nbsp;     * type can be seen similarly to creating a subclass where the subclass is later merged with the original class file.
&nbsp;     *
&nbsp;     * @param type                  The type that is being rebased.
&nbsp;     * @param classFileLocator      The class file locator that is queried for the rebased type&#39;s class file.
&nbsp;     * @param methodNameTransformer The method name transformer for renaming a method that is rebased.
&nbsp;     * @param &lt;T&gt;                   The loaded type of the rebased type.
&nbsp;     * @return A type builder for rebasing the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; rebase(Class&lt;T&gt; type, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer) {
<b class="nc">&nbsp;        return rebase(TypeDescription.ForLoadedType.of(type), classFileLocator, methodNameTransformer);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Rebases the given type where any intercepted method that is declared by the redefined type is preserved within the
&nbsp;     * rebased type&#39;s class such that the class&#39;s original can be invoked from the new method implementations. Rebasing a
&nbsp;     * type can be seen similarly to creating a subclass where the subclass is later merged with the original class file.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When a method is rebased, the original method is copied into a new method with a different name. These names are
&nbsp;     * generated automatically by Byte Buddy unless a {@link MethodNameTransformer} is specified explicitly.
&nbsp;     * Use {@link ByteBuddy#rebase(TypeDescription, ClassFileLocator, MethodNameTransformer)} for doing so.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type             The type that is being rebased.
&nbsp;     * @param classFileLocator The class file locator that is queried for the rebased type&#39;s class file.
&nbsp;     * @param &lt;T&gt;              The loaded type of the rebased type.
&nbsp;     * @return A type builder for rebasing the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; rebase(TypeDescription type, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return rebase(type, classFileLocator, MethodNameTransformer.Suffixing.withRandomSuffix());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebases the given type where any intercepted method that is declared by the redefined type is preserved within the
&nbsp;     * rebased type&#39;s class such that the class&#39;s original can be invoked from the new method implementations. Rebasing a
&nbsp;     * type can be seen similarly to creating a subclass where the subclass is later merged with the original class file.
&nbsp;     *
&nbsp;     * @param type                  The type that is being rebased.
&nbsp;     * @param classFileLocator      The class file locator that is queried for the rebased type&#39;s class file.
&nbsp;     * @param methodNameTransformer The method name transformer for renaming a method that is rebased.
&nbsp;     * @param &lt;T&gt;                   The loaded type of the rebased type.
&nbsp;     * @return A type builder for rebasing the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; rebase(TypeDescription type, ClassFileLocator classFileLocator, MethodNameTransformer methodNameTransformer) {
<b class="fc">&nbsp;        if (type.isArray() || type.isPrimitive()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot rebase array or primitive type: &quot; + type);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new RebaseDynamicTypeBuilder&lt;T&gt;(instrumentedTypeFactory.represent(type),</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                type,
&nbsp;                classFileLocator,
&nbsp;                methodNameTransformer);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebases a package. This offers an opportunity to add annotations to the package definition. Packages are defined
&nbsp;     * by classes named {@code package-info} without any methods or fields but permit annotations. Any field or method
&nbsp;     * definition will cause an {@link IllegalStateException} to be thrown when the type is created.
&nbsp;     *
&nbsp;     * @param aPackage         The package that is being rebased.
&nbsp;     * @param classFileLocator The class file locator to use for locating the package&#39;s class file.
&nbsp;     * @return A type builder for rebasing the given package.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; rebase(Package aPackage, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return rebase(new PackageDescription.ForLoadedPackage(aPackage), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Rebases a package. This offers an opportunity to add annotations to the package definition. Packages are defined
&nbsp;     * by classes named {@code package-info} without any methods or fields but permit annotations. Any field or method
&nbsp;     * definition will cause an {@link IllegalStateException} to be thrown when the type is created.
&nbsp;     *
&nbsp;     * @param aPackage         The package that is being rebased.
&nbsp;     * @param classFileLocator The class file locator to use for locating the package&#39;s class file.
&nbsp;     * @return A type builder for rebasing the given package.
&nbsp;     */
&nbsp;    public DynamicType.Builder&lt;?&gt; rebase(PackageDescription aPackage, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return rebase(new TypeDescription.ForPackageDescription(aPackage), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Decorates a type with {@link net.bytebuddy.asm.AsmVisitorWrapper} and allows adding attributes and annotations. A decoration does
&nbsp;     * not allow for any standard transformations but can be used as a performance optimization compared to a redefinition, especially
&nbsp;     * when implementing a Java agent that only applies ASM-based code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Only use this mode to improve performance in a narrowly defined transformation. Using other features as those mentioned
&nbsp;     * might result in an unexpected outcome of the transformation or error. Using decoration also requires the configuration of an
&nbsp;     * {@link Implementation.Context.Factory} that does not attempt any type transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type The type to decorate.
&nbsp;     * @param &lt;T&gt;  The loaded type of the decorated type.
&nbsp;     * @return A type builder for decorating the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; decorate(Class&lt;T&gt; type) {
<b class="fc">&nbsp;        return decorate(type, ClassFileLocator.ForClassLoader.of(type.getClassLoader()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Decorates a type with {@link net.bytebuddy.asm.AsmVisitorWrapper} and allows adding attributes and annotations. A decoration does
&nbsp;     * not allow for any standard transformations but can be used as a performance optimization compared to a redefinition, especially
&nbsp;     * when implementing a Java agent that only applies ASM-based code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Only use this mode to improve performance in a narrowly defined transformation. Using other features as those mentioned
&nbsp;     * might result in an unexpected outcome of the transformation or error. Using decoration also requires the configuration of an
&nbsp;     * {@link Implementation.Context.Factory} that does not attempt any type transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type             The type to decorate.
&nbsp;     * @param classFileLocator The class file locator to use.
&nbsp;     * @param &lt;T&gt;              The loaded type of the decorated type.
&nbsp;     * @return A type builder for decorating the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; decorate(Class&lt;T&gt; type, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return decorate(TypeDescription.ForLoadedType.of(type), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Decorates a type with {@link net.bytebuddy.asm.AsmVisitorWrapper} and allows adding attributes and annotations. A decoration does
&nbsp;     * not allow for any standard transformations but can be used as a performance optimization compared to a redefinition, especially
&nbsp;     * when implementing a Java agent that only applies ASM-based code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Only use this mode to improve performance in a narrowly defined transformation. Using other features as those mentioned
&nbsp;     * might result in an unexpected outcome of the transformation or error. Using decoration also requires the configuration of an
&nbsp;     * {@link Implementation.Context.Factory} that does not attempt any type transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type             The type to decorate.
&nbsp;     * @param classFileLocator The class file locator to use.
&nbsp;     * @param &lt;T&gt;              The loaded type of the decorated type.
&nbsp;     * @return A type builder for decorating the provided type.
&nbsp;     */
&nbsp;    public &lt;T&gt; DynamicType.Builder&lt;T&gt; decorate(TypeDescription type, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        if (type.isArray() || type.isPrimitive()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot decorate array or primitive type: &quot; + type);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new DecoratingDynamicTypeBuilder&lt;T&gt;(type,</b>
&nbsp;                classFileVersion,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                typeValidation,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods,
&nbsp;                classFileLocator);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where all class files that are not based on an existing class file are created
&nbsp;     * using the supplied class file version. When creating a Byte Buddy instance by {@link ByteBuddy#ByteBuddy()}, the class
&nbsp;     * file version is detected automatically. If the class file version is known before creating a Byte Buddy instance, the
&nbsp;     * {@link ByteBuddy#ByteBuddy(ClassFileVersion)} constructor should be used.
&nbsp;     *
&nbsp;     * @param classFileVersion The class file version to use for types that are not based on an existing class file.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied class file version.
&nbsp;     */
&nbsp;    public ByteBuddy with(ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where new types are named by applying the given naming strategy. By default, Byte Buddy
&nbsp;     * simply retains the name of rebased and redefined types but adds a random suffix to the name of created subclasses or
&nbsp;     * -interfaces. If a type is defined within the {@code java.*} namespace, Byte Buddy also adds a suffix to the generated
&nbsp;     * class because this namespace is only available for the bootstrap class loader.
&nbsp;     *
&nbsp;     * @param namingStrategy The naming strategy to apply when creating a new dynamic type.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied naming strategy.
&nbsp;     */
&nbsp;    public ByteBuddy with(NamingStrategy namingStrategy) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where auxiliary types are named by applying the given naming strategy. Auxiliary types
&nbsp;     * are helper types that might be required for implementing certain {@link Implementation}s. By default, Byte Buddy
&nbsp;     * adds a random suffix to the instrumented type&#39;s name when naming its auxiliary types.
&nbsp;     *
&nbsp;     * @param auxiliaryTypeNamingStrategy The naming strategy to apply when creating a new auxiliary type.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied naming strategy for auxiliary types.
&nbsp;     */
&nbsp;    public ByteBuddy with(AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy) {
<b class="nc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where annotation values are written according to the given filter factory. Using
&nbsp;     * a filter factory, it is for example possible not to include certain values into a class file such that the
&nbsp;     * runtime returns an annotation type&#39;s default value. By default, Byte Buddy includes all values into a class file,
&nbsp;     * also such values for which a default value exists.
&nbsp;     *
&nbsp;     * @param annotationValueFilterFactory The annotation value filter factory to use.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied annotation value filter factory.
&nbsp;     */
&nbsp;    public ByteBuddy with(AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new configuration where annotations that are found in an existing class file are or are not preserved
&nbsp;     * in the format they are discovered, i.e. rewritten in the format they were already present in the class file.
&nbsp;     * By default, Byte Buddy retains annotations when a class is rebased or redefined.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: Retaining annotations can cause problems when annotations of a field or method are added based
&nbsp;     * on the annotations of a matched method. Doing so, Byte Buddy might write the annotations of the field or method
&nbsp;     * explicitly to a class file while simultaneously retaining the existing annotation what results in duplicates.
&nbsp;     * When matching fields or methods while adding annotations, disabling annotation retention might be required.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param annotationRetention The annotation retention strategy to use.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied annotation retention strategy.
&nbsp;     */
&nbsp;    public ByteBuddy with(AnnotationRetention annotationRetention) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where the {@link net.bytebuddy.implementation.Implementation.Context} of any created
&nbsp;     * type is a product of the given implementation context factory. An implementation context might imply unwanted
&nbsp;     * side-effects, for example, the creation of an additional synthetic methods in order to support specific features
&nbsp;     * for realizing an {@link Implementation}. By default, Byte Buddy supplies a factory that enables all features. When
&nbsp;     * redefining a loaded class, it is however required by the JVM that no additional members are added such that a
&nbsp;     * {@link net.bytebuddy.implementation.Implementation.Context.Disabled} factory might be more appropriate.
&nbsp;     *
&nbsp;     * @param implementationContextFactory The implementation context factory to use for defining an instrumented type.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied implementation context factory.
&nbsp;     */
&nbsp;    public ByteBuddy with(Implementation.Context.Factory implementationContextFactory) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where the {@link MethodGraph.Compiler} is used for creating a {@link MethodGraph}
&nbsp;     * of the instrumented type. A method graph is a representation of a type&#39;s virtual methods, including all information
&nbsp;     * on bridge methods that are inserted by the Java compiler. Creating a method graph is a rather expensive operation
&nbsp;     * and more efficient strategies might exist for certain types or ava types that are created by alternative JVM
&nbsp;     * languages. By default, a general purpose method graph compiler is used that uses the information that is exposed
&nbsp;     * by the generic type information that is embedded in any class file.
&nbsp;     *
&nbsp;     * @param methodGraphCompiler The method graph compiler to use for analyzing the instrumented type.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied method graph compiler.
&nbsp;     */
&nbsp;    public ByteBuddy with(MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures Byte Buddy to use the specified factory for creating {@link InstrumentedType}s. Doing so, more efficient
&nbsp;     * representations can be chosen when only certain operations are required. By default, all operations are supported.
&nbsp;     *
&nbsp;     * @param instrumentedTypeFactory The factory to use when creating instrumented types.
&nbsp;     * @return A new Byte Buddy instance that uses the supplied factory for creating instrumented types.
&nbsp;     */
&nbsp;    public ByteBuddy with(InstrumentedType.Factory instrumentedTypeFactory) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration that applies the supplied type validation. By default, explicitly type validation is applied
&nbsp;     * by Byte Buddy but it might be disabled for performance reason or for voluntarily creating illegal types. The Java virtual
&nbsp;     * machine applies its own type validation where some {@link Error} is thrown if a type is invalid, while Byte Buddy throws
&nbsp;     * some {@link RuntimeException}.
&nbsp;     *
&nbsp;     * @param typeValidation The type validation to apply during type creation.
&nbsp;     * @return A new Byte Buddy instance that applies the supplied type validation.
&nbsp;     */
&nbsp;    public ByteBuddy with(TypeValidation typeValidation) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration that applies the supplied visibility bridge strategy. By default, visibility bridges
&nbsp;     * are create for all methods for which a visibility bridge is normally necessary.
&nbsp;     *
&nbsp;     * @param visibilityBridgeStrategy The visibility bridge strategy to apply.
&nbsp;     * @return A new Byte Buddy instance that applies the supplied visibility bridge strategy.
&nbsp;     */
&nbsp;    public ByteBuddy with(VisibilityBridgeStrategy visibilityBridgeStrategy) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration that applies the supplied class writer strategy. By default, the constant pool of redefined and retransformed
&nbsp;     * classes is retained as most changes are additive and this retention improves performance.
&nbsp;     *
&nbsp;     * @param classWriterStrategy The class writer strategy to apply during type creation.
&nbsp;     * @return A new Byte Buddy instance that applies the supplied class writer strategy.
&nbsp;     */
&nbsp;    public ByteBuddy with(ClassWriterStrategy classWriterStrategy) {
<b class="nc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new configuration where any {@link MethodDescription} that matches the provided method matcher is excluded
&nbsp;     * from instrumentation. Any previous matcher for ignored methods is replaced. By default, Byte Buddy ignores any
&nbsp;     * synthetic method (bridge methods are handled automatically) and the {@link Object#finalize()} method.
&nbsp;     *
&nbsp;     * @param ignoredMethods A matcher for identifying methods to be excluded from instrumentation.
&nbsp;     * @return A new Byte Buddy instance that excludes any method from instrumentation if it is matched by the supplied matcher.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    public ByteBuddy ignore(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;        return ignore(new LatentMatcher.Resolved&lt;MethodDescription&gt;(ignoredMethods));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a new configuration where any {@link MethodDescription} that matches the provided method matcher is excluded
&nbsp;     * from instrumentation. Any previous matcher for ignored methods is replaced. By default, Byte Buddy ignores any
&nbsp;     * synthetic method (bridge methods are handled automatically) and the {@link Object#finalize()} method. Using a latent
&nbsp;     * matcher gives opportunity to resolve an {@link ElementMatcher} based on the instrumented type before applying the matcher.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param ignoredMethods A matcher for identifying methods to be excluded from instrumentation.
&nbsp;     * @return A new Byte Buddy instance that excludes any method from instrumentation if it is matched by the supplied matcher.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    public ByteBuddy ignore(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion,</b>
&nbsp;                namingStrategy,
&nbsp;                auxiliaryTypeNamingStrategy,
&nbsp;                annotationValueFilterFactory,
&nbsp;                annotationRetention,
&nbsp;                implementationContextFactory,
&nbsp;                methodGraphCompiler,
&nbsp;                instrumentedTypeFactory,
&nbsp;                typeValidation,
&nbsp;                visibilityBridgeStrategy,
&nbsp;                classWriterStrategy,
&nbsp;                ignoredMethods);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation fo the {@code values} method of an enumeration type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class EnumerationImplementation implements Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link java.lang.Object#clone()} method.
&nbsp;         */
&nbsp;        protected static final String CLONE_METHOD_NAME = &quot;clone&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@code valueOf} method that is defined for any enumeration.
&nbsp;         */
&nbsp;        protected static final String ENUM_VALUE_OF_METHOD_NAME = &quot;valueOf&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@code values} method that is defined for any enumeration.
&nbsp;         */
&nbsp;        protected static final String ENUM_VALUES_METHOD_NAME = &quot;values&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The field modifiers to use for any field that is added to an enumeration.
&nbsp;         */
&nbsp;        private static final int ENUM_FIELD_MODIFIERS = Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the field containing an array of all enumeration values.
&nbsp;         */
&nbsp;        private static final String ENUM_VALUES = &quot;$VALUES&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The names of the enumerations to define for the enumeration.
&nbsp;         */
&nbsp;        private final List&lt;String&gt; values;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new implementation of an enumeration type.
&nbsp;         *
&nbsp;         * @param values The values of the enumeration.
&nbsp;         */
<b class="fc">&nbsp;        protected EnumerationImplementation(List&lt;String&gt; values) {</b>
<b class="fc">&nbsp;            this.values = values;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            for (String value : values) {</b>
<b class="fc">&nbsp;                instrumentedType = instrumentedType.withField(new FieldDescription.Token(value,</b>
&nbsp;                        ENUM_FIELD_MODIFIERS | Opcodes.ACC_ENUM,
<b class="fc">&nbsp;                        TargetType.DESCRIPTION.asGenericType()));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return instrumentedType</b>
<b class="fc">&nbsp;                    .withField(new FieldDescription.Token(ENUM_VALUES,</b>
&nbsp;                            ENUM_FIELD_MODIFIERS | Opcodes.ACC_SYNTHETIC,
<b class="fc">&nbsp;                            TypeDescription.ArrayProjection.of(TargetType.DESCRIPTION).asGenericType()))</b>
<b class="fc">&nbsp;                    .withInitializer(new InitializationAppender(values));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new ValuesMethodAppender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A byte code appender for the {@code values} method of any enumeration type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ValuesMethodAppender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented enumeration type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender for the {@code values} method.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented enumeration type.
&nbsp;             */
<b class="fc">&nbsp;            protected ValuesMethodAppender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                FieldDescription valuesField = instrumentedType.getDeclaredFields().filter(named(ENUM_VALUES)).getOnly();</b>
<b class="fc">&nbsp;                MethodDescription cloneMethod = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class).getDeclaredMethods().filter(named(CLONE_METHOD_NAME)).getOnly();</b>
<b class="fc">&nbsp;                return new Size(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        FieldAccess.forField(valuesField).read(),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(cloneMethod).virtual(valuesField.getType().asErasure()),</b>
<b class="fc">&nbsp;                        TypeCasting.to(valuesField.getType().asErasure()),</b>
&nbsp;                        MethodReturn.REFERENCE
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A byte code appender for the type initializer of any enumeration type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class InitializationAppender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The values of the enumeration that is being created.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; values;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an appender for an enumerations type initializer.
&nbsp;             *
&nbsp;             * @param values The values of the enumeration that is being created.
&nbsp;             */
<b class="fc">&nbsp;            protected InitializationAppender(List&lt;String&gt; values) {</b>
<b class="fc">&nbsp;                this.values = values;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                TypeDescription instrumentedType = instrumentedMethod.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                MethodDescription enumConstructor = instrumentedType.getDeclaredMethods()</b>
<b class="fc">&nbsp;                        .filter(isConstructor().and(takesArguments(String.class, int.class)))</b>
<b class="fc">&nbsp;                        .getOnly();</b>
<b class="fc">&nbsp;                int ordinal = 0;</b>
<b class="fc">&nbsp;                StackManipulation stackManipulation = StackManipulation.Trivial.INSTANCE;</b>
<b class="fc">&nbsp;                List&lt;FieldDescription&gt; enumerationFields = new ArrayList&lt;FieldDescription&gt;(values.size());</b>
<b class="fc">&nbsp;                for (String value : values) {</b>
<b class="fc">&nbsp;                    FieldDescription fieldDescription = instrumentedType.getDeclaredFields().filter(named(value)).getOnly();</b>
<b class="fc">&nbsp;                    stackManipulation = new StackManipulation.Compound(stackManipulation,</b>
<b class="fc">&nbsp;                            TypeCreation.of(instrumentedType),</b>
&nbsp;                            Duplication.SINGLE,
&nbsp;                            new TextConstant(value),
<b class="fc">&nbsp;                            IntegerConstant.forValue(ordinal++),</b>
<b class="fc">&nbsp;                            MethodInvocation.invoke(enumConstructor),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).write());</b>
<b class="fc">&nbsp;                    enumerationFields.add(fieldDescription);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; fieldGetters = new ArrayList&lt;StackManipulation&gt;(values.size());</b>
<b class="fc">&nbsp;                for (FieldDescription fieldDescription : enumerationFields) {</b>
<b class="fc">&nbsp;                    fieldGetters.add(FieldAccess.forField(fieldDescription).read());</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                stackManipulation = new StackManipulation.Compound(</b>
&nbsp;                        stackManipulation,
<b class="fc">&nbsp;                        ArrayFactory.forType(instrumentedType.asGenericType()).withValues(fieldGetters),</b>
<b class="fc">&nbsp;                        FieldAccess.forField(instrumentedType.getDeclaredFields().filter(named(ENUM_VALUES)).getOnly()).write()</b>
&nbsp;                );
<b class="fc">&nbsp;                return new Size(stackManipulation.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A constructor strategy for implementing a Java record.
&nbsp;     */
<b class="fc">&nbsp;    @HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;    protected enum RecordConstructorStrategy implements ConstructorStrategy, Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public List&lt;MethodDescription.Token&gt; extractConstructors(TypeDescription instrumentedType) {
<b class="fc">&nbsp;            List&lt;ParameterDescription.Token&gt; tokens = new ArrayList&lt;ParameterDescription.Token&gt;(instrumentedType.getRecordComponents().size());</b>
<b class="fc">&nbsp;            for (RecordComponentDescription.InDefinedShape recordComponent : instrumentedType.getRecordComponents()) {</b>
<b class="fc">&nbsp;                tokens.add(new ParameterDescription.Token(recordComponent.getType(),</b>
<b class="fc">&nbsp;                        recordComponent.getDeclaredAnnotations().filter(targetsElement(ElementType.CONSTRUCTOR)),</b>
<b class="fc">&nbsp;                        recordComponent.getActualName(),</b>
<b class="fc">&nbsp;                        ModifierContributor.EMPTY_MASK));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return Collections.singletonList(new MethodDescription.Token(MethodDescription.CONSTRUCTOR_INTERNAL_NAME,</b>
&nbsp;                    Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                    Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
<b class="fc">&nbsp;                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class),</b>
&nbsp;                    tokens,
<b class="fc">&nbsp;                    Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                    AnnotationValue.UNDEFINED,
&nbsp;                    TypeDescription.Generic.UNDEFINED));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodRegistry inject(TypeDescription instrumentedType, MethodRegistry methodRegistry) {
<b class="fc">&nbsp;            return methodRegistry.prepend(new LatentMatcher.Resolved&lt;MethodDescription&gt;(isConstructor().and(takesGenericArguments(instrumentedType.getRecordComponents().asTypeList()))),</b>
&nbsp;                    new MethodRegistry.Handler.ForImplementation(this),
&nbsp;                    MethodAttributeAppender.ForInstrumentedMethod.EXCLUDING_RECEIVER,
<b class="fc">&nbsp;                    Transformer.ForMethod.NoOp.&lt;MethodDescription&gt;make());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            for (RecordComponentDescription.InDefinedShape recordComponent : instrumentedType.getRecordComponents()) {</b>
<b class="fc">&nbsp;                instrumentedType = instrumentedType</b>
<b class="fc">&nbsp;                        .withField(new FieldDescription.Token(recordComponent.getActualName(),</b>
&nbsp;                                Opcodes.ACC_PRIVATE | Opcodes.ACC_FINAL,
<b class="fc">&nbsp;                                recordComponent.getType(),</b>
<b class="fc">&nbsp;                                recordComponent.getDeclaredAnnotations().filter(targetsElement(ElementType.FIELD))))</b>
<b class="fc">&nbsp;                        .withMethod(new MethodDescription.Token(recordComponent.getActualName(),</b>
&nbsp;                                Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
<b class="fc">&nbsp;                                recordComponent.getType(),</b>
<b class="fc">&nbsp;                                Collections.&lt;ParameterDescription.Token&gt;emptyList(),</b>
<b class="fc">&nbsp;                                Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                                recordComponent.getDeclaredAnnotations().filter(targetsElement(ElementType.METHOD)),</b>
&nbsp;                                AnnotationValue.UNDEFINED,
&nbsp;                                TypeDescription.Generic.UNDEFINED));
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A byte code appender for accessors and the record constructor.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for accessors and the record constructor.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (instrumentedMethod.isMethod()) {</b>
<b class="fc">&nbsp;                    return new Simple(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(instrumentedType.getDeclaredFields().filter(named(instrumentedMethod.getName())).getOnly()).read(),</b>
<b class="fc">&nbsp;                            MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(instrumentedType.getRecordComponents().size() * 3 + 2);</b>
<b class="fc">&nbsp;                    stackManipulations.add(MethodVariableAccess.loadThis());</b>
<b class="fc">&nbsp;                    stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.RECORD.getTypeStub(), new MethodDescription.Token(Opcodes.ACC_PUBLIC))));</b>
<b class="fc">&nbsp;                    int offset = 1;</b>
<b class="fc">&nbsp;                    for (RecordComponentDescription.InDefinedShape recordComponent : instrumentedType.getRecordComponents()) {</b>
<b class="fc">&nbsp;                        stackManipulations.add(MethodVariableAccess.loadThis());</b>
<b class="fc">&nbsp;                        stackManipulations.add(MethodVariableAccess.of(recordComponent.getType()).loadFrom(offset));</b>
<b class="fc">&nbsp;                        stackManipulations.add(FieldAccess.forField(instrumentedType.getDeclaredFields()</b>
<b class="fc">&nbsp;                                .filter(named(recordComponent.getActualName()))</b>
<b class="fc">&nbsp;                                .getOnly()).write());</b>
<b class="fc">&nbsp;                        offset += recordComponent.getType().getStackSize().getSize();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    stackManipulations.add(MethodReturn.VOID);</b>
<b class="fc">&nbsp;                    return new Simple(stackManipulations).apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the object methods of the Java record type.
&nbsp;     */
<b class="fc">&nbsp;    @HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;    protected enum RecordObjectMethod implements Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code hashCode} method.
&nbsp;         */
<b class="fc">&nbsp;        HASH_CODE(&quot;hashCode&quot;, StackManipulation.Trivial.INSTANCE, int.class),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code equals} method.
&nbsp;         */
<b class="fc">&nbsp;        EQUALS(&quot;equals&quot;, MethodVariableAccess.REFERENCE.loadFrom(1), boolean.class, Object.class),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code toString} method.
&nbsp;         */
<b class="fc">&nbsp;        TO_STRING(&quot;toString&quot;, StackManipulation.Trivial.INSTANCE, String.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The method name.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The stack manipulation to append to the arguments.
&nbsp;         */
&nbsp;        private final StackManipulation stackManipulation;
&nbsp;
&nbsp;        /**
&nbsp;         * The return type.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The arguments type.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; arguments;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new object method instance for a Java record.
&nbsp;         *
&nbsp;         * @param name              The method name.
&nbsp;         * @param stackManipulation The stack manipulation to append to the arguments.
&nbsp;         * @param returnType        The return type.
&nbsp;         * @param arguments         The arguments type.
&nbsp;         */
<b class="fc">&nbsp;        RecordObjectMethod(String name, StackManipulation stackManipulation, Class&lt;?&gt; returnType, Class&lt;?&gt;... arguments) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;            this.returnType = TypeDescription.ForLoadedType.of(returnType);</b>
<b class="fc">&nbsp;            this.arguments = new TypeList.ForLoadedTypes(arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            List&lt;JavaConstant&gt; methodHandles = new ArrayList&lt;JavaConstant&gt;(implementationTarget.getInstrumentedType().getRecordComponents().size());</b>
<b class="fc">&nbsp;            for (RecordComponentDescription.InDefinedShape recordComponent : implementationTarget.getInstrumentedType().getRecordComponents()) {</b>
<b class="fc">&nbsp;                if (stringBuilder.length() &gt; 0) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&quot;;&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                stringBuilder.append(recordComponent.getActualName());</b>
<b class="fc">&nbsp;                methodHandles.add(JavaConstant.MethodHandle.ofGetter(implementationTarget.getInstrumentedType().getDeclaredFields()</b>
<b class="fc">&nbsp;                        .filter(named(recordComponent.getActualName()))</b>
<b class="fc">&nbsp;                        .getOnly()));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new ByteCodeAppender.Simple(MethodVariableAccess.loadThis(),</b>
&nbsp;                    stackManipulation,
<b class="fc">&nbsp;                    MethodInvocation.invoke(new MethodDescription.Latent(JavaType.OBJECT_METHODS.getTypeStub(), new MethodDescription.Token(&quot;bootstrap&quot;,</b>
&nbsp;                            Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
<b class="fc">&nbsp;                            TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class),</b>
<b class="fc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                    TypeDescription.ForLoadedType.of(String.class).asGenericType(),</b>
<b class="fc">&nbsp;                                    JavaType.TYPE_DESCRIPTOR.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class).asGenericType(),</b>
<b class="fc">&nbsp;                                    TypeDescription.ForLoadedType.of(String.class).asGenericType(),</b>
<b class="fc">&nbsp;                                    TypeDescription.ArrayProjection.of(JavaType.METHOD_HANDLE.getTypeStub()).asGenericType())))).dynamic(name,</b>
&nbsp;                            returnType,
<b class="fc">&nbsp;                            CompoundList.of(implementationTarget.getInstrumentedType(), arguments),</b>
<b class="fc">&nbsp;                            CompoundList.of(Arrays.asList(JavaConstant.Simple.of(implementationTarget.getInstrumentedType()), JavaConstant.Simple.ofLoaded(stringBuilder.toString())), methodHandles)),</b>
<b class="fc">&nbsp;                    MethodReturn.of(returnType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
