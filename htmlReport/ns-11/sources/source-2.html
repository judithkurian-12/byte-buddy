


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > RecordComponentDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.type</a>
</div>

<h1>Coverage Summary for Class: RecordComponentDescription (net.bytebuddy.description.type)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">RecordComponentDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    26.3%
  </span>
  <span class="absValue">
    (5/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$ForLoadedRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$ForLoadedRecordComponent$RecordComponent</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$MockitoMock$2010420130</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$MockitoMock$2010420130$auxiliary$GmrQKqeZ</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$MockitoMock$2010420130$auxiliary$QYHYeDdG</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (15/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715$auxiliary$7NH7G5uX</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715$auxiliary$FuXn04NM</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715$auxiliary$IhYSbCc5</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715$auxiliary$koE4TyHJ</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715$auxiliary$PSTxU3YD</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$Token$MockitoMock$507450715$auxiliary$TfRbr9Or</td>
  </tr>
  <tr>
    <td class="name">RecordComponentDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    68.3%
  </span>
  <span class="absValue">
    (28/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62%
  </span>
  <span class="absValue">
    (49/79)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.type;
&nbsp;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.DeclaredByType;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.signature.SignatureWriter;
&nbsp;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import java.lang.reflect.AnnotatedElement;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * Represents a component of a Java record.
&nbsp; */
&nbsp;public interface RecordComponentDescription extends DeclaredByType.WithMandatoryDeclaration,
&nbsp;        NamedElement.WithDescriptor,
&nbsp;        AnnotationSource,
&nbsp;        ByteCodeElement.TypeDependant&lt;RecordComponentDescription.InDefinedShape, RecordComponentDescription.Token&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the type of the record.
&nbsp;     *
&nbsp;     * @return The type of the record.
&nbsp;     */
&nbsp;    TypeDescription.Generic getType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the accessor for this record component.
&nbsp;     *
&nbsp;     * @return The accessor for this record component.
&nbsp;     */
&nbsp;    MethodDescription getAccessor();
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves this record component to a token where all types are detached.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply for detachment.
&nbsp;     * @return An appropriate token.
&nbsp;     */
&nbsp;    Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher);
&nbsp;
&nbsp;    /**
&nbsp;     * A description of a record component in generic shape.
&nbsp;     */
&nbsp;    interface InGenericShape extends RecordComponentDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        MethodDescription.InGenericShape getAccessor();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of a record component in its defined shape.
&nbsp;     */
&nbsp;    interface InDefinedShape extends RecordComponentDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        MethodDescription.InDefinedShape getAccessor();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        TypeDescription getDeclaringType();
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a record component description in its defined shape.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends RecordComponentDescription.AbstractBase implements InDefinedShape {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape getAccessor() {
<b class="fc">&nbsp;                return getDeclaringType().getDeclaredMethods().filter(named(getActualName())).getOnly();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InDefinedShape asDefined() {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation for a record component description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase implements RecordComponentDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="nc">&nbsp;            return new Token(getActualName(),</b>
<b class="nc">&nbsp;                    getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="nc">&nbsp;                    getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return getType().asErasure().getDescriptor();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getGenericSignature() {
<b class="fc">&nbsp;            TypeDescription.Generic recordComponentType = getType();</b>
&nbsp;            try {
<b class="fc">&nbsp;                return recordComponentType.getSort().isNonGeneric()</b>
<b class="fc">&nbsp;                        ? NON_GENERIC_SIGNATURE</b>
<b class="nc">&nbsp;                        : recordComponentType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(new SignatureWriter())).toString();</b>
<b class="nc">&nbsp;            } catch (GenericSignatureFormatError ignored) {</b>
<b class="nc">&nbsp;                return NON_GENERIC_SIGNATURE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return getActualName().hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof RecordComponentDescription)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            RecordComponentDescription recordComponentDescription = (RecordComponentDescription) other;</b>
<b class="nc">&nbsp;            return getActualName().equals(recordComponentDescription.getActualName());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return getType().getTypeName() + &quot; &quot; + getActualName();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a loaded record component.
&nbsp;     */
&nbsp;    class ForLoadedRecordComponent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for accessing {@code java.lang.RecordComponent} types.
&nbsp;         */
<b class="fc">&nbsp;        protected static final RecordComponent RECORD_COMPONENT = doPrivileged(JavaDispatcher.of(RecordComponent.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The represented record component.
&nbsp;         */
&nbsp;        private final AnnotatedElement recordComponent;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new representation of a loaded record component.
&nbsp;         *
&nbsp;         * @param recordComponent The represented record component.
&nbsp;         */
<b class="fc">&nbsp;        protected ForLoadedRecordComponent(AnnotatedElement recordComponent) {</b>
<b class="fc">&nbsp;            this.recordComponent = recordComponent;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves an instance into a record component description.
&nbsp;         *
&nbsp;         * @param recordComponent The record component to represent.
&nbsp;         * @return A suitable description of the record component.
&nbsp;         */
&nbsp;        public static RecordComponentDescription of(Object recordComponent) {
<b class="nc">&nbsp;            if (!RECORD_COMPONENT.isInstance(recordComponent)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a record component: &quot; + recordComponent);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new ForLoadedRecordComponent((AnnotatedElement) recordComponent);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return new TypeDescription.Generic.LazyProjection.OfRecordComponent(recordComponent);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public MethodDescription.InDefinedShape getAccessor() {
<b class="fc">&nbsp;            return new MethodDescription.ForLoadedMethod(RECORD_COMPONENT.getAccessor(recordComponent));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(RECORD_COMPONENT.getDeclaringRecord(recordComponent));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getActualName() {
<b class="fc">&nbsp;            return RECORD_COMPONENT.getName(recordComponent);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @MaybeNull
&nbsp;        public String getGenericSignature() {
<b class="nc">&nbsp;            return RECORD_COMPONENT.getGenericSignature(recordComponent);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(recordComponent.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for accessing methods of {@code java.lang.reflect.RecordComponent}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.reflect.RecordComponent&quot;)
&nbsp;        protected interface RecordComponent {
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the supplied instance is a record component.
&nbsp;             *
&nbsp;             * @param instance The instance to evaluate.
&nbsp;             * @return {@code true} if the supplied instance is a record component.
&nbsp;             */
&nbsp;            @JavaDispatcher.Instance
&nbsp;            boolean isInstance(Object instance);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a record component&#39;s name.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the name for.
&nbsp;             * @return The record component&#39;s name.
&nbsp;             */
&nbsp;            String getName(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a record component&#39;s declaring type.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the declared type for.
&nbsp;             * @return The record component&#39;s declaring type.
&nbsp;             */
&nbsp;            Class&lt;?&gt; getDeclaringRecord(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a record component&#39;s accessor method.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the accessor method for.
&nbsp;             * @return The record component&#39;s accessor method.
&nbsp;             */
&nbsp;            Method getAccessor(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a record component&#39;s type.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the type for.
&nbsp;             * @return The record component&#39;s type.
&nbsp;             */
&nbsp;            Class&lt;?&gt; getType(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a record component&#39;s generic type.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the generic type for.
&nbsp;             * @return The record component&#39;s generic type.
&nbsp;             */
&nbsp;            Type getGenericType(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the record component type&#39;s generic signature.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the generic signature for.
&nbsp;             * @return The record component type&#39;s generic signature or {@code null} if no signature is defined.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            String getGenericSignature(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a record component&#39;s annotated type.
&nbsp;             *
&nbsp;             * @param value The record component to resolve the annotated type for.
&nbsp;             * @return The record component&#39;s annotated type.
&nbsp;             */
&nbsp;            AnnotatedElement getAnnotatedType(Object value);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent record component description.
&nbsp;     */
&nbsp;    class Latent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The record component&#39;s declaring type.
&nbsp;         */
&nbsp;        private final TypeDescription declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The record component&#39;s name.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The record component&#39;s type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic type;
&nbsp;
&nbsp;        /**
&nbsp;         * The record component&#39;s annotations.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent record component.
&nbsp;         *
&nbsp;         * @param declaringType The record component&#39;s declaring type.
&nbsp;         * @param token         The token representing the record component&#39;s detached properties.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType, Token token) {
<b class="fc">&nbsp;            this(declaringType,</b>
<b class="fc">&nbsp;                    token.getName(),</b>
<b class="fc">&nbsp;                    token.getType(),</b>
<b class="fc">&nbsp;                    token.getAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent record component.
&nbsp;         *
&nbsp;         * @param declaringType The record component&#39;s declaring type-
&nbsp;         * @param name          The record component&#39;s name.
&nbsp;         * @param type          The record component&#39;s type.
&nbsp;         * @param annotations   The record component&#39;s annotations.
&nbsp;         */
<b class="fc">&nbsp;        public Latent(TypeDescription declaringType, String name, TypeDescription.Generic type, List&lt;? extends AnnotationDescription&gt; annotations) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return type.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getActualName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type substituting representation of a record component description.
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;
&nbsp;        /**
&nbsp;         * The type that declares this type-substituted record component.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented record component.
&nbsp;         */
&nbsp;        private final RecordComponentDescription recordComponentDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that is applied to the parameter type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type substituting representation of a record component description.
&nbsp;         *
&nbsp;         * @param declaringType              The type that declares this type-substituted record component.
&nbsp;         * @param recordComponentDescription The represented record component.
&nbsp;         * @param visitor                    A visitor that is applied to the parameter type.
&nbsp;         */
&nbsp;        public TypeSubstituting(TypeDescription.Generic declaringType,
&nbsp;                                RecordComponentDescription recordComponentDescription,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.recordComponentDescription = recordComponentDescription;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDescription.InGenericShape getAccessor() {
<b class="nc">&nbsp;            return declaringType.getDeclaredMethods().filter(named(getActualName())).getOnly();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return recordComponentDescription.getType().accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InDefinedShape asDefined() {
<b class="nc">&nbsp;            return recordComponentDescription.asDefined();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDefinition getDeclaringType() {
<b class="nc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getActualName() {
<b class="nc">&nbsp;            return recordComponentDescription.getActualName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;            return recordComponentDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a record component&#39;s properties detached from a type.
&nbsp;     */
&nbsp;    class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The token&#39;s name.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The token&#39;s type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic type;
&nbsp;
&nbsp;        /**
&nbsp;         * The token&#39;s annotations.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new record component token without annotations.
&nbsp;         *
&nbsp;         * @param name The token&#39;s name.
&nbsp;         * @param type The token&#39;s type.
&nbsp;         */
&nbsp;        public Token(String name, TypeDescription.Generic type) {
<b class="fc">&nbsp;            this(name, type, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new record component token.
&nbsp;         *
&nbsp;         * @param name        The token&#39;s name.
&nbsp;         * @param type        The token&#39;s type.
&nbsp;         * @param annotations The token&#39;s annotations.
&nbsp;         */
<b class="fc">&nbsp;        public Token(String name, TypeDescription.Generic type, List&lt;? extends AnnotationDescription&gt; annotations) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the token&#39;s name.
&nbsp;         *
&nbsp;         * @return The token&#39;s name.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the token&#39;s type.
&nbsp;         *
&nbsp;         * @return The token&#39;s type.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the token&#39;s annotations.
&nbsp;         *
&nbsp;         * @return The token&#39;s annotations.
&nbsp;         */
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(name, type.accept(visitor), annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + type.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + annotations.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            RecordComponentDescription.Token token = (RecordComponentDescription.Token) other;</b>
<b class="fc">&nbsp;            return name.equals(token.name)</b>
<b class="fc">&nbsp;                    &amp;&amp; type.equals(token.type)</b>
<b class="fc">&nbsp;                    &amp;&amp; annotations.equals(token.annotations);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
