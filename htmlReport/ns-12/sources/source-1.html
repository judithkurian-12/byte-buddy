


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ClassFileLocator</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic</a>
</div>

<h1>Coverage Summary for Class: ClassFileLocator (net.bytebuddy.dynamic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">ClassFileLocator$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Filtering</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (33/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$BootLoaderProxyCreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$MockitoMock$624069169</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$MockitoMock$624069169$auxiliary$AewqcTXA</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$MockitoMock$624069169$auxiliary$crtUDo0S</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$MockitoMock$624069169$auxiliary$ebcbyCda</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$MockitoMock$624069169$auxiliary$Tx5kWkme</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForClassLoader$WeaklyReferenced</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (10/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForFolder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (21/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$Default$BootLoaderProxyCreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$ForDelegatingClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.4%
  </span>
  <span class="absValue">
    (3/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$ForDelegatingClassLoader$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$ForDelegatingClassLoader$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$ForDelegatingClassLoader$Dispatcher$Initializable</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$ForDelegatingClassLoader$Dispatcher$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ClassLoadingDelegate$ForDelegatingClassLoader$Dispatcher$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForInstrumentation$ExtractionClassFileTransformer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForJarFile</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (20/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForModule</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.5%
  </span>
  <span class="absValue">
    (23/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForModule$WeaklyReferenced</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (12/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForModuleFile</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.2%
  </span>
  <span class="absValue">
    (27/56)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForUrl</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$ForUrl$ClassLoaderCreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$MockitoMock$1861161343</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$MockitoMock$1861161343$auxiliary$IlZZF2Mb</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$MockitoMock$1861161343$auxiliary$ZqeArXsO</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$PackageDiscriminating</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Resolution</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Resolution$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Resolution$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Resolution$MockitoMock$1820831176</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Resolution$MockitoMock$1820831176$auxiliary$pfZsj71c</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Resolution$MockitoMock$1820831176$auxiliary$wXplPcxY</td>
  </tr>
  <tr>
    <td class="name">ClassFileLocator$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88.1%
  </span>
  <span class="absValue">
    (118/134)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.5%
  </span>
  <span class="absValue">
    (278/378)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.agent.builder.AgentBuilder;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.StreamDrainer;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.lang.instrument.ClassFileTransformer;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.instrument.UnmodifiableClassException;
&nbsp;import java.lang.ref.WeakReference;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.*;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.zip.ZipEntry;
&nbsp;import java.util.zip.ZipFile;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isChildOf;
&nbsp;
&nbsp;/**
&nbsp; * Locates a class file or its byte array representation when it is given its type description.
&nbsp; */
&nbsp;public interface ClassFileLocator extends Closeable {
&nbsp;
&nbsp;    /**
&nbsp;     * The file extension for a Java class file.
&nbsp;     */
&nbsp;    String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Locates the class file for a given type and returns the binary data of the class file.
&nbsp;     *
&nbsp;     * @param name The name of the type to locate a class file representation for.
&nbsp;     * @return Any binary representation of the type which might be illegal.
&nbsp;     * @throws java.io.IOException If reading a class file causes an error.
&nbsp;     */
&nbsp;    Resolution locate(String name) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a class file as binary data.
&nbsp;     */
&nbsp;    interface Resolution {
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if this binary representation is valid.
&nbsp;         *
&nbsp;         * @return {@code true} if this binary representation is valid.
&nbsp;         */
&nbsp;        boolean isResolved();
&nbsp;
&nbsp;        /**
&nbsp;         * Finds the data of this binary representation. Calling this method is only legal for resolved instances.
&nbsp;         * For non-resolved instances, an exception is thrown.
&nbsp;         *
&nbsp;         * @return The requested binary data. The returned array must not be altered.
&nbsp;         */
&nbsp;        byte[] resolve();
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical representation of an illegal binary representation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Illegal implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the unresolved class file.
&nbsp;             */
&nbsp;            private final String typeName;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an illegal resolution for a class file.
&nbsp;             *
&nbsp;             * @param typeName The name of the unresolved class file.
&nbsp;             */
<b class="fc">&nbsp;            public Illegal(String typeName) {</b>
<b class="fc">&nbsp;                this.typeName = typeName;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public byte[] resolve() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Could not locate class file for &quot; + typeName);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a byte array as binary data.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Explicit implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented data.
&nbsp;             */
&nbsp;            private final byte[] binaryRepresentation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new explicit resolution of a given array of binary data.
&nbsp;             *
&nbsp;             * @param binaryRepresentation The binary data to represent. The array must not be modified.
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not modified by class contract.&quot;)
<b class="fc">&nbsp;            public Explicit(byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;                this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP&quot;, justification = &quot;The array is not modified by class contract.&quot;)
&nbsp;            public byte[] resolve() {
<b class="fc">&nbsp;                return binaryRepresentation;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that cannot locate any class files.
&nbsp;     */
<b class="fc">&nbsp;    enum NoOp implements ClassFileLocator {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) {
<b class="fc">&nbsp;            return new Resolution.Illegal(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A simple class file locator that returns class files from a selection of given types.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Simple implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * The class files that are known to this class file locator mapped by their type name.
&nbsp;         */
&nbsp;        private final Map&lt;String, byte[]&gt; classFiles;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new simple class file locator.
&nbsp;         *
&nbsp;         * @param classFiles The class files that are known to this class file locator mapped by their type name.
&nbsp;         */
<b class="fc">&nbsp;        public Simple(Map&lt;String, byte[]&gt; classFiles) {</b>
<b class="fc">&nbsp;            this.classFiles = classFiles;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator for a single known type.
&nbsp;         *
&nbsp;         * @param typeName             The name of the type.
&nbsp;         * @param binaryRepresentation The binary representation of the type.
&nbsp;         * @return An appropriate class file locator.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(String typeName, byte[] binaryRepresentation) {
<b class="fc">&nbsp;            return new Simple(Collections.singletonMap(typeName, binaryRepresentation));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator that represents all types of a dynamic type.
&nbsp;         *
&nbsp;         * @param dynamicType The dynamic type to represent.
&nbsp;         * @return A class file locator representing the dynamic type&#39;s types.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(DynamicType dynamicType) {
<b class="fc">&nbsp;            return of(dynamicType.getAllTypes());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator that represents all types of a dynamic type.
&nbsp;         *
&nbsp;         * @param binaryRepresentations The binary representation of all types.
&nbsp;         * @return A class file locator representing the dynamic type&#39;s types.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) {
<b class="fc">&nbsp;            Map&lt;String, byte[]&gt; classFiles = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : binaryRepresentations.entrySet()) {</b>
<b class="fc">&nbsp;                classFiles.put(entry.getKey().getName(), entry.getValue());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Simple(classFiles);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator of a map of resources where class files are mapped by their path and file extension.
&nbsp;         *
&nbsp;         * @param binaryRepresentations A map of resource names to their binary representation.
&nbsp;         * @return A class file locator that finds class files within the map.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofResources(Map&lt;String, byte[]&gt; binaryRepresentations) {
<b class="fc">&nbsp;            Map&lt;String, byte[]&gt; classFiles = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;String, byte[]&gt; entry : binaryRepresentations.entrySet()) {</b>
<b class="fc">&nbsp;                if (entry.getKey().endsWith(CLASS_FILE_EXTENSION)) {</b>
<b class="fc">&nbsp;                    classFiles.put(entry.getKey().substring(0, entry.getKey().length() - CLASS_FILE_EXTENSION.length()).replace(&#39;/&#39;, &#39;.&#39;), entry.getValue());</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Simple(classFiles);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) {
<b class="fc">&nbsp;            byte[] binaryRepresentation = classFiles.get(name);</b>
<b class="fc">&nbsp;            return binaryRepresentation == null</b>
<b class="fc">&nbsp;                    ? new Resolution.Illegal(name)</b>
<b class="fc">&nbsp;                    : new Resolution.Explicit(binaryRepresentation);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A class file locator that queries a class loader for binary representations of class files.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Even when calling {@link Closeable#close()} on this class file locator, no underlying
&nbsp;     * class loader is closed if it implements the {@link Closeable} interface as this is typically not intended.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForClassLoader implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * A class loader that does not define resources of its own but allows querying for resources supplied by the boot loader.
&nbsp;         */
<b class="fc">&nbsp;        private static final ClassLoader BOOT_LOADER_PROXY = doPrivileged(BootLoaderProxyCreationAction.INSTANCE);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to query.
&nbsp;         */
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for the given class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to query which must not be the bootstrap class loader, i.e. {@code null}.
&nbsp;         */
<b class="fc">&nbsp;        protected ForClassLoader(ClassLoader classLoader) {</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator that queries the system class loader.
&nbsp;         *
&nbsp;         * @return A class file locator that queries the system class loader.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofSystemLoader() {
<b class="fc">&nbsp;            return new ForClassLoader(ClassLoader.getSystemClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator that queries the plaform class loader or the extension class loader if the
&nbsp;         * current VM is not at least of version 9.
&nbsp;         *
&nbsp;         * @return A class file locator that queries the plaform class loader or the extension class loader.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofPlatformLoader() {
<b class="fc">&nbsp;            return of(ClassLoader.getSystemClassLoader().getParent());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator that queries the boot loader.
&nbsp;         *
&nbsp;         * @return A class file locator that queries the boot loader.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofBootLoader() {
<b class="fc">&nbsp;            return new ForClassLoader(BOOT_LOADER_PROXY);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator for a given class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to be used which might be {@code null} to represent the bootstrap loader.
&nbsp;         * @return A corresponding source locator.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            return new ForClassLoader(classLoader == null</b>
<b class="fc">&nbsp;                    ? BOOT_LOADER_PROXY</b>
<b class="fc">&nbsp;                    : classLoader);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to create a binary representation of a loaded type by requesting data from its
&nbsp;         * {@link java.lang.ClassLoader}.
&nbsp;         *
&nbsp;         * @param type The type of interest.
&nbsp;         * @return The binary representation of the supplied type.
&nbsp;         */
&nbsp;        public static byte[] read(Class&lt;?&gt; type) {
&nbsp;            try {
<b class="fc">&nbsp;                ClassLoader classLoader = type.getClassLoader();</b>
<b class="fc">&nbsp;                return locate(classLoader == null</b>
<b class="fc">&nbsp;                        ? BOOT_LOADER_PROXY</b>
<b class="fc">&nbsp;                        : classLoader, TypeDescription.ForLoadedType.getName(type)).resolve();</b>
<b class="nc">&nbsp;            } catch (IOException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot read class file for &quot; + type, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to create a binary representation of several loaded types by requesting
&nbsp;         * data from their respective {@link java.lang.ClassLoader}s.
&nbsp;         *
&nbsp;         * @param type The types of interest.
&nbsp;         * @return A mapping of the supplied types to their binary representation.
&nbsp;         */
&nbsp;        public static Map&lt;Class&lt;?&gt;, byte[]&gt; read(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            return read(Arrays.asList(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to create a binary representation of several loaded types by requesting
&nbsp;         * data from their respective {@link java.lang.ClassLoader}s.
&nbsp;         *
&nbsp;         * @param types The types of interest.
&nbsp;         * @return A mapping of the supplied types to their binary representation.
&nbsp;         */
&nbsp;        public static Map&lt;Class&lt;?&gt;, byte[]&gt; read(Collection&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;            Map&lt;Class&lt;?&gt;, byte[]&gt; result = new HashMap&lt;Class&lt;?&gt;, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                result.put(type, read(type));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to create a binary representation of several loaded types by requesting
&nbsp;         * data from their respective {@link java.lang.ClassLoader}s.
&nbsp;         *
&nbsp;         * @param type The types of interest.
&nbsp;         * @return A mapping of the supplied types&#39; names to their binary representation.
&nbsp;         */
&nbsp;        public static Map&lt;String, byte[]&gt; readToNames(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            return readToNames(Arrays.asList(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to create a binary representation of several loaded types by requesting
&nbsp;         * data from their respective {@link java.lang.ClassLoader}s.
&nbsp;         *
&nbsp;         * @param types The types of interest.
&nbsp;         * @return A mapping of the supplied types&#39; names to their binary representation.
&nbsp;         */
&nbsp;        public static Map&lt;String, byte[]&gt; readToNames(Collection&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;            Map&lt;String, byte[]&gt; result = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                result.put(type.getName(), read(type));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            return locate(classLoader, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Locates the class file for the supplied type by requesting a resource from the class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to query.
&nbsp;         * @param name        The name of the type for which to locate a class file.
&nbsp;         * @return A resolution for the class file.
&nbsp;         * @throws IOException If reading the class file causes an exception.
&nbsp;         */
&nbsp;        protected static Resolution locate(ClassLoader classLoader, String name) throws IOException {
<b class="fc">&nbsp;            InputStream inputStream = classLoader.getResourceAsStream(name.replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;            if (inputStream != null) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A privileged action for creating a proxy class loader for the boot class loader.
&nbsp;         */
<b class="fc">&nbsp;        protected enum BootLoaderProxyCreationAction implements PrivilegedAction&lt;ClassLoader&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassLoader run() {
<b class="fc">&nbsp;                return new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A class file locator that queries a class loader for binary representations of class files.
&nbsp;         * The class loader is only weakly referenced.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Even when calling {@link Closeable#close()} on this class file locator, no underlying
&nbsp;         * class loader is closed if it implements the {@link Closeable} interface as this is typically not intended.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        public static class WeaklyReferenced extends WeakReference&lt;ClassLoader&gt; implements ClassFileLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented class loader&#39;s hash code.
&nbsp;             */
&nbsp;            private final int hashCode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class file locator for a class loader that is weakly referenced.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to represent.
&nbsp;             */
&nbsp;            protected WeaklyReferenced(ClassLoader classLoader) {
<b class="fc">&nbsp;                super(classLoader);</b>
<b class="fc">&nbsp;                hashCode = System.identityHashCode(classLoader);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class file locator for a given class loader. If the class loader is not the bootstrap
&nbsp;             * class loader or the system class loader which cannot be collected, the class loader is only weakly
&nbsp;             * referenced.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to be used. If this class loader represents the bootstrap class
&nbsp;             *                    loader which is represented by the {@code null} value, this system class loader
&nbsp;             *                    is used instead.
&nbsp;             * @return A corresponding source locator.
&nbsp;             */
&nbsp;            public static ClassFileLocator of(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                return classLoader == null || classLoader == ClassLoader.getSystemClassLoader() || classLoader == ClassLoader.getSystemClassLoader().getParent()</b>
<b class="fc">&nbsp;                        ? ForClassLoader.of(classLoader)</b>
<b class="fc">&nbsp;                        : new WeaklyReferenced(classLoader);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;                ClassLoader classLoader = get();</b>
<b class="fc">&nbsp;                return classLoader == null</b>
<b class="nc">&nbsp;                        ? new Resolution.Illegal(name)</b>
<b class="fc">&nbsp;                        : ForClassLoader.locate(classLoader, name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void close() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return hashCode;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                WeaklyReferenced weaklyReferenced = (WeaklyReferenced) other;</b>
<b class="nc">&nbsp;                ClassLoader classLoader = weaklyReferenced.get();</b>
<b class="nc">&nbsp;                return classLoader != null &amp;&amp; get() == classLoader;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A class file locator that locates class files by querying a Java module&#39;s {@code getResourceAsStream} method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Even when calling {@link Closeable#close()} on this class file locator, no underlying
&nbsp;     * class loader is closed if it implements the {@link Closeable} interface as this is typically not intended.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForModule implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object[] NO_ARGUMENT = new Object[0];</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The represented Java module.
&nbsp;         */
&nbsp;        private final JavaModule module;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for a Java module.
&nbsp;         *
&nbsp;         * @param module The represented Java module.
&nbsp;         */
<b class="fc">&nbsp;        protected ForModule(JavaModule module) {</b>
<b class="fc">&nbsp;            this.module = module;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a class file locator that exposes all class files of the boot module layer. This class file locator is only available
&nbsp;         * on virtual machines of version 9 or later. On earlier versions, the returned class file locator does not locate any resources.
&nbsp;         *
&nbsp;         * @return A class file locator that locates classes of the boot layer.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should always be wrapped for clarity&quot;)
&nbsp;        public static ClassFileLocator ofBootLayer() {
&nbsp;            try {
<b class="fc">&nbsp;                Map&lt;String, ClassFileLocator&gt; bootModules = new HashMap&lt;String, ClassFileLocator&gt;();</b>
<b class="fc">&nbsp;                Class&lt;?&gt; layerType = Class.forName(&quot;java.lang.ModuleLayer&quot;);</b>
<b class="fc">&nbsp;                Method getPackages = JavaType.MODULE.load().getMethod(&quot;getPackages&quot;);</b>
<b class="fc">&nbsp;                for (Object rawModule : (Set&lt;?&gt;) layerType.getMethod(&quot;modules&quot;).invoke(layerType.getMethod(&quot;boot&quot;).invoke(null))) {</b>
<b class="fc">&nbsp;                    ClassFileLocator classFileLocator = ForModule.of(JavaModule.of(rawModule));</b>
<b class="fc">&nbsp;                    for (Object packageName : (Set&lt;?&gt;) getPackages.invoke(rawModule, NO_ARGUMENT)) {</b>
<b class="fc">&nbsp;                        bootModules.put((String) packageName, classFileLocator);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new PackageDiscriminating(bootModules);</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot process boot layer&quot;, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a class file locator for the provided module. If the provided module is not named, class files are located via this
&nbsp;         * unnamed module&#39;s class loader.
&nbsp;         *
&nbsp;         * @param module The module to create a class file locator for.
&nbsp;         * @return An appropriate class file locator.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(JavaModule module) {
<b class="fc">&nbsp;            return module.isNamed()</b>
<b class="fc">&nbsp;                    ? new ForModule(module)</b>
<b class="fc">&nbsp;                    : ForClassLoader.of(module.getClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            return locate(module, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a resolution for a Java module&#39;s class files.
&nbsp;         *
&nbsp;         * @param module   The Java module to query.
&nbsp;         * @param typeName The name of the type being queried.
&nbsp;         * @return A resolution for the query.
&nbsp;         * @throws IOException If an I/O exception was thrown.
&nbsp;         */
&nbsp;        protected static Resolution locate(JavaModule module, String typeName) throws IOException {
<b class="fc">&nbsp;            InputStream inputStream = module.getResourceAsStream(typeName.replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;            if (inputStream != null) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return new Resolution.Illegal(typeName);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A class file locator for a Java module that only references this module weakly. If a module was garbage collected,
&nbsp;         * this class file locator only returns unresolved resolutions.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Even when calling {@link Closeable#close()} on this class file locator, no underlying
&nbsp;         * class loader is closed if it implements the {@link Closeable} interface as this is typically not intended.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        public static class WeaklyReferenced extends WeakReference&lt;Object&gt; implements ClassFileLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented module&#39;s hash code.
&nbsp;             */
&nbsp;            private final int hashCode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class file locator for a Java module that is weakly referenced.
&nbsp;             *
&nbsp;             * @param module The raw Java module to represent.
&nbsp;             */
&nbsp;            protected WeaklyReferenced(Object module) {
<b class="fc">&nbsp;                super(module);</b>
<b class="fc">&nbsp;                hashCode = System.identityHashCode(module);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class file locator for a Java module where the module is referenced weakly. If the module is not named, the module&#39;s class loader
&nbsp;             * is represented instead. Module&#39;s of the boot layer are not referenced weakly.
&nbsp;             *
&nbsp;             * @param module The Java module to represent.
&nbsp;             * @return A suitable class file locator.
&nbsp;             */
&nbsp;            public static ClassFileLocator of(JavaModule module) {
<b class="fc">&nbsp;                if (module.isNamed()) {</b>
<b class="fc">&nbsp;                    return module.getClassLoader() == null || module.getClassLoader() == ClassLoader.getSystemClassLoader() || module.getClassLoader() == ClassLoader.getSystemClassLoader().getParent()</b>
<b class="fc">&nbsp;                            ? new ForModule(module)</b>
<b class="fc">&nbsp;                            : new WeaklyReferenced(module.unwrap());</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return ForClassLoader.WeaklyReferenced.of(module.getClassLoader());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;                Object module = get();</b>
<b class="fc">&nbsp;                return module == null</b>
<b class="nc">&nbsp;                        ? new Resolution.Illegal(name)</b>
<b class="fc">&nbsp;                        : ForModule.locate(JavaModule.of(module), name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void close() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return hashCode;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                WeaklyReferenced weaklyReferenced = (WeaklyReferenced) other;</b>
<b class="nc">&nbsp;                Object module = weaklyReferenced.get();</b>
<b class="nc">&nbsp;                return module != null &amp;&amp; get() == module;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that locates classes within a Java &lt;i&gt;jar&lt;/i&gt; file.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForJarFile implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * A list of potential locations of the runtime jar for different platforms.
&nbsp;         */
<b class="fc">&nbsp;        private static final List&lt;String&gt; RUNTIME_LOCATIONS = Arrays.asList(&quot;lib/rt.jar&quot;, &quot;../lib/rt.jar&quot;, &quot;../Classes/classes.jar&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The jar file to read from.
&nbsp;         */
&nbsp;        private final JarFile jarFile;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for the given jar file.
&nbsp;         *
&nbsp;         * @param jarFile The jar file to read from.
&nbsp;         */
<b class="fc">&nbsp;        public ForJarFile(JarFile jarFile) {</b>
<b class="fc">&nbsp;            this.jarFile = jarFile;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for the given jar file.
&nbsp;         *
&nbsp;         * @param file The jar file to read from.
&nbsp;         * @return A class file locator for the jar file.
&nbsp;         * @throws IOException If an I/O exception is thrown.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(File file) throws IOException {
<b class="fc">&nbsp;            return new ForJarFile(new JarFile(file));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a class file locator for the class path that reads class files directly from the file system. The resulting
&nbsp;         * class file locator does not imply classes on the boot path.
&nbsp;         *
&nbsp;         * @return A class file locator for the class path.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofClassPath() throws IOException {
<b class="fc">&nbsp;            return ofClassPath(System.getProperty(&quot;java.class.path&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Resolves a class file locator for the class path that reads class files directly from the file system.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: The resulting class file locator does not include classes of the bootstrap class loader.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param classPath The class path to scan with the elements separated by {@code path.separator}.
&nbsp;         * @return A class file locator for the class path.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofClassPath(String classPath) throws IOException {
<b class="fc">&nbsp;            List&lt;ClassFileLocator&gt; classFileLocators = new ArrayList&lt;ClassFileLocator&gt;();</b>
<b class="fc">&nbsp;            for (String element : Pattern.compile(System.getProperty(&quot;path.separator&quot;), Pattern.LITERAL).split(classPath)) {</b>
<b class="fc">&nbsp;                File file = new File(element);</b>
<b class="fc">&nbsp;                if (file.isDirectory()) {</b>
<b class="fc">&nbsp;                    classFileLocators.add(new ForFolder(file));</b>
<b class="fc">&nbsp;                } else if (file.isFile()) {</b>
<b class="fc">&nbsp;                    classFileLocators.add(of(file));</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return new Compound(classFileLocators);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a class file locator for the runtime jar. If such a file does not exist or cannot be located, a runtime exception is thrown.
&nbsp;         *
&nbsp;         * @return A class file locator for the runtime jar, if available.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofRuntimeJar() throws IOException {
<b class="nc">&nbsp;            String javaHome = System.getProperty(&quot;java.home&quot;).replace(&#39;\\&#39;, &#39;/&#39;);</b>
<b class="nc">&nbsp;            File runtimeJar = null;</b>
<b class="nc">&nbsp;            for (String location : RUNTIME_LOCATIONS) {</b>
<b class="nc">&nbsp;                File candidate = new File(javaHome, location);</b>
<b class="nc">&nbsp;                if (candidate.isFile()) {</b>
<b class="nc">&nbsp;                    runtimeJar = candidate;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (runtimeJar == null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Runtime jar does not exist in &quot; + javaHome + &quot; for any of &quot; + RUNTIME_LOCATIONS);</b>
&nbsp;            }
<b class="nc">&nbsp;            return of(runtimeJar);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            ZipEntry zipEntry = jarFile.getEntry(name.replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;            if (zipEntry == null) {</b>
<b class="fc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                InputStream inputStream = jarFile.getInputStream(zipEntry);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() throws IOException {
<b class="fc">&nbsp;            jarFile.close();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that locates classes within a Java &lt;i&gt;jmod&lt;/i&gt; file. This class file locator should not be used
&nbsp;     * for reading modular jar files for which {@link ForJarFile} is appropriate.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForModuleFile implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * The file extension of a modular Java package.
&nbsp;         */
&nbsp;        private static final String JMOD_FILE_EXTENSION = &quot;.jmod&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of potential locations of the boot path for different platforms.
&nbsp;         */
<b class="fc">&nbsp;        private static final List&lt;String&gt; BOOT_LOCATIONS = Arrays.asList(&quot;jmods&quot;, &quot;../jmods&quot;, &quot;modules&quot;);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The represented jmod file.
&nbsp;         */
&nbsp;        private final ZipFile zipFile;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for a jmod file.
&nbsp;         *
&nbsp;         * @param zipFile The represented jmod file.
&nbsp;         */
<b class="fc">&nbsp;        public ForModuleFile(ZipFile zipFile) {</b>
<b class="fc">&nbsp;            this.zipFile = zipFile;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for this VM&#39;s boot module path.
&nbsp;         *
&nbsp;         * @return A class file locator for this VM&#39;s boot module path.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofBootPath() throws IOException {
<b class="fc">&nbsp;            String javaHome = System.getProperty(&quot;java.home&quot;).replace(&#39;\\&#39;, &#39;/&#39;);</b>
<b class="fc">&nbsp;            File bootPath = null;</b>
<b class="fc">&nbsp;            for (String location : BOOT_LOCATIONS) {</b>
<b class="fc">&nbsp;                File candidate = new File(javaHome, location);</b>
<b class="fc">&nbsp;                if (candidate.isDirectory()) {</b>
<b class="fc">&nbsp;                    bootPath = candidate;</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (bootPath == null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Boot modules do not exist in &quot; + javaHome + &quot; for any of &quot; + BOOT_LOCATIONS);</b>
&nbsp;            }
<b class="fc">&nbsp;            return ofBootPath(bootPath);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for a Java boot module path.
&nbsp;         *
&nbsp;         * @param bootPath The boot path folder.
&nbsp;         * @return A class file locator for this VMs boot module path.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofBootPath(File bootPath) throws IOException {
<b class="fc">&nbsp;            File[] module = bootPath.listFiles();</b>
<b class="fc">&nbsp;            if (module == null) {</b>
<b class="nc">&nbsp;                return NoOp.INSTANCE;</b>
&nbsp;            }
<b class="fc">&nbsp;            List&lt;ClassFileLocator&gt; classFileLocators = new ArrayList&lt;ClassFileLocator&gt;(module.length);</b>
<b class="fc">&nbsp;            for (File aModule : module) {</b>
<b class="fc">&nbsp;                if (aModule.isFile()) {</b>
<b class="fc">&nbsp;                    classFileLocators.add(of(aModule));</b>
<b class="nc">&nbsp;                } else if (aModule.isDirectory()) { // Relevant for locally built OpenJDK.</b>
<b class="nc">&nbsp;                    classFileLocators.add(new ForFolder(aModule));</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return new Compound(classFileLocators);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Resolves a class file locator for this VM&#39;s Java module path that reads class files directly from the file system.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: The resulting class file locator does not include classes of the bootstrap class loader.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A class file locator for the class path.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofModulePath() throws IOException {
<b class="nc">&nbsp;            String modulePath = System.getProperty(&quot;jdk.module.path&quot;);</b>
<b class="nc">&nbsp;            return modulePath == null</b>
<b class="nc">&nbsp;                    ? NoOp.INSTANCE</b>
<b class="nc">&nbsp;                    : ofModulePath(modulePath);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Resolves a class file locator for a Java module path that reads class files directly from the file system. All
&nbsp;         * elements of the module path are resolved relative to this VM&#39;s {@code user.dir}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: The resulting class file locator does not include classes of the bootstrap class loader.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param modulePath The module path to scan with the elements separated by {@code path.separator}.
&nbsp;         * @return A class file locator for the class path.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofModulePath(String modulePath) throws IOException {
<b class="nc">&nbsp;            return ofModulePath(modulePath, System.getProperty(&quot;user.dir&quot;));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Resolves a class file locator for a Java module path that reads class files directly from the file system.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: The resulting class file locator does not include classes of the bootstrap class loader.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param modulePath The module path to scan with the elements separated by {@code path.separator}.
&nbsp;         * @param baseFolder The relative location of the elements on the module path.
&nbsp;         * @return A class file locator for the class path.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator ofModulePath(String modulePath, String baseFolder) throws IOException {
<b class="nc">&nbsp;            List&lt;ClassFileLocator&gt; classFileLocators = new ArrayList&lt;ClassFileLocator&gt;();</b>
<b class="nc">&nbsp;            for (String element : Pattern.compile(System.getProperty(&quot;path.separator&quot;), Pattern.LITERAL).split(modulePath)) {</b>
<b class="nc">&nbsp;                File file = new File(baseFolder, element);</b>
<b class="nc">&nbsp;                if (file.isDirectory()) {</b>
<b class="nc">&nbsp;                    File[] module = file.listFiles();</b>
<b class="nc">&nbsp;                    if (module != null) {</b>
<b class="nc">&nbsp;                        for (File aModule : module) {</b>
<b class="nc">&nbsp;                            if (aModule.isDirectory()) {</b>
<b class="nc">&nbsp;                                classFileLocators.add(new ForFolder(aModule));</b>
<b class="nc">&nbsp;                            } else if (aModule.isFile()) {</b>
<b class="nc">&nbsp;                                classFileLocators.add(aModule.getName().endsWith(JMOD_FILE_EXTENSION)</b>
<b class="nc">&nbsp;                                        ? of(aModule)</b>
<b class="nc">&nbsp;                                        : ForJarFile.of(aModule));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } else if (file.isFile()) {</b>
<b class="nc">&nbsp;                    classFileLocators.add(file.getName().endsWith(JMOD_FILE_EXTENSION)</b>
<b class="nc">&nbsp;                            ? of(file)</b>
<b class="nc">&nbsp;                            : ForJarFile.of(file));</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;            return new Compound(classFileLocators);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a class file locator for the given module file.
&nbsp;         *
&nbsp;         * @param file The module file.
&nbsp;         * @return A class file locator for the given module
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(File file) throws IOException {
<b class="fc">&nbsp;            return new ForModuleFile(new ZipFile(file));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            ZipEntry zipEntry = zipFile.getEntry(&quot;classes/&quot; + name.replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;            if (zipEntry == null) {</b>
<b class="fc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                InputStream inputStream = zipFile.getInputStream(zipEntry);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() throws IOException {
<b class="fc">&nbsp;            zipFile.close();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that finds files from a standardized Java folder structure with
&nbsp;     * folders donating packages and class files being saved as {@code &lt;classname&gt;.class} files
&nbsp;     * within their package folder.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForFolder implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * The base folder of the package structure.
&nbsp;         */
&nbsp;        private final File folder;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for a folder structure of class files.
&nbsp;         *
&nbsp;         * @param folder The base folder of the package structure.
&nbsp;         */
<b class="fc">&nbsp;        public ForFolder(File folder) {</b>
<b class="fc">&nbsp;            this.folder = folder;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            File file = new File(folder, name.replace(&#39;.&#39;, File.separatorChar) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;            if (file.exists()) {</b>
<b class="fc">&nbsp;                InputStream inputStream = new FileInputStream(file);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new Resolution.Explicit(StreamDrainer.DEFAULT.drain(inputStream));</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that reads class files from one or several URLs. The reading is accomplished via using an {@link URLClassLoader}.
&nbsp;     * Doing so, boot loader resources might be located additionally to those found via the specified URLs.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForUrl implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader that delegates to the URLs.
&nbsp;         */
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for the given URLs.
&nbsp;         *
&nbsp;         * @param url The URLs to search for class files.
&nbsp;         */
<b class="fc">&nbsp;        public ForUrl(URL... url) {</b>
<b class="fc">&nbsp;            classLoader = doPrivileged(new ClassLoaderCreationAction(url));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file locator for the given URLs.
&nbsp;         *
&nbsp;         * @param urls The URLs to search for class files.
&nbsp;         */
&nbsp;        public ForUrl(Collection&lt;? extends URL&gt; urls) {
<b class="fc">&nbsp;            this(urls.toArray(new URL[0]));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            return ForClassLoader.locate(classLoader, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() throws IOException {
<b class="fc">&nbsp;            if (classLoader instanceof Closeable) {</b>
<b class="fc">&nbsp;                ((Closeable) classLoader).close();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An action to create a class loader with the purpose of locating classes from an URL location.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ClassLoaderCreationAction implements PrivilegedAction&lt;ClassLoader&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The URLs to locate classes from.
&nbsp;             */
&nbsp;            private final URL[] url;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new class loader creation action.
&nbsp;             *
&nbsp;             * @param url The URLs to locate classes from.
&nbsp;             */
<b class="fc">&nbsp;            protected ClassLoaderCreationAction(URL[] url) {</b>
<b class="fc">&nbsp;                this.url = url;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassLoader run() {
<b class="fc">&nbsp;                return new URLClassLoader(url, ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A Java agent that allows the location of class files by emulating a retransformation. Note that this class file
&nbsp;     * locator causes a class to be loaded in order to look up its class file. Also, this locator does deliberately not
&nbsp;     * support the look-up of classes that represent lambda expressions.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class ForInstrumentation implements ClassFileLocator {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interacting with the instrumentation API.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumentation instance to use for looking up the binary format of a type.
&nbsp;         */
&nbsp;        private final Instrumentation instrumentation;
&nbsp;
&nbsp;        /**
&nbsp;         * The delegate to load a class by its name.
&nbsp;         */
&nbsp;        private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an agent-based class file locator.
&nbsp;         *
&nbsp;         * @param instrumentation The instrumentation to be used.
&nbsp;         * @param classLoader     The class loader to read a class from or {@code null} to use the boot loader.
&nbsp;         */
&nbsp;        public ForInstrumentation(Instrumentation instrumentation, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            this(instrumentation, ClassLoadingDelegate.Default.of(classLoader));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an agent-based class file locator.
&nbsp;         *
&nbsp;         * @param instrumentation      The instrumentation to be used.
&nbsp;         * @param classLoadingDelegate The delegate responsible for class loading.
&nbsp;         */
<b class="fc">&nbsp;        public ForInstrumentation(Instrumentation instrumentation, ClassLoadingDelegate classLoadingDelegate) {</b>
<b class="fc">&nbsp;            if (!DISPATCHER.isRetransformClassesSupported(instrumentation)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(instrumentation + &quot; does not support retransformation&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;            this.classLoadingDelegate = classLoadingDelegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the instrumentation provided by {@code net.bytebuddy.agent.Installer}.
&nbsp;         *
&nbsp;         * @return The installed instrumentation instance.
&nbsp;         */
&nbsp;        private static Instrumentation resolveByteBuddyAgentInstrumentation() {
&nbsp;            try {
<b class="fc">&nbsp;                Class&lt;?&gt; installer = ClassLoader.getSystemClassLoader().loadClass(&quot;net.bytebuddy.agent.Installer&quot;);</b>
<b class="fc">&nbsp;                JavaModule source = JavaModule.ofType(AgentBuilder.class), target = JavaModule.ofType(installer);</b>
<b class="fc">&nbsp;                if (source != null &amp;&amp; !source.canRead(target)) {</b>
<b class="nc">&nbsp;                    Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;);</b>
<b class="nc">&nbsp;                    module.getMethod(&quot;addReads&quot;, module).invoke(source.unwrap(), target.unwrap());</b>
&nbsp;                }
<b class="fc">&nbsp;                return (Instrumentation) installer.getMethod(&quot;getInstrumentation&quot;).invoke(null);</b>
<b class="nc">&nbsp;            } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                throw exception;</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;The Byte Buddy agent is not installed or not accessible&quot;, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an agent-based class file locator for the given class loader and an already installed
&nbsp;         * Byte Buddy-agent.
&nbsp;         *
&nbsp;         * @param classLoader The class loader that is expected to load the looked-up a class.
&nbsp;         * @return A class file locator for the given class loader based on a Byte Buddy agent.
&nbsp;         */
&nbsp;        public static ClassFileLocator fromInstalledAgent(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            return new ForInstrumentation(resolveByteBuddyAgentInstrumentation(), classLoader);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a class file locator that is capable of locating a class file for the given type using the given instrumentation instance.
&nbsp;         *
&nbsp;         * @param instrumentation The instrumentation instance to query for a retransformation.
&nbsp;         * @param type            The locatable type which class loader is used as a fallback.
&nbsp;         * @return A class file locator for locating the class file of the given type.
&nbsp;         */
&nbsp;        public static ClassFileLocator of(Instrumentation instrumentation, Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return new ForInstrumentation(instrumentation, ClassLoadingDelegate.Explicit.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) {
&nbsp;            try {
<b class="fc">&nbsp;                ExtractionClassFileTransformer classFileTransformer = new ExtractionClassFileTransformer(classLoadingDelegate.getClassLoader(), name);</b>
<b class="fc">&nbsp;                DISPATCHER.addTransformer(instrumentation, classFileTransformer, true);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    DISPATCHER.retransformClasses(instrumentation, new Class&lt;?&gt;[]{classLoadingDelegate.locate(name)});</b>
<b class="fc">&nbsp;                    byte[] binaryRepresentation = classFileTransformer.getBinaryRepresentation();</b>
<b class="fc">&nbsp;                    return binaryRepresentation == null</b>
<b class="nc">&nbsp;                            ? new Resolution.Illegal(name)</b>
<b class="fc">&nbsp;                            : new Resolution.Explicit(binaryRepresentation);</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    instrumentation.removeTransformer(classFileTransformer);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                throw exception;</b>
<b class="nc">&nbsp;            } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with the {@link Instrumentation} API.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.instrument.Instrumentation&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Invokes the {@code Instrumentation#isRetransformClassesSupported} method.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to invoke the method on.
&nbsp;             * @return {@code true} if the supplied instrumentation instance supports retransformation.
&nbsp;             */
&nbsp;            boolean isRetransformClassesSupported(Instrumentation instrumentation);
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a transformer.
&nbsp;             *
&nbsp;             * @param instrumentation      The instrumentation instance to invoke the method on.
&nbsp;             * @param classFileTransformer The class file transformer to register.
&nbsp;             * @param canRetransform       {@code true} if the class file transformer should be invoked upon a retransformation.
&nbsp;             */
&nbsp;            void addTransformer(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, boolean canRetransform);
&nbsp;
&nbsp;            /**
&nbsp;             * Retransforms the supplied classes.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to invoke the method on.
&nbsp;             * @param type            The types to retransform.
&nbsp;             * @throws UnmodifiableClassException If any of the supplied types are unmodifiable.
&nbsp;             */
&nbsp;            void retransformClasses(Instrumentation instrumentation, Class&lt;?&gt;[] type) throws UnmodifiableClassException;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A delegate that is queried for loading a class.
&nbsp;         */
&nbsp;        public interface ClassLoadingDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * Loads a class by its name.
&nbsp;             *
&nbsp;             * @param name The name of the type.
&nbsp;             * @return The class with the given name.
&nbsp;             * @throws ClassNotFoundException If a class cannot be found.
&nbsp;             */
&nbsp;            Class&lt;?&gt; locate(String name) throws ClassNotFoundException;
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the underlying class loader.
&nbsp;             *
&nbsp;             * @return The underlying class loader.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            ClassLoader getClassLoader();
&nbsp;
&nbsp;            /**
&nbsp;             * A default implementation of a class loading delegate.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Default implements ClassLoadingDelegate {
&nbsp;
&nbsp;                /**
&nbsp;                 * A class loader that does not define resources of its own but allows querying for resources supplied by the boot loader.
&nbsp;                 */
<b class="fc">&nbsp;                private static final ClassLoader BOOT_LOADER_PROXY = doPrivileged(BootLoaderProxyCreationAction.INSTANCE);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The underlying class loader.
&nbsp;                 */
&nbsp;                protected final ClassLoader classLoader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a default class loading delegate.
&nbsp;                 *
&nbsp;                 * @param classLoader The class loader to be queried.
&nbsp;                 */
<b class="fc">&nbsp;                protected Default(ClassLoader classLoader) {</b>
<b class="fc">&nbsp;                    this.classLoader = classLoader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a class loading delegate for the given class loader.
&nbsp;                 *
&nbsp;                 * @param classLoader The class loader for which to create a delegate or {@code null} to use the boot loader.
&nbsp;                 * @return The class loading delegate for the provided class loader.
&nbsp;                 */
&nbsp;                public static ClassLoadingDelegate of(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                    return ForDelegatingClassLoader.isDelegating(classLoader)</b>
<b class="nc">&nbsp;                            ? new ForDelegatingClassLoader(classLoader)</b>
<b class="fc">&nbsp;                            : new Default(classLoader == null ? BOOT_LOADER_PROXY : classLoader);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; locate(String name) throws ClassNotFoundException {
<b class="fc">&nbsp;                    return classLoader.loadClass(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public ClassLoader getClassLoader() {
<b class="fc">&nbsp;                    return classLoader == BOOT_LOADER_PROXY</b>
<b class="fc">&nbsp;                            ? ClassLoadingStrategy.BOOTSTRAP_LOADER</b>
<b class="fc">&nbsp;                            : classLoader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A privileged action for creating a proxy class loader for the boot class loader.
&nbsp;                 */
<b class="fc">&nbsp;                protected enum BootLoaderProxyCreationAction implements PrivilegedAction&lt;ClassLoader&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassLoader run() {
<b class="fc">&nbsp;                        return new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A class loading delegate that accounts for a {@code sun.reflect.DelegatingClassLoader} which
&nbsp;             * cannot load its own classes by name.
&nbsp;             */
&nbsp;            class ForDelegatingClassLoader extends Default {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the delegating class loader.
&nbsp;                 */
&nbsp;                private static final String DELEGATING_CLASS_LOADER_NAME = &quot;sun.reflect.DelegatingClassLoader&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * An index indicating the first element of a collection.
&nbsp;                 */
&nbsp;                private static final int ONLY = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for extracting a class loader&#39;s loaded classes.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Dispatcher.Initializable DISPATCHER = doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a class loading delegate for a delegating class loader.
&nbsp;                 *
&nbsp;                 * @param classLoader The delegating class loader.
&nbsp;                 */
&nbsp;                protected ForDelegatingClassLoader(ClassLoader classLoader) {
<b class="nc">&nbsp;                    super(classLoader);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;                 *
&nbsp;                 * @param action The action to execute from a privileged context.
&nbsp;                 * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;                 * @return The action&#39;s resolved value.
&nbsp;                 */
&nbsp;                @AccessControllerPlugin.Enhance
&nbsp;                private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;                    return action.run();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Checks if a class loader is a delegating class loader.
&nbsp;                 *
&nbsp;                 * @param classLoader The class loader to inspect or {@code null} to check the boot loader.
&nbsp;                 * @return {@code true} if the class loader is a delegating class loader.
&nbsp;                 */
&nbsp;                protected static boolean isDelegating(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                    return classLoader != null &amp;&amp; classLoader.getClass().getName().equals(DELEGATING_CLASS_LOADER_NAME);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; locate(String name) throws ClassNotFoundException {
&nbsp;                    Vector&lt;Class&lt;?&gt;&gt; classes;
&nbsp;                    try {
<b class="nc">&nbsp;                        classes = DISPATCHER.initialize().extract(classLoader);</b>
<b class="nc">&nbsp;                    } catch (RuntimeException ignored) {</b>
<b class="nc">&nbsp;                        return super.locate(name);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    if (classes.size() != 1) {</b>
<b class="nc">&nbsp;                        return super.locate(name);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Class&lt;?&gt; type = classes.get(ONLY);</b>
<b class="nc">&nbsp;                    return TypeDescription.ForLoadedType.getName(type).equals(name)</b>
<b class="nc">&nbsp;                            ? type</b>
<b class="nc">&nbsp;                            : super.locate(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Representation of a Java {@link java.lang.reflect.Field}.
&nbsp;                 */
&nbsp;                protected interface Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Reads the classes of the represented collection.
&nbsp;                     *
&nbsp;                     * @param classLoader The class loader to read from.
&nbsp;                     * @return The class loader&#39;s loaded classes.
&nbsp;                     */
&nbsp;                    Vector&lt;Class&lt;?&gt;&gt; extract(ClassLoader classLoader);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An uninitialized version of a dispatcher for extracting a class loader&#39;s loaded classes.
&nbsp;                     */
&nbsp;                    interface Initializable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Initializes the dispatcher.
&nbsp;                         *
&nbsp;                         * @return An initialized dispatcher.
&nbsp;                         */
&nbsp;                        Dispatcher initialize();
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An action for creating a dispatcher.
&nbsp;                     */
<b class="fc">&nbsp;                    enum CreationAction implements PrivilegedAction&lt;Initializable&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The singleton instance.
&nbsp;                         */
<b class="fc">&nbsp;                        INSTANCE;</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Initializable run() {
&nbsp;                            try {
<b class="fc">&nbsp;                                return new Dispatcher.Resolved(ClassLoader.class.getDeclaredField(&quot;classes&quot;));</b>
<b class="fc">&nbsp;                            } catch (Exception exception) {</b>
<b class="fc">&nbsp;                                return new Dispatcher.Unresolved(exception.getMessage());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents a field that could be located.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Resolved implements Dispatcher, Initializable, PrivilegedAction&lt;Dispatcher&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented field.
&nbsp;                         */
&nbsp;                        private final Field field;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved field.
&nbsp;                         *
&nbsp;                         * @param field the represented field.l
&nbsp;                         */
<b class="nc">&nbsp;                        public Resolved(Field field) {</b>
<b class="nc">&nbsp;                            this.field = field;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;                         *
&nbsp;                         * @param action The action to execute from a privileged context.
&nbsp;                         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;                         * @return The action&#39;s resolved value.
&nbsp;                         */
&nbsp;                        @AccessControllerPlugin.Enhance
&nbsp;                        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="nc">&nbsp;                            return action.run();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Dispatcher initialize() {
<b class="nc">&nbsp;                            return doPrivileged(this);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                        public Vector&lt;Class&lt;?&gt;&gt; extract(ClassLoader classLoader) {
&nbsp;                            try {
<b class="nc">&nbsp;                                return (Vector&lt;Class&lt;?&gt;&gt;) field.get(classLoader);</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot access field&quot;, exception);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Dispatcher run() {
<b class="nc">&nbsp;                            field.setAccessible(true);</b>
<b class="nc">&nbsp;                            return this;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents a field that could not be located.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Unresolved implements Initializable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The reason why this dispatcher is unavailable.
&nbsp;                         */
&nbsp;                        private final String message;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a representation of a non-resolved field.
&nbsp;                         *
&nbsp;                         * @param message The reason why this dispatcher is unavailable.
&nbsp;                         */
<b class="fc">&nbsp;                        public Unresolved(String message) {</b>
<b class="fc">&nbsp;                            this.message = message;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Dispatcher initialize() {
<b class="nc">&nbsp;                            throw new UnsupportedOperationException(&quot;Could not locate classes vector: &quot; + message);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A class loading delegate that allows the location of explicitly registered classes that cannot
&nbsp;             * be located by a class loader directly. This allows for locating classes that are loaded by
&nbsp;             * an anonymous class loader which does not register its classes in a system dictionary.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Explicit implements ClassLoadingDelegate {
&nbsp;
&nbsp;                /**
&nbsp;                 * A class loading delegate that is queried for classes that are not registered explicitly.
&nbsp;                 */
&nbsp;                private final ClassLoadingDelegate fallbackDelegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * The map of registered classes mapped by their name.
&nbsp;                 */
&nbsp;                private final Map&lt;String, Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new class loading delegate with a possibility of looking up explicitly
&nbsp;                 * registered classes.
&nbsp;                 *
&nbsp;                 * @param classLoader The class loader to be used for looking up classes.
&nbsp;                 * @param types       A collection of classes that cannot be looked up explicitly.
&nbsp;                 */
&nbsp;                public Explicit(@MaybeNull ClassLoader classLoader, Collection&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    this(Default.of(classLoader), types);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new class loading delegate with a possibility of looking up explicitly
&nbsp;                 * registered classes.
&nbsp;                 *
&nbsp;                 * @param fallbackDelegate The class loading delegate to query for any class that is not
&nbsp;                 *                         registered explicitly.
&nbsp;                 * @param types            A collection of classes that cannot be looked up explicitly.
&nbsp;                 */
<b class="fc">&nbsp;                public Explicit(ClassLoadingDelegate fallbackDelegate, Collection&lt;? extends Class&lt;?&gt;&gt; types) {</b>
<b class="fc">&nbsp;                    this.fallbackDelegate = fallbackDelegate;</b>
<b class="fc">&nbsp;                    this.types = new HashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                    for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                        this.types.put(TypeDescription.ForLoadedType.getName(type), type);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an explicit class loading delegate for the given type.
&nbsp;                 *
&nbsp;                 * @param type The type that is explicitly locatable.
&nbsp;                 * @return A suitable class loading delegate.
&nbsp;                 */
&nbsp;                public static ClassLoadingDelegate of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                    return new Explicit(type.getClassLoader(), Collections.singleton(type));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; locate(String name) throws ClassNotFoundException {
<b class="fc">&nbsp;                    Class&lt;?&gt; type = types.get(name);</b>
<b class="fc">&nbsp;                    return type == null</b>
<b class="fc">&nbsp;                            ? fallbackDelegate.locate(name)</b>
<b class="fc">&nbsp;                            : type;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public ClassLoader getClassLoader() {
<b class="fc">&nbsp;                    return fallbackDelegate.getClassLoader();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational class file transformer that remembers the binary format of a given class.
&nbsp;         */
&nbsp;        protected static class ExtractionClassFileTransformer implements ClassFileTransformer {
&nbsp;
&nbsp;            /**
&nbsp;             * An indicator that an attempted class file transformation did not alter the handed class file.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final byte[] DO_NOT_TRANSFORM = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader that is expected to have loaded the looked-up a class.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final ClassLoader classLoader;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type to look up.
&nbsp;             */
&nbsp;            private final String typeName;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary representation of the looked-up class.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @SuppressFBWarnings(value = &quot;VO_VOLATILE_REFERENCE_TO_ARRAY&quot;, justification = &quot;The array is not to be modified by contract&quot;)
&nbsp;            private volatile byte[] binaryRepresentation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class file transformer for the purpose of extraction.
&nbsp;             *
&nbsp;             * @param classLoader The class loader that is expected to have loaded the looked-up a class.
&nbsp;             * @param typeName    The name of the type to look up.
&nbsp;             */
<b class="fc">&nbsp;            protected ExtractionClassFileTransformer(@MaybeNull ClassLoader classLoader, String typeName) {</b>
<b class="fc">&nbsp;                this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                this.typeName = typeName;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @SuppressFBWarnings(value = {&quot;EI_EXPOSE_REP&quot;, &quot;EI_EXPOSE_REP2&quot;}, justification = &quot;The array is not modified by class contract.&quot;)
&nbsp;            public byte[] transform(@MaybeNull ClassLoader classLoader,
&nbsp;                                    @MaybeNull String internalName,
&nbsp;                                    @MaybeNull Class&lt;?&gt; redefinedType,
&nbsp;                                    ProtectionDomain protectionDomain,
&nbsp;                                    byte[] binaryRepresentation) {
<b class="fc">&nbsp;                if (internalName != null &amp;&amp; isChildOf(this.classLoader).matches(classLoader) &amp;&amp; typeName.equals(internalName.replace(&#39;/&#39;, &#39;.&#39;))) {</b>
<b class="fc">&nbsp;                    this.binaryRepresentation = binaryRepresentation.clone();</b>
&nbsp;                }
<b class="fc">&nbsp;                return DO_NOT_TRANSFORM;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the binary representation of the class file that was looked up. The returned array must never be modified.
&nbsp;             *
&nbsp;             * @return The binary representation of the class file or {@code null} if no such class file could
&nbsp;             * be located.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP&quot;, justification = &quot;The array is not to be modified by contract&quot;)
&nbsp;            protected byte[] getBinaryRepresentation() {
<b class="fc">&nbsp;                return binaryRepresentation;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that discriminates by a type&#39;s package.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class PackageDiscriminating implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * A mapping of package names to class file locators.
&nbsp;         */
&nbsp;        private final Map&lt;String, ClassFileLocator&gt; classFileLocators;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new package-discriminating class file locator.
&nbsp;         *
&nbsp;         * @param classFileLocators A mapping of package names to class file locators where an empty string donates the default package.
&nbsp;         */
<b class="fc">&nbsp;        public PackageDiscriminating(Map&lt;String, ClassFileLocator&gt; classFileLocators) {</b>
<b class="fc">&nbsp;            this.classFileLocators = classFileLocators;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            int packageIndex = name.lastIndexOf(&#39;.&#39;);</b>
<b class="fc">&nbsp;            ClassFileLocator classFileLocator = classFileLocators.get(packageIndex == -1</b>
<b class="fc">&nbsp;                    ? NamedElement.EMPTY_NAME</b>
<b class="fc">&nbsp;                    : name.substring(0, packageIndex));</b>
<b class="fc">&nbsp;            return classFileLocator == null</b>
<b class="fc">&nbsp;                    ? new Resolution.Illegal(name)</b>
<b class="fc">&nbsp;                    : classFileLocator.locate(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() throws IOException {
<b class="fc">&nbsp;            for (ClassFileLocator classFileLocator : classFileLocators.values()) {</b>
<b class="fc">&nbsp;                classFileLocator.close();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class file locator that only applies for matched names.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Filtering implements ClassFileLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * The matcher to determine if the delegate matcher is considered.
&nbsp;         */
&nbsp;        private final ElementMatcher&lt;? super String&gt; matcher;
&nbsp;
&nbsp;        /**
&nbsp;         * The delegate class file locator.
&nbsp;         */
&nbsp;        private final ClassFileLocator delegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new filtering class file locator.
&nbsp;         *
&nbsp;         * @param matcher  The matcher to determine if the delegate matcher is considered.
&nbsp;         * @param delegate The delegate class file locator.
&nbsp;         */
<b class="fc">&nbsp;        public Filtering(ElementMatcher&lt;? super String&gt; matcher, ClassFileLocator delegate) {</b>
<b class="fc">&nbsp;            this.matcher = matcher;</b>
<b class="fc">&nbsp;            this.delegate = delegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            return matcher.matches(name) ? delegate.locate(name) : new Resolution.Illegal(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() throws IOException {
<b class="fc">&nbsp;            delegate.close();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compound {@link ClassFileLocator} that chains several locators.
&nbsp;     * Any class file locator is queried in the supplied order until one locator is able to provide an input
&nbsp;     * stream of the class file.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Compound implements ClassFileLocator, Closeable {
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link ClassFileLocator}s which are represented by this compound
&nbsp;         * class file locator  in the order of their application.
&nbsp;         */
&nbsp;        private final List&lt;ClassFileLocator&gt; classFileLocators;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new compound class file locator.
&nbsp;         *
&nbsp;         * @param classFileLocator The {@link ClassFileLocator}s to be
&nbsp;         *                         represented by this compound class file locator in the order of their application.
&nbsp;         */
&nbsp;        public Compound(ClassFileLocator... classFileLocator) {
<b class="fc">&nbsp;            this(Arrays.asList(classFileLocator));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new compound class file locator.
&nbsp;         *
&nbsp;         * @param classFileLocators The {@link ClassFileLocator}s to be represented by this compound class file locator in
&nbsp;         *                          the order of their application.
&nbsp;         */
<b class="fc">&nbsp;        public Compound(List&lt;? extends ClassFileLocator&gt; classFileLocators) {</b>
<b class="fc">&nbsp;            this.classFileLocators = new ArrayList&lt;ClassFileLocator&gt;();</b>
<b class="fc">&nbsp;            for (ClassFileLocator classFileLocator : classFileLocators) {</b>
<b class="fc">&nbsp;                if (classFileLocator instanceof Compound) {</b>
<b class="fc">&nbsp;                    this.classFileLocators.addAll(((Compound) classFileLocator).classFileLocators);</b>
<b class="fc">&nbsp;                } else if (!(classFileLocator instanceof NoOp)) {</b>
<b class="fc">&nbsp;                    this.classFileLocators.add(classFileLocator);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            for (ClassFileLocator classFileLocator : classFileLocators) {</b>
<b class="fc">&nbsp;                Resolution resolution = classFileLocator.locate(name);</b>
<b class="fc">&nbsp;                if (resolution.isResolved()) {</b>
<b class="fc">&nbsp;                    return resolution;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Resolution.Illegal(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() throws IOException {
<b class="fc">&nbsp;            for (ClassFileLocator classFileLocator : classFileLocators) {</b>
<b class="fc">&nbsp;                classFileLocator.close();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
