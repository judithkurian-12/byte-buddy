


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > DynamicType</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic</a>
</div>

<h1>Coverage Summary for Class: DynamicType (net.bytebuddy.dynamic)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">DynamicType$Builder</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    82.1%
  </span>
  <span class="absValue">
    (55/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.8%
  </span>
  <span class="absValue">
    (75/103)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (28/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.4%
  </span>
  <span class="absValue">
    (51/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$FieldDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$FieldMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$InnerTypeDefinitionForMethodAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$InnerTypeDefinitionForTypeAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.2%
  </span>
  <span class="absValue">
    (35/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$AnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.2%
  </span>
  <span class="absValue">
    (23/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$ParameterAnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (11/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$SimpleParameterAnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodDefinitionAdapter$TypeVariableAnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$MethodMatchAdapter$AnnotationAdapter</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$OptionalMethodMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$RecordComponentDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.5%
  </span>
  <span class="absValue">
    (8/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$RecordComponentMatchAdapter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Adapter$TypeVariableDefinitionAdapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    52.5%
  </span>
  <span class="absValue">
    (21/40)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52.5%
  </span>
  <span class="absValue">
    (21/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$AbstractBase$UsingTypeWriter</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Optional$Valuable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$FieldDefinition$Valuable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$InnerTypeDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$InnerTypeDefinition$ForType</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ExceptionDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ExceptionDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ImplementationDefinition$Optional</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Annotatable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Annotatable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Annotatable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (2/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Initial</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Initial$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ParameterDefinition$Simple$Annotatable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ReceiverTypeDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$ReceiverTypeDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$Annotatable</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$Annotatable$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MethodDefinition$TypeVariableDefinition$Annotatable$AbstractBase$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MockitoMock$1998141440</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MockitoMock$1998141440$auxiliary$C37BKpul</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$MockitoMock$1998141440$auxiliary$SDxyoHhi</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$RecordComponentDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$RecordComponentDefinition$Optional</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$RecordComponentDefinition$Optional$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$TypeVariableDefinition</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Builder$TypeVariableDefinition$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.1%
  </span>
  <span class="absValue">
    (105/114)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Default$Unloaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Loaded</td>
  </tr>
  <tr>
    <td class="name">DynamicType$MockitoMock$575262464</td>
  </tr>
  <tr>
    <td class="name">DynamicType$MockitoMock$575262464$auxiliary$nT7Mdj6Z</td>
  </tr>
  <tr>
    <td class="name">DynamicType$MockitoMock$575262464$auxiliary$WIh8fxXV</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Unloaded</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Unloaded$MockitoMock$1322406342</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Unloaded$MockitoMock$1322406342$auxiliary$Bm5ebEMc</td>
  </tr>
  <tr>
    <td class="name">DynamicType$Unloaded$MockitoMock$1322406342$auxiliary$L9GbvBww</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    75.8%
  </span>
  <span class="absValue">
    (257/339)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.6%
  </span>
  <span class="absValue">
    (531/659)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.*;
&nbsp;import net.bytebuddy.description.type.*;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.dynamic.loading.InjectionClassLoader;
&nbsp;import net.bytebuddy.dynamic.scaffold.*;
&nbsp;import net.bytebuddy.implementation.*;
&nbsp;import net.bytebuddy.implementation.attribute.*;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.LatentMatcher;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.FileSystem;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.visitor.ContextClassVisitor;
&nbsp;import org.objectweb.asm.ClassVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.util.*;
&nbsp;import java.util.jar.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A dynamic type that is created at runtime, usually as the result of applying a
&nbsp; * {@link net.bytebuddy.dynamic.DynamicType.Builder} or as the result of an
&nbsp; * {@link net.bytebuddy.implementation.auxiliary.AuxiliaryType}.
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * Note that the {@link TypeDescription}s will represent their
&nbsp; * unloaded forms and therefore differ from the loaded types, especially with regards to annotations.
&nbsp; */
&nbsp;public interface DynamicType extends ClassFileLocator {
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a description of this dynamic type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This description will most likely differ from the binary representation of this type. Normally,
&nbsp;     * annotations and intercepted methods are not added to this type description.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A description of this dynamic type.
&nbsp;     */
&nbsp;    TypeDescription getTypeDescription();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a byte array representing this dynamic type. This byte array might be reused by this dynamic type and
&nbsp;     * must therefore not be altered.
&nbsp;     *
&nbsp;     * @return A byte array of the type&#39;s binary representation.
&nbsp;     */
&nbsp;    byte[] getBytes();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a map of all auxiliary types that are required for making use of the main type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;     * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A map of all auxiliary types by their descriptions to their binary representation.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, byte[]&gt; getAuxiliaryTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns all types that are implied by this dynamic type.
&nbsp;     *
&nbsp;     * @return A mapping from all type descriptions, the actual type and its auxiliary types to their binary
&nbsp;     * representation
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, byte[]&gt; getAllTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a map of all loaded type initializers for the main type and all auxiliary types, if any.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;     * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A mapping of all types&#39; descriptions to their loaded type initializers.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, LoadedTypeInitializer&gt; getLoadedTypeInitializers();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a dynamic type requires some form of explicit type initialization, either for itself or for one
&nbsp;     * of its auxiliary types, if any. This is the case when this dynamic type was defined to delegate method calls
&nbsp;     * to a specific instance which is stored in a field of the created type. If this class serialized, it could not
&nbsp;     * be used without its loaded type initializers since the field value represents a specific runtime context.
&nbsp;     *
&nbsp;     * @return {@code true} if this type requires explicit type initialization.
&nbsp;     */
&nbsp;    boolean hasAliveLoadedTypeInitializers();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Saves a dynamic type in a given folder using the Java class file format while respecting the naming conventions
&nbsp;     * for saving compiled Java classes. All auxiliary types, if any, are saved in the same directory. The resulting
&nbsp;     * folder structure will resemble the structure that is required for Java run times, i.e. each folder representing
&nbsp;     * a segment of the package name. If the specified {@code folder} does not yet exist, it is created during the
&nbsp;     * call of this method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;     * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param folder The base target folder for storing this dynamic type and its auxiliary types, if any.
&nbsp;     * @return A map of type descriptions pointing to files with their stored binary representations within {@code folder}.
&nbsp;     * @throws IOException Thrown if the underlying file operations cause an {@code IOException}.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, File&gt; saveIn(File folder) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Injects the types of this dynamic type into a given &lt;i&gt;jar&lt;/i&gt; file. Any pre-existent type with the same name
&nbsp;     * is overridden during injection. The resulting jar is going to be a recreation of the original jar and not a
&nbsp;     * patched version with a new central directory. No directory entries are added to the generated jar.
&nbsp;     *
&nbsp;     * @param sourceJar The original jar file.
&nbsp;     * @param targetJar The {@code source} jar file with the injected contents.
&nbsp;     * @return The {@code target} jar file.
&nbsp;     * @throws IOException If an I/O exception occurs while injecting from the source into the target.
&nbsp;     */
&nbsp;    File inject(File sourceJar, File targetJar) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Injects the types of this dynamic type into a given &lt;i&gt;jar&lt;/i&gt; file. Any pre-existent type with the same name
&nbsp;     * is overridden during injection. The resulting jar is going to be a recreation of the original jar and not a
&nbsp;     * patched version with a new central directory. No directory entries are added to the generated jar.
&nbsp;     *
&nbsp;     * @param jar The jar file to replace with an injected version.
&nbsp;     * @return The {@code jar} file.
&nbsp;     * @throws IOException If an I/O exception occurs while injecting into the jar.
&nbsp;     */
&nbsp;    File inject(File jar) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Saves the contents of this dynamic type inside a &lt;i&gt;jar&lt;/i&gt; file. The folder of the given {@code file} must
&nbsp;     * exist prior to calling this method. The jar file is created with a simple manifest that only contains a version
&nbsp;     * number. No directory entries are added to the generated jar.
&nbsp;     *
&nbsp;     * @param file The target file to which the &lt;i&gt;jar&lt;/i&gt; is written to.
&nbsp;     * @return The given {@code file}.
&nbsp;     * @throws IOException If an I/O exception occurs while writing the file.
&nbsp;     */
&nbsp;    File toJar(File file) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Saves the contents of this dynamic type inside a &lt;i&gt;jar&lt;/i&gt; file. The folder of the given {@code file} must
&nbsp;     * exist prior to calling this method. No directory entries are added to the generated jar.
&nbsp;     *
&nbsp;     * @param file     The target file to which the &lt;i&gt;jar&lt;/i&gt; is written to.
&nbsp;     * @param manifest The manifest of the created &lt;i&gt;jar&lt;/i&gt;.
&nbsp;     * @return The given {@code file}.
&nbsp;     * @throws IOException If an I/O exception occurs while writing the file.
&nbsp;     */
&nbsp;    File toJar(File file, Manifest manifest) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    void close();
&nbsp;
&nbsp;    /**
&nbsp;     * A builder for creating a dynamic type.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;     */
&nbsp;    interface Builder&lt;T&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Applies the supplied {@link AsmVisitorWrapper} onto the {@link org.objectweb.asm.ClassVisitor} during building a dynamic type.
&nbsp;         * Using an ASM visitor, it is possible to manipulate byte code directly. Byte Buddy does not validate directly created byte code
&nbsp;         * and it remains the responsibility of the visitor&#39;s implementor to generate legal byte code. If several ASM visitor wrappers
&nbsp;         * are registered, they are applied on top of another in their registration order.
&nbsp;         *
&nbsp;         * @param asmVisitorWrapper The ASM visitor wrapper to apply during
&nbsp;         * @return A new builder that is equal to this builder and applies the ASM visitor wrapper.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; visit(AsmVisitorWrapper asmVisitorWrapper);
&nbsp;
&nbsp;        /**
&nbsp;         * Names the dynamic type by the supplied name. The name needs to be fully qualified and in the binary format (packages separated
&nbsp;         * by dots: {@code foo.Bar}). A type&#39;s package determines what other types are visible to the instrumented type and what methods
&nbsp;         * can be overridden or be represented in method signatures or as field types.
&nbsp;         *
&nbsp;         * @param name The fully qualified name of the generated class in a binary format.
&nbsp;         * @return A new builder that is equal to this builder but with the instrumented type named by the supplied name.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; name(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Adds a suffix to the current type name without changing the type&#39;s package.
&nbsp;         *
&nbsp;         * @param suffix The suffix to append to the current type name.
&nbsp;         * @return A new builder that is equal to this builder but with the instrumented type named suffixed by the supplied suffix.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; suffix(String suffix);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied modifiers as the modifiers of the instrumented type.
&nbsp;         *
&nbsp;         * @param modifierContributor The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers applied onto the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; modifiers(ModifierContributor.ForType... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied modifiers as the modifiers of the instrumented type.
&nbsp;         *
&nbsp;         * @param modifierContributors The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers applied onto the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; modifiers(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied modifiers as the modifiers of the instrumented type.
&nbsp;         *
&nbsp;         * @param modifiers The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers applied onto the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; modifiers(int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Merges the supplied modifier contributors with the modifiers of the instrumented type and defines them as the instrumented
&nbsp;         * type&#39;s new modifiers.
&nbsp;         *
&nbsp;         * @param modifierContributor The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers merged into the instrumented type&#39;s modifiers.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; merge(ModifierContributor.ForType... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Merges the supplied modifier contributors with the modifiers of the instrumented type and defines them as the instrumented
&nbsp;         * type&#39;s new modifiers.
&nbsp;         *
&nbsp;         * @param modifierContributors The modifiers of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied modifiers merged into the instrumented type&#39;s modifiers.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a top-level type that is not declared by another type or enclosed by another member.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A new builder that is equal to this builder but without any declaration of a a declared or enclosed type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; topLevelType();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an inner type of the supplied type. Without any additional configuration, the type declaration is defined
&nbsp;         * as a local type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The type to declare as the built type&#39;s outer type.
&nbsp;         * @return A new builder that is equal to this builder with the supplied type as the built type&#39;s outer type.
&nbsp;         */
&nbsp;        InnerTypeDefinition.ForType&lt;T&gt; innerTypeOf(Class&lt;?&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an inner type of the supplied type. Without any additional configuration, the type declaration is
&nbsp;         * defined as a local type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The type to declare as the built type&#39;s outer type.
&nbsp;         * @return A new builder that is equal to this builder with the supplied type as the built type&#39;s outer type.
&nbsp;         */
&nbsp;        InnerTypeDefinition.ForType&lt;T&gt; innerTypeOf(TypeDescription type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an inner type that was declared within the supplied method.  Without any additional configuration, the type
&nbsp;         * declaration is defined as a local type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param method The method to declare as the built type&#39;s declaring method.
&nbsp;         * @return A new builder that is equal to this builder with the supplied method as the built type&#39;s declaring method.
&nbsp;         */
&nbsp;        InnerTypeDefinition&lt;T&gt; innerTypeOf(Method method);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an inner type that was declared within the supplied constructor. Without any additional configuration, the type
&nbsp;         * declaration is defined as a local type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param constructor The constructor to declare as the built type&#39;s declaring method.
&nbsp;         * @return A new builder that is equal to this builder with the supplied method as the built type&#39;s declaring constructor.
&nbsp;         */
&nbsp;        InnerTypeDefinition&lt;T&gt; innerTypeOf(Constructor&lt;?&gt; constructor);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an inner type that was declared within the supplied method or constructor. Without any additional configuration,
&nbsp;         * the type declaration is defined as a local type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param methodDescription The method or constructor to declare as the built type&#39;s declaring method.
&nbsp;         * @return A new builder that is equal to this builder with the supplied method as the built type&#39;s declaring method or constructor.
&nbsp;         */
&nbsp;        InnerTypeDefinition&lt;T&gt; innerTypeOf(MethodDescription.InDefinedShape methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an the outer type of the supplied types. Using this method, it is possible to add inner type declarations
&nbsp;         * for anonymous or local types which are not normally exposed by type descriptions. Doing so, it is however possible to indicate to
&nbsp;         * Byte Buddy that the required attributes for such an inner type declaration should be added to a class file.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The types being declared.
&nbsp;         * @return A new builder that is equal to this builder with the supplied types being declared by the built type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; declaredTypes(Class&lt;?&gt;... type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an the outer type of the supplied types. Using this method, it is possible to add inner type declarations
&nbsp;         * for anonymous or local types which are not normally exposed by type descriptions. Doing so, it is however possible to indicate to
&nbsp;         * Byte Buddy that the required attributes for such an inner type declaration should be added to a class file.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The types being declared.
&nbsp;         * @return A new builder that is equal to this builder with the supplied types being declared by the built type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; declaredTypes(TypeDescription... type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an the outer type of the supplied types. Using this method, it is possible to add inner type declarations
&nbsp;         * for anonymous or local types which are not normally exposed by type descriptions. Doing so, it is however possible to indicate to
&nbsp;         * Byte Buddy that the required attributes for such an inner type declaration should be added to a class file.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param types The types being declared.
&nbsp;         * @return A new builder that is equal to this builder with the supplied types being declared by the built type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; declaredTypes(List&lt;? extends Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as an the outer type of the supplied types. Using this method, it is possible to add inner type declarations
&nbsp;         * for anonymous or local types which are not normally exposed by type descriptions. Doing so, it is however possible to indicate to
&nbsp;         * Byte Buddy that the required attributes for such an inner type declaration should be added to a class file.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the declaration hierarchy of a type has no influence on the nest mate hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: By changing this type&#39;s declaration, any other type will not change its declaration of enclosing members or
&nbsp;         * declared types about any nesting of a declaration. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param types The types being declared.
&nbsp;         * @return A new builder that is equal to this builder with the supplied types being declared by the built type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; declaredTypes(Collection&lt;? extends TypeDescription&gt; types);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as self-hosted, i.e. as only being a nest mate of itself.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a self-hosted nest mate.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; noNestMate();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a nest member of the supplied type as a nest host.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The nest host.
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a nest member of the supplied host.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; nestHost(Class&lt;?&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a nest member of the supplied type as a nest host.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The nest host.
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a nest member of the supplied host.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; nestHost(TypeDescription type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a nest host for the supplied types.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The nest members.
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a nest host of the supplied types.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; nestMembers(Class&lt;?&gt;... type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a nest host for the supplied types.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param type The nest members.
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a nest host of the supplied types.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; nestMembers(TypeDescription... type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a nest host for the supplied types.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param types The nest members.
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a nest host of the supplied types.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; nestMembers(List&lt;? extends Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines this type as a nest host for the supplied types.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Changing the nest mate hierarchy of a type has no influence on the declaration hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: Changing nest mate hierarchies always requires changing a member and its host or a host and all its members.
&nbsp;         * Otherwise, the runtime will not accept further nest mates. It is the responsibility of the user of this API to keep such declarations
&nbsp;         * consistent among the definitions of connected types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param types The nest members.
&nbsp;         * @return A new builder that is equal to this builder but where the built type is a nest host of the supplied types.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; nestMembers(Collection&lt;? extends TypeDescription&gt; types);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines this type to allow the supplied permitted subclasses additionally to any prior permitted subclasses. If
&nbsp;         * this type was not previously sealed, only the supplied subclasses are permitted.
&nbsp;         *
&nbsp;         * @param type The permitted subclasses.
&nbsp;         * @return A new builder that is equal to this builder but where the built type permits the supplied subclasses.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; permittedSubclass(Class&lt;?&gt;... type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines this type to allow the supplied permitted subclasses additionally to any prior permitted subclasses. If
&nbsp;         * this type was not previously sealed, only the supplied subclasses are permitted.
&nbsp;         *
&nbsp;         * @param type The permitted subclasses.
&nbsp;         * @return A new builder that is equal to this builder but where the built type permits the supplied subclasses.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; permittedSubclass(TypeDescription... type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines this type to allow the supplied permitted subclasses additionally to any prior permitted subclasses. If
&nbsp;         * this type was not previously sealed, only the supplied subclasses are permitted.
&nbsp;         *
&nbsp;         * @param types The permitted subclasses.
&nbsp;         * @return A new builder that is equal to this builder but where the built type permits the supplied subclasses.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; permittedSubclass(List&lt;? extends Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines this type to allow the supplied permitted subclasses additionally to any prior permitted subclasses. If
&nbsp;         * this type was not previously sealed, only the supplied subclasses are permitted.
&nbsp;         *
&nbsp;         * @param types The permitted subclasses.
&nbsp;         * @return A new builder that is equal to this builder but where the built type permits the supplied subclasses.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; permittedSubclass(Collection&lt;? extends TypeDescription&gt; types);
&nbsp;
&nbsp;        /**
&nbsp;         * Unseales this type.
&nbsp;         *
&nbsp;         * @return A new builder that is equal to this builder but where the built type does not restrain its permitted subclasses.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; unsealed();
&nbsp;
&nbsp;        /**
&nbsp;         * Applies the given type attribute appender onto the instrumented type. Using a type attribute appender, it is possible to append
&nbsp;         * any type of meta data to a type, not only Java {@link Annotation}s.
&nbsp;         *
&nbsp;         * @param typeAttributeAppender The type attribute appender to apply.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied type attribute appender applied to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; attribute(TypeAttributeAppender typeAttributeAppender);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotation The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(Annotation... annotation);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotations The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotation The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(AnnotationDescription... annotation);
&nbsp;
&nbsp;        /**
&nbsp;         * Annotates the instrumented type with the supplied annotations.
&nbsp;         *
&nbsp;         * @param annotations The annotations to add to the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the annotations added to the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;         * as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceType The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(Type... interfaceType);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link Class} values are implemented
&nbsp;         * as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceTypes The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(List&lt;? extends Type&gt; interfaceTypes);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are
&nbsp;         * implemented as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceType The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(TypeDefinition... interfaceType);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Implements the supplied interfaces for the instrumented type. Optionally, it is possible to define the
&nbsp;         * methods that are defined by the interfaces or the interfaces&#39; super interfaces. This excludes methods that
&nbsp;         * are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: This methods implements the supplied types &lt;i&gt;as is&lt;/i&gt;, i.e. any {@link TypeDescription} values are
&nbsp;         * implemented as raw types if they declare type variables or an owner type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param interfaceTypes The interface types to implement.
&nbsp;         * @return A new builder that is equal to this builder but with the interfaces implemented by the instrumented type.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition.Optional&lt;T&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Executes the supplied byte code appender within the beginning of the instrumented type&#39;s type initializer. The
&nbsp;         * supplied byte code appender &lt;b&gt;must not return&lt;/b&gt; from the method. If several byte code appenders are supplied,
&nbsp;         * they are executed within their application order.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This method should only be used for preparing an instrumented type with a specific configuration. Normally,
&nbsp;         * a byte code appender is applied via Byte Buddy&#39;s standard API by invoking {@link Builder#invokable(ElementMatcher)}
&nbsp;         * using the {@link net.bytebuddy.matcher.ElementMatchers#isTypeInitializer()} matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param byteCodeAppender The byte code appender to execute within the instrumented type&#39;s type initializer.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied byte code appender being executed within
&nbsp;         * the instrumented type&#39;s type initializer.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; initializer(ByteCodeAppender byteCodeAppender);
&nbsp;
&nbsp;        /**
&nbsp;         * Executes the supplied loaded type initializer when loading the created instrumented type. If several loaded
&nbsp;         * type initializers are supplied, each loaded type initializer is executed in its registration order.
&nbsp;         *
&nbsp;         * @param loadedTypeInitializer The loaded type initializer to execute upon loading the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied loaded type initializer executed upon
&nbsp;         * loading the instrumented type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; initializer(LoadedTypeInitializer loadedTypeInitializer);
&nbsp;
&nbsp;        /**
&nbsp;         * Explicitly requires another dynamic type for the creation of this type.
&nbsp;         *
&nbsp;         * @param type                 The type to require.
&nbsp;         * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;         * @return A new builder that is equal to this builder but which explicitly requires the supplied type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; require(TypeDescription type, byte[] binaryRepresentation);
&nbsp;
&nbsp;        /**
&nbsp;         * Explicitly requires another dynamic type for the creation of this type.
&nbsp;         *
&nbsp;         * @param type                 The type to require.
&nbsp;         * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;         * @param typeInitializer      The type&#39;s loaded type initializer.
&nbsp;         * @return A new builder that is equal to this builder but which explicitly requires the supplied type.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; require(TypeDescription type, byte[] binaryRepresentation, LoadedTypeInitializer typeInitializer);
&nbsp;
&nbsp;        /**
&nbsp;         * Explicitly requires other dynamic types for the creation of this type.
&nbsp;         *
&nbsp;         * @param auxiliaryType The required dynamic types.
&nbsp;         * @return A new builder that is equal to this builder but which explicitly requires the supplied types.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; require(DynamicType... auxiliaryType);
&nbsp;
&nbsp;        /**
&nbsp;         * Explicitly requires other dynamic types for the creation of this type.
&nbsp;         *
&nbsp;         * @param auxiliaryTypes The required dynamic types.
&nbsp;         * @return A new builder that is equal to this builder but which explicitly requires the supplied types.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; require(Collection&lt;DynamicType&gt; auxiliaryTypes);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable without any bounds as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bound  The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, Type... bound);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bounds The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bound  The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, TypeDefinition... bound);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied type variable with the given bound as a type variable of the instrumented type.
&nbsp;         *
&nbsp;         * @param symbol The type variable&#39;s symbol.
&nbsp;         * @param bounds The type variable&#39;s upper bounds. Can also be {@link net.bytebuddy.dynamic.TargetType} if the bound type
&nbsp;         *               should be equal to the currently instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         */
&nbsp;        TypeVariableDefinition&lt;T&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds);
&nbsp;
&nbsp;        /**
&nbsp;         * Transforms any type variable that is defined by this type if it is matched by the supplied matcher.
&nbsp;         *
&nbsp;         * @param matcher     The matcher to decide what type variables to transform.
&nbsp;         * @param transformer The transformer to apply to the matched type variables.
&nbsp;         * @return A new builder that is equal to this builder but with the supplied transformer applied to all type variables.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param type                The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, Type type, ModifierContributor.ForField... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                 The name of the field.
&nbsp;         * @param type                 The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, Type type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name      The name of the field.
&nbsp;         * @param type      The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                  should be equal to the currently instrumented type.
&nbsp;         * @param modifiers The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, Type type, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param type                The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name                 The name of the field.
&nbsp;         * @param type                 The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, TypeDefinition type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified field as a field of the built dynamic type.
&nbsp;         *
&nbsp;         * @param name      The name of the field.
&nbsp;         * @param type      The type of the field. Can also be {@link net.bytebuddy.dynamic.TargetType} if the field type
&nbsp;         *                  should be equal to the currently instrumented type.
&nbsp;         * @param modifiers The modifiers of the field.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; defineField(String name, TypeDefinition type, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a field that is similar to the supplied field but without copying any annotations on the field.
&nbsp;         *
&nbsp;         * @param field The field to imitate as a field of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; define(Field field);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a field that is similar to the supplied field but without copying any annotations on the field.
&nbsp;         *
&nbsp;         * @param field The field to imitate as a field of the instrumented type.
&nbsp;         * @return A new builder that is equal to this builder but with the given field defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional.Valuable&lt;T&gt; define(FieldDescription field);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a private, static, final field for a serial version UID of the given value.
&nbsp;         *
&nbsp;         * @param serialVersionUid The serial version UID to define as a value.
&nbsp;         * @return A new builder that is equal to this builder but with the given type variable defined for the instrumented type.
&nbsp;         * Furthermore, it is possible to optionally define a value, annotations or custom attributes for the field.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; serialVersionUid(long serialVersionUid);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a field that is already declared by the instrumented type. This gives opportunity to change that field&#39;s
&nbsp;         * default value, annotations or custom attributes.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the field declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a field is already matched by a previously specified field matcher, the new field definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous field definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared fields are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a field&#39;s definition.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        FieldDefinition.Valuable&lt;T&gt; field(ElementMatcher&lt;? super FieldDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a field that is already declared by the instrumented type. This gives opportunity to change that field&#39;s
&nbsp;         * default value, annotations or custom attributes. Using a latent matcher gives opportunity to resolve an
&nbsp;         * {@link ElementMatcher} based on the instrumented type before applying the matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the field declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a field is already matched by a previously specified field matcher, the new field definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous field definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared fields are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a field&#39;s definition.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        FieldDefinition.Valuable&lt;T&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Specifies to exclude any method that is matched by the supplied matcher from instrumentation. Previously supplied matchers
&nbsp;         * remain valid after supplying a new matcher, i.e. any method that is matched by a previously supplied matcher is always ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When ignoring a type, previously registered matchers are applied before this matcher. If a previous matcher indicates that a type
&nbsp;         * is to be ignored, this matcher is no longer executed.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param ignoredMethods The matcher for determining what methods to exclude from instrumentation.
&nbsp;         * @return A new builder that is equal to this builder but that is excluding any method that is matched by the supplied matcher from
&nbsp;         * instrumentation.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        Builder&lt;T&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Specifies to exclude any method that is matched by the supplied matcher from instrumentation. Previously supplied matchers
&nbsp;         * remain valid after supplying a new matcher, i.e. any method that is matched by a previously supplied matcher is always ignored.
&nbsp;         * Using a latent matcher gives opportunity to resolve an {@link ElementMatcher} based on the instrumented type before applying the
&nbsp;         * matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When ignoring a type, previously registered matchers are applied before this matcher. If a previous matcher indicates that a type
&nbsp;         * is to be ignored, this matcher is no longer executed.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param ignoredMethods The matcher for determining what methods to exclude from instrumentation.
&nbsp;         * @return A new builder that is equal to this builder but that is excluding any method that is matched by the supplied matcher from
&nbsp;         * instrumentation.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        Builder&lt;T&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                The name of the method.
&nbsp;         * @param returnType          The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                 The name of the method.
&nbsp;         * @param returnType           The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, Type returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name       The name of the method.
&nbsp;         * @param returnType The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                   should be equal to the currently instrumented type.
&nbsp;         * @param modifiers  The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, Type returnType, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                The name of the method.
&nbsp;         * @param returnType          The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                            should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributor The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name                 The name of the method.
&nbsp;         * @param returnType           The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                             should be equal to the currently instrumented type.
&nbsp;         * @param modifierContributors The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, TypeDefinition returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified method to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param name       The name of the method.
&nbsp;         * @param returnType The method&#39;s return type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the return type
&nbsp;         *                   should be equal to the currently instrumented type.
&nbsp;         * @param modifiers  The method&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the method, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineMethod(String name, TypeDefinition returnType, int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified constructor to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param modifierContributor The constructor&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the constructor, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(ModifierContributor.ForMethod... modifierContributor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified constructor to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param modifierContributors The constructor&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the constructor, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the specified constructor to be declared by the instrumented type. Method parameters or parameter types, declared exceptions and
&nbsp;         * type variables can be defined in subsequent steps.
&nbsp;         *
&nbsp;         * @param modifiers The constructor&#39;s modifiers.
&nbsp;         * @return A builder that allows for further defining the constructor, either by adding more properties or by defining an implementation.
&nbsp;         */
&nbsp;        MethodDefinition.ParameterDefinition.Initial&lt;T&gt; defineConstructor(int modifiers);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a method that is similar to the supplied method but without copying any annotations of the method or method parameters.
&nbsp;         *
&nbsp;         * @param method The method to imitate as a method of the instrumented type.
&nbsp;         * @return A builder that allows for defining an implementation for the method.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(Method method);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a constructor that is similar to the supplied constructor but without copying any annotations of the constructor or
&nbsp;         * constructor parameters.
&nbsp;         *
&nbsp;         * @param constructor The constructor to imitate as a method of the instrumented type.
&nbsp;         * @return A builder that allows for defining an implementation for the constructor.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(Constructor&lt;?&gt; constructor);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a method or constructor that is similar to the supplied method description but without copying any annotations of
&nbsp;         * the method/constructor or method/constructor parameters.
&nbsp;         *
&nbsp;         * @param methodDescription The method description to imitate as a method or constructor of the instrumented type.
&nbsp;         * @return A builder that allows for defining an implementation for the method or constructor.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; define(MethodDescription methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name The name of the property.
&nbsp;         * @param type The property type.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, Type type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name     The name of the property.
&nbsp;         * @param type     The property type.
&nbsp;         * @param readOnly {@code true} if the property is read only, i.e. no setter should be defined and the field should be {@code final}.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, Type type, boolean readOnly);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name The name of the property.
&nbsp;         * @param type The property type.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, TypeDefinition type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a Java bean property with the specified name.
&nbsp;         *
&nbsp;         * @param name     The name of the property.
&nbsp;         * @param type     The property type.
&nbsp;         * @param readOnly {@code true} if the property is read only, i.e. no setter should be defined and the field should be {@code final}.
&nbsp;         * @return A builder that defines the specified property where the field holding the property can be refined by subsequent steps.
&nbsp;         */
&nbsp;        FieldDefinition.Optional&lt;T&gt; defineProperty(String name, TypeDefinition type, boolean readOnly);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a method that is already declared or inherited by the instrumented type. This gives opportunity to change or to
&nbsp;         * override that method&#39;s implementation, default value, annotations or custom attributes. It is also possible to make
&nbsp;         * a method abstract.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the method declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method is already matched by a previously specified matcher, the new method definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous method definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what methods are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; method(ElementMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a constructor that is already declared by the instrumented type. This gives opportunity to change that constructor&#39;s
&nbsp;         * implementation, default value, annotations or custom attributes.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the constructor declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a constructor is already matched by a previously specified matcher, the new constructor definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous constructor definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what constructors are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; constructor(ElementMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a method or constructor that is already declared or inherited by the instrumented type. This gives
&nbsp;         * opportunity to change or to override that method&#39;s or constructor&#39;s implementation, default value, annotations
&nbsp;         * or custom attributes. It is also possible to make a method abstract.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the method or constructor declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method or constructor is already matched by a previously specified matcher, the new definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: It is possible to instrument the dynamic type&#39;s initializer. Depending on the used {@link TypeResolutionStrategy},
&nbsp;         * the type initializer might be run &lt;b&gt;before&lt;/b&gt; Byte Buddy could apply any {@link LoadedTypeInitializer}s which are
&nbsp;         * responsible for preparing the instrumented type prior to the initializer&#39;s execution. For preparing the type prior to
&nbsp;         * executing the initializer, an {@link TypeResolutionStrategy.Active} resolver must be chosen.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what methods or constructors are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; invokable(ElementMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a method or constructor that is already declared or inherited by the instrumented type. This gives
&nbsp;         * opportunity to change or to override that method&#39;s or constructor&#39;s implementation, default value, annotations
&nbsp;         * or custom attributes. It is also possible to make a method abstract. Using a latent matcher gives opportunity
&nbsp;         * to resolve an {@link ElementMatcher} based on the instrumented type before applying the matcher.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the method or constructor declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method or constructor is already matched by a previously specified matcher, the new definition gets precedence
&nbsp;         * over the previous definition, i.e. the previous definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Note that the specified definition does never apply for methods that are explicitly ignored.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: It is possible to instrument the dynamic type&#39;s initializer. Depending on the used {@link TypeResolutionStrategy},
&nbsp;         * the type initializer might be run &lt;b&gt;before&lt;/b&gt; Byte Buddy could apply any {@link LoadedTypeInitializer}s which are
&nbsp;         * responsible for preparing the instrumented type prior to the initializer&#39;s execution. For preparing the type prior to
&nbsp;         * executing the initializer, an {@link TypeResolutionStrategy.Active} resolver must be chosen.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared methods or constructors are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a method&#39;s or constructor&#39;s definition.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        MethodDefinition.ImplementationDefinition&lt;T&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Implements {@link Object#hashCode()} and {@link Object#equals(Object)} methods for the instrumented type if those
&nbsp;         * methods are not declared as {@code final} by a super class. The implementations do not consider any implementations
&nbsp;         * of a super class and compare a class field by field without considering synthetic fields.
&nbsp;         *
&nbsp;         * @return A new type builder that defines {@link Object#hashCode()} and {@link Object#equals(Object)} methods accordingly.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; withHashCodeEquals();
&nbsp;
&nbsp;        /**
&nbsp;         * Implements a {@link Object#toString()} method for the instrumented type if such a method is not declared as {@code final}
&nbsp;         * by a super class. The implementation prefixes the string with the simple class name and prints each non-synthetic field&#39;s
&nbsp;         * value after the field&#39;s name.
&nbsp;         *
&nbsp;         * @return A new type builder that defines {@link Object#toString()} method accordingly.
&nbsp;         */
&nbsp;        Builder&lt;T&gt; withToString();
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a new record component. Note that this does not add or change implementations for a field, an accessor
&nbsp;         * to this field or a constructor unless {@link net.bytebuddy.ByteBuddy#makeRecord()} is used.
&nbsp;         *
&nbsp;         * @param name The record component&#39;s name.
&nbsp;         * @param type The record component&#39;s type.
&nbsp;         * @return A new builder that is equal to this builder but also defines the supplied record component.
&nbsp;         */
&nbsp;        RecordComponentDefinition.Optional&lt;T&gt; defineRecordComponent(String name, Type type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a new record component. Note that this does not add or change implementations for a field, an accessor
&nbsp;         * to this field or a constructor unless {@link net.bytebuddy.ByteBuddy#makeRecord()} is used.
&nbsp;         *
&nbsp;         * @param name The record component&#39;s name.
&nbsp;         * @param type The record component&#39;s type.
&nbsp;         * @return A new builder that is equal to this builder but also defines the supplied record component.
&nbsp;         */
&nbsp;        RecordComponentDefinition.Optional&lt;T&gt; defineRecordComponent(String name, TypeDefinition type);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a new record component. Note that this does not add or change implementations for a field, an accessor
&nbsp;         * to this field or a constructor unless {@link net.bytebuddy.ByteBuddy#makeRecord()} is used.
&nbsp;         *
&nbsp;         * @param recordComponentDescription A description of the record component to immitate.
&nbsp;         * @return A new builder that is equal to this builder but also defines the supplied record component.
&nbsp;         */
&nbsp;        RecordComponentDefinition.Optional&lt;T&gt; define(RecordComponentDescription recordComponentDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a record component that is already declared by the instrumented type. This gives opportunity to change that
&nbsp;         * record component&#39;s annotations or custom attributes.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the field declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a record component is already matched by a previously specified record component matcher, the new record component
&nbsp;         * definition gets precedence over the previous definition, i.e. the previous record component definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared record components are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a record component&#39;s definition.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        RecordComponentDefinition&lt;T&gt; recordComponent(ElementMatcher&lt;? super RecordComponentDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Matches a record component that is already declared by the instrumented type. This gives opportunity to change that
&nbsp;         * record component&#39;s annotations or custom attributes.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When a type is redefined or rebased, any annotations that the field declared previously is preserved
&nbsp;         * &lt;i&gt;as it is&lt;/i&gt; if Byte Buddy is configured to retain such annotations by
&nbsp;         * {@link net.bytebuddy.implementation.attribute.AnnotationRetention#ENABLED}. If any existing annotations should be
&nbsp;         * altered, annotation retention must be disabled.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a record component is already matched by a previously specified record component matcher, the new record component
&nbsp;         * definition gets precedence over the previous definition, i.e. the previous record component definition is no longer applied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param matcher The matcher that determines what declared record components are affected by the subsequent specification.
&nbsp;         * @return A builder that allows for changing a record component&#39;s definition.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;overloads&quot;)
&nbsp;        RecordComponentDefinition&lt;T&gt; recordComponent(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a class visitor with the configuration that is represented by this dynamic type builder, using a
&nbsp;         * default {@link TypePool}. A wrapper might not apply all features that are normally applied by Byte
&nbsp;         * Buddy, if those features require control of the class loading life cycle. Neither does a wrapper define
&nbsp;         * auxiliary types. It is therefore recommended to use {@link Implementation.Context.Disabled}.
&nbsp;         *
&nbsp;         * @param classVisitor The class visitor to wrap.
&nbsp;         * @return A new class visitor that wraps a representation of this dynamic type.
&nbsp;         */
&nbsp;        ContextClassVisitor wrap(ClassVisitor classVisitor);
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a class visitor with the configuration that is represented by this dynamic type builder, using a
&nbsp;         * default {@link TypePool}. A wrapper might not apply all features that are normally applied by Byte
&nbsp;         * Buddy, if those features require control of the class loading life cycle. Neither does a wrapper define
&nbsp;         * auxiliary types. It is therefore recommended to use {@link Implementation.Context.Disabled}.
&nbsp;         *
&nbsp;         * @param classVisitor The class visitor to wrap.
&nbsp;         * @param writerFlags  The ASM writer flags to apply.
&nbsp;         * @param readerFlags  The ASM reader flags to apply.
&nbsp;         * @return A new class visitor that wraps a representation of this dynamic type.
&nbsp;         */
&nbsp;        ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags);
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a class visitor with the configuration that is represented by this dynamic type builder. A wrapper
&nbsp;         * might not apply all features that are normally applied by Byte Buddy, if those features require control of
&nbsp;         * the class loading life cycle. Neither does a wrapper define auxiliary types.  It is therefore recommended
&nbsp;         * to use {@link Implementation.Context.Disabled}.
&nbsp;         *
&nbsp;         * @param classVisitor The class visitor to wrap.
&nbsp;         * @param typePool     A type pool that is used for computing stack map frames by the underlying class writer, if required.
&nbsp;         * @return A new class visitor that wraps a representation of this dynamic type.
&nbsp;         */
&nbsp;        ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool);
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a class visitor with the configuration that is represented by this dynamic type builder. A wrapper
&nbsp;         * might not apply all features that are normally applied by Byte Buddy, if those features require control
&nbsp;         * of the class loading life cycle. Neither does a wrapper define auxiliary types.  It is therefore
&nbsp;         * recommended to use {@link Implementation.Context.Disabled}.
&nbsp;         *
&nbsp;         * @param classVisitor The class visitor to wrap.
&nbsp;         * @param typePool     A type pool that is used for computing stack map frames by the underlying class writer, if required.
&nbsp;         * @param writerFlags  The ASM writer flags to apply.
&nbsp;         * @param readerFlags  The ASM reader flags to apply.
&nbsp;         * @return A new class visitor that wraps a representation of this dynamic type.
&nbsp;         */
&nbsp;        ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Other than {@link DynamicType.Builder#make(TypePool)}, this method supplies a context-dependant type pool to the underlying class writer.
&nbsp;         * Supplying a type pool only makes sense if custom byte code is created by adding a custom {@link AsmVisitorWrapper} where ASM might be
&nbsp;         * required to compute stack map frames by processing information over any mentioned type&#39;s class hierarchy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The dynamic type is initialized using a {@link TypeResolutionStrategy.Passive} strategy. Using this strategy, no
&nbsp;         * {@link LoadedTypeInitializer} is run during the execution of the type&#39;s initializer such that no {@link Implementation} used for
&nbsp;         * executing the initializer must rely on such an initializer.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The dynamic type is initialized using a {@link TypeResolutionStrategy.Passive} strategy. Using this strategy, no
&nbsp;         * {@link LoadedTypeInitializer} is run during the execution of the type&#39;s initializer such that no {@link Implementation} used for
&nbsp;         * executing the initializer must rely on such an initializer.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typeResolutionStrategy The type resolution strategy to use for the created type&#39;s initialization.
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make(TypeResolutionStrategy typeResolutionStrategy);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The dynamic type is initialized using a {@link TypeResolutionStrategy.Passive} strategy. Using this strategy, no
&nbsp;         * {@link LoadedTypeInitializer} is run during the execution of the type&#39;s initializer such that no {@link Implementation} used for
&nbsp;         * executing the initializer must rely on such an initializer.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typePool A type pool that is used for computing stack map frames by the underlying class writer, if required.
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make(TypePool typePool);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates the dynamic type this builder represents. If the specified dynamic type is not legal, an {@link IllegalStateException} is thrown.
&nbsp;         *
&nbsp;         * @param typeResolutionStrategy The type resolution strategy to use for the created type&#39;s initialization.
&nbsp;         * @param typePool               A type pool that is used for computing stack map frames by the underlying class writer, if required.
&nbsp;         * @return An unloaded dynamic type representing the type specified by this builder.
&nbsp;         */
&nbsp;        DynamicType.Unloaded&lt;T&gt; make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@link TypeDescription} for the currently built type.
&nbsp;         *
&nbsp;         * @return A {@link TypeDescription} for the currently built type.
&nbsp;         */
&nbsp;        TypeDescription toTypeDescription();
&nbsp;
&nbsp;        /**
&nbsp;         * An inner type definition for defining a type that is contained within another type, method or constructor.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface InnerTypeDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Defines this inner type declaration as an anonymous type.
&nbsp;             *
&nbsp;             * @return A new builder that is equal to this type builder but that defines the previous inner type definition as a anonymous type.
&nbsp;             */
&nbsp;            Builder&lt;S&gt; asAnonymousType();
&nbsp;
&nbsp;            /**
&nbsp;             * An inner type definition for defining a type that is contained within another type.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ForType&lt;U&gt; extends InnerTypeDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines this inner type declaration as a member type.
&nbsp;                 *
&nbsp;                 * @return A new builder that is equal to this type builder but that defines the previous inner type definition as a member type.
&nbsp;                 */
&nbsp;                Builder&lt;U&gt; asMemberType();
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a type variable definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface TypeVariableDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined type variable with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined type variable.
&nbsp;             */
&nbsp;            TypeVariableDefinition&lt;S&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of a type variable definition.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
<b class="fc">&nbsp;            abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements TypeVariableDefinition&lt;U&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(Annotation... annotation) {
<b class="nc">&nbsp;                    return annotateTypeVariable(Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                    return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                    return annotateTypeVariable(Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a field definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface FieldDefinition&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched field with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied attribute appender factory onto the previously defined or matched field.
&nbsp;             *
&nbsp;             * @param fieldAttributeAppenderFactory The field attribute appender factory that should be applied on the
&nbsp;             *                                      previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied field attribute appender factory
&nbsp;             * applied to the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied transformer onto the previously defined or matched field. The transformed
&nbsp;             * field is written &lt;i&gt;as it is&lt;/i&gt; and it not subject to any validations.
&nbsp;             *
&nbsp;             * @param transformer The transformer to apply to the previously defined or matched field.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied field transformer
&nbsp;             * applied to the previously defined or matched field.
&nbsp;             */
&nbsp;            FieldDefinition.Optional&lt;S&gt; transform(Transformer&lt;FieldDescription&gt; transformer);
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for a field definition that allows for defining a value.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface Valuable&lt;U&gt; extends FieldDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code boolean} value as a default value of the previously defined or matched field. The value can only
&nbsp;                 * be set for numeric fields of type {@code boolean}, {@code byte}, {@code short}, {@code char} or {@code int}. For non-boolean
&nbsp;                 * fields, the field&#39;s value is set to {@code 0} for {@code false} or {@code 1} for {@code true}.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(boolean value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code int} value as a default value of the previously defined or matched field. The value can only
&nbsp;                 * be set for numeric fields of type {@code boolean}, {@code byte}, {@code short}, {@code char} or {@code int} where the
&nbsp;                 * value must be within the numeric type&#39;s range. The {@code boolean} type is regarded as a numeric type with the possible
&nbsp;                 * values of {@code 0} and {@code 1} representing {@code false} and {@code true}.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(int value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code long} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(long value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code float} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(float value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@code double} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(double value);
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Defines the supplied {@link String} value as a default value of the previously defined or matched field.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: A default value in a Java class file defines a field&#39;s value prior to the class&#39;s initialization. This value
&nbsp;                 * is only visible to code if the field is declared {@code static}. A default value can also be set for non-static fields where
&nbsp;                 * the value is not visible to code. The Java compiler only defines such values for {@code final} fields.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param value The value to define as a default value of the defined field.
&nbsp;                 * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                 * previously defined or matched field.
&nbsp;                 */
&nbsp;                FieldDefinition.Optional&lt;U&gt; value(String value);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for an optional field definition.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface Optional&lt;U&gt; extends FieldDefinition&lt;U&gt;, Builder&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for an optional field definition that allows for defining a value.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Valuable&lt;V&gt; extends FieldDefinition.Valuable&lt;V&gt;, Optional&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation of an optional field definition that allows for defining a value.
&nbsp;                     *
&nbsp;                     * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;U&gt; extends Optional.AbstractBase&lt;U&gt; implements Optional.Valuable&lt;U&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(boolean value) {
<b class="fc">&nbsp;                            return defaultValue(value ? 1 : 0);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(int value) {
<b class="fc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(long value) {
<b class="fc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(float value) {
<b class="fc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(double value) {
<b class="fc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public FieldDefinition.Optional&lt;U&gt; value(String value) {
<b class="fc">&nbsp;                            if (value == null) {</b>
<b class="fc">&nbsp;                                throw new IllegalArgumentException(&quot;Cannot define &#39;null&#39; as constant value&quot;);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return defaultValue(value);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied value as a default value of the previously defined or matched field.
&nbsp;                         *
&nbsp;                         * @param defaultValue The value to define as a default value of the defined field.
&nbsp;                         * @return A new builder that is equal to this builder but with the given default value declared for the
&nbsp;                         * previously defined or matched field.
&nbsp;                         */
&nbsp;                        protected abstract FieldDefinition.Optional&lt;U&gt; defaultValue(Object defaultValue);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An adapter for an optional field definition that allows for defining a value.
&nbsp;                         *
&nbsp;                         * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        private abstract static class Adapter&lt;V&gt; extends Optional.Valuable.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The field attribute appender factory to apply.
&nbsp;                             */
&nbsp;                            protected final FieldAttributeAppender.Factory fieldAttributeAppenderFactory;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The field transformer to apply.
&nbsp;                             */
&nbsp;                            protected final Transformer&lt;FieldDescription&gt; transformer;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            protected final Object defaultValue;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new field adapter.
&nbsp;                             *
&nbsp;                             * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                             * @param transformer                   The field transformer to apply.
&nbsp;                             * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                             */
&nbsp;                            protected Adapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                              Transformer&lt;FieldDescription&gt; transformer,
<b class="fc">&nbsp;                                              @MaybeNull Object defaultValue) {</b>
<b class="fc">&nbsp;                                this.fieldAttributeAppenderFactory = fieldAttributeAppenderFactory;</b>
<b class="fc">&nbsp;                                this.transformer = transformer;</b>
<b class="fc">&nbsp;                                this.defaultValue = defaultValue;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public FieldDefinition.Optional&lt;V&gt; attribute(FieldAttributeAppender.Factory fieldAttributeAppenderFactory) {
<b class="fc">&nbsp;                                return materialize(new FieldAttributeAppender.Factory.Compound(this.fieldAttributeAppenderFactory, fieldAttributeAppenderFactory), transformer, defaultValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                            public FieldDefinition.Optional&lt;V&gt; transform(Transformer&lt;FieldDescription&gt; transformer) {
<b class="fc">&nbsp;                                return materialize(fieldAttributeAppenderFactory, new Transformer.Compound&lt;FieldDescription&gt;(this.transformer, transformer), defaultValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected FieldDefinition.Optional&lt;V&gt; defaultValue(Object defaultValue) {
<b class="fc">&nbsp;                                return materialize(fieldAttributeAppenderFactory, transformer, defaultValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new optional field definition for which all of the supplied values are represented.
&nbsp;                             *
&nbsp;                             * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                             * @param transformer                   The field transformer to apply.
&nbsp;                             * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                             * @return A new field definition that represents the supplied values.
&nbsp;                             */
&nbsp;                            protected abstract FieldDefinition.Optional&lt;V&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                                                       Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                                                       @MaybeNull Object defaultValue);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for an optional field definition.
&nbsp;                 *
&nbsp;                 * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements FieldDefinition.Optional&lt;U&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(Annotation... annotation) {
<b class="fc">&nbsp;                        return annotateField(Arrays.asList(annotation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(List&lt;? extends Annotation&gt; annotations) {
<b class="fc">&nbsp;                        return annotateField(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDefinition.Optional&lt;U&gt; annotateField(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                        return annotateField(Arrays.asList(annotation));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a method definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface MethodDefinition&lt;S&gt; extends Builder&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index       The parameter&#39;s index.
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index      The parameter&#39;s index.
&nbsp;             * @param annotation The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the parameter of the given index of the previously defined or matched method with the supplied annotations.
&nbsp;             *
&nbsp;             * @param index       The parameter&#39;s index.
&nbsp;             * @param annotations The annotations to declare on the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;             * on the previously defined or matched method&#39;s parameter of the given index.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied method attribute appender factory onto the previously defined or matched method.
&nbsp;             *
&nbsp;             * @param methodAttributeAppenderFactory The method attribute appender factory that should be applied on the
&nbsp;             *                                       previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied method attribute appender factory
&nbsp;             * applied to the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied transformer onto the previously defined or matched method. The transformed
&nbsp;             * method is written &lt;i&gt;as it is&lt;/i&gt; and it not subject to any validations.
&nbsp;             *
&nbsp;             * @param transformer The transformer to apply to the previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied transformer
&nbsp;             * applied to the previously defined or matched method.
&nbsp;             */
&nbsp;            MethodDefinition&lt;S&gt; transform(Transformer&lt;MethodDescription&gt; transformer);
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for a method definition with a receiver type.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ReceiverTypeDefinition&lt;U&gt; extends MethodDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the supplied (annotated) receiver type for the previously defined or matched method.
&nbsp;                 *
&nbsp;                 * @param receiverType The receiver type to define on the previously defined or matched method.
&nbsp;                 * @return A new builder that is equal to this builder but with the given type defined as the
&nbsp;                 * receiver on the previously defined or matched method.
&nbsp;                 */
&nbsp;                MethodDefinition&lt;U&gt; receiverType(AnnotatedElement receiverType);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the supplied (annotated) receiver type for the previously defined or matched method.
&nbsp;                 *
&nbsp;                 * @param receiverType The receiver type to define on the previously defined or matched method.
&nbsp;                 * @return A new builder that is equal to this builder but with the given type defined as the
&nbsp;                 * receiver on the previously defined or matched method.
&nbsp;                 */
&nbsp;                MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType);
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation of a method definition that can accept a receiver type.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends MethodDefinition.AbstractBase&lt;V&gt; implements ReceiverTypeDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition&lt;V&gt; receiverType(AnnotatedElement receiverType) {
<b class="nc">&nbsp;                        return receiverType(TypeDefinition.Sort.describeAnnotated(receiverType));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ImplementationDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Implements the previously defined or matched method by the supplied implementation. A method interception
&nbsp;                 * is typically implemented in one of the following ways:
&nbsp;                 * &lt;ol&gt;
&nbsp;                 * &lt;li&gt;If a method is declared by the instrumented type and the type builder creates a subclass or redefinition,
&nbsp;                 * any preexisting method is replaced by the given implementation. Any previously defined implementation is lost.&lt;/li&gt;
&nbsp;                 * &lt;li&gt;If a method is declared by the instrumented type and the type builder creates a rebased version of the
&nbsp;                 * instrumented type, the original method is preserved within a private, synthetic method within the instrumented
&nbsp;                 * type. The original method therefore remains invokeable and is treated as the direct super method of the new
&nbsp;                 * method. When rebasing a type, it therefore becomes possible to invoke a non-virtual method&#39;s super method
&nbsp;                 * when a preexisting method body is replaced.&lt;/li&gt;
&nbsp;                 * &lt;li&gt;If a virtual method is inherited from a super type, it is overridden. The overridden method is available
&nbsp;                 * for super method invocation.&lt;/li&gt;
&nbsp;                 * &lt;/ol&gt;
&nbsp;                 *
&nbsp;                 * @param implementation The implementation for implementing the previously defined or matched method.
&nbsp;                 * @return A new builder where the previously defined or matched method is implemented by the
&nbsp;                 * supplied implementation.
&nbsp;                 */
&nbsp;                MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the previously defined or matched method not to declare a method body. This implies the
&nbsp;                 * method to be {@code abstract} unless it was already declared to be {@code native}.
&nbsp;                 *
&nbsp;                 * @return A new builder where the previously defined or matched method is implemented to be abstract.
&nbsp;                 */
&nbsp;                MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode();
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the previously defined or matched method to return the supplied value as an annotation default value. The
&nbsp;                 * value must be supplied in its unloaded state, i.e. enumerations as {@link net.bytebuddy.description.enumeration.EnumerationDescription},
&nbsp;                 * types as {@link TypeDescription} and annotations as {@link AnnotationDescription}. For supplying loaded types, use
&nbsp;                 * {@link ImplementationDefinition#defaultValue(Object, Class)} must be used.
&nbsp;                 *
&nbsp;                 * @param annotationValue The value to be defined as a default value.
&nbsp;                 * @return A builder where the previously defined or matched method is implemented to return an annotation default value.
&nbsp;                 */
&nbsp;                MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the previously defined or matched method to return the supplied value as an annotation default value. The
&nbsp;                 * value must be supplied in its loaded state paired with the property type of the value.
&nbsp;                 *
&nbsp;                 * @param value The value to be defined as a default value.
&nbsp;                 * @param type  The type of the annotation property.
&nbsp;                 * @param &lt;W&gt;   The type of the annotation property.
&nbsp;                 * @return A builder where the previously defined or matched method is implemented to return an annotation default value.
&nbsp;                 */
&nbsp;                &lt;W&gt; MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(W value, Class&lt;? extends W&gt; type);
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for optionally defining an implementation of a method.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Optional&lt;V&gt; extends ImplementationDefinition&lt;V&gt;, Builder&lt;V&gt; {
&nbsp;                    /* union type */
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for a builder optionally defining an implementation of a method.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; implements ImplementationDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public &lt;W&gt; MethodDefinition.ReceiverTypeDefinition&lt;V&gt; defaultValue(W value, Class&lt;? extends W&gt; type) {
<b class="fc">&nbsp;                        return defaultValue(AnnotationDescription.ForLoadedAnnotation.asValue(value, type));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method and optionally defining a type variable.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface TypeVariableDefinition&lt;U&gt; extends ImplementationDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method. The defined method variable does not define any bounds.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bound  The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, Type... bound);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bounds The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bound  The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, TypeDefinition... bound);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param symbol The symbol of the type variable.
&nbsp;                 * @param bounds The bounds of the type variables. Can also be {@link net.bytebuddy.dynamic.TargetType} for any type
&nbsp;                 *               if a bound type should be equal to the currently instrumented type.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified type variable.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds);
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for optionally defining an annotation for a type variable.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Annotatable&lt;V&gt; extends TypeVariableDefinition&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(Annotation... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(AnnotationDescription... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined type variable with the supplied annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined type variable.
&nbsp;                     * @return A new builder that is equal to this builder but with the given annotations declared
&nbsp;                     * on the previously defined type variable.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation for defining an annotation on a parameter.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;W&gt; extends TypeVariableDefinition.AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeVariableDefinition.Annotatable&lt;W&gt; annotateTypeVariable(Annotation... annotation) {
<b class="nc">&nbsp;                            return annotateTypeVariable(Arrays.asList(annotation));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeVariableDefinition.Annotatable&lt;W&gt; annotateTypeVariable(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                            return annotateTypeVariable(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeVariableDefinition.Annotatable&lt;W&gt; annotateTypeVariable(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                            return annotateTypeVariable(Arrays.asList(annotation));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An adapter implementation for an annotatable type variable definition.
&nbsp;                         *
&nbsp;                         * @param &lt;X&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
<b class="fc">&nbsp;                        protected abstract static class Adapter&lt;X&gt; extends TypeVariableDefinition.Annotatable.AbstractBase&lt;X&gt; {</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="fc">&nbsp;                                return materialize().typeVariable(symbol, bounds);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                                return materialize().intercept(implementation);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; withoutCode() {
<b class="fc">&nbsp;                                return materialize().withoutCode();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                                return materialize().defaultValue(annotationValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
<b class="nc">&nbsp;                                return materialize().defaultValue(value, type);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Materializes this instance as a parameter definition with the currently defined properties.
&nbsp;                             *
&nbsp;                             * @return A parameter definition with the currently defined properties.
&nbsp;                             */
&nbsp;                            protected abstract MethodDefinition.ParameterDefinition&lt;X&gt; materialize();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for defining an implementation of a method and optionally defining a type variable.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends ImplementationDefinition.AbstractBase&lt;V&gt; implements TypeVariableDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol) {
<b class="fc">&nbsp;                        return typeVariable(symbol, Collections.singletonList(Object.class));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, Type... bound) {
<b class="fc">&nbsp;                        return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds) {
<b class="fc">&nbsp;                        return typeVariable(symbol, new TypeList.Generic.ForLoadedTypes(bounds));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Annotatable&lt;V&gt; typeVariable(String symbol, TypeDefinition... bound) {
<b class="fc">&nbsp;                        return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method and optionally defining a type variable or thrown exception.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ExceptionDefinition&lt;U&gt; extends TypeVariableDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(Type... type);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param types The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(List&lt;? extends Type&gt; types);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(TypeDefinition... type);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a method variable to be declared by the currently defined method.
&nbsp;                 *
&nbsp;                 * @param types The type of the exception being declared by the currently defined method.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method declares the specified exception type.
&nbsp;                 */
&nbsp;                ExceptionDefinition&lt;U&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types);
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for defining an implementation of a method and optionally defining a type variable or thrown exception.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends TypeVariableDefinition.AbstractBase&lt;V&gt; implements ExceptionDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(Type... type) {
<b class="fc">&nbsp;                        return throwing(Arrays.asList(type));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(List&lt;? extends Type&gt; types) {
<b class="fc">&nbsp;                        return throwing(new TypeList.Generic.ForLoadedTypes(types));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ExceptionDefinition&lt;V&gt; throwing(TypeDefinition... type) {
<b class="fc">&nbsp;                        return throwing(Arrays.asList(type));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A builder for defining an implementation of a method and optionally defining a type variable, thrown exception or method parameter.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface ParameterDefinition&lt;U&gt; extends ExceptionDefinition&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                            should be equal to the currently instrumented type.
&nbsp;                 * @param name                The parameter&#39;s name.
&nbsp;                 * @param modifierContributor The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                 The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                             should be equal to the currently instrumented type.
&nbsp;                 * @param name                 The parameter&#39;s name.
&nbsp;                 * @param modifierContributors The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(Type type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type      The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                  should be equal to the currently instrumented type.
&nbsp;                 * @param name      The parameter&#39;s name.
&nbsp;                 * @param modifiers The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(Type type, String name, int modifiers);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                            should be equal to the currently instrumented type.
&nbsp;                 * @param name                The parameter&#39;s name.
&nbsp;                 * @param modifierContributor The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type                 The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                             should be equal to the currently instrumented type.
&nbsp;                 * @param name                 The parameter&#39;s name.
&nbsp;                 * @param modifierContributors The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                 *
&nbsp;                 * @param type      The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                 *                  should be equal to the currently instrumented type.
&nbsp;                 * @param name      The parameter&#39;s name.
&nbsp;                 * @param modifiers The parameter&#39;s modifiers.
&nbsp;                 * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                 */
&nbsp;                Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, int modifiers);
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for optionally defining an annotation on a parameter.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Annotatable&lt;V&gt; extends ParameterDefinition&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(Annotation... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(AnnotationDescription... annotation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Annotates the previously defined parameter with the specified annotations.
&nbsp;                     *
&nbsp;                     * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                     * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                     * the specified annotations.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation for defining an annotation on a parameter.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;W&gt; extends ParameterDefinition.AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ParameterDefinition.Annotatable&lt;W&gt; annotateParameter(Annotation... annotation) {
<b class="nc">&nbsp;                            return annotateParameter(Arrays.asList(annotation));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ParameterDefinition.Annotatable&lt;W&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                            return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ParameterDefinition.Annotatable&lt;W&gt; annotateParameter(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                            return annotateParameter(Arrays.asList(annotation));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An adapter implementation for defining an annotation on a parameter.
&nbsp;                         *
&nbsp;                         * @param &lt;X&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
<b class="fc">&nbsp;                        protected abstract static class Adapter&lt;X&gt; extends ParameterDefinition.Annotatable.AbstractBase&lt;X&gt; {</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public ParameterDefinition.Annotatable&lt;X&gt; withParameter(TypeDefinition type, String name, int modifiers) {
<b class="nc">&nbsp;                                return materialize().withParameter(type, name, modifiers);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public ExceptionDefinition&lt;X&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="fc">&nbsp;                                return materialize().throwing(types);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="nc">&nbsp;                                return materialize().typeVariable(symbol, bounds);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
<b class="nc">&nbsp;                                return materialize().intercept(implementation);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; withoutCode() {
<b class="nc">&nbsp;                                return materialize().withoutCode();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                                return materialize().defaultValue(annotationValue);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
<b class="nc">&nbsp;                                return materialize().defaultValue(value, type);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Materializes this instance as a parameter definition with the currently defined properties.
&nbsp;                             *
&nbsp;                             * @return A parameter definition with the currently defined properties.
&nbsp;                             */
&nbsp;                            protected abstract MethodDefinition.ParameterDefinition&lt;X&gt; materialize();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for defining an implementation of a method and optionally defining a type variable, thrown exception or a parameter type.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Simple&lt;V&gt; extends ExceptionDefinition&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; withParameter(Type type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameter for the currently defined method as the last parameter of the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter&#39;s type. Can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameter.
&nbsp;                     */
&nbsp;                    Annotatable&lt;V&gt; withParameter(TypeDefinition type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A builder for optionally defining an annotation on a parameter.
&nbsp;                     *
&nbsp;                     * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
&nbsp;                    interface Annotatable&lt;V&gt; extends Simple&lt;V&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(Annotation... annotation);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotation The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(AnnotationDescription... annotation);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Annotates the previously defined parameter with the specified annotations.
&nbsp;                         *
&nbsp;                         * @param annotations The annotations to declare on the previously defined parameter.
&nbsp;                         * @return A new builder that is equal to this builder but with the previously defined parameter annotated with
&nbsp;                         * the specified annotations.
&nbsp;                         */
&nbsp;                        Annotatable&lt;V&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An abstract base implementation of a simple parameter definition.
&nbsp;                         *
&nbsp;                         * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                         */
<b class="fc">&nbsp;                        abstract class AbstractBase&lt;W&gt; extends Simple.AbstractBase&lt;W&gt; implements Annotatable&lt;W&gt; {</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Simple.Annotatable&lt;W&gt; annotateParameter(Annotation... annotation) {
<b class="nc">&nbsp;                                return annotateParameter(Arrays.asList(annotation));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Simple.Annotatable&lt;W&gt; annotateParameter(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                                return annotateParameter(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Simple.Annotatable&lt;W&gt; annotateParameter(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                                return annotateParameter(Arrays.asList(annotation));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An adapter implementation of a simple parameter definition.
&nbsp;                             *
&nbsp;                             * @param &lt;X&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                             */
<b class="fc">&nbsp;                            protected abstract static class Adapter&lt;X&gt; extends Simple.Annotatable.AbstractBase&lt;X&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Simple.Annotatable&lt;X&gt; withParameter(TypeDefinition type) {
<b class="fc">&nbsp;                                    return materialize().withParameter(type);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public ExceptionDefinition&lt;X&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="fc">&nbsp;                                    return materialize().throwing(types);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public TypeVariableDefinition.Annotatable&lt;X&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="nc">&nbsp;                                    return materialize().typeVariable(symbol, bounds);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                                    return materialize().intercept(implementation);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; withoutCode() {
<b class="fc">&nbsp;                                    return materialize().withoutCode();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                                    return materialize().defaultValue(annotationValue);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;X&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
<b class="nc">&nbsp;                                    return materialize().defaultValue(value, type);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Materializes this instance as a simple parameter definition with the currently defined properties.
&nbsp;                                 *
&nbsp;                                 * @return A simple parameter definition with the currently defined properties.
&nbsp;                                 */
&nbsp;                                protected abstract MethodDefinition.ParameterDefinition.Simple&lt;X&gt; materialize();
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation of an exception definition.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;W&gt; extends ExceptionDefinition.AbstractBase&lt;W&gt; implements Simple&lt;W&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Simple.Annotatable&lt;W&gt; withParameter(Type type) {
<b class="nc">&nbsp;                            return withParameter(TypeDefinition.Sort.describe(type));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A builder for defining an implementation of a method and optionally defining a type variable, thrown exception or method parameter.
&nbsp;                 * Implementations allow for the &lt;i&gt;one-by-one&lt;/i&gt; definition of parameters what gives opportunity to annotate parameters in a fluent
&nbsp;                 * style. Doing so, it is optionally possible to define parameter names and modifiers. This can be done for either all or no parameters.
&nbsp;                 * Alternatively, parameters without annotations, names or modifiers can be defined by a single step.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                interface Initial&lt;V&gt; extends ParameterDefinition&lt;V&gt;, Simple&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(Type... type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param types The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *              should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(List&lt;? extends Type&gt; types);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param type The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *             should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(TypeDefinition... type);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Defines the specified parameters for the currently defined method.
&nbsp;                     *
&nbsp;                     * @param types The parameter types. Any type can also be {@link net.bytebuddy.dynamic.TargetType} if the parameter type
&nbsp;                     *              should be equal to the currently instrumented type.
&nbsp;                     * @return A new builder that is equal to the current builder but where the currently defined method appends the specified parameters.
&nbsp;                     */
&nbsp;                    ExceptionDefinition&lt;V&gt; withParameters(Collection&lt;? extends TypeDefinition&gt; types);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation for an initial parameter definition.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase&lt;W&gt; extends ParameterDefinition.AbstractBase&lt;W&gt; implements Initial&lt;W&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Simple.Annotatable&lt;W&gt; withParameter(Type type) {
<b class="fc">&nbsp;                            return withParameter(TypeDefinition.Sort.describe(type));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(Type... type) {
<b class="fc">&nbsp;                            return withParameters(Arrays.asList(type));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(List&lt;? extends Type&gt; types) {
<b class="fc">&nbsp;                            return withParameters(new TypeList.Generic.ForLoadedTypes(types));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(TypeDefinition... type) {
<b class="fc">&nbsp;                            return withParameters(Arrays.asList(type));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ExceptionDefinition&lt;W&gt; withParameters(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="fc">&nbsp;                            ParameterDefinition.Simple&lt;W&gt; parameterDefinition = this;</b>
<b class="fc">&nbsp;                            for (TypeDefinition type : types) {</b>
<b class="fc">&nbsp;                                parameterDefinition = parameterDefinition.withParameter(type);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return parameterDefinition;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation for defining an implementation of a method and optionally defining a type variable, thrown exception or parameter type.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;V&gt; extends ExceptionDefinition.AbstractBase&lt;V&gt; implements ParameterDefinition&lt;V&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(Type type, String name, ModifierContributor.ForParameter... modifierContributor) {
<b class="fc">&nbsp;                        return withParameter(type, name, Arrays.asList(modifierContributor));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(Type type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors) {
<b class="fc">&nbsp;                        return withParameter(type, name, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(Type type, String name, int modifiers) {
<b class="fc">&nbsp;                        return withParameter(TypeDefinition.Sort.describe(type), name, modifiers);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(TypeDefinition type, String name, ModifierContributor.ForParameter... modifierContributor) {
<b class="nc">&nbsp;                        return withParameter(type, name, Arrays.asList(modifierContributor));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterDefinition.Annotatable&lt;V&gt; withParameter(TypeDefinition type, String name, Collection&lt;? extends ModifierContributor.ForParameter&gt; modifierContributors) {
<b class="nc">&nbsp;                        return withParameter(type, name, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of a method definition.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
<b class="fc">&nbsp;            abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements MethodDefinition&lt;U&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(Annotation... annotation) {
<b class="fc">&nbsp;                    return annotateMethod(Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(List&lt;? extends Annotation&gt; annotations) {
<b class="fc">&nbsp;                    return annotateMethod(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition&lt;U&gt; annotateMethod(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                    return annotateMethod(Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, Annotation... annotation) {
<b class="nc">&nbsp;                    return annotateParameter(index, Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                    return annotateParameter(index, new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition&lt;U&gt; annotateParameter(int index, AnnotationDescription... annotation) {
<b class="nc">&nbsp;                    return annotateParameter(index, Arrays.asList(annotation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter implementation of a method definition.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class Adapter&lt;V&gt; extends MethodDefinition.ReceiverTypeDefinition.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The handler that determines how a method is implemented.
&nbsp;                     */
&nbsp;                    protected final MethodRegistry.Handler handler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                     */
&nbsp;                    protected final MethodAttributeAppender.Factory methodAttributeAppenderFactory;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The transformer to apply onto the method that is currently being implemented.
&nbsp;                     */
&nbsp;                    protected final Transformer&lt;MethodDescription&gt; transformer;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new adapter for a method definition.
&nbsp;                     *
&nbsp;                     * @param handler                        The handler that determines how a method is implemented.
&nbsp;                     * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                     * @param transformer                    The transformer to apply onto the method that is currently being implemented.
&nbsp;                     */
&nbsp;                    protected Adapter(MethodRegistry.Handler handler,
&nbsp;                                      MethodAttributeAppender.Factory methodAttributeAppenderFactory,
<b class="fc">&nbsp;                                      Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                        this.handler = handler;</b>
<b class="fc">&nbsp;                        this.methodAttributeAppenderFactory = methodAttributeAppenderFactory;</b>
<b class="fc">&nbsp;                        this.transformer = transformer;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition&lt;V&gt; attribute(MethodAttributeAppender.Factory methodAttributeAppenderFactory) {
<b class="fc">&nbsp;                        return materialize(handler, new MethodAttributeAppender.Factory.Compound(this.methodAttributeAppenderFactory, methodAttributeAppenderFactory), transformer);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                    public MethodDefinition&lt;V&gt; transform(Transformer&lt;MethodDescription&gt; transformer) {
<b class="fc">&nbsp;                        return materialize(handler, methodAttributeAppenderFactory, new Transformer.Compound&lt;MethodDescription&gt;(this.transformer, transformer));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Materializes the current builder as a method definition.
&nbsp;                     *
&nbsp;                     * @param handler                        The handler that determines how a method is implemented.
&nbsp;                     * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                     * @param transformer                    The method transformer to apply onto the method that is currently being implemented.
&nbsp;                     * @return Returns a method definition for the supplied properties.
&nbsp;                     */
&nbsp;                    protected abstract MethodDefinition&lt;V&gt; materialize(MethodRegistry.Handler handler,
&nbsp;                                                                       MethodAttributeAppender.Factory methodAttributeAppenderFactory,
&nbsp;                                                                       Transformer&lt;MethodDescription&gt; transformer);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for a record component definition.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
&nbsp;        interface RecordComponentDefinition&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the record component with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare.
&nbsp;             * @return A new builder that is equal to this builder but where the defined component declares the supplied annotations.
&nbsp;             */
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(Annotation... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the record component with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare.
&nbsp;             * @return A new builder that is equal to this builder but where the defined component declares the supplied annotations.
&nbsp;             */
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(List&lt;? extends Annotation&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the record component with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotation The annotations to declare.
&nbsp;             * @return A new builder that is equal to this builder but where the defined component declares the supplied annotations.
&nbsp;             */
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(AnnotationDescription... annotation);
&nbsp;
&nbsp;            /**
&nbsp;             * Annotates the record component with the supplied annotations.
&nbsp;             *
&nbsp;             * @param annotations The annotations to declare.
&nbsp;             * @return A new builder that is equal to this builder but where the defined component declares the supplied annotations.
&nbsp;             */
&nbsp;            Optional&lt;S&gt; annotateRecordComponent(Collection&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the supplied record component attribute appender factory onto the previously defined record component.
&nbsp;             *
&nbsp;             * @param recordComponentAttributeAppenderFactory The record component attribute appender factory that should be applied on the
&nbsp;             *                                                previously defined or matched method.
&nbsp;             * @return A new builder that is equal to this builder but with the supplied record component attribute appender factory
&nbsp;             * applied to the previously defined record component.
&nbsp;             */
&nbsp;            Optional&lt;S&gt; attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms a record component description before writing.
&nbsp;             *
&nbsp;             * @param transformer The transformer to apply.
&nbsp;             * @return new builder that is equal to this builder but with the supplied transformer being applied.
&nbsp;             */
&nbsp;            Optional&lt;S&gt; transform(Transformer&lt;RecordComponentDescription&gt; transformer);
&nbsp;
&nbsp;            /**
&nbsp;             * A {@link RecordComponentDefinition} as an optional build step.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            interface Optional&lt;U&gt; extends RecordComponentDefinition&lt;U&gt;, Builder&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation of a record definition.
&nbsp;                 *
&nbsp;                 * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;                 */
<b class="fc">&nbsp;                abstract class AbstractBase&lt;U&gt; extends Builder.AbstractBase.Delegator&lt;U&gt; implements RecordComponentDefinition.Optional&lt;U&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(Annotation... annotation) {
<b class="nc">&nbsp;                        return annotateRecordComponent(Arrays.asList(annotation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                        return annotateRecordComponent(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                        return annotateRecordComponent(Arrays.asList(annotation));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a dynamic type builder.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase&lt;S&gt; implements Builder&lt;S&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InnerTypeDefinition.ForType&lt;S&gt; innerTypeOf(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return innerTypeOf(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InnerTypeDefinition&lt;S&gt; innerTypeOf(Method method) {
<b class="fc">&nbsp;                return innerTypeOf(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InnerTypeDefinition&lt;S&gt; innerTypeOf(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;                return innerTypeOf(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; declaredTypes(Class&lt;?&gt;... type) {
<b class="nc">&nbsp;                return declaredTypes(Arrays.asList(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; declaredTypes(TypeDescription... type) {
<b class="fc">&nbsp;                return declaredTypes(Arrays.asList(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; declaredTypes(List&lt;? extends Class&lt;?&gt;&gt; type) {
<b class="nc">&nbsp;                return declaredTypes(new TypeList.ForLoadedTypes(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; noNestMate() {
<b class="fc">&nbsp;                return nestHost(TargetType.DESCRIPTION);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; nestHost(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return nestHost(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; nestMembers(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;                return nestMembers(Arrays.asList(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; nestMembers(TypeDescription... type) {
<b class="fc">&nbsp;                return nestMembers(Arrays.asList(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; nestMembers(List&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                return nestMembers(new TypeList.ForLoadedTypes(types));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; permittedSubclass(Class&lt;?&gt;... type) {
<b class="nc">&nbsp;                return permittedSubclass(Arrays.asList(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; permittedSubclass(TypeDescription... type) {
<b class="fc">&nbsp;                return permittedSubclass(Arrays.asList(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; permittedSubclass(List&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="nc">&nbsp;                return permittedSubclass(new TypeList.ForLoadedTypes(types));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; annotateType(Annotation... annotation) {
<b class="fc">&nbsp;                return annotateType(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; annotateType(List&lt;? extends Annotation&gt; annotations) {
<b class="fc">&nbsp;                return annotateType(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; annotateType(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                return annotateType(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; modifiers(ModifierContributor.ForType... modifierContributor) {
<b class="fc">&nbsp;                return modifiers(Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; modifiers(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
<b class="fc">&nbsp;                return modifiers(ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; merge(ModifierContributor.ForType... modifierContributor) {
<b class="fc">&nbsp;                return merge(Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(Type... interfaceType) {
<b class="fc">&nbsp;                return implement(Arrays.asList(interfaceType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(List&lt;? extends Type&gt; interfaceTypes) {
<b class="fc">&nbsp;                return implement(new TypeList.Generic.ForLoadedTypes(interfaceTypes));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition.Optional&lt;S&gt; implement(TypeDefinition... interfaceType) {
<b class="fc">&nbsp;                return implement(Arrays.asList(interfaceType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol) {
<b class="fc">&nbsp;                return typeVariable(symbol, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, Type... bound) {
<b class="fc">&nbsp;                return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, List&lt;? extends Type&gt; bounds) {
<b class="fc">&nbsp;                return typeVariable(symbol, new TypeList.Generic.ForLoadedTypes(bounds));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableDefinition&lt;S&gt; typeVariable(String symbol, TypeDefinition... bound) {
<b class="fc">&nbsp;                return typeVariable(symbol, Arrays.asList(bound));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentDefinition.Optional&lt;S&gt; defineRecordComponent(String name, Type type) {
<b class="fc">&nbsp;                return defineRecordComponent(name, TypeDefinition.Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentDefinition.Optional&lt;S&gt; define(RecordComponentDescription recordComponentDescription) {
<b class="nc">&nbsp;                return defineRecordComponent(recordComponentDescription.getActualName(), recordComponentDescription.getType());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentDefinition&lt;S&gt; recordComponent(ElementMatcher&lt;? super RecordComponentDescription&gt; matcher) {
<b class="nc">&nbsp;                return recordComponent(new LatentMatcher.Resolved&lt;RecordComponentDescription&gt;(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, ModifierContributor.ForField... modifierContributor) {
<b class="fc">&nbsp;                return defineField(name, type, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineField(name, type, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, Type type, int modifiers) {
<b class="fc">&nbsp;                return defineField(name, TypeDefinition.Sort.describe(type), modifiers);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, TypeDefinition type, ModifierContributor.ForField... modifierContributor) {
<b class="fc">&nbsp;                return defineField(name, type, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; defineField(String name, TypeDefinition type, Collection&lt;? extends ModifierContributor.ForField&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineField(name, type, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; define(Field field) {
<b class="nc">&nbsp;                return define(new FieldDescription.ForLoadedField(field));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional.Valuable&lt;S&gt; define(FieldDescription field) {
<b class="nc">&nbsp;                return defineField(field.getName(), field.getType(), field.getModifiers());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional&lt;S&gt; serialVersionUid(long serialVersionUid) {
<b class="fc">&nbsp;                return defineField(&quot;serialVersionUID&quot;, long.class, Visibility.PRIVATE, FieldManifestation.FINAL, Ownership.STATIC).value(serialVersionUid);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Valuable&lt;S&gt; field(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;                return field(new LatentMatcher.Resolved&lt;FieldDescription&gt;(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;                return ignoreAlso(new LatentMatcher.Resolved&lt;MethodDescription&gt;(ignoredMethods));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, ModifierContributor.ForMethod... modifierContributor) {
<b class="fc">&nbsp;                return defineMethod(name, returnType, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineMethod(name, returnType, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, Type returnType, int modifiers) {
<b class="fc">&nbsp;                return defineMethod(name, TypeDefinition.Sort.describe(returnType), modifiers);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, TypeDefinition returnType, ModifierContributor.ForMethod... modifierContributor) {
<b class="fc">&nbsp;                return defineMethod(name, returnType, Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineMethod(String name, TypeDefinition returnType, Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineMethod(name, returnType, ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineConstructor(ModifierContributor.ForMethod... modifierContributor) {
<b class="fc">&nbsp;                return defineConstructor(Arrays.asList(modifierContributor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ParameterDefinition.Initial&lt;S&gt; defineConstructor(Collection&lt;? extends ModifierContributor.ForMethod&gt; modifierContributors) {
<b class="fc">&nbsp;                return defineConstructor(ModifierContributor.Resolver.of(modifierContributors).resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(Method method) {
<b class="nc">&nbsp;                return define(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;                return define(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; define(MethodDescription methodDescription) {
<b class="nc">&nbsp;                MethodDefinition.ParameterDefinition.Initial&lt;S&gt; initialParameterDefinition = methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                        ? defineConstructor(methodDescription.getModifiers())</b>
<b class="nc">&nbsp;                        : defineMethod(methodDescription.getInternalName(), methodDescription.getReturnType(), methodDescription.getModifiers());</b>
<b class="nc">&nbsp;                ParameterList&lt;?&gt; parameterList = methodDescription.getParameters();</b>
&nbsp;                MethodDefinition.ExceptionDefinition&lt;S&gt; exceptionDefinition;
<b class="nc">&nbsp;                if (parameterList.hasExplicitMetaData()) {</b>
<b class="nc">&nbsp;                    MethodDefinition.ParameterDefinition&lt;S&gt; parameterDefinition = initialParameterDefinition;</b>
<b class="nc">&nbsp;                    for (ParameterDescription parameter : parameterList) {</b>
<b class="nc">&nbsp;                        parameterDefinition = parameterDefinition.withParameter(parameter.getType(), parameter.getName(), parameter.getModifiers());</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    exceptionDefinition = parameterDefinition;</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    exceptionDefinition = initialParameterDefinition.withParameters(parameterList.asTypeList());</b>
&nbsp;                }
<b class="nc">&nbsp;                MethodDefinition.TypeVariableDefinition&lt;S&gt; typeVariableDefinition = exceptionDefinition.throwing(methodDescription.getExceptionTypes());</b>
<b class="nc">&nbsp;                for (TypeDescription.Generic typeVariable : methodDescription.getTypeVariables()) {</b>
<b class="nc">&nbsp;                    typeVariableDefinition = typeVariableDefinition.typeVariable(typeVariable.getSymbol(), typeVariable.getUpperBounds());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return typeVariableDefinition;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, Type type) {
<b class="fc">&nbsp;                return defineProperty(name, TypeDefinition.Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, Type type, boolean readOnly) {
<b class="fc">&nbsp;                return defineProperty(name, TypeDefinition.Sort.describe(type), readOnly);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, TypeDefinition type) {
<b class="fc">&nbsp;                return defineProperty(name, type, false);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDefinition.Optional&lt;S&gt; defineProperty(String name, TypeDefinition type, boolean readOnly) {
<b class="fc">&nbsp;                if (name.length() == 0) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;A bean property cannot have an empty name&quot;);</b>
<b class="fc">&nbsp;                } else if (type.represents(void.class)) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;A bean property cannot have a void type&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                DynamicType.Builder&lt;S&gt; builder = this;</b>
&nbsp;                FieldManifestation fieldManifestation;
<b class="fc">&nbsp;                if (!readOnly) {</b>
<b class="fc">&nbsp;                    builder = builder</b>
<b class="fc">&nbsp;                            .defineMethod(&quot;set&quot; + Character.toUpperCase(name.charAt(0)) + name.substring(1), void.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                            .withParameters(type)</b>
<b class="fc">&nbsp;                            .intercept(FieldAccessor.ofField(name));</b>
<b class="fc">&nbsp;                    fieldManifestation = FieldManifestation.PLAIN;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    fieldManifestation = FieldManifestation.FINAL;</b>
&nbsp;                }
<b class="fc">&nbsp;                return builder</b>
<b class="fc">&nbsp;                        .defineMethod((type.represents(boolean.class)</b>
<b class="fc">&nbsp;                                ? &quot;is&quot;</b>
<b class="fc">&nbsp;                                : &quot;get&quot;) + Character.toUpperCase(name.charAt(0)) + name.substring(1), type, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                        .intercept(FieldAccessor.ofField(name))</b>
<b class="fc">&nbsp;                        .defineField(name, type, Visibility.PRIVATE, fieldManifestation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; method(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                return invokable(isMethod().and(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; constructor(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                return invokable(isConstructor().and(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDefinition.ImplementationDefinition&lt;S&gt; invokable(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                return invokable(new LatentMatcher.Resolved&lt;MethodDescription&gt;(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; withHashCodeEquals() {
<b class="fc">&nbsp;                return method(isHashCode())</b>
<b class="fc">&nbsp;                        .intercept(HashCodeMethod.usingDefaultOffset().withIgnoredFields(isSynthetic()))</b>
<b class="fc">&nbsp;                        .method(isEquals())</b>
<b class="fc">&nbsp;                        .intercept(EqualsMethod.isolated().withIgnoredFields(isSynthetic()));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; withToString() {
<b class="fc">&nbsp;                return method(isToString()).intercept(ToStringMethod.prefixedBySimpleClassName());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; require(TypeDescription type, byte[] binaryRepresentation) {
<b class="fc">&nbsp;                return require(type, binaryRepresentation, LoadedTypeInitializer.NoOp.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; require(TypeDescription type, byte[] binaryRepresentation, LoadedTypeInitializer typeInitializer) {
<b class="fc">&nbsp;                return require(new Default(type, binaryRepresentation, typeInitializer, Collections.&lt;DynamicType&gt;emptyList()));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Builder&lt;S&gt; require(DynamicType... auxiliaryType) {
<b class="fc">&nbsp;                return require(Arrays.asList(auxiliaryType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ContextClassVisitor wrap(ClassVisitor classVisitor) {
<b class="fc">&nbsp;                return wrap(classVisitor, AsmVisitorWrapper.NO_FLAGS, AsmVisitorWrapper.NO_FLAGS);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool) {
<b class="nc">&nbsp;                return wrap(classVisitor, typePool, AsmVisitorWrapper.NO_FLAGS, AsmVisitorWrapper.NO_FLAGS);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Unloaded&lt;S&gt; make(TypePool typePool) {
<b class="fc">&nbsp;                return make(TypeResolutionStrategy.Passive.INSTANCE, typePool);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Unloaded&lt;S&gt; make() {
<b class="fc">&nbsp;                return make(TypeResolutionStrategy.Passive.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A delegator for a dynamic type builder delegating all invocations to another dynamic type builder.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class Delegator&lt;U&gt; extends AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; visit(AsmVisitorWrapper asmVisitorWrapper) {
<b class="fc">&nbsp;                    return materialize().visit(asmVisitorWrapper);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; initializer(LoadedTypeInitializer loadedTypeInitializer) {
<b class="fc">&nbsp;                    return materialize().initializer(loadedTypeInitializer);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                    return materialize().annotateType(annotations);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; attribute(TypeAttributeAppender typeAttributeAppender) {
<b class="nc">&nbsp;                    return materialize().attribute(typeAttributeAppender);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; modifiers(int modifiers) {
<b class="fc">&nbsp;                    return materialize().modifiers(modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
<b class="nc">&nbsp;                    return materialize().merge(modifierContributors);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; suffix(String suffix) {
<b class="nc">&nbsp;                    return materialize().suffix(suffix);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; name(String name) {
<b class="nc">&nbsp;                    return materialize().name(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; topLevelType() {
<b class="nc">&nbsp;                    return materialize().topLevelType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InnerTypeDefinition.ForType&lt;U&gt; innerTypeOf(TypeDescription type) {
<b class="nc">&nbsp;                    return materialize().innerTypeOf(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InnerTypeDefinition&lt;U&gt; innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
<b class="nc">&nbsp;                    return materialize().innerTypeOf(methodDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; declaredTypes(Collection&lt;? extends TypeDescription&gt; types) {
<b class="fc">&nbsp;                    return materialize().declaredTypes(types);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; nestHost(TypeDescription type) {
<b class="nc">&nbsp;                    return materialize().nestHost(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; nestMembers(Collection&lt;? extends TypeDescription&gt; types) {
<b class="nc">&nbsp;                    return materialize().nestMembers(types);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; permittedSubclass(Collection&lt;? extends TypeDescription&gt; types) {
<b class="nc">&nbsp;                    return materialize().permittedSubclass(types);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; unsealed() {
<b class="nc">&nbsp;                    return materialize().unsealed();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
<b class="fc">&nbsp;                    return materialize().implement(interfaceTypes);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; initializer(ByteCodeAppender byteCodeAppender) {
<b class="fc">&nbsp;                    return materialize().initializer(byteCodeAppender);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; ignoreAlso(ElementMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;                    return materialize().ignoreAlso(ignoredMethods);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="nc">&nbsp;                    return materialize().ignoreAlso(ignoredMethods);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableDefinition&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="fc">&nbsp;                    return materialize().typeVariable(symbol, bounds);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
<b class="fc">&nbsp;                    return materialize().transform(matcher, transformer);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDefinition.Optional.Valuable&lt;U&gt; defineField(String name, TypeDefinition type, int modifiers) {
<b class="fc">&nbsp;                    return materialize().defineField(name, type, modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDefinition.Valuable&lt;U&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;                    return materialize().field(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineMethod(String name, TypeDefinition returnType, int modifiers) {
<b class="fc">&nbsp;                    return materialize().defineMethod(name, returnType, modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineConstructor(int modifiers) {
<b class="fc">&nbsp;                    return materialize().defineConstructor(modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ImplementationDefinition&lt;U&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                    return materialize().invokable(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; require(Collection&lt;DynamicType&gt; auxiliaryTypes) {
<b class="nc">&nbsp;                    return materialize().require(auxiliaryTypes);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDefinition.Optional&lt;U&gt; defineRecordComponent(String name, TypeDefinition type) {
<b class="fc">&nbsp;                    return materialize().defineRecordComponent(name, type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDefinition.Optional&lt;U&gt; define(RecordComponentDescription recordComponentDescription) {
<b class="nc">&nbsp;                    return materialize().define(recordComponentDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDefinition&lt;U&gt; recordComponent(ElementMatcher&lt;? super RecordComponentDescription&gt; matcher) {
<b class="nc">&nbsp;                    return materialize().recordComponent(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDefinition&lt;U&gt; recordComponent(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher) {
<b class="nc">&nbsp;                    return materialize().recordComponent(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
<b class="fc">&nbsp;                    return materialize().wrap(classVisitor, writerFlags, readerFlags);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
<b class="nc">&nbsp;                    return materialize().wrap(classVisitor, typePool, writerFlags, readerFlags);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Unloaded&lt;U&gt; make() {
<b class="fc">&nbsp;                    return materialize().make();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy) {
<b class="fc">&nbsp;                    return materialize().make(typeResolutionStrategy);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Unloaded&lt;U&gt; make(TypePool typePool) {
<b class="nc">&nbsp;                    return materialize().make(typePool);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
<b class="fc">&nbsp;                    return materialize().make(typeResolutionStrategy, typePool);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription toTypeDescription() {
<b class="fc">&nbsp;                    return materialize().toTypeDescription();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new builder that realizes the current state of the builder.
&nbsp;                 *
&nbsp;                 * @return A new builder that realizes the current state of the builder.
&nbsp;                 */
&nbsp;                protected abstract Builder&lt;U&gt; materialize();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dynamic type writer that uses a {@link TypeWriter} to create a dynamic type.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class UsingTypeWriter&lt;U&gt; extends AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
<b class="fc">&nbsp;                    return toTypeWriter().wrap(classVisitor, writerFlags, readerFlags);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ContextClassVisitor wrap(ClassVisitor classVisitor, TypePool typePool, int writerFlags, int readerFlags) {
<b class="nc">&nbsp;                    return toTypeWriter(typePool).wrap(classVisitor, writerFlags, readerFlags);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy) {
<b class="fc">&nbsp;                    return toTypeWriter().make(typeResolutionStrategy.resolve());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Unloaded&lt;U&gt; make(TypeResolutionStrategy typeResolutionStrategy, TypePool typePool) {
<b class="fc">&nbsp;                    return toTypeWriter(typePool).make(typeResolutionStrategy.resolve());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a {@link TypeWriter} without an explicitly specified {@link TypePool}.
&nbsp;                 *
&nbsp;                 * @return An appropriate {@link TypeWriter}.
&nbsp;                 */
&nbsp;                protected abstract TypeWriter&lt;U&gt; toTypeWriter();
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a {@link TypeWriter} given the specified {@link TypePool}.
&nbsp;                 *
&nbsp;                 * @param typePool The {@link TypePool} to use.
&nbsp;                 * @return An appropriate {@link TypeWriter}.
&nbsp;                 */
&nbsp;                protected abstract TypeWriter&lt;U&gt; toTypeWriter(TypePool typePool);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An adapter implementation of a dynamic type builder.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; A loaded type that the built type is guaranteed to be a subclass of.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public abstract static class Adapter&lt;U&gt; extends UsingTypeWriter&lt;U&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type to be created.
&nbsp;                 */
&nbsp;                protected final InstrumentedType.WithFlexibleName instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The current field registry.
&nbsp;                 */
&nbsp;                protected final FieldRegistry fieldRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * The current method registry.
&nbsp;                 */
&nbsp;                protected final MethodRegistry methodRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * The current record component registry.
&nbsp;                 */
&nbsp;                protected final RecordComponentRegistry recordComponentRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type attribute appender to apply onto the instrumented type.
&nbsp;                 */
&nbsp;                protected final TypeAttributeAppender typeAttributeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 */
&nbsp;                protected final AsmVisitorWrapper asmVisitorWrapper;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file version to define auxiliary types in.
&nbsp;                 */
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                /**
&nbsp;                 * The naming strategy for auxiliary types to apply.
&nbsp;                 */
&nbsp;                protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation value filter factory to apply.
&nbsp;                 */
&nbsp;                protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation retention to apply.
&nbsp;                 */
&nbsp;                protected final AnnotationRetention annotationRetention;
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation context factory to apply.
&nbsp;                 */
&nbsp;                protected final Implementation.Context.Factory implementationContextFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method graph compiler to use.
&nbsp;                 */
&nbsp;                protected final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines if a type should be explicitly validated.
&nbsp;                 */
&nbsp;                protected final TypeValidation typeValidation;
&nbsp;
&nbsp;                /**
&nbsp;                 * The visibility bridge strategy to apply.
&nbsp;                 */
&nbsp;                protected final VisibilityBridgeStrategy visibilityBridgeStrategy;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class writer strategy to use.
&nbsp;                 */
&nbsp;                protected final ClassWriterStrategy classWriterStrategy;
&nbsp;
&nbsp;                /**
&nbsp;                 * A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;                 */
&nbsp;                protected final LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of explicitly defined auxiliary types.
&nbsp;                 */
&nbsp;                protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new default type writer for creating a new type that is not based on an existing class file.
&nbsp;                 *
&nbsp;                 * @param instrumentedType             The instrumented type to be created.
&nbsp;                 * @param fieldRegistry                The current field registry.
&nbsp;                 * @param methodRegistry               The current method registry.
&nbsp;                 * @param recordComponentRegistry      The record component pool to use.
&nbsp;                 * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;                 * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 * @param classFileVersion             The class file version to define auxiliary types in.
&nbsp;                 * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;                 * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;                 * @param annotationRetention          The annotation retention to apply.
&nbsp;                 * @param implementationContextFactory The implementation context factory to apply.
&nbsp;                 * @param methodGraphCompiler          The method graph compiler to use.
&nbsp;                 * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;                 * @param visibilityBridgeStrategy     The visibility bridge strategy to apply.
&nbsp;                 * @param classWriterStrategy          The class writer strategy to use.
&nbsp;                 * @param ignoredMethods               A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;                 * @param auxiliaryTypes               A list of explicitly defined auxiliary types.
&nbsp;                 */
&nbsp;                protected Adapter(InstrumentedType.WithFlexibleName instrumentedType,
&nbsp;                                  FieldRegistry fieldRegistry,
&nbsp;                                  MethodRegistry methodRegistry,
&nbsp;                                  RecordComponentRegistry recordComponentRegistry,
&nbsp;                                  TypeAttributeAppender typeAttributeAppender,
&nbsp;                                  AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                  ClassFileVersion classFileVersion,
&nbsp;                                  AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                  AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                  AnnotationRetention annotationRetention,
&nbsp;                                  Implementation.Context.Factory implementationContextFactory,
&nbsp;                                  MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                  TypeValidation typeValidation,
&nbsp;                                  VisibilityBridgeStrategy visibilityBridgeStrategy,
&nbsp;                                  ClassWriterStrategy classWriterStrategy,
&nbsp;                                  LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods,
<b class="fc">&nbsp;                                  List&lt;? extends DynamicType&gt; auxiliaryTypes) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.fieldRegistry = fieldRegistry;</b>
<b class="fc">&nbsp;                    this.methodRegistry = methodRegistry;</b>
<b class="fc">&nbsp;                    this.recordComponentRegistry = recordComponentRegistry;</b>
<b class="fc">&nbsp;                    this.typeAttributeAppender = typeAttributeAppender;</b>
<b class="fc">&nbsp;                    this.asmVisitorWrapper = asmVisitorWrapper;</b>
<b class="fc">&nbsp;                    this.classFileVersion = classFileVersion;</b>
<b class="fc">&nbsp;                    this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;</b>
<b class="fc">&nbsp;                    this.annotationValueFilterFactory = annotationValueFilterFactory;</b>
<b class="fc">&nbsp;                    this.annotationRetention = annotationRetention;</b>
<b class="fc">&nbsp;                    this.implementationContextFactory = implementationContextFactory;</b>
<b class="fc">&nbsp;                    this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;                    this.typeValidation = typeValidation;</b>
<b class="fc">&nbsp;                    this.visibilityBridgeStrategy = visibilityBridgeStrategy;</b>
<b class="fc">&nbsp;                    this.classWriterStrategy = classWriterStrategy;</b>
<b class="fc">&nbsp;                    this.ignoredMethods = ignoredMethods;</b>
<b class="fc">&nbsp;                    this.auxiliaryTypes = auxiliaryTypes;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDefinition.Optional.Valuable&lt;U&gt; defineField(String name, TypeDefinition type, int modifiers) {
<b class="fc">&nbsp;                    return new FieldDefinitionAdapter(new FieldDescription.Token(name, modifiers, type.asGenericType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDefinition.Valuable&lt;U&gt; field(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;                    return new FieldMatchAdapter(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineMethod(String name, TypeDefinition returnType, int modifiers) {
<b class="fc">&nbsp;                    return new MethodDefinitionAdapter(new MethodDescription.Token(name, modifiers, returnType.asGenericType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ParameterDefinition.Initial&lt;U&gt; defineConstructor(int modifiers) {
<b class="fc">&nbsp;                    return new MethodDefinitionAdapter(new MethodDescription.Token(modifiers));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ImplementationDefinition&lt;U&gt; invokable(LatentMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                    return new MethodMatchAdapter(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; implement(Collection&lt;? extends TypeDefinition&gt; interfaceTypes) {
<b class="fc">&nbsp;                    return new OptionalMethodMatchAdapter(new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(interfaceTypes)));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                public Builder&lt;U&gt; ignoreAlso(LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            new LatentMatcher.Disjunction&lt;MethodDescription&gt;(this.ignoredMethods, ignoredMethods),
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDefinition.Optional&lt;U&gt; defineRecordComponent(String name, TypeDefinition type) {
<b class="fc">&nbsp;                    return new RecordComponentDefinitionAdapter(new RecordComponentDescription.Token(name, type.asGenericType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDefinition&lt;U&gt; recordComponent(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher) {
<b class="nc">&nbsp;                    return new RecordComponentMatchAdapter(matcher);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; initializer(ByteCodeAppender byteCodeAppender) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withInitializer(byteCodeAppender),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; initializer(LoadedTypeInitializer loadedTypeInitializer) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withInitializer(loadedTypeInitializer),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; name(String name) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withName(name),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; suffix(String suffix) {
<b class="nc">&nbsp;                    return name(instrumentedType.getName() + &quot;$&quot; + suffix);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; modifiers(int modifiers) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withModifiers(modifiers),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; merge(Collection&lt;? extends ModifierContributor.ForType&gt; modifierContributors) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withModifiers(ModifierContributor.Resolver.of(modifierContributors).resolve(instrumentedType.getModifiers())),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; topLevelType() {
<b class="fc">&nbsp;                    return Adapter.this.materialize(instrumentedType</b>
<b class="fc">&nbsp;                                    .withDeclaringType(TypeDescription.UNDEFINED)</b>
<b class="fc">&nbsp;                                    .withEnclosingType(TypeDescription.UNDEFINED)</b>
<b class="fc">&nbsp;                                    .withLocalClass(false),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InnerTypeDefinition.ForType&lt;U&gt; innerTypeOf(TypeDescription type) {
<b class="fc">&nbsp;                    return new InnerTypeDefinitionForTypeAdapter(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InnerTypeDefinition&lt;U&gt; innerTypeOf(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                    return methodDescription.isTypeInitializer()</b>
<b class="fc">&nbsp;                            ? new InnerTypeDefinitionForTypeAdapter(methodDescription.getDeclaringType())</b>
<b class="fc">&nbsp;                            : new InnerTypeDefinitionForMethodAdapter(methodDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; declaredTypes(Collection&lt;? extends TypeDescription&gt; types) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withDeclaredTypes(new TypeList.Explicit(new ArrayList&lt;TypeDescription&gt;(types))),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; nestHost(TypeDescription type) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withNestHost(type),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; nestMembers(Collection&lt;? extends TypeDescription&gt; types) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withNestMembers(new TypeList.Explicit(new ArrayList&lt;TypeDescription&gt;(types))),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; permittedSubclass(Collection&lt;? extends TypeDescription&gt; types) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withPermittedSubclasses(new TypeList.Explicit(new ArrayList&lt;TypeDescription&gt;(types))),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; unsealed() {
<b class="nc">&nbsp;                    return materialize(instrumentedType.withPermittedSubclasses(TypeList.UNDEFINED),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableDefinition&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="fc">&nbsp;                    return new TypeVariableDefinitionAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(bounds))));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; transform(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher, Transformer&lt;TypeVariableToken&gt; transformer) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withTypeVariables(matcher, transformer),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; attribute(TypeAttributeAppender typeAttributeAppender) {
<b class="fc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            new TypeAttributeAppender.Compound(this.typeAttributeAppender, typeAttributeAppender),
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; annotateType(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return materialize(instrumentedType.withAnnotations(new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; visit(AsmVisitorWrapper asmVisitorWrapper) {
<b class="fc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            new AsmVisitorWrapper.Compound(this.asmVisitorWrapper, asmVisitorWrapper),
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
&nbsp;                            auxiliaryTypes);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder&lt;U&gt; require(Collection&lt;DynamicType&gt; auxiliaryTypes) {
<b class="fc">&nbsp;                    return materialize(instrumentedType,</b>
&nbsp;                            fieldRegistry,
&nbsp;                            methodRegistry,
&nbsp;                            recordComponentRegistry,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            implementationContextFactory,
&nbsp;                            methodGraphCompiler,
&nbsp;                            typeValidation,
&nbsp;                            visibilityBridgeStrategy,
&nbsp;                            classWriterStrategy,
&nbsp;                            ignoredMethods,
<b class="fc">&nbsp;                            CompoundList.of(this.auxiliaryTypes, new ArrayList&lt;DynamicType&gt;(auxiliaryTypes)));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription toTypeDescription() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Materializes the supplied state of a dynamic type builder.
&nbsp;                 *
&nbsp;                 * @param instrumentedType             The instrumented type.
&nbsp;                 * @param fieldRegistry                The current field registry.
&nbsp;                 * @param methodRegistry               The current method registry.
&nbsp;                 * @param recordComponentRegistry      The record component pool to use.
&nbsp;                 * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;                 * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 * @param classFileVersion             The class file version to define auxiliary types in.
&nbsp;                 * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;                 * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;                 * @param annotationRetention          The annotation retention to apply.
&nbsp;                 * @param implementationContextFactory The implementation context factory to apply.
&nbsp;                 * @param methodGraphCompiler          The method graph compiler to use.
&nbsp;                 * @param typeValidation               The type validation state.
&nbsp;                 * @param visibilityBridgeStrategy     The visibility bridge strategy to apply.
&nbsp;                 * @param classWriterStrategy          The class writer strategy to use.
&nbsp;                 * @param ignoredMethods               A matcher for identifying methods that should be excluded from instrumentation.
&nbsp;                 * @param auxiliaryTypes               A list of explicitly required auxiliary types.
&nbsp;                 * @return A type builder that represents the supplied arguments.
&nbsp;                 */
&nbsp;                protected abstract Builder&lt;U&gt; materialize(InstrumentedType.WithFlexibleName instrumentedType,
&nbsp;                                                          FieldRegistry fieldRegistry,
&nbsp;                                                          MethodRegistry methodRegistry,
&nbsp;                                                          RecordComponentRegistry recordComponentRegistry,
&nbsp;                                                          TypeAttributeAppender typeAttributeAppender,
&nbsp;                                                          AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                                          ClassFileVersion classFileVersion,
&nbsp;                                                          AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                          AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                          AnnotationRetention annotationRetention,
&nbsp;                                                          Implementation.Context.Factory implementationContextFactory,
&nbsp;                                                          MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                                          TypeValidation typeValidation,
&nbsp;                                                          VisibilityBridgeStrategy visibilityBridgeStrategy,
&nbsp;                                                          ClassWriterStrategy classWriterStrategy,
&nbsp;                                                          LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods,
&nbsp;                                                          List&lt;? extends DynamicType&gt; auxiliaryTypes);
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for applying an inner type definition for an outer type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class InnerTypeDefinitionForTypeAdapter extends Builder.AbstractBase.Delegator&lt;U&gt; implements InnerTypeDefinition.ForType&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the type that is the defined outer type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new adapter for an inner type definition for an outer type.
&nbsp;                     *
&nbsp;                     * @param typeDescription A description of the type that is the defined outer type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected InnerTypeDefinitionForTypeAdapter(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Builder&lt;U&gt; asAnonymousType() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType</b>
<b class="fc">&nbsp;                                        .withDeclaringType(TypeDescription.UNDEFINED)</b>
<b class="fc">&nbsp;                                        .withEnclosingType(typeDescription)</b>
<b class="fc">&nbsp;                                        .withAnonymousClass(true),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Builder&lt;U&gt; asMemberType() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType</b>
<b class="fc">&nbsp;                                        .withDeclaringType(typeDescription)</b>
<b class="fc">&nbsp;                                        .withEnclosingType(typeDescription)</b>
<b class="fc">&nbsp;                                        .withAnonymousClass(false)</b>
<b class="fc">&nbsp;                                        .withLocalClass(false),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType</b>
<b class="fc">&nbsp;                                        .withDeclaringType(TypeDescription.UNDEFINED)</b>
<b class="fc">&nbsp;                                        .withEnclosingType(typeDescription)</b>
<b class="fc">&nbsp;                                        .withLocalClass(true),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for applying an inner type definition for an outer method or constructor.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class InnerTypeDefinitionForMethodAdapter extends Builder.AbstractBase.Delegator&lt;U&gt; implements InnerTypeDefinition&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the declaring method or constructor.
&nbsp;                     */
&nbsp;                    private final MethodDescription.InDefinedShape methodDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new adapter for defining a type that is declared within a method or constructor.
&nbsp;                     *
&nbsp;                     * @param methodDescription A description of the declaring method or constructor.
&nbsp;                     */
<b class="fc">&nbsp;                    protected InnerTypeDefinitionForMethodAdapter(MethodDescription.InDefinedShape methodDescription) {</b>
<b class="fc">&nbsp;                        this.methodDescription = methodDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Builder&lt;U&gt; asAnonymousType() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType</b>
<b class="fc">&nbsp;                                        .withDeclaringType(TypeDescription.UNDEFINED)</b>
<b class="fc">&nbsp;                                        .withEnclosingMethod(methodDescription)</b>
<b class="fc">&nbsp;                                        .withAnonymousClass(true),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType</b>
<b class="fc">&nbsp;                                        .withDeclaringType(TypeDescription.UNDEFINED)</b>
<b class="fc">&nbsp;                                        .withEnclosingMethod(methodDescription)</b>
<b class="fc">&nbsp;                                        .withLocalClass(true),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a new type variable for the instrumented type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class TypeVariableDefinitionAdapter extends TypeVariableDefinition.AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The current definition of the type variable.
&nbsp;                     */
&nbsp;                    private final TypeVariableToken token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type variable definition adapter.
&nbsp;                     *
&nbsp;                     * @param token The current definition of the type variable.
&nbsp;                     */
<b class="fc">&nbsp;                    protected TypeVariableDefinitionAdapter(TypeVariableToken token) {</b>
<b class="fc">&nbsp;                        this.token = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeVariableDefinition&lt;U&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                        return new TypeVariableDefinitionAdapter(new TypeVariableToken(token.getSymbol(),</b>
<b class="fc">&nbsp;                                token.getBounds(),</b>
<b class="fc">&nbsp;                                CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType.withTypeVariable(token),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a new field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class FieldDefinitionAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The token representing the current field definition.
&nbsp;                     */
&nbsp;                    private final FieldDescription.Token token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field definition adapter.
&nbsp;                     *
&nbsp;                     * @param token The token representing the current field definition.
&nbsp;                     */
&nbsp;                    protected FieldDefinitionAdapter(FieldDescription.Token token) {
<b class="fc">&nbsp;                        this(FieldAttributeAppender.ForInstrumentedField.INSTANCE,</b>
<b class="fc">&nbsp;                                Transformer.NoOp.&lt;FieldDescription&gt;make(),</b>
&nbsp;                                FieldDescription.NO_DEFAULT_VALUE,
&nbsp;                                token);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field definition adapter.
&nbsp;                     *
&nbsp;                     * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                     * @param transformer                   The field transformer to apply.
&nbsp;                     * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                     * @param token                         The token representing the current field definition.
&nbsp;                     */
&nbsp;                    protected FieldDefinitionAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                     Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                     @MaybeNull Object defaultValue,
<b class="fc">&nbsp;                                                     FieldDescription.Token token) {</b>
<b class="fc">&nbsp;                        super(fieldAttributeAppenderFactory, transformer, defaultValue);</b>
<b class="fc">&nbsp;                        this.token = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                        return new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, new FieldDescription.Token(token.getName(),</b>
<b class="fc">&nbsp;                                token.getModifiers(),</b>
<b class="fc">&nbsp;                                token.getType(),</b>
<b class="fc">&nbsp;                                CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withField(token),</b>
<b class="fc">&nbsp;                                fieldRegistry.prepend(new LatentMatcher.ForFieldToken(token), fieldAttributeAppenderFactory, defaultValue, transformer),</b>
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Optional&lt;U&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                      Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                      @MaybeNull Object defaultValue) {
<b class="fc">&nbsp;                        return new FieldDefinitionAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, token);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for matching an existing field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class FieldMatchAdapter extends FieldDefinition.Optional.Valuable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The matcher for any fields to apply this matcher to.
&nbsp;                     */
&nbsp;                    private final LatentMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field match adapter.
&nbsp;                     *
&nbsp;                     * @param matcher The matcher for any fields to apply this matcher to.
&nbsp;                     */
&nbsp;                    protected FieldMatchAdapter(LatentMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;                        this(FieldAttributeAppender.NoOp.INSTANCE,</b>
<b class="fc">&nbsp;                                Transformer.NoOp.&lt;FieldDescription&gt;make(),</b>
&nbsp;                                FieldDescription.NO_DEFAULT_VALUE,
&nbsp;                                matcher);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field match adapter.
&nbsp;                     *
&nbsp;                     * @param fieldAttributeAppenderFactory The field attribute appender factory to apply.
&nbsp;                     * @param transformer                   The field transformer to apply.
&nbsp;                     * @param defaultValue                  The field&#39;s default value or {@code null} if no value is to be defined.
&nbsp;                     * @param matcher                       The matcher for any fields to apply this matcher to.
&nbsp;                     */
&nbsp;                    protected FieldMatchAdapter(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                @MaybeNull Object defaultValue,
<b class="fc">&nbsp;                                                LatentMatcher&lt;? super FieldDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                        super(fieldAttributeAppenderFactory, transformer, defaultValue);</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateField(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                        return attribute(new FieldAttributeAppender.Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType,</b>
<b class="fc">&nbsp;                                fieldRegistry.prepend(matcher, fieldAttributeAppenderFactory, defaultValue, transformer),</b>
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Optional&lt;U&gt; materialize(FieldAttributeAppender.Factory fieldAttributeAppenderFactory,
&nbsp;                                                      Transformer&lt;FieldDescription&gt; transformer,
&nbsp;                                                      @MaybeNull Object defaultValue) {
<b class="fc">&nbsp;                        return new FieldMatchAdapter(fieldAttributeAppenderFactory, transformer, defaultValue, matcher);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a new method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                protected class MethodDefinitionAdapter extends MethodDefinition.ParameterDefinition.Initial.AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token representing the currently defined method.
&nbsp;                     */
&nbsp;                    private final MethodDescription.Token token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new method definition adapter.
&nbsp;                     *
&nbsp;                     * @param token A token representing the currently defined method.
&nbsp;                     */
<b class="fc">&nbsp;                    protected MethodDefinitionAdapter(MethodDescription.Token token) {</b>
<b class="fc">&nbsp;                        this.token = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ParameterDefinition.Annotatable&lt;U&gt; withParameter(TypeDefinition type, String name, int modifiers) {
<b class="fc">&nbsp;                        return new ParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType(), name, modifiers));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Simple.Annotatable&lt;U&gt; withParameter(TypeDefinition type) {
<b class="fc">&nbsp;                        return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(type.asGenericType()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ExceptionDefinition&lt;U&gt; throwing(Collection&lt;? extends TypeDefinition&gt; types) {
<b class="fc">&nbsp;                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="fc">&nbsp;                                token.getModifiers(),</b>
<b class="fc">&nbsp;                                token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                token.getReturnType(),</b>
<b class="fc">&nbsp;                                token.getParameterTokens(),</b>
<b class="fc">&nbsp;                                CompoundList.of(token.getExceptionTypes(), new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(types))),</b>
<b class="fc">&nbsp;                                token.getAnnotations(),</b>
<b class="fc">&nbsp;                                token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                token.getReceiverType()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.TypeVariableDefinition.Annotatable&lt;U&gt; typeVariable(String symbol, Collection&lt;? extends TypeDefinition&gt; bounds) {
<b class="fc">&nbsp;                        return new TypeVariableAnnotationAdapter(new TypeVariableToken(symbol, new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(bounds))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                        return materialize(new MethodRegistry.Handler.ForImplementation(implementation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
<b class="fc">&nbsp;                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="fc">&nbsp;                                (token.getModifiers() &amp; Opcodes.ACC_NATIVE) == 0</b>
<b class="fc">&nbsp;                                        ? ModifierContributor.Resolver.of(MethodManifestation.ABSTRACT).resolve(token.getModifiers())</b>
<b class="nc">&nbsp;                                        : token.getModifiers(),</b>
<b class="fc">&nbsp;                                token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                token.getReturnType(),</b>
<b class="fc">&nbsp;                                token.getParameterTokens(),</b>
<b class="fc">&nbsp;                                token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                token.getAnnotations(),</b>
<b class="fc">&nbsp;                                token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                token.getReceiverType())).materialize(MethodRegistry.Handler.ForAbstractMethod.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;                        return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="fc">&nbsp;                                ModifierContributor.Resolver.of(MethodManifestation.ABSTRACT).resolve(token.getModifiers()),</b>
<b class="fc">&nbsp;                                token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                token.getReturnType(),</b>
<b class="fc">&nbsp;                                token.getParameterTokens(),</b>
<b class="fc">&nbsp;                                token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                token.getAnnotations(),</b>
&nbsp;                                annotationValue,
<b class="fc">&nbsp;                                token.getReceiverType())).materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Materializes the given handler as the implementation.
&nbsp;                     *
&nbsp;                     * @param handler The handler for implementing the method.
&nbsp;                     * @return A method definition for the given handler.
&nbsp;                     */
&nbsp;                    private MethodDefinition.ReceiverTypeDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                        return new AnnotationAdapter(handler);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An adapter for defining a new type variable for the currently defined method.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class TypeVariableAnnotationAdapter extends MethodDefinition.TypeVariableDefinition.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The currently defined type variable.
&nbsp;                         */
&nbsp;                        private final TypeVariableToken token;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type variable annotation adapter.
&nbsp;                         *
&nbsp;                         * @param token The currently defined type variable.
&nbsp;                         */
<b class="fc">&nbsp;                        protected TypeVariableAnnotationAdapter(TypeVariableToken token) {</b>
<b class="fc">&nbsp;                            this.token = token;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition.ParameterDefinition&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getModifiers(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(MethodDefinitionAdapter.this.token.getTypeVariableTokens(), token),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReturnType(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getParameterTokens(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getAnnotations(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReceiverType()));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Annotatable&lt;U&gt; annotateTypeVariable(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                            return new TypeVariableAnnotationAdapter(new TypeVariableToken(token.getSymbol(),</b>
<b class="fc">&nbsp;                                    token.getBounds(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for a parameter definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class ParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The token of the currently defined parameter.
&nbsp;                         */
&nbsp;                        private final ParameterDescription.Token token;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new parameter annotation adapter.
&nbsp;                         *
&nbsp;                         * @param token The token of the currently defined parameter.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ParameterAnnotationAdapter(ParameterDescription.Token token) {</b>
<b class="fc">&nbsp;                            this.token = token;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition.ParameterDefinition.Annotatable&lt;U&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            return new ParameterAnnotationAdapter(new ParameterDescription.Token(token.getType(),</b>
<b class="nc">&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="nc">&nbsp;                                    token.getName(),</b>
<b class="nc">&nbsp;                                    token.getModifiers()));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition.ParameterDefinition&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getModifiers(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReturnType(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), token),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getAnnotations(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReceiverType()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for a simple parameter definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class SimpleParameterAnnotationAdapter extends MethodDefinition.ParameterDefinition.Simple.Annotatable.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The token of the currently defined parameter.
&nbsp;                         */
&nbsp;                        private final ParameterDescription.Token token;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new simple parameter annotation adapter.
&nbsp;                         *
&nbsp;                         * @param token The token of the currently defined parameter.
&nbsp;                         */
<b class="fc">&nbsp;                        protected SimpleParameterAnnotationAdapter(ParameterDescription.Token token) {</b>
<b class="fc">&nbsp;                            this.token = token;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition.ParameterDefinition.Simple.Annotatable&lt;U&gt; annotateParameter(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                            return new SimpleParameterAnnotationAdapter(new ParameterDescription.Token(token.getType(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="fc">&nbsp;                                    token.getName(),</b>
<b class="fc">&nbsp;                                    token.getModifiers()));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition.ParameterDefinition.Simple&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(MethodDefinitionAdapter.this.token.getName(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getModifiers(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReturnType(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(MethodDefinitionAdapter.this.token.getParameterTokens(), token),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getAnnotations(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                    MethodDefinitionAdapter.this.token.getReceiverType()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for a method definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler The handler that determines how a method is implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                            this(handler,</b>
&nbsp;                                    MethodAttributeAppender.ForInstrumentedMethod.INCLUDING_RECEIVER,
<b class="fc">&nbsp;                                    Transformer.NoOp.&lt;MethodDescription&gt;make());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler                        The handler that determines how a method is implemented.
&nbsp;                         * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                         * @param transformer                    The method transformer to apply onto the method that is currently being implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler,
&nbsp;                                                    MethodAttributeAppender.Factory methodAttributeAppenderFactory,
<b class="fc">&nbsp;                                                    Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                            super(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType) {
<b class="fc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="fc">&nbsp;                                    token.getModifiers(),</b>
<b class="fc">&nbsp;                                    token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                    token.getReturnType(),</b>
<b class="fc">&nbsp;                                    token.getParameterTokens(),</b>
<b class="fc">&nbsp;                                    token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                    token.getAnnotations(),</b>
<b class="fc">&nbsp;                                    token.getDefaultValue(),</b>
&nbsp;                                    receiverType)).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition&lt;U&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="fc">&nbsp;                                    token.getModifiers(),</b>
<b class="fc">&nbsp;                                    token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                                    token.getReturnType(),</b>
<b class="fc">&nbsp;                                    token.getParameterTokens(),</b>
<b class="fc">&nbsp;                                    token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                                    CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="fc">&nbsp;                                    token.getDefaultValue(),</b>
<b class="fc">&nbsp;                                    token.getReceiverType())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition&lt;U&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            List&lt;ParameterDescription.Token&gt; parameterTokens = new ArrayList&lt;ParameterDescription.Token&gt;(token.getParameterTokens());</b>
<b class="nc">&nbsp;                            parameterTokens.set(index, new ParameterDescription.Token(token.getParameterTokens().get(index).getType(),</b>
<b class="nc">&nbsp;                                    CompoundList.of(token.getParameterTokens().get(index).getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations)),</b>
<b class="nc">&nbsp;                                    token.getParameterTokens().get(index).getName(),</b>
<b class="nc">&nbsp;                                    token.getParameterTokens().get(index).getModifiers()));</b>
<b class="nc">&nbsp;                            return new MethodDefinitionAdapter(new MethodDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                    token.getModifiers(),</b>
<b class="nc">&nbsp;                                    token.getTypeVariableTokens(),</b>
<b class="nc">&nbsp;                                    token.getReturnType(),</b>
&nbsp;                                    parameterTokens,
<b class="nc">&nbsp;                                    token.getExceptionTypes(),</b>
<b class="nc">&nbsp;                                    token.getAnnotations(),</b>
<b class="nc">&nbsp;                                    token.getDefaultValue(),</b>
<b class="nc">&nbsp;                                    token.getReceiverType())).new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler,
&nbsp;                                                                  MethodAttributeAppender.Factory methodAttributeAppenderFactory,
&nbsp;                                                                  Transformer&lt;MethodDescription&gt; transformer) {
<b class="nc">&nbsp;                            return new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withMethod(token),</b>
&nbsp;                                    fieldRegistry,
<b class="fc">&nbsp;                                    methodRegistry.prepend(new LatentMatcher.ForMethodToken(token),</b>
&nbsp;                                            handler,
&nbsp;                                            methodAttributeAppenderFactory,
&nbsp;                                            transformer),
&nbsp;                                    recordComponentRegistry,
&nbsp;                                    typeAttributeAppender,
&nbsp;                                    asmVisitorWrapper,
&nbsp;                                    classFileVersion,
&nbsp;                                    auxiliaryTypeNamingStrategy,
&nbsp;                                    annotationValueFilterFactory,
&nbsp;                                    annotationRetention,
&nbsp;                                    implementationContextFactory,
&nbsp;                                    methodGraphCompiler,
&nbsp;                                    typeValidation,
&nbsp;                                    visibilityBridgeStrategy,
&nbsp;                                    classWriterStrategy,
&nbsp;                                    ignoredMethods,
&nbsp;                                    auxiliaryTypes);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for matching an existing method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                protected class MethodMatchAdapter extends MethodDefinition.ImplementationDefinition.AbstractBase&lt;U&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method matcher of this adapter.
&nbsp;                     */
&nbsp;                    private final LatentMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new method match adapter.
&nbsp;                     *
&nbsp;                     * @param matcher The method matcher of this adapter.
&nbsp;                     */
<b class="fc">&nbsp;                    protected MethodMatchAdapter(LatentMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                        return materialize(new MethodRegistry.Handler.ForImplementation(implementation));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
<b class="fc">&nbsp;                        return materialize(MethodRegistry.Handler.ForAbstractMethod.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;                        return materialize(new MethodRegistry.Handler.ForAnnotationValue(annotationValue));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Materializes the method definition with the supplied handler.
&nbsp;                     *
&nbsp;                     * @param handler The handler that implements any method matched by this instances matcher.
&nbsp;                     * @return A method definition where any matched method is implemented by the supplied handler.
&nbsp;                     */
&nbsp;                    private MethodDefinition.ReceiverTypeDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                        return new AnnotationAdapter(handler);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation adapter for implementing annotations during a method definition.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class AnnotationAdapter extends MethodDefinition.AbstractBase.Adapter&lt;U&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler The handler that determines how a method is implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler) {
<b class="fc">&nbsp;                            this(handler, MethodAttributeAppender.NoOp.INSTANCE, Transformer.NoOp.&lt;MethodDescription&gt;make());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation adapter.
&nbsp;                         *
&nbsp;                         * @param handler                        The handler that determines how a method is implemented.
&nbsp;                         * @param methodAttributeAppenderFactory The method attribute appender factory to apply onto the method that is currently being implemented.
&nbsp;                         * @param transformer                    The method transformer to apply onto the method that is currently being implemented.
&nbsp;                         */
&nbsp;                        protected AnnotationAdapter(MethodRegistry.Handler handler,
&nbsp;                                                    MethodAttributeAppender.Factory methodAttributeAppenderFactory,
<b class="fc">&nbsp;                                                    Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                            super(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition&lt;U&gt; receiverType(TypeDescription.Generic receiverType) {
<b class="fc">&nbsp;                            return new AnnotationAdapter(handler,</b>
&nbsp;                                    new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.ForReceiverType(receiverType)),
&nbsp;                                    transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition&lt;U&gt; annotateMethod(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                            return new AnnotationAdapter(handler,</b>
&nbsp;                                    new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations))),
&nbsp;                                    transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public MethodDefinition&lt;U&gt; annotateParameter(int index, Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                            return new AnnotationAdapter(handler,</b>
&nbsp;                                    new MethodAttributeAppender.Factory.Compound(methodAttributeAppenderFactory, new MethodAttributeAppender.Explicit(index, new ArrayList&lt;AnnotationDescription&gt;(annotations))),
&nbsp;                                    transformer);
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected MethodDefinition&lt;U&gt; materialize(MethodRegistry.Handler handler,
&nbsp;                                                                  MethodAttributeAppender.Factory methodAttributeAppenderFactory,
&nbsp;                                                                  Transformer&lt;MethodDescription&gt; transformer) {
<b class="fc">&nbsp;                            return new AnnotationAdapter(handler, methodAttributeAppenderFactory, transformer);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                            return Builder.AbstractBase.Adapter.this.materialize(instrumentedType,</b>
&nbsp;                                    fieldRegistry,
<b class="fc">&nbsp;                                    methodRegistry.prepend(matcher, handler, methodAttributeAppenderFactory, transformer),</b>
&nbsp;                                    recordComponentRegistry,
&nbsp;                                    typeAttributeAppender,
&nbsp;                                    asmVisitorWrapper,
&nbsp;                                    classFileVersion,
&nbsp;                                    auxiliaryTypeNamingStrategy,
&nbsp;                                    annotationValueFilterFactory,
&nbsp;                                    annotationRetention,
&nbsp;                                    implementationContextFactory,
&nbsp;                                    methodGraphCompiler,
&nbsp;                                    typeValidation,
&nbsp;                                    visibilityBridgeStrategy,
&nbsp;                                    classWriterStrategy,
&nbsp;                                    ignoredMethods,
&nbsp;                                    auxiliaryTypes);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for optionally matching methods defined by declared interfaces.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class OptionalMethodMatchAdapter extends Builder.AbstractBase.Delegator&lt;U&gt; implements MethodDefinition.ImplementationDefinition.Optional&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The interfaces whose methods are optionally matched.
&nbsp;                     */
&nbsp;                    private final TypeList.Generic interfaces;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new optional method match adapter.
&nbsp;                     *
&nbsp;                     * @param interfaces The interfaces whose methods are optionally matched.
&nbsp;                     */
<b class="fc">&nbsp;                    protected OptionalMethodMatchAdapter(TypeList.Generic interfaces) {</b>
<b class="fc">&nbsp;                        this.interfaces = interfaces;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Adapter.this.materialize(instrumentedType.withInterfaces(interfaces),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
&nbsp;                                recordComponentRegistry,
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; intercept(Implementation implementation) {
<b class="fc">&nbsp;                        return interfaceType().intercept(implementation);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; withoutCode() {
<b class="nc">&nbsp;                        return interfaceType().withoutCode();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="nc">&nbsp;                        return interfaceType().defaultValue(annotationValue);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public &lt;V&gt; MethodDefinition.ReceiverTypeDefinition&lt;U&gt; defaultValue(V value, Class&lt;? extends V&gt; type) {
<b class="nc">&nbsp;                        return interfaceType().defaultValue(value, type);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a matcher for the interfaces&#39; methods.
&nbsp;                     *
&nbsp;                     * @return A matcher for the interfaces&#39; methods.
&nbsp;                     */
&nbsp;                    private MethodDefinition.ImplementationDefinition&lt;U&gt; interfaceType() {
<b class="fc">&nbsp;                        ElementMatcher.Junction&lt;TypeDescription&gt; elementMatcher = none();</b>
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : interfaces.asErasures()) {</b>
<b class="fc">&nbsp;                            elementMatcher = elementMatcher.or(isSuperTypeOf(typeDescription));</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return materialize().invokable(isDeclaredBy(isInterface().and(elementMatcher)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for defining a record component.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class RecordComponentDefinitionAdapter extends RecordComponentDefinition.Optional.AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The record component attribute appender factory to apply.
&nbsp;                     */
&nbsp;                    private final RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token representing the defined record component.
&nbsp;                     */
&nbsp;                    private final RecordComponentDescription.Token token;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A transformer to apply on matched record component descriptions.
&nbsp;                     */
&nbsp;                    private final Transformer&lt;RecordComponentDescription&gt; transformer;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new record component definition adapter.
&nbsp;                     *
&nbsp;                     * @param token A token representing the defined record component.
&nbsp;                     */
&nbsp;                    protected RecordComponentDefinitionAdapter(RecordComponentDescription.Token token) {
<b class="fc">&nbsp;                        this(RecordComponentAttributeAppender.ForInstrumentedRecordComponent.INSTANCE,</b>
<b class="fc">&nbsp;                                Transformer.NoOp.&lt;RecordComponentDescription&gt;make(),</b>
&nbsp;                                token);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new record component definition adapter.
&nbsp;                     *
&nbsp;                     * @param recordComponentAttributeAppenderFactory The record component attribute appender factory to apply.
&nbsp;                     * @param transformer                             A transformer to apply on matched record component descriptions.
&nbsp;                     * @param token                                   A token representing the defined record component.
&nbsp;                     */
&nbsp;                    protected RecordComponentDefinitionAdapter(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory,
&nbsp;                                                               Transformer&lt;RecordComponentDescription&gt; transformer,
<b class="fc">&nbsp;                                                               RecordComponentDescription.Token token) {</b>
<b class="fc">&nbsp;                        this.recordComponentAttributeAppenderFactory = recordComponentAttributeAppenderFactory;</b>
<b class="fc">&nbsp;                        this.transformer = transformer;</b>
<b class="fc">&nbsp;                        this.token = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                        return new RecordComponentDefinitionAdapter(recordComponentAttributeAppenderFactory, transformer, new RecordComponentDescription.Token(token.getName(),</b>
<b class="nc">&nbsp;                                token.getType(),</b>
<b class="nc">&nbsp;                                CompoundList.of(token.getAnnotations(), new ArrayList&lt;AnnotationDescription&gt;(annotations))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory) {
<b class="nc">&nbsp;                        return new RecordComponentDefinitionAdapter(new RecordComponentAttributeAppender.Factory.Compound(this.recordComponentAttributeAppenderFactory,</b>
&nbsp;                                recordComponentAttributeAppenderFactory), transformer, token);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                    public Optional&lt;U&gt; transform(Transformer&lt;RecordComponentDescription&gt; transformer) {
<b class="nc">&nbsp;                        return new RecordComponentDefinitionAdapter(recordComponentAttributeAppenderFactory,</b>
&nbsp;                                new Transformer.Compound&lt;RecordComponentDescription&gt;(this.transformer, transformer),
&nbsp;                                token);
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="fc">&nbsp;                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType.withRecordComponent(token),</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
<b class="fc">&nbsp;                                recordComponentRegistry.prepend(new LatentMatcher.ForRecordComponentToken(token),</b>
&nbsp;                                        recordComponentAttributeAppenderFactory,
&nbsp;                                        transformer),
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An adapter for matching record components.
&nbsp;                 */
&nbsp;                protected class RecordComponentMatchAdapter extends RecordComponentDefinition.Optional.AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The matcher for identifying record components to match.
&nbsp;                     */
&nbsp;                    private final LatentMatcher&lt;? super RecordComponentDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The record component attribute appender factory to apply.
&nbsp;                     */
&nbsp;                    private final RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A transformer to apply on matched record component descriptions.
&nbsp;                     */
&nbsp;                    private final Transformer&lt;RecordComponentDescription&gt; transformer;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new record component match adapter.
&nbsp;                     *
&nbsp;                     * @param matcher The matcher for identifying record components to match.
&nbsp;                     */
&nbsp;                    protected RecordComponentMatchAdapter(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher) {
<b class="nc">&nbsp;                        this(matcher, RecordComponentAttributeAppender.NoOp.INSTANCE, Transformer.NoOp.&lt;RecordComponentDescription&gt;make());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new record component match adapter.
&nbsp;                     *
&nbsp;                     * @param matcher                                 The matcher for identifying record components to match.
&nbsp;                     * @param recordComponentAttributeAppenderFactory The record component attribute appender factory to apply.
&nbsp;                     * @param transformer                             A transformer to apply on matched record component descriptions.
&nbsp;                     */
&nbsp;                    protected RecordComponentMatchAdapter(LatentMatcher&lt;? super RecordComponentDescription&gt; matcher,
&nbsp;                                                          RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory,
<b class="nc">&nbsp;                                                          Transformer&lt;RecordComponentDescription&gt; transformer) {</b>
<b class="nc">&nbsp;                        this.matcher = matcher;</b>
<b class="nc">&nbsp;                        this.recordComponentAttributeAppenderFactory = recordComponentAttributeAppenderFactory;</b>
<b class="nc">&nbsp;                        this.transformer = transformer;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; annotateRecordComponent(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="nc">&nbsp;                        return attribute(new RecordComponentAttributeAppender.Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Optional&lt;U&gt; attribute(RecordComponentAttributeAppender.Factory recordComponentAttributeAppenderFactory) {
<b class="nc">&nbsp;                        return new RecordComponentMatchAdapter(matcher, new RecordComponentAttributeAppender.Factory.Compound(this.recordComponentAttributeAppenderFactory,</b>
&nbsp;                                recordComponentAttributeAppenderFactory), transformer);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)  // In absence of @SafeVarargs
&nbsp;                    public Optional&lt;U&gt; transform(Transformer&lt;RecordComponentDescription&gt; transformer) {
<b class="nc">&nbsp;                        return new RecordComponentMatchAdapter(matcher,</b>
&nbsp;                                recordComponentAttributeAppenderFactory,
&nbsp;                                new Transformer.Compound&lt;RecordComponentDescription&gt;(this.transformer, transformer));
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Builder&lt;U&gt; materialize() {
<b class="nc">&nbsp;                        return Builder.AbstractBase.Adapter.this.materialize(instrumentedType,</b>
&nbsp;                                fieldRegistry,
&nbsp;                                methodRegistry,
<b class="nc">&nbsp;                                recordComponentRegistry.prepend(matcher, recordComponentAttributeAppenderFactory, transformer),</b>
&nbsp;                                typeAttributeAppender,
&nbsp;                                asmVisitorWrapper,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                annotationValueFilterFactory,
&nbsp;                                annotationRetention,
&nbsp;                                implementationContextFactory,
&nbsp;                                methodGraphCompiler,
&nbsp;                                typeValidation,
&nbsp;                                visibilityBridgeStrategy,
&nbsp;                                classWriterStrategy,
&nbsp;                                ignoredMethods,
&nbsp;                                auxiliaryTypes);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dynamic type that has not yet been loaded by a given {@link java.lang.ClassLoader}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;     *            type itself, an interface or the direct super class.
&nbsp;     */
&nbsp;    interface Unloaded&lt;T&gt; extends DynamicType {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Attempts to load this dynamic type including all of its auxiliary types, if any. If the class loader is an
&nbsp;         * unsealed instance of {@link InjectionClassLoader}, the classes are injected directy into the class loader, otherwise,
&nbsp;         * a new class loader is created where the supplied class loader is set as parent.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: A new class is attempted to be loaded each time this method is invoked, even if a compatible class was
&nbsp;         * created previously. Consider using a {@link net.bytebuddy.TypeCache}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param classLoader The class loader to use for this class loading or {@code null} for using the boot loader.
&nbsp;         * @return This dynamic type in its loaded state.
&nbsp;         */
&nbsp;        Loaded&lt;T&gt; load(@MaybeNull ClassLoader classLoader);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Attempts to load this dynamic type including all of its auxiliary types, if any.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: A new class is attempted to be loaded each time this method is invoked, even if a compatible class was
&nbsp;         * created previously. Consider using a {@link net.bytebuddy.TypeCache}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param classLoader          The class loader to use for this class loading.
&nbsp;         * @param classLoadingStrategy The class loader strategy which should be used for this class loading.
&nbsp;         * @param &lt;S&gt;                  The least specific type of class loader this strategy can apply to.
&nbsp;         * @return This dynamic type in its loaded state.
&nbsp;         * @see net.bytebuddy.dynamic.loading.ClassLoadingStrategy.Default
&nbsp;         */
&nbsp;        &lt;S extends ClassLoader&gt; Loaded&lt;T&gt; load(@MaybeNull S classLoader, ClassLoadingStrategy&lt;? super S&gt; classLoadingStrategy);
&nbsp;
&nbsp;        /**
&nbsp;         * Includes the provided dynamic types as auxiliary types of this instance.
&nbsp;         *
&nbsp;         * @param dynamicType The dynamic types to include.
&nbsp;         * @return A copy of this unloaded dynamic type which includes the provided dynamic types.
&nbsp;         */
&nbsp;        Unloaded&lt;T&gt; include(DynamicType... dynamicType);
&nbsp;
&nbsp;        /**
&nbsp;         * Includes the provided dynamic types as auxiliary types of this instance.
&nbsp;         *
&nbsp;         * @param dynamicTypes The dynamic types to include.
&nbsp;         * @return A copy of this unloaded dynamic type which includes the provided dynamic types.
&nbsp;         */
&nbsp;        Unloaded&lt;T&gt; include(List&lt;? extends DynamicType&gt; dynamicTypes);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dynamic type that has been loaded into the running instance of the Java virtual machine.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;     *            type itself, an interface or the direct super class.
&nbsp;     */
&nbsp;    interface Loaded&lt;T&gt; extends DynamicType {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the loaded main class.
&nbsp;         *
&nbsp;         * @return A loaded class representation of this dynamic type.
&nbsp;         */
&nbsp;        Class&lt;? extends T&gt; getLoaded();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns a map of all loaded auxiliary types to this dynamic type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: The type descriptions will most likely differ from the binary representation of this type.
&nbsp;         * Normally, annotations and intercepted methods are not added to the type descriptions of auxiliary types.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A mapping from the fully qualified names of all auxiliary types to their loaded class representations.
&nbsp;         */
&nbsp;        Map&lt;TypeDescription, Class&lt;?&gt;&gt; getLoadedAuxiliaryTypes();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns all loaded types that are implied by this dynamic type.
&nbsp;         *
&nbsp;         * @return All loaded types that are implied by this dynamic type.
&nbsp;         */
&nbsp;        Map&lt;TypeDescription, Class&lt;?&gt;&gt; getAllLoaded();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A default implementation of a dynamic type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Default implements DynamicType {
&nbsp;
&nbsp;        /**
&nbsp;         * The file name extension for Java class files.
&nbsp;         */
&nbsp;        private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The default version of a jar file manifest.
&nbsp;         */
&nbsp;        private static final String MANIFEST_VERSION = &quot;1.0&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The size of a writing buffer.
&nbsp;         */
&nbsp;        private static final int BUFFER_SIZE = 1024;
&nbsp;
&nbsp;        /**
&nbsp;         * A convenience index for the beginning of an array to improve the readability of the code.
&nbsp;         */
&nbsp;        private static final int FROM_BEGINNING = 0;
&nbsp;
&nbsp;        /**
&nbsp;         * A convenience representative of an {@link java.io.InputStream}&#39;s end to improve the readability of the code.
&nbsp;         */
&nbsp;        private static final int END_OF_FILE = -1;
&nbsp;
&nbsp;        /**
&nbsp;         * A suffix for temporary files.
&nbsp;         */
&nbsp;        private static final String TEMP_SUFFIX = &quot;tmp&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A type description of this dynamic type.
&nbsp;         */
&nbsp;        protected final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * The byte array representing this dynamic type.
&nbsp;         */
&nbsp;        protected final byte[] binaryRepresentation;
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded type initializer for this dynamic type.
&nbsp;         */
&nbsp;        protected final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of auxiliary types for this dynamic type.
&nbsp;         */
&nbsp;        protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new dynamic type.
&nbsp;         *
&nbsp;         * @param typeDescription       A description of this dynamic type.
&nbsp;         * @param binaryRepresentation  A byte array containing the binary representation of this dynamic type. The array must not be modified.
&nbsp;         * @param loadedTypeInitializer The loaded type initializer of this dynamic type.
&nbsp;         * @param auxiliaryTypes        The auxiliary type required for this dynamic type.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not modified by class contract.&quot;)
&nbsp;        public Default(TypeDescription typeDescription,
&nbsp;                       byte[] binaryRepresentation,
&nbsp;                       LoadedTypeInitializer loadedTypeInitializer,
<b class="fc">&nbsp;                       List&lt;? extends DynamicType&gt; auxiliaryTypes) {</b>
<b class="fc">&nbsp;            this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;            this.binaryRepresentation = binaryRepresentation;</b>
<b class="fc">&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;</b>
<b class="fc">&nbsp;            this.auxiliaryTypes = auxiliaryTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution locate(String name) throws IOException {
<b class="fc">&nbsp;            if (typeDescription.getName().equals(name)) {</b>
<b class="fc">&nbsp;                return new Resolution.Explicit(binaryRepresentation);</b>
&nbsp;            }
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                Resolution resolution = auxiliaryType.locate(name);</b>
<b class="fc">&nbsp;                if (resolution.isResolved()) {</b>
<b class="fc">&nbsp;                    return resolution;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Resolution.Illegal(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="nc">&nbsp;        }</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getTypeDescription() {
<b class="fc">&nbsp;            return typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;TypeDescription, byte[]&gt; getAllTypes() {
<b class="fc">&nbsp;            Map&lt;TypeDescription, byte[]&gt; allTypes = new LinkedHashMap&lt;TypeDescription, byte[]&gt;();</b>
<b class="fc">&nbsp;            allTypes.put(typeDescription, binaryRepresentation);</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                allTypes.putAll(auxiliaryType.getAllTypes());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return allTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;TypeDescription, LoadedTypeInitializer&gt; getLoadedTypeInitializers() {
<b class="fc">&nbsp;            Map&lt;TypeDescription, LoadedTypeInitializer&gt; classLoadingCallbacks = new HashMap&lt;TypeDescription, LoadedTypeInitializer&gt;();</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                classLoadingCallbacks.putAll(auxiliaryType.getLoadedTypeInitializers());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            classLoadingCallbacks.put(typeDescription, loadedTypeInitializer);</b>
<b class="fc">&nbsp;            return classLoadingCallbacks;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasAliveLoadedTypeInitializers() {
<b class="fc">&nbsp;            for (LoadedTypeInitializer loadedTypeInitializer : getLoadedTypeInitializers().values()) {</b>
<b class="fc">&nbsp;                if (loadedTypeInitializer.isAlive()) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP&quot;, justification = &quot;The array is not modified by class contract.&quot;)
&nbsp;        public byte[] getBytes() {
<b class="fc">&nbsp;            return binaryRepresentation;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;TypeDescription, byte[]&gt; getAuxiliaryTypes() {
<b class="fc">&nbsp;            Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = new HashMap&lt;TypeDescription, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : this.auxiliaryTypes) {</b>
<b class="fc">&nbsp;                auxiliaryTypes.put(auxiliaryType.getTypeDescription(), auxiliaryType.getBytes());</b>
<b class="fc">&nbsp;                auxiliaryTypes.putAll(auxiliaryType.getAuxiliaryTypes());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return auxiliaryTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;TypeDescription, File&gt; saveIn(File folder) throws IOException {
<b class="fc">&nbsp;            Map&lt;TypeDescription, File&gt; files = new HashMap&lt;TypeDescription, File&gt;();</b>
<b class="fc">&nbsp;            File target = new File(folder, typeDescription.getName().replace(&#39;.&#39;, File.separatorChar) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;            if (target.getParentFile() != null &amp;&amp; !target.getParentFile().isDirectory() &amp;&amp; !target.getParentFile().mkdirs()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Could not create directory: &quot; + target.getParentFile());</b>
&nbsp;            }
<b class="fc">&nbsp;            OutputStream outputStream = new FileOutputStream(target);</b>
&nbsp;            try {
<b class="fc">&nbsp;                outputStream.write(binaryRepresentation);</b>
<b class="nc">&nbsp;            } finally {</b>
<b class="fc">&nbsp;                outputStream.close();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            files.put(typeDescription, target);</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                files.putAll(auxiliaryType.saveIn(folder));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return files;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public File inject(File sourceJar, File targetJar) throws IOException {
<b class="fc">&nbsp;            return sourceJar.equals(targetJar)</b>
<b class="fc">&nbsp;                    ? inject(sourceJar)</b>
<b class="fc">&nbsp;                    : doInject(sourceJar, targetJar);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public File inject(File jar) throws IOException {
<b class="fc">&nbsp;            FileSystem.getInstance().move(doInject(jar, File.createTempFile(jar.getName(), TEMP_SUFFIX)), jar);</b>
<b class="fc">&nbsp;            return jar;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Injects this dynamic type into a source jar and writes the result to the target jar.
&nbsp;         *
&nbsp;         * @param sourceJar The source jar.
&nbsp;         * @param targetJar The target jar.
&nbsp;         * @return The jar file that was written to.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        private File doInject(File sourceJar, File targetJar) throws IOException {
<b class="fc">&nbsp;            JarInputStream inputStream = new JarInputStream(new FileInputStream(sourceJar));</b>
&nbsp;            try {
<b class="fc">&nbsp;                if (!targetJar.isFile() &amp;&amp; !targetJar.createNewFile()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Could not create file: &quot; + targetJar);</b>
&nbsp;                }
<b class="fc">&nbsp;                Manifest manifest = inputStream.getManifest();</b>
<b class="fc">&nbsp;                JarOutputStream outputStream = manifest == null</b>
<b class="nc">&nbsp;                        ? new JarOutputStream(new FileOutputStream(targetJar))</b>
<b class="fc">&nbsp;                        : new JarOutputStream(new FileOutputStream(targetJar), manifest);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    Map&lt;TypeDescription, byte[]&gt; rawAuxiliaryTypes = getAuxiliaryTypes();</b>
<b class="fc">&nbsp;                    Map&lt;String, byte[]&gt; files = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;                    for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : rawAuxiliaryTypes.entrySet()) {</b>
<b class="fc">&nbsp;                        files.put(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION, entry.getValue());</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    files.put(typeDescription.getInternalName() + CLASS_FILE_EXTENSION, binaryRepresentation);</b>
&nbsp;                    JarEntry jarEntry;
<b class="fc">&nbsp;                    while ((jarEntry = inputStream.getNextJarEntry()) != null) {</b>
<b class="fc">&nbsp;                        byte[] replacement = files.remove(jarEntry.getName());</b>
<b class="fc">&nbsp;                        if (replacement == null) {</b>
<b class="fc">&nbsp;                            outputStream.putNextEntry(jarEntry);</b>
<b class="fc">&nbsp;                            byte[] buffer = new byte[BUFFER_SIZE];</b>
&nbsp;                            int index;
<b class="fc">&nbsp;                            while ((index = inputStream.read(buffer)) != END_OF_FILE) {</b>
<b class="fc">&nbsp;                                outputStream.write(buffer, FROM_BEGINNING, index);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            outputStream.putNextEntry(new JarEntry(jarEntry.getName()));</b>
<b class="fc">&nbsp;                            outputStream.write(replacement);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        inputStream.closeEntry();</b>
<b class="fc">&nbsp;                        outputStream.closeEntry();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    for (Map.Entry&lt;String, byte[]&gt; entry : files.entrySet()) {</b>
<b class="fc">&nbsp;                        outputStream.putNextEntry(new JarEntry(entry.getKey()));</b>
<b class="fc">&nbsp;                        outputStream.write(entry.getValue());</b>
<b class="fc">&nbsp;                        outputStream.closeEntry();</b>
<b class="fc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } finally {</b>
<b class="fc">&nbsp;                    outputStream.close();</b>
<b class="fc">&nbsp;                }</b>
<b class="nc">&nbsp;            } finally {</b>
<b class="fc">&nbsp;                inputStream.close();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return targetJar;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public File toJar(File file) throws IOException {
<b class="fc">&nbsp;            Manifest manifest = new Manifest();</b>
<b class="fc">&nbsp;            manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION);</b>
<b class="fc">&nbsp;            return toJar(file, manifest);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public File toJar(File file, Manifest manifest) throws IOException {
<b class="fc">&nbsp;            if (!file.isFile() &amp;&amp; !file.createNewFile()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Could not create file: &quot; + file);</b>
&nbsp;            }
<b class="fc">&nbsp;            JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(file), manifest);</b>
&nbsp;            try {
<b class="fc">&nbsp;                for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : getAuxiliaryTypes().entrySet()) {</b>
<b class="fc">&nbsp;                    outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION));</b>
<b class="fc">&nbsp;                    outputStream.write(entry.getValue());</b>
<b class="fc">&nbsp;                    outputStream.closeEntry();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                outputStream.putNextEntry(new JarEntry(typeDescription.getInternalName() + CLASS_FILE_EXTENSION));</b>
<b class="fc">&nbsp;                outputStream.write(binaryRepresentation);</b>
<b class="fc">&nbsp;                outputStream.closeEntry();</b>
<b class="nc">&nbsp;            } finally {</b>
<b class="fc">&nbsp;                outputStream.close();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return file;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of an unloaded dynamic type.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;         *            type itself, an interface or the direct super class.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class Unloaded&lt;T&gt; extends Default implements DynamicType.Unloaded&lt;T&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type resolution strategy to use for initializing the dynamic type.
&nbsp;             */
&nbsp;            private final TypeResolutionStrategy.Resolved typeResolutionStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new unloaded representation of a dynamic type.
&nbsp;             *
&nbsp;             * @param typeDescription        A description of this dynamic type.
&nbsp;             * @param binaryRepresentation   An array of byte of the binary representation of this dynamic type.
&nbsp;             * @param loadedTypeInitializer  The type initializer of this dynamic type.
&nbsp;             * @param auxiliaryTypes         The auxiliary types that are required for this dynamic type.
&nbsp;             * @param typeResolutionStrategy The type resolution strategy to use for initializing the dynamic type.
&nbsp;             */
&nbsp;            public Unloaded(TypeDescription typeDescription,
&nbsp;                            byte[] binaryRepresentation,
&nbsp;                            LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                            List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                            TypeResolutionStrategy.Resolved typeResolutionStrategy) {
<b class="fc">&nbsp;                super(typeDescription, binaryRepresentation, loadedTypeInitializer, auxiliaryTypes);</b>
<b class="fc">&nbsp;                this.typeResolutionStrategy = typeResolutionStrategy;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Loaded&lt;T&gt; load(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                if (classLoader instanceof InjectionClassLoader &amp;&amp; !((InjectionClassLoader) classLoader).isSealed()) {</b>
<b class="fc">&nbsp;                    return load((InjectionClassLoader) classLoader, InjectionClassLoader.Strategy.INSTANCE);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return load(classLoader, ClassLoadingStrategy.Default.WRAPPER);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;S extends ClassLoader&gt; DynamicType.Loaded&lt;T&gt; load(@MaybeNull S classLoader, ClassLoadingStrategy&lt;? super S&gt; classLoadingStrategy) {
<b class="fc">&nbsp;                return new Default.Loaded&lt;T&gt;(typeDescription,</b>
&nbsp;                        binaryRepresentation,
&nbsp;                        loadedTypeInitializer,
&nbsp;                        auxiliaryTypes,
<b class="fc">&nbsp;                        typeResolutionStrategy.initialize(this, classLoader, classLoadingStrategy));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Unloaded&lt;T&gt; include(DynamicType... dynamicType) {
<b class="fc">&nbsp;                return include(Arrays.asList(dynamicType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Unloaded&lt;T&gt; include(List&lt;? extends DynamicType&gt; dynamicType) {
<b class="fc">&nbsp;                return new Default.Unloaded&lt;T&gt;(typeDescription,</b>
&nbsp;                        binaryRepresentation,
&nbsp;                        loadedTypeInitializer,
<b class="fc">&nbsp;                        CompoundList.of(auxiliaryTypes, dynamicType),</b>
&nbsp;                        typeResolutionStrategy);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of a loaded dynamic type.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The most specific known loaded type that is implemented by this dynamic type, usually the
&nbsp;         *            type itself, an interface or the direct super class.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Loaded&lt;T&gt; extends Default implements DynamicType.Loaded&lt;T&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded types for the given loaded dynamic type.
&nbsp;             */
&nbsp;            private final Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new representation of a loaded dynamic type.
&nbsp;             *
&nbsp;             * @param typeDescription       A description of this dynamic type.
&nbsp;             * @param typeByte              An array of byte of the binary representation of this dynamic type.
&nbsp;             * @param loadedTypeInitializer The type initializer of this dynamic type.
&nbsp;             * @param auxiliaryTypes        The auxiliary types that are required for this dynamic type.
&nbsp;             * @param loadedTypes           A map of loaded types for this dynamic type and all its auxiliary types.
&nbsp;             */
&nbsp;            protected Loaded(TypeDescription typeDescription,
&nbsp;                             byte[] typeByte,
&nbsp;                             LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                             List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                             Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes) {
<b class="fc">&nbsp;                super(typeDescription, typeByte, loadedTypeInitializer, auxiliaryTypes);</b>
<b class="fc">&nbsp;                this.loadedTypes = loadedTypes;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public Class&lt;? extends T&gt; getLoaded() {
<b class="fc">&nbsp;                return (Class&lt;? extends T&gt;) loadedTypes.get(typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Map&lt;TypeDescription, Class&lt;?&gt;&gt; getLoadedAuxiliaryTypes() {
<b class="fc">&nbsp;                Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedAuxiliaryTypes = new HashMap&lt;TypeDescription, Class&lt;?&gt;&gt;(loadedTypes);</b>
<b class="fc">&nbsp;                loadedAuxiliaryTypes.remove(typeDescription);</b>
<b class="fc">&nbsp;                return loadedAuxiliaryTypes;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Map&lt;TypeDescription, Class&lt;?&gt;&gt; getAllLoaded() {
<b class="fc">&nbsp;                return new HashMap&lt;TypeDescription, Class&lt;?&gt;&gt;(loadedTypes);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
