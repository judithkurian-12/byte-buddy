


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > InvokeDynamic</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: InvokeDynamic (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">InvokeDynamic</td>
<td class="coverageStat">
  <span class="percent">
    53.5%
  </span>
  <span class="absValue">
    (23/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49.3%
  </span>
  <span class="absValue">
    (74/150)
  </span>
</td>
</tr>
  <tr>
    <td class="name">InvokeDynamic$1</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$AbstractDelegator</td>
<td class="coverageStat">
  <span class="percent">
    41.9%
  </span>
  <span class="absValue">
    (13/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.9%
  </span>
  <span class="absValue">
    (13/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.9%
  </span>
  <span class="absValue">
    (22/45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$1</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$5</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$6</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$7</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$8</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ConstantPoolWrapper$WrappingArgumentProvider</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForBooleanConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForByteConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForCharacterConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForClassConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForDoubleConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForEnumerationValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForField$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForFloatConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForInstance</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForIntegerConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForInterceptedMethodInstanceAndParameters</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForInterceptedMethodParameters</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForJavaConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForLongConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForMethodParameter$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForNullValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForShortConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForStringConstant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$ForThisInstance</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$Resolved</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ArgumentProvider$Resolved$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$Default$Target</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$NameProvider</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$NameProvider$ForExplicitName</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$NameProvider$ForInterceptedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ReturnTypeProvider</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ReturnTypeProvider$ForExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$ReturnTypeProvider$ForInterceptedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$Target</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$Target$Resolved</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$InvocationProvider$Target$Resolved$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$TerminationHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$TerminationHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$TerminationHandler$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$WithImplicitArguments</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$WithImplicitTarget</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$WithImplicitType$OfArgument</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$WithImplicitType$OfField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">InvokeDynamic$WithImplicitType$OfInstance</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    59.5%
  </span>
  <span class="absValue">
    (132/222)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.5%
  </span>
  <span class="absValue">
    (290/487)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Removal;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.*;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isAbstract;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * An implementation that applies a
&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/8/docs/api/java/lang/invoke/package-summary.html&quot;&gt;dynamic method invocation&lt;/a&gt;.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class InvokeDynamic implements Implementation.Composable {
&nbsp;
&nbsp;    /**
&nbsp;     * The bootstrap method.
&nbsp;     */
&nbsp;    protected final MethodDescription.InDefinedShape bootstrap;
&nbsp;
&nbsp;    /**
&nbsp;     * The arguments that are provided to the bootstrap method.
&nbsp;     */
&nbsp;    protected final List&lt;? extends JavaConstant&gt; arguments;
&nbsp;
&nbsp;    /**
&nbsp;     * The target provided that identifies the method to be bootstrapped.
&nbsp;     */
&nbsp;    protected final InvocationProvider invocationProvider;
&nbsp;
&nbsp;    /**
&nbsp;     * A handler that handles the method return.
&nbsp;     */
&nbsp;    protected final TerminationHandler terminationHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to be used.
&nbsp;     */
&nbsp;    protected final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new invoke dynamic implementation.
&nbsp;     *
&nbsp;     * @param bootstrap          The bootstrap method.
&nbsp;     * @param arguments          The arguments that are provided to the bootstrap method.
&nbsp;     * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;     * @param terminationHandler A handler that handles the method return.
&nbsp;     * @param assigner           The assigner to be used.
&nbsp;     * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected InvokeDynamic(MethodDescription.InDefinedShape bootstrap,
&nbsp;                            List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                            InvocationProvider invocationProvider,
&nbsp;                            TerminationHandler terminationHandler,
&nbsp;                            Assigner assigner,
<b class="fc">&nbsp;                            Assigner.Typing typing) {</b>
<b class="fc">&nbsp;        this.bootstrap = bootstrap;</b>
<b class="fc">&nbsp;        this.arguments = arguments;</b>
<b class="fc">&nbsp;        this.invocationProvider = invocationProvider;</b>
<b class="fc">&nbsp;        this.terminationHandler = terminationHandler;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.typing = typing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the instrumented method with a dynamic method invocation which is linked at runtime using the
&nbsp;     * specified bootstrap method.
&nbsp;     *
&nbsp;     * @param method   The bootstrap method that is used to link the instrumented method.
&nbsp;     * @param constant The constant values passed to the bootstrap method. Values can be represented either
&nbsp;     *                 as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;     *                 {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;     * @return An implementation where a {@code this} reference, if available, and all arguments of the
&nbsp;     * instrumented method are passed to the bootstrapped method unless explicit parameters are specified.
&nbsp;     */
&nbsp;    public static WithImplicitTarget bootstrap(Method method, Object... constant) {
<b class="fc">&nbsp;        return bootstrap(new MethodDescription.ForLoadedMethod(method), constant);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the instrumented method with a dynamic method invocation which is linked at runtime using the
&nbsp;     * specified bootstrap method.
&nbsp;     *
&nbsp;     * @param method    The bootstrap method that is used to link the instrumented method.
&nbsp;     * @param constants The constant values passed to the bootstrap method. Values can be represented either
&nbsp;     *                  as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;     *                  {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;     * @return An implementation where a {@code this} reference, if available, and all arguments of the
&nbsp;     * instrumented method are passed to the bootstrapped method unless explicit parameters are specified.
&nbsp;     */
&nbsp;    public static WithImplicitTarget bootstrap(Method method, List&lt;?&gt; constants) {
<b class="nc">&nbsp;        return bootstrap(new MethodDescription.ForLoadedMethod(method), constants);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the instrumented method with a dynamic method invocation which is linked at runtime using the
&nbsp;     * specified bootstrap constructor.
&nbsp;     *
&nbsp;     * @param constructor The bootstrap constructor that is used to link the instrumented method.
&nbsp;     * @param constant    The constant values passed to the bootstrap method. Values can be represented either
&nbsp;     *                    as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;     *                    {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;     * @return An implementation where a {@code this} reference, if available, and all arguments of the
&nbsp;     * instrumented method are passed to the bootstrapped method unless explicit parameters are specified.
&nbsp;     */
&nbsp;    public static WithImplicitTarget bootstrap(Constructor&lt;?&gt; constructor, Object... constant) {
<b class="fc">&nbsp;        return bootstrap(new MethodDescription.ForLoadedConstructor(constructor), constant);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the instrumented method with a dynamic method invocation which is linked at runtime using the
&nbsp;     * specified bootstrap constructor.
&nbsp;     *
&nbsp;     * @param constructor The bootstrap constructor that is used to link the instrumented method.
&nbsp;     * @param constants   The constant values passed to the bootstrap method. Values can be represented either
&nbsp;     *                    as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;     *                    {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;     * @return An implementation where a {@code this} reference, if available, and all arguments of the
&nbsp;     * instrumented method are passed to the bootstrapped method unless explicit parameters are specified.
&nbsp;     */
&nbsp;    public static WithImplicitTarget bootstrap(Constructor&lt;?&gt; constructor, List&lt;?&gt; constants) {
<b class="nc">&nbsp;        return bootstrap(new MethodDescription.ForLoadedConstructor(constructor), constants);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the instrumented method with a dynamic method invocation which is linked at runtime using the
&nbsp;     * specified bootstrap method or constructor.
&nbsp;     *
&nbsp;     * @param bootstrap The bootstrap method or constructor that is used to link the instrumented method.
&nbsp;     * @param constant  The constant values passed to the bootstrap method. Values can be represented either
&nbsp;     *                  as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;     *                  {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;     * @return An implementation where a {@code this} reference, if available, and all arguments of the
&nbsp;     * instrumented method are passed to the bootstrapped method unless explicit parameters are specified.
&nbsp;     */
&nbsp;    public static WithImplicitTarget bootstrap(MethodDescription.InDefinedShape bootstrap, Object... constant) {
<b class="fc">&nbsp;        return bootstrap(bootstrap, Arrays.asList(constant));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements the instrumented method with a dynamic method invocation which is linked at runtime using the
&nbsp;     * specified bootstrap method or constructor.
&nbsp;     *
&nbsp;     * @param bootstrap The bootstrap method or constructor that is used to link the instrumented method.
&nbsp;     * @param constants The constant values passed to the bootstrap method. Values can be represented either
&nbsp;     *                  as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;     *                  {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;     * @return An implementation where a {@code this} reference, if available, and all arguments of the
&nbsp;     * instrumented method are passed to the bootstrapped method unless explicit parameters are specified.
&nbsp;     */
&nbsp;    public static WithImplicitTarget bootstrap(MethodDescription.InDefinedShape bootstrap, List&lt;?&gt; constants) {
<b class="fc">&nbsp;        List&lt;JavaConstant&gt; arguments = JavaConstant.Simple.wrap(constants);</b>
<b class="fc">&nbsp;        if (!bootstrap.isInvokeBootstrap(TypeList.Explicit.of(arguments))) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Not a valid bootstrap method &quot; + bootstrap + &quot; for &quot; + arguments);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new WithImplicitTarget(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                new InvocationProvider.Default(),
&nbsp;                TerminationHandler.RETURNING,
&nbsp;                Assigner.DEFAULT,
&nbsp;                Assigner.Typing.STATIC);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a lambda expression using the JVM&#39;s lambda meta factory. The method that is implementing the lambda expression is provided
&nbsp;     * the explicit arguments first and the functional interface&#39;s method second.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Byte Buddy does not validate that the provided arguments are correct considering the required arguments of the bound
&nbsp;     * functional interface. Binding an incorrect number of arguments or arguments of incompatible types does not create illegal byte code
&nbsp;     * but yields a runtime error when the call site is first used. This is done to support future extensions or alternative implementations
&nbsp;     * of the Java virtual machine.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param method              The method that implements the lambda expression.
&nbsp;     * @param functionalInterface The functional interface that is an instance of the lambda expression.
&nbsp;     * @return A builder for creating a lambda expression.
&nbsp;     */
&nbsp;    public static WithImplicitArguments lambda(Method method, Type functionalInterface) {
<b class="fc">&nbsp;        return lambda(new MethodDescription.ForLoadedMethod(method), TypeDefinition.Sort.describe(functionalInterface));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a lambda expression using the JVM&#39;s lambda meta factory. The method that is implementing the lambda expression is provided
&nbsp;     * the explicit arguments first and the functional interface&#39;s method second.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Byte Buddy does not validate that the provided arguments are correct considering the required arguments of the bound
&nbsp;     * functional interface. Binding an incorrect number of arguments or arguments of incompatible types does not create illegal byte code
&nbsp;     * but yields a runtime error when the call site is first used. This is done to support future extensions or alternative implementations
&nbsp;     * of the Java virtual machine.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param method              The method that implements the lambda expression.
&nbsp;     * @param functionalInterface The functional interface that is an instance of the lambda expression.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A builder for creating a lambda expression.
&nbsp;     */
&nbsp;    public static WithImplicitArguments lambda(Method method, Type functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return lambda(new MethodDescription.ForLoadedMethod(method), TypeDefinition.Sort.describe(functionalInterface), methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a lambda expression using the JVM&#39;s lambda meta factory. The method that is implementing the lambda expression is provided
&nbsp;     * the explicit arguments first and the functional interface&#39;s method second.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Byte Buddy does not validate that the provided arguments are correct considering the required arguments of the bound
&nbsp;     * functional interface. Binding an incorrect number of arguments or arguments of incompatible types does not create illegal byte code
&nbsp;     * but yields a runtime error when the call site is first used. This is done to support future extensions or alternative implementations
&nbsp;     * of the Java virtual machine.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param methodDescription   The method that implements the lambda expression.
&nbsp;     * @param functionalInterface The functional interface that is an instance of the lambda expression.
&nbsp;     * @return A builder for creating a lambda expression.
&nbsp;     */
&nbsp;    public static WithImplicitArguments lambda(MethodDescription.InDefinedShape methodDescription, TypeDefinition functionalInterface) {
<b class="fc">&nbsp;        return lambda(methodDescription, functionalInterface, MethodGraph.Compiler.Default.forJavaHierarchy());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a lambda expression using the JVM&#39;s lambda meta factory. The method that is implementing the lambda expression is provided
&nbsp;     * the explicit arguments first and the functional interface&#39;s method second.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Byte Buddy does not validate that the provided arguments are correct considering the required arguments of the bound
&nbsp;     * functional interface. Binding an incorrect number of arguments or arguments of incompatible types does not create illegal byte code
&nbsp;     * but yields a runtime error when the call site is first used. This is done to support future extensions or alternative implementations
&nbsp;     * of the Java virtual machine.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param methodDescription   The method that implements the lambda expression.
&nbsp;     * @param functionalInterface The functional interface that is an instance of the lambda expression.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A builder for creating a lambda expression.
&nbsp;     */
&nbsp;    public static WithImplicitArguments lambda(MethodDescription.InDefinedShape methodDescription,
&nbsp;                                               TypeDefinition functionalInterface,
&nbsp;                                               MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;        if (!functionalInterface.isInterface()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(functionalInterface + &quot; is not an interface type&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        MethodList&lt;?&gt; methods = methodGraphCompiler.compile(functionalInterface)</b>
<b class="fc">&nbsp;                .listNodes()</b>
<b class="fc">&nbsp;                .asMethodList()</b>
<b class="fc">&nbsp;                .filter(isAbstract());</b>
<b class="fc">&nbsp;        if (methods.size() != 1) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(functionalInterface + &quot; does not define exactly one abstract method: &quot; + methods);</b>
&nbsp;        }
<b class="fc">&nbsp;        return bootstrap(new MethodDescription.Latent(new TypeDescription.Latent(&quot;java.lang.invoke.LambdaMetafactory&quot;,</b>
&nbsp;                        Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                        TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)),</b>
&nbsp;                        &quot;metafactory&quot;,
&nbsp;                        Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                        Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
<b class="fc">&nbsp;                        JavaType.CALL_SITE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                        Arrays.asList(new ParameterDescription.Token(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                new ParameterDescription.Token(TypeDescription.ForLoadedType.of(String.class).asGenericType()),</b>
<b class="fc">&nbsp;                                new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                new ParameterDescription.Token(JavaType.METHOD_HANDLE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType())),</b>
<b class="fc">&nbsp;                        Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                        Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                        AnnotationValue.UNDEFINED,
&nbsp;                        TypeDescription.Generic.UNDEFINED),
<b class="fc">&nbsp;                JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()),</b>
<b class="fc">&nbsp;                JavaConstant.MethodHandle.of(methodDescription),</b>
<b class="fc">&nbsp;                JavaConstant.MethodType.ofSignature(methods.getOnly())).invoke(methods.asDefined().getOnly().getInternalName());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code boolean} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withBooleanValue(boolean... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (boolean aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForBooleanConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code byte} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withByteValue(byte... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (byte aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForByteConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code short} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withShortValue(short... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (short aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForShortConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code char} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withCharacterValue(char... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (char aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForCharacterConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code int} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withIntegerValue(int... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (int aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForIntegerConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code long} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withLongValue(long... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (long aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForLongConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code float} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withFloatValue(float... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (float aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForFloatConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified {@code double} arguments
&nbsp;     * as its next parameters.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withDoubleValue(double... value) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="nc">&nbsp;        for (double aValue : value) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForDoubleConstant(aValue));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified arguments as its next parameters.
&nbsp;     * Note that any primitive parameters are passed as their wrapper types. Furthermore, values that can be stored
&nbsp;     * in the instrumented class&#39;s constant pool might be of different object identity when passed to the
&nbsp;     * bootstrapped method or might not be visible to the the created class what later results in a runtime error.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withValue(Object... value) {
<b class="fc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="fc">&nbsp;        for (Object aValue : value) {</b>
<b class="fc">&nbsp;            argumentProviders.add(InvocationProvider.ArgumentProvider.ConstantPoolWrapper.of(aValue));</b>
&nbsp;        }
<b class="fc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="fc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified argument as its next parameter while
&nbsp;     * allowing to specify the value to be of a different type than the actual instance type.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public WithImplicitType withReference(Object value) {
<b class="fc">&nbsp;        return new WithImplicitType.OfInstance(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                invocationProvider,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing,
&nbsp;                value);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Requires the bootstrap method to bootstrap a method that takes the specified arguments as its next parameters.
&nbsp;     * Note that any primitive parameters are passed as their wrapper types. Any value that is passed to the
&nbsp;     * bootstrapped method is guaranteed to be of the same object identity.
&nbsp;     *
&nbsp;     * @param value The arguments to pass to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withReference(Object... value) {
<b class="fc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(value.length);</b>
<b class="fc">&nbsp;        for (Object aValue : value) {</b>
<b class="fc">&nbsp;            argumentProviders.add(InvocationProvider.ArgumentProvider.ForInstance.of(aValue));</b>
&nbsp;        }
<b class="fc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="fc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hands the provided types to the dynamically bound method. The type is stored in the generated class&#39;s
&nbsp;     * constant pool and is loaded at invocation time. For this to be possible, the created class&#39;s
&nbsp;     * class loader must be able to see the provided type.
&nbsp;     *
&nbsp;     * @param typeDescription The classes to provide to the bound method as an argument.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified type.
&nbsp;     */
&nbsp;    public InvokeDynamic withType(TypeDescription... typeDescription) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(typeDescription.length);</b>
<b class="nc">&nbsp;        for (TypeDescription aTypeDescription : typeDescription) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForClassConstant(aTypeDescription));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hands the provided enumerations to the dynamically bound method. The enumeration values are read from
&nbsp;     * the enumeration class on demand. For this to be possible, the created class&#39;s class loader must be
&nbsp;     * able to see the enumeration type.
&nbsp;     *
&nbsp;     * @param enumerationDescription The enumeration values to provide to the bound method as an argument.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified enumerations.
&nbsp;     */
&nbsp;    public InvokeDynamic withEnumeration(EnumerationDescription... enumerationDescription) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(enumerationDescription.length);</b>
<b class="nc">&nbsp;        for (EnumerationDescription anEnumerationDescription : enumerationDescription) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForEnumerationValue(anEnumerationDescription));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hands the provided Java instance to the dynamically bound method. The instance is stored in the generated class&#39;s
&nbsp;     * constant pool and is loaded at invocation time. For this to be possible, the created class&#39;s class loader must
&nbsp;     * be able to create the provided Java instance.
&nbsp;     *
&nbsp;     * @param constant The constants to provide to the bound method as an argument.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified Java instance.
&nbsp;     */
&nbsp;    public InvokeDynamic withInstance(ConstantValue... constant) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(constant.length);</b>
<b class="nc">&nbsp;        for (ConstantValue aConstant : constant) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForJavaConstant(aConstant));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Hands the provided Java instance to the dynamically bound method. The instance is stored in the generated class&#39;s
&nbsp;     * constant pool and is loaded at invocation time. For this to be possible, the created class&#39;s class loader must
&nbsp;     * be able to create the provided Java instance.
&nbsp;     *
&nbsp;     * @param constant The constants to provide to the bound method as an argument.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified Java instance.
&nbsp;     */
&nbsp;    public InvokeDynamic withInstance(JavaConstant... constant) {
<b class="nc">&nbsp;        return withInstance((ConstantValue[]) constant);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes {@code null} values of the given types to the bootstrapped method.
&nbsp;     *
&nbsp;     * @param type The type that the {@code null} values should represent.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withNullValue(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;        return withNullValue(new TypeList.ForLoadedTypes(type).toArray(new TypeDescription[0]));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes {@code null} values of the given types to the bootstrapped method.
&nbsp;     *
&nbsp;     * @param typeDescription The type that the {@code null} values should represent.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withNullValue(TypeDescription... typeDescription) {
<b class="fc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(typeDescription.length);</b>
<b class="fc">&nbsp;        for (TypeDescription aTypeDescription : typeDescription) {</b>
<b class="fc">&nbsp;            if (aTypeDescription.isPrimitive()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot assign null to primitive type: &quot; + aTypeDescription);</b>
&nbsp;            }
<b class="fc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForNullValue(aTypeDescription));</b>
&nbsp;        }
<b class="fc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="fc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes parameters of the instrumented method to the bootstrapped method.
&nbsp;     *
&nbsp;     * @param index The indices of the parameters that should be passed to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withArgument(int... index) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(index.length);</b>
<b class="nc">&nbsp;        for (int anIndex : index) {</b>
<b class="nc">&nbsp;            if (anIndex &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Method parameter indices cannot be negative: &quot; + anIndex);</b>
&nbsp;            }
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForMethodParameter(anIndex));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes a parameter of the instrumented method to the bootstrapped method.
&nbsp;     *
&nbsp;     * @param index The index of the parameter that should be passed to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified argument
&nbsp;     * with its implicit type.
&nbsp;     */
&nbsp;    public WithImplicitType withArgument(int index) {
<b class="fc">&nbsp;        if (index &lt; 0) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Method parameter indices cannot be negative: &quot; + index);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new WithImplicitType.OfArgument(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                invocationProvider,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing,
&nbsp;                index);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes references to {@code this} onto the operand stack where the instance is represented as
&nbsp;     * the given types.
&nbsp;     *
&nbsp;     * @param type The types as which the {@code this} reference of the intercepted method should be masked.
&nbsp;     * @return This implementation where {@code this} references are passed as the next arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withThis(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;        return withThis(new TypeList.ForLoadedTypes(type).toArray(new TypeDescription[0]));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes references to {@code this} onto the operand stack where the instance is represented as
&nbsp;     * the given types.
&nbsp;     *
&nbsp;     * @param typeDescription The types as which the {@code this} reference of the intercepted method should be masked.
&nbsp;     * @return This implementation where {@code this} references are passed as the next arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withThis(TypeDescription... typeDescription) {
<b class="fc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(typeDescription.length);</b>
<b class="fc">&nbsp;        for (TypeDescription aTypeDescription : typeDescription) {</b>
<b class="fc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForThisInstance(aTypeDescription));</b>
&nbsp;        }
<b class="fc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="fc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds all method arguments to the the bootstrapped method.
&nbsp;     *
&nbsp;     * @return This invoke dynamic implementation with all parameters of the instrumented method added.
&nbsp;     */
&nbsp;    public InvokeDynamic withMethodArguments() {
<b class="fc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="fc">&nbsp;                invocationProvider.appendArgument(InvocationProvider.ArgumentProvider.ForInterceptedMethodParameters.INSTANCE),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a potential {@code this} reference and all method arguments to the the bootstrapped method.
&nbsp;     *
&nbsp;     * @return This invoke dynamic implementation with a potential {@code this} reference and all
&nbsp;     * parameters of the instrumented method added.
&nbsp;     */
&nbsp;    public InvokeDynamic withImplicitAndMethodArguments() {
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArgument(InvocationProvider.ArgumentProvider.ForInterceptedMethodInstanceAndParameters.INSTANCE),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes the values of the specified fields to the bootstrap method. Any of the specified fields must already
&nbsp;     * exist for the instrumented type.
&nbsp;     *
&nbsp;     * @param name The names of the fields to be passed to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withField(String... name) {
<b class="nc">&nbsp;        return withField(FieldLocator.ForClassHierarchy.Factory.INSTANCE, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes the values of the specified fields to the bootstrap method. Any of the specified fields must already
&nbsp;     * exist for the instrumented type.
&nbsp;     *
&nbsp;     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;     * @param name                The names of the fields to be passed to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public InvokeDynamic withField(FieldLocator.Factory fieldLocatorFactory, String... name) {
<b class="nc">&nbsp;        List&lt;InvocationProvider.ArgumentProvider&gt; argumentProviders = new ArrayList&lt;InvocationProvider.ArgumentProvider&gt;(name.length);</b>
<b class="nc">&nbsp;        for (String aName : name) {</b>
<b class="nc">&nbsp;            argumentProviders.add(new InvocationProvider.ArgumentProvider.ForField(aName, fieldLocatorFactory));</b>
&nbsp;        }
<b class="nc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
<b class="nc">&nbsp;                invocationProvider.appendArguments(argumentProviders),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes the values of the specified fields to the bootstrap method. Any of the specified fields must already
&nbsp;     * exist for the instrumented type.
&nbsp;     *
&nbsp;     * @param name The names of the fields to be passed to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public WithImplicitType withField(String name) {
<b class="fc">&nbsp;        return withField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Passes the values of the specified fields to the bootstrap method. Any of the specified fields must already
&nbsp;     * exist for the instrumented type.
&nbsp;     *
&nbsp;     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;     * @param name                The names of the fields to be passed to the bootstrapped method.
&nbsp;     * @return This invoke dynamic implementation where the bootstrapped method is passed the specified arguments.
&nbsp;     */
&nbsp;    public WithImplicitType withField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="fc">&nbsp;        return new WithImplicitType.OfField(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                invocationProvider,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing,
&nbsp;                name,
&nbsp;                fieldLocatorFactory);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs this implementation to use the provided assigner and decides if the assigner should apply
&nbsp;     * dynamic typing.
&nbsp;     *
&nbsp;     * @param assigner The assigner to use.
&nbsp;     * @param typing   {@code true} if the assigner should attempt dynamic typing.
&nbsp;     * @return The invoke dynamic instruction where the given assigner and dynamic-typing directive are applied.
&nbsp;     */
&nbsp;    public Implementation.Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;        return new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                invocationProvider,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Implementation andThen(Implementation implementation) {
<b class="fc">&nbsp;        return new Implementation.Compound(new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                invocationProvider,
&nbsp;                TerminationHandler.DROPPING,
&nbsp;                assigner,
&nbsp;                typing),
&nbsp;                implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;        return new Implementation.Compound.Composable(new InvokeDynamic(bootstrap,</b>
&nbsp;                arguments,
&nbsp;                invocationProvider,
&nbsp;                TerminationHandler.DROPPING,
&nbsp;                assigner,
&nbsp;                typing),
&nbsp;                implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        return invocationProvider.prepare(instrumentedType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An invocation provider is responsible for loading the arguments of the invoked method onto the operand
&nbsp;     * stack and for creating the actual &lt;i&gt;invoke dynamic&lt;/i&gt; instruction.
&nbsp;     */
&nbsp;    protected interface InvocationProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a target for the invocation.
&nbsp;         *
&nbsp;         * @param methodDescription The method that is being intercepted.
&nbsp;         * @return The target for the invocation.
&nbsp;         */
&nbsp;        Target make(MethodDescription methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the given arguments to the invocation to be loaded onto the operand stack.
&nbsp;         *
&nbsp;         * @param argumentProviders The next arguments to be loaded onto the operand stack.
&nbsp;         * @return An invocation provider for this target that loads the given arguments onto the operand stack.
&nbsp;         */
&nbsp;        InvocationProvider appendArguments(List&lt;ArgumentProvider&gt; argumentProviders);
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the given argument to the invocation to be loaded onto the operand stack.
&nbsp;         *
&nbsp;         * @param argumentProvider The next argument to be loaded onto the operand stack.
&nbsp;         * @return An invocation provider for this target that loads the given arguments onto the operand stack.
&nbsp;         */
&nbsp;        InvocationProvider appendArgument(ArgumentProvider argumentProvider);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a copy of this invocation provider that does not add any arguments.
&nbsp;         *
&nbsp;         * @return A copy of this invocation provider that does not add any arguments.
&nbsp;         */
&nbsp;        InvocationProvider withoutArguments();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a copy of this invocation provider that applies the given name provider.
&nbsp;         *
&nbsp;         * @param nameProvider The name provider to be used.
&nbsp;         * @return A copy of this invocation provider that applies the given name provider.
&nbsp;         */
&nbsp;        InvocationProvider withNameProvider(NameProvider nameProvider);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a copy of this invocation provider that applies the given return type provider.
&nbsp;         *
&nbsp;         * @param returnTypeProvider The return type provider to be used.
&nbsp;         * @return A copy of this invocation provider that applies the given return type provider.
&nbsp;         */
&nbsp;        InvocationProvider withReturnTypeProvider(ReturnTypeProvider returnTypeProvider);
&nbsp;
&nbsp;        /**
&nbsp;         * Prepares the instrumented type.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type to prepare.
&nbsp;         * @return The prepared instrumented type.
&nbsp;         */
&nbsp;        InstrumentedType prepare(InstrumentedType instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * A target for a dynamic method invocation.
&nbsp;         */
&nbsp;        interface Target {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the target.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param assigner         The assigner to be used.
&nbsp;             * @param typing           Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @return The resolved target.
&nbsp;             */
&nbsp;            Resolved resolve(TypeDescription instrumentedType, Assigner assigner, Assigner.Typing typing);
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a resolved {@link net.bytebuddy.implementation.InvokeDynamic.InvocationProvider.Target}.
&nbsp;             */
&nbsp;            interface Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the stack manipulation that loads the arguments onto the operand stack.
&nbsp;                 *
&nbsp;                 * @return The stack manipulation that loads the arguments onto the operand stack.
&nbsp;                 */
&nbsp;                StackManipulation getStackManipulation();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the requested return type.
&nbsp;                 *
&nbsp;                 * @return The requested return type.
&nbsp;                 */
&nbsp;                TypeDescription getReturnType();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the internal name of the requested method.
&nbsp;                 *
&nbsp;                 * @return The internal name of the requested method.
&nbsp;                 */
&nbsp;                String getInternalName();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the types of the values on the operand stack.
&nbsp;                 *
&nbsp;                 * @return The types of the values on the operand stack.
&nbsp;                 */
&nbsp;                List&lt;TypeDescription&gt; getParameterTypes();
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple implementation of
&nbsp;                 * {@link net.bytebuddy.implementation.InvokeDynamic.InvocationProvider.Target.Resolved}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simple implements Resolved {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack manipulation that loads the arguments onto the operand stack.
&nbsp;                     */
&nbsp;                    private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The internal name of the requested method.
&nbsp;                     */
&nbsp;                    private final String internalName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The requested return type.
&nbsp;                     */
&nbsp;                    private final TypeDescription returnType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The types of the values on the operand stack.
&nbsp;                     */
&nbsp;                    private final List&lt;TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple instance.
&nbsp;                     *
&nbsp;                     * @param stackManipulation The stack manipulation that loads the arguments onto the operand stack.
&nbsp;                     * @param internalName      The internal name of the requested method.
&nbsp;                     * @param returnType        The requested return type.
&nbsp;                     * @param parameterTypes    The types of the values on the operand stack.
&nbsp;                     */
&nbsp;                    public Simple(StackManipulation stackManipulation,
&nbsp;                                  String internalName,
&nbsp;                                  TypeDescription returnType,
<b class="fc">&nbsp;                                  List&lt;TypeDescription&gt; parameterTypes) {</b>
<b class="fc">&nbsp;                        this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                        this.internalName = internalName;</b>
<b class="fc">&nbsp;                        this.returnType = returnType;</b>
<b class="fc">&nbsp;                        this.parameterTypes = parameterTypes;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation getStackManipulation() {
<b class="fc">&nbsp;                        return stackManipulation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription getReturnType() {
<b class="fc">&nbsp;                        return returnType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getInternalName() {
<b class="fc">&nbsp;                        return internalName;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;TypeDescription&gt; getParameterTypes() {
<b class="fc">&nbsp;                        return parameterTypes;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument provider is responsible for loading arguments to a bootstrapped method onto the operand
&nbsp;         * stack and providing the types of these arguments.
&nbsp;         */
&nbsp;        interface ArgumentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an argument provider.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param assigner           The assigner to be used.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @return A resolved version of this argument provider.
&nbsp;             */
&nbsp;            Resolved resolve(TypeDescription instrumentedType,
&nbsp;                             MethodDescription instrumentedMethod,
&nbsp;                             Assigner assigner,
&nbsp;                             Assigner.Typing typing);
&nbsp;
&nbsp;            /**
&nbsp;             * Prepares the instrumented type.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return The prepared instrumented type.
&nbsp;             */
&nbsp;            InstrumentedType prepare(InstrumentedType instrumentedType);
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider that loads a reference to the intercepted instance and all arguments of
&nbsp;             * the intercepted method.
&nbsp;             */
<b class="fc">&nbsp;            enum ForInterceptedMethodInstanceAndParameters implements ArgumentProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
<b class="nc">&nbsp;                            instrumentedMethod.isStatic()</b>
<b class="nc">&nbsp;                                    ? instrumentedMethod.getParameters().asTypeList().asErasures()</b>
<b class="nc">&nbsp;                                    : CompoundList.of(instrumentedMethod.getDeclaringType().asErasure(), instrumentedMethod.getParameters().asTypeList().asErasures()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider that loads all arguments of the intercepted method.
&nbsp;             */
<b class="fc">&nbsp;            enum ForInterceptedMethodParameters implements ArgumentProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    return new Resolved.Simple(MethodVariableAccess.allArgumentsOf(instrumentedMethod),</b>
<b class="fc">&nbsp;                            instrumentedMethod.getParameters().asTypeList().asErasures());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents wrapper types and types that could be stored in a class&#39;s constant pool as such
&nbsp;             * constant pool values.
&nbsp;             */
<b class="fc">&nbsp;            enum ConstantPoolWrapper {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Boolean} as a {@code boolean} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                BOOLEAN(boolean.class, Boolean.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(IntegerConstant.forValue((Boolean) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Byte} as a {@code byte} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                BYTE(byte.class, Byte.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(IntegerConstant.forValue((Byte) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Short} as a {@code short} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                SHORT(short.class, Short.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(IntegerConstant.forValue((Short) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Character} as a {@code char} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                CHARACTER(char.class, Character.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(IntegerConstant.forValue((Character) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Integer} as a {@code int} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER(int.class, Integer.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(IntegerConstant.forValue((Integer) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Long} as a {@code long} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                LONG(long.class, Long.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(LongConstant.forValue((Long) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Float} as a {@code float} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT(float.class, Float.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(FloatConstant.forValue((Float) value));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores a {@link java.lang.Double} as a {@code double} and wraps it on load.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE(double.class, Double.class) {</b>
&nbsp;                    @Override
&nbsp;                    protected ArgumentProvider make(Object value) {
<b class="nc">&nbsp;                        return new WrappingArgumentProvider(DoubleConstant.forValue((Double) value));</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * The primitive type that can be stored on the constant pool.
&nbsp;                 */
&nbsp;                private final TypeDescription primitiveType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The wrapper type that is to be represented.
&nbsp;                 */
&nbsp;                private final TypeDescription wrapperType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new wrapper delegate for a primitive type.
&nbsp;                 *
&nbsp;                 * @param primitiveType The primitive type that can be stored on the constant pool.
&nbsp;                 * @param wrapperType   The wrapper type that is to be represented.
&nbsp;                 */
<b class="fc">&nbsp;                ConstantPoolWrapper(Class&lt;?&gt; primitiveType, Class&lt;?&gt; wrapperType) {</b>
<b class="fc">&nbsp;                    this.primitiveType = TypeDescription.ForLoadedType.of(primitiveType);</b>
<b class="fc">&nbsp;                    this.wrapperType = TypeDescription.ForLoadedType.of(wrapperType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the given value by a constant pool value or as a field if this is not possible.
&nbsp;                 *
&nbsp;                 * @param value The value to provide to the bootstrapped method.
&nbsp;                 * @return An argument provider for this value.
&nbsp;                 */
&nbsp;                public static ArgumentProvider of(Object value) {
<b class="fc">&nbsp;                    if (value instanceof Boolean) {</b>
<b class="nc">&nbsp;                        return BOOLEAN.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Byte) {</b>
<b class="nc">&nbsp;                        return BYTE.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Short) {</b>
<b class="nc">&nbsp;                        return SHORT.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Character) {</b>
<b class="nc">&nbsp;                        return CHARACTER.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Integer) {</b>
<b class="nc">&nbsp;                        return INTEGER.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Long) {</b>
<b class="nc">&nbsp;                        return LONG.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Float) {</b>
<b class="nc">&nbsp;                        return FLOAT.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof Double) {</b>
<b class="nc">&nbsp;                        return DOUBLE.make(value);</b>
<b class="fc">&nbsp;                    } else if (value instanceof String) {</b>
<b class="fc">&nbsp;                        return new ForStringConstant((String) value);</b>
<b class="nc">&nbsp;                    } else if (value instanceof Class&lt;?&gt;) {</b>
<b class="nc">&nbsp;                        return new ForClassConstant(TypeDescription.ForLoadedType.of((Class&lt;?&gt;) value));</b>
<b class="nc">&nbsp;                    } else if (value instanceof TypeDescription) {</b>
<b class="nc">&nbsp;                        return new ForClassConstant((TypeDescription) value);</b>
<b class="nc">&nbsp;                    } else if (value instanceof Enum&lt;?&gt;) {</b>
<b class="nc">&nbsp;                        return new ForEnumerationValue(new EnumerationDescription.ForLoadedEnumeration((Enum&lt;?&gt;) value));</b>
<b class="nc">&nbsp;                    } else if (value instanceof EnumerationDescription) {</b>
<b class="nc">&nbsp;                        return new ForEnumerationValue((EnumerationDescription) value);</b>
<b class="nc">&nbsp;                    } else if (JavaType.METHOD_HANDLE.isInstance(value)) {</b>
<b class="nc">&nbsp;                        return new ForJavaConstant(JavaConstant.MethodHandle.ofLoaded(value));</b>
<b class="nc">&nbsp;                    } else if (JavaType.METHOD_TYPE.isInstance(value)) {</b>
<b class="nc">&nbsp;                        return new ForJavaConstant(JavaConstant.MethodType.ofLoaded(value));</b>
<b class="nc">&nbsp;                    } else if (value instanceof JavaConstant) {</b>
<b class="nc">&nbsp;                        return new ForJavaConstant((JavaConstant) value);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return ForInstance.of(value);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an argument provider for a given primitive value.
&nbsp;                 *
&nbsp;                 * @param value The wrapper-type value to provide to the bootstrapped method.
&nbsp;                 * @return An argument provider for this value.
&nbsp;                 */
&nbsp;                protected abstract ArgumentProvider make(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument provider that loads a primitive value from the constant pool and wraps it.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class WrappingArgumentProvider implements ArgumentProvider {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack manipulation that represents the loading of the primitive value.
&nbsp;                     */
&nbsp;                    private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new wrapping argument provider.
&nbsp;                     *
&nbsp;                     * @param stackManipulation The stack manipulation that represents the loading of the
&nbsp;                     *                          primitive value.
&nbsp;                     */
<b class="nc">&nbsp;                    protected WrappingArgumentProvider(StackManipulation stackManipulation) {</b>
<b class="nc">&nbsp;                        this.stackManipulation = stackManipulation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                        return new Resolved.Simple(new StackManipulation.Compound(stackManipulation,</b>
<b class="nc">&nbsp;                                assigner.assign(primitiveType.asGenericType(), wrapperType.asGenericType(), typing)), wrapperType);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                        return instrumentedType;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved {@link net.bytebuddy.implementation.InvokeDynamic.InvocationProvider.ArgumentProvider}.
&nbsp;             */
&nbsp;            interface Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a stack manipulation that loads the arguments onto the operand stack.
&nbsp;                 *
&nbsp;                 * @return A stack manipulation that loads the arguments onto the operand stack.
&nbsp;                 */
&nbsp;                StackManipulation getLoadInstruction();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a list of all types of the arguments that were loaded onto the operand stack.
&nbsp;                 *
&nbsp;                 * @return A list of all types of the arguments that were loaded onto the operand stack.
&nbsp;                 */
&nbsp;                List&lt;TypeDescription&gt; getLoadedTypes();
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple implementation of a resolved argument provider.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simple implements Resolved {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A stack manipulation that loads the arguments onto the operand stack.
&nbsp;                     */
&nbsp;                    private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of all types of the arguments that were loaded onto the operand stack.
&nbsp;                     */
&nbsp;                    private final List&lt;TypeDescription&gt; loadedTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a simple resolved argument provider.
&nbsp;                     *
&nbsp;                     * @param stackManipulation A stack manipulation that loads the argument onto the operand stack.
&nbsp;                     * @param loadedType        The type of the arguments that is loaded onto the operand stack.
&nbsp;                     */
&nbsp;                    public Simple(StackManipulation stackManipulation, TypeDescription loadedType) {
<b class="fc">&nbsp;                        this(stackManipulation, Collections.singletonList(loadedType));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a simple resolved argument provider.
&nbsp;                     *
&nbsp;                     * @param stackManipulation A stack manipulation that loads the arguments onto the operand stack.
&nbsp;                     * @param loadedTypes       A list of all types of the arguments that were loaded onto the
&nbsp;                     *                          operand stack.
&nbsp;                     */
<b class="fc">&nbsp;                    public Simple(StackManipulation stackManipulation, List&lt;TypeDescription&gt; loadedTypes) {</b>
<b class="fc">&nbsp;                        this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                        this.loadedTypes = loadedTypes;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation getLoadInstruction() {
<b class="fc">&nbsp;                        return stackManipulation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;TypeDescription&gt; getLoadedTypes() {
<b class="fc">&nbsp;                        return loadedTypes;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider that loads the intercepted instance.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForThisInstance implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type as which the intercepted instance should be loaded onto the operand stack.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for the instance of the instrumented type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type as which the instrumented type should be loaded onto the operand stack.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForThisInstance(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    if (instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot get this instance from static method: &quot; + instrumentedMethod);</b>
<b class="fc">&nbsp;                    } else if (!instrumentedType.isAssignableTo(typeDescription)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedType + &quot; is not assignable to &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Resolved.Simple(MethodVariableAccess.loadThis(), typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a value that is stored in a randomly named static field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForInstance implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The prefix of any field generated by this argument provider.
&nbsp;                 */
&nbsp;                private static final String FIELD_PREFIX = &quot;invokeDynamic&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The value that is stored in the static field.
&nbsp;                 */
&nbsp;                private final Object value;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the static field.
&nbsp;                 */
&nbsp;                private final TypeDescription fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider that stores the given value in a static field.
&nbsp;                 *
&nbsp;                 * @param value     The value that is to be provided to the bootstrapped method.
&nbsp;                 * @param fieldType The type of the field which is also provided to the bootstrap method.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForInstance(Object value, TypeDescription fieldType) {</b>
<b class="fc">&nbsp;                    this.value = value;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
<b class="fc">&nbsp;                    name = FIELD_PREFIX + &quot;$&quot; + RandomString.hashOf(value);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider that stores the given value in a static field of the instance type.
&nbsp;                 *
&nbsp;                 * @param value The value that is to be provided to the bootstrapped method.
&nbsp;                 * @return A corresponding argument provider.
&nbsp;                 */
&nbsp;                protected static ArgumentProvider of(Object value) {
<b class="fc">&nbsp;                    return new ForInstance(value, TypeDescription.ForLoadedType.of(value.getClass()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    FieldDescription fieldDescription = instrumentedType.getDeclaredFields().filter(named(name)).getOnly();</b>
<b class="fc">&nbsp;                    StackManipulation stackManipulation = assigner.assign(fieldDescription.getType(), fieldType.asGenericType(), typing);</b>
<b class="fc">&nbsp;                    if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription + &quot; to &quot; + fieldType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Resolved.Simple(new StackManipulation.Compound(FieldAccess.forField(fieldDescription).read(),</b>
<b class="fc">&nbsp;                            stackManipulation), fieldDescription.getType().asErasure());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name,</b>
&nbsp;                            Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC,
<b class="fc">&nbsp;                            fieldType.asGenericType()), value);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Provides an argument from an existing field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForField implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                protected final String fieldName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field locator factory to use.
&nbsp;                 */
&nbsp;                protected final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider that loads the value of an existing field.
&nbsp;                 *
&nbsp;                 * @param fieldName           The name of the field.
&nbsp;                 * @param fieldLocatorFactory The field locator factory to use.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForField(String fieldName, FieldLocator.Factory fieldLocatorFactory) {</b>
<b class="fc">&nbsp;                    this.fieldName = fieldName;</b>
<b class="fc">&nbsp;                    this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(fieldName);</b>
<b class="fc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot find a field &quot; + fieldName + &quot; for &quot; + instrumentedType);</b>
<b class="fc">&nbsp;                    } else if (!resolution.getField().isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access non-static &quot; + resolution.getField() + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return doResolve(new StackManipulation.Compound(resolution.getField().isStatic()</b>
<b class="nc">&nbsp;                                    ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                    : MethodVariableAccess.loadThis(), FieldAccess.forField(resolution.getField()).read()),</b>
<b class="fc">&nbsp;                            resolution.getField().getType(),</b>
&nbsp;                            assigner,
&nbsp;                            typing);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves this argument provider.
&nbsp;                 *
&nbsp;                 * @param access   The stack manipulation for accessing the argument value.
&nbsp;                 * @param type     The type of the loaded value.
&nbsp;                 * @param assigner The assigner to use.
&nbsp;                 * @param typing   The typing required.
&nbsp;                 * @return A resolved version of this arguments provider.
&nbsp;                 */
&nbsp;                protected Resolved doResolve(StackManipulation access, TypeDescription.Generic type, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    return new Resolved.Simple(access, type.asErasure());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument provider for a field value with an explicit type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class WithExplicitType extends ForField {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The explicit type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an argument provider for a field value with an explicit type.
&nbsp;                     *
&nbsp;                     * @param fieldName           The name of the field.
&nbsp;                     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;                     * @param typeDescription     The explicit type.
&nbsp;                     */
&nbsp;                    protected WithExplicitType(String fieldName, FieldLocator.Factory fieldLocatorFactory, TypeDescription typeDescription) {
<b class="fc">&nbsp;                        super(fieldName, fieldLocatorFactory);</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    protected Resolved doResolve(StackManipulation access, TypeDescription.Generic typeDescription, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                        StackManipulation stackManipulation = assigner.assign(typeDescription, this.typeDescription.asGenericType(), typing);</b>
<b class="fc">&nbsp;                        if (!stackManipulation.isValid()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + typeDescription + &quot; to &quot; + this.typeDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Resolved.Simple(new StackManipulation.Compound(access, stackManipulation), this.typeDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider that loads an argument of the intercepted method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForMethodParameter implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the parameter.
&nbsp;                 */
&nbsp;                protected final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an argument provider for an argument of the intercepted method.
&nbsp;                 *
&nbsp;                 * @param index The index of the parameter.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForMethodParameter(int index) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    ParameterList&lt;?&gt; parameters = instrumentedMethod.getParameters();</b>
<b class="fc">&nbsp;                    if (index &gt;= parameters.size()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;No parameter &quot; + index + &quot; for &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return doResolve(MethodVariableAccess.load(parameters.get(index)), parameters.get(index).getType(), assigner, typing);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves this argument provider.
&nbsp;                 *
&nbsp;                 * @param access   The stack manipulation for accessing the argument value.
&nbsp;                 * @param type     The type of the loaded value.
&nbsp;                 * @param assigner The assigner to use.
&nbsp;                 * @param typing   The typing required.
&nbsp;                 * @return A resolved version of this arguments provider.
&nbsp;                 */
&nbsp;                protected Resolved doResolve(StackManipulation access, TypeDescription.Generic type, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    return new Resolved.Simple(access, type.asErasure());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument provider for a method parameter with an explicit type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class WithExplicitType extends ForMethodParameter {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The explicit type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new argument provider for a method parameter with an explicit type.
&nbsp;                     *
&nbsp;                     * @param index           The index of the parameter.
&nbsp;                     * @param typeDescription The explicit type.
&nbsp;                     */
&nbsp;                    protected WithExplicitType(int index, TypeDescription typeDescription) {
<b class="nc">&nbsp;                        super(index);</b>
<b class="nc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    protected Resolved doResolve(StackManipulation access, TypeDescription.Generic type, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                        StackManipulation stackManipulation = assigner.assign(type, typeDescription.asGenericType(), typing);</b>
<b class="nc">&nbsp;                        if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + typeDescription);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new Resolved.Simple(new StackManipulation.Compound(access, stackManipulation), typeDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code boolean} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForBooleanConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code boolean} value.
&nbsp;                 */
&nbsp;                private final boolean value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code boolean} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code boolean} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForBooleanConstant(boolean value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(IntegerConstant.forValue(value), TypeDescription.ForLoadedType.of(boolean.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code byte} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForByteConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code byte} value.
&nbsp;                 */
&nbsp;                private final byte value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code byte} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code byte} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForByteConstant(byte value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(IntegerConstant.forValue(value), TypeDescription.ForLoadedType.of(byte.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code short} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForShortConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code short} value.
&nbsp;                 */
&nbsp;                private final short value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code short} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code short} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForShortConstant(short value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(IntegerConstant.forValue(value), TypeDescription.ForLoadedType.of(short.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code char} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForCharacterConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code char} value.
&nbsp;                 */
&nbsp;                private final char value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code char} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code char} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForCharacterConstant(char value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(IntegerConstant.forValue(value), TypeDescription.ForLoadedType.of(char.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code int} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForIntegerConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code int} value.
&nbsp;                 */
&nbsp;                private final int value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code int} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code int} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForIntegerConstant(int value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(IntegerConstant.forValue(value), TypeDescription.ForLoadedType.of(int.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code long} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForLongConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code long} value.
&nbsp;                 */
&nbsp;                private final long value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code long} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code long} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForLongConstant(long value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(LongConstant.forValue(value), TypeDescription.ForLoadedType.of(long.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code float} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForFloatConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code float} value.
&nbsp;                 */
&nbsp;                private final float value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code float} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code float} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForFloatConstant(float value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(FloatConstant.forValue(value), TypeDescription.ForLoadedType.of(float.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@code double} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForDoubleConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code double} value.
&nbsp;                 */
&nbsp;                private final double value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@code double} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@code double} value.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForDoubleConstant(double value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(DoubleConstant.forValue(value), TypeDescription.ForLoadedType.of(double.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@link java.lang.String} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForStringConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@link java.lang.String} value.
&nbsp;                 */
&nbsp;                private final String value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a {@link java.lang.String} value.
&nbsp;                 *
&nbsp;                 * @param value The represented {@link java.lang.String} value.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForStringConstant(String value) {</b>
<b class="fc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    return new Resolved.Simple(new TextConstant(value), TypeDescription.ForLoadedType.of(String.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a {@link java.lang.Class} constant.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForClassConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type that is represented by this constant.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for the given type description.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type to represent.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForClassConstant(TypeDescription typeDescription) {</b>
<b class="nc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(ClassConstant.of(typeDescription), TypeDescription.ForLoadedType.of(Class.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for an {@link java.lang.Enum} constant.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForEnumerationValue implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the enumeration to represent.
&nbsp;                 */
&nbsp;                private final EnumerationDescription enumerationDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for an enumeration value.
&nbsp;                 *
&nbsp;                 * @param enumerationDescription A description of the enumeration to represent.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForEnumerationValue(EnumerationDescription enumerationDescription) {</b>
<b class="nc">&nbsp;                    this.enumerationDescription = enumerationDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for the {@code null} value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForNullValue implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type to be represented by the {@code null} value.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for the {@code null} value.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type to be represented by the {@code null} value.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForNullValue(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    return new Resolved.Simple(NullConstant.INSTANCE, typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a Java instance.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForJavaConstant implements ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The Java instance to provide to the bootstrapped method.
&nbsp;                 */
&nbsp;                private final ConstantValue constant;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for the given Java instance.
&nbsp;                 *
&nbsp;                 * @param constant The Java instance to provide to the bootstrapped method.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForJavaConstant(ConstantValue constant) {</b>
<b class="nc">&nbsp;                    this.constant = constant;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return new Resolved.Simple(constant.toStackManipulation(), constant.getTypeDescription());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Provides the name of the method that is to be bound by a dynamic method call.
&nbsp;         */
&nbsp;        interface NameProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the name given the intercepted method.
&nbsp;             *
&nbsp;             * @param methodDescription The intercepted method.
&nbsp;             * @return The name of the method to be bound by the bootstrap method.
&nbsp;             */
&nbsp;            String resolve(MethodDescription methodDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * A name provider that provides the name of the intercepted method.
&nbsp;             */
<b class="fc">&nbsp;            enum ForInterceptedMethod implements NameProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return methodDescription.getInternalName();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A name provider that provides an explicit name.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForExplicitName implements NameProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name to be provided.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new name provider for an explicit name.
&nbsp;                 *
&nbsp;                 * @param internalName The name to be provided.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForExplicitName(String internalName) {</b>
<b class="fc">&nbsp;                    this.internalName = internalName;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return internalName;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Provides the return type that is requested from the bootstrap method.
&nbsp;         */
&nbsp;        interface ReturnTypeProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the return type that is requested from the bootstrap method.
&nbsp;             *
&nbsp;             * @param methodDescription The intercepted method.
&nbsp;             * @return The return type that is requested from the bootstrap method.
&nbsp;             */
&nbsp;            TypeDescription resolve(MethodDescription methodDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * Requests the return type of the intercepted method.
&nbsp;             */
<b class="fc">&nbsp;            enum ForInterceptedMethod implements ReturnTypeProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return methodDescription.getReturnType().asErasure();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Requests an explicit return type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForExplicitType implements ReturnTypeProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The requested return type.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new return type provider for an explicit return type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The requested return type.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForExplicitType(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An invocation provider that requests a synthetic dynamic invocation where all arguments are explicitly
&nbsp;         * provided by the user.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Default implements InvocationProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The provider for the name of the intercepted method.
&nbsp;             */
&nbsp;            private final NameProvider nameProvider;
&nbsp;
&nbsp;            /**
&nbsp;             * The provider for the required return type.
&nbsp;             */
&nbsp;            private final ReturnTypeProvider returnTypeProvider;
&nbsp;
&nbsp;            /**
&nbsp;             * The providers for the method arguments in their order.
&nbsp;             */
&nbsp;            private final List&lt;ArgumentProvider&gt; argumentProviders;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default invocation provider that provides information and arguments of the
&nbsp;             * intercepted method.
&nbsp;             */
&nbsp;            protected Default() {
<b class="fc">&nbsp;                this(NameProvider.ForInterceptedMethod.INSTANCE,</b>
&nbsp;                        ReturnTypeProvider.ForInterceptedMethod.INSTANCE,
<b class="fc">&nbsp;                        Collections.&lt;ArgumentProvider&gt;singletonList(ArgumentProvider.ForInterceptedMethodInstanceAndParameters.INSTANCE));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default invocation provider.
&nbsp;             *
&nbsp;             * @param nameProvider       The provider for the name of the intercepted method.
&nbsp;             * @param returnTypeProvider The provider for the required return type.
&nbsp;             * @param argumentProviders  The providers for the method arguments in their order.
&nbsp;             */
&nbsp;            protected Default(NameProvider nameProvider,
&nbsp;                              ReturnTypeProvider returnTypeProvider,
<b class="fc">&nbsp;                              List&lt;ArgumentProvider&gt; argumentProviders) {</b>
<b class="fc">&nbsp;                this.nameProvider = nameProvider;</b>
<b class="fc">&nbsp;                this.returnTypeProvider = returnTypeProvider;</b>
<b class="fc">&nbsp;                this.argumentProviders = argumentProviders;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target make(MethodDescription methodDescription) {
<b class="fc">&nbsp;                return new Target(nameProvider.resolve(methodDescription),</b>
<b class="fc">&nbsp;                        returnTypeProvider.resolve(methodDescription),</b>
&nbsp;                        argumentProviders,
&nbsp;                        methodDescription);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InvocationProvider appendArguments(List&lt;ArgumentProvider&gt; argumentProviders) {
<b class="fc">&nbsp;                return new Default(nameProvider,</b>
&nbsp;                        returnTypeProvider,
<b class="fc">&nbsp;                        CompoundList.of(this.argumentProviders, argumentProviders));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InvocationProvider appendArgument(ArgumentProvider argumentProvider) {
<b class="fc">&nbsp;                return new Default(nameProvider,</b>
&nbsp;                        returnTypeProvider,
<b class="fc">&nbsp;                        CompoundList.of(this.argumentProviders, argumentProvider));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InvocationProvider withoutArguments() {
<b class="fc">&nbsp;                return new Default(nameProvider,</b>
&nbsp;                        returnTypeProvider,
<b class="fc">&nbsp;                        Collections.&lt;ArgumentProvider&gt;emptyList());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InvocationProvider withNameProvider(NameProvider nameProvider) {
<b class="fc">&nbsp;                return new Default(nameProvider,</b>
&nbsp;                        returnTypeProvider,
&nbsp;                        argumentProviders);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InvocationProvider withReturnTypeProvider(ReturnTypeProvider returnTypeProvider) {
<b class="fc">&nbsp;                return new Default(nameProvider,</b>
&nbsp;                        returnTypeProvider,
&nbsp;                        argumentProviders);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                for (ArgumentProvider argumentProvider : argumentProviders) {</b>
<b class="fc">&nbsp;                    instrumentedType = argumentProvider.prepare(instrumentedType);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target for a synthetically bound method call.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Target implements InvocationProvider.Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name to be passed to the bootstrap method.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The return type to be requested from the bootstrapping method.
&nbsp;                 */
&nbsp;                private final TypeDescription returnType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The arguments to be passed to the bootstrap method.
&nbsp;                 */
&nbsp;                private final List&lt;ArgumentProvider&gt; argumentProviders;
&nbsp;
&nbsp;                /**
&nbsp;                 * The intercepted method.
&nbsp;                 */
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target.
&nbsp;                 *
&nbsp;                 * @param internalName       The name to be passed to the bootstrap method.
&nbsp;                 * @param returnType         The return type to be requested from the bootstrapping method.
&nbsp;                 * @param argumentProviders  The arguments to be passed to the bootstrap method.
&nbsp;                 * @param instrumentedMethod The intercepted method.
&nbsp;                 */
&nbsp;                protected Target(String internalName,
&nbsp;                                 TypeDescription returnType,
&nbsp;                                 List&lt;ArgumentProvider&gt; argumentProviders,
<b class="fc">&nbsp;                                 MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                    this.internalName = internalName;</b>
<b class="fc">&nbsp;                    this.returnType = returnType;</b>
<b class="fc">&nbsp;                    this.argumentProviders = argumentProviders;</b>
<b class="fc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InvocationProvider.Target.Resolved resolve(TypeDescription instrumentedType, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    StackManipulation[] stackManipulation = new StackManipulation[argumentProviders.size()];</b>
<b class="fc">&nbsp;                    List&lt;TypeDescription&gt; parameterTypes = new ArrayList&lt;TypeDescription&gt;();</b>
<b class="fc">&nbsp;                    int index = 0;</b>
<b class="fc">&nbsp;                    for (ArgumentProvider argumentProvider : argumentProviders) {</b>
<b class="fc">&nbsp;                        ArgumentProvider.Resolved resolved = argumentProvider.resolve(instrumentedType, instrumentedMethod, assigner, typing);</b>
<b class="fc">&nbsp;                        parameterTypes.addAll(resolved.getLoadedTypes());</b>
<b class="fc">&nbsp;                        stackManipulation[index++] = resolved.getLoadInstruction();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new Resolved.Simple(new StackManipulation.Compound(stackManipulation),</b>
&nbsp;                            internalName,
&nbsp;                            returnType,
&nbsp;                            parameterTypes);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A termination handler is responsible to handle the return value of a method that is invoked via a
&nbsp;     * {@link net.bytebuddy.implementation.InvokeDynamic}.
&nbsp;     */
<b class="fc">&nbsp;    protected enum TerminationHandler {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler that returns the bound method&#39;s return value.
&nbsp;         */
<b class="fc">&nbsp;        RETURNING {</b>
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(MethodDescription interceptedMethod, TypeDescription returnType, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                StackManipulation stackManipulation = assigner.assign(returnType.asGenericType(), interceptedMethod.getReturnType(), typing);</b>
<b class="fc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot return &quot; + returnType + &quot; from &quot; + interceptedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(stackManipulation, MethodReturn.of(interceptedMethod.getReturnType()));</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler that drops the bound method&#39;s return value.
&nbsp;         */
<b class="fc">&nbsp;        DROPPING {</b>
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(MethodDescription interceptedMethod, TypeDescription returnType, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                return Removal.of(returnType);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation that handles the method return.
&nbsp;         *
&nbsp;         * @param interceptedMethod The method being intercepted.
&nbsp;         * @param returnType        The return type of the instrumented method.
&nbsp;         * @param assigner          The assigner to use.
&nbsp;         * @param typing            Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return A stack manipulation that handles the method return.
&nbsp;         */
&nbsp;        protected abstract StackManipulation resolve(MethodDescription interceptedMethod,
&nbsp;                                                     TypeDescription returnType,
&nbsp;                                                     Assigner assigner,
&nbsp;                                                     Assigner.Typing typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract delegator that allows to specify a configuration for any specification of an argument.
&nbsp;     */
&nbsp;    protected abstract static class AbstractDelegator extends InvokeDynamic {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new abstract delegator for a dynamic method invocation.
&nbsp;         *
&nbsp;         * @param bootstrap          The bootstrap method or constructor.
&nbsp;         * @param arguments          The arguments that are provided to the bootstrap method or constructor.
&nbsp;         * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;         * @param terminationHandler A handler that handles the method return.
&nbsp;         * @param assigner           The assigner to be used.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        protected AbstractDelegator(MethodDescription.InDefinedShape bootstrap,
&nbsp;                                    List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                                    InvocationProvider invocationProvider,
&nbsp;                                    TerminationHandler terminationHandler,
&nbsp;                                    Assigner assigner,
&nbsp;                                    Assigner.Typing typing) {
<b class="fc">&nbsp;            super(bootstrap, arguments, invocationProvider, terminationHandler, assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the current configuration into a fully initialized invoke dynamic instance.
&nbsp;         *
&nbsp;         * @return The fully resolved invoke dynamic instance.
&nbsp;         */
&nbsp;        protected abstract InvokeDynamic materialize();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withBooleanValue(boolean... value) {
<b class="nc">&nbsp;            return materialize().withBooleanValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withByteValue(byte... value) {
<b class="nc">&nbsp;            return materialize().withByteValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withShortValue(short... value) {
<b class="nc">&nbsp;            return materialize().withShortValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withCharacterValue(char... value) {
<b class="nc">&nbsp;            return materialize().withCharacterValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withIntegerValue(int... value) {
<b class="nc">&nbsp;            return materialize().withIntegerValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withLongValue(long... value) {
<b class="nc">&nbsp;            return materialize().withLongValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withFloatValue(float... value) {
<b class="nc">&nbsp;            return materialize().withFloatValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withDoubleValue(double... value) {
<b class="nc">&nbsp;            return materialize().withDoubleValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withValue(Object... value) {
<b class="fc">&nbsp;            return materialize().withValue(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public WithImplicitType withReference(Object value) {
<b class="fc">&nbsp;            return materialize().withReference(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withReference(Object... value) {
<b class="fc">&nbsp;            return materialize().withReference(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withType(TypeDescription... typeDescription) {
<b class="nc">&nbsp;            return materialize().withType(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withInstance(JavaConstant... javaConstant) {
<b class="nc">&nbsp;            return materialize().withInstance(javaConstant);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withNullValue(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            return materialize().withNullValue(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withNullValue(TypeDescription... typeDescription) {
<b class="nc">&nbsp;            return materialize().withNullValue(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withArgument(int... index) {
<b class="nc">&nbsp;            return materialize().withArgument(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public WithImplicitType withArgument(int index) {
<b class="fc">&nbsp;            return materialize().withArgument(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withThis(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            return materialize().withThis(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withThis(TypeDescription... typeDescription) {
<b class="nc">&nbsp;            return materialize().withThis(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withMethodArguments() {
<b class="fc">&nbsp;            return materialize().withMethodArguments();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withImplicitAndMethodArguments() {
<b class="nc">&nbsp;            return materialize().withImplicitAndMethodArguments();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withField(String... fieldName) {
<b class="nc">&nbsp;            return materialize().withField(fieldName);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withEnumeration(EnumerationDescription... enumerationDescription) {
<b class="nc">&nbsp;            return materialize().withEnumeration(enumerationDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InvokeDynamic withField(FieldLocator.Factory fieldLocatorFactory, String... name) {
<b class="nc">&nbsp;            return materialize().withField(fieldLocatorFactory, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public WithImplicitType withField(String name) {
<b class="fc">&nbsp;            return materialize().withField(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public WithImplicitType withField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;            return materialize().withField(name, fieldLocatorFactory);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;            return materialize().withAssigner(assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation andThen(Implementation implementation) {
<b class="fc">&nbsp;            return materialize().andThen(implementation);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return materialize().prepare(instrumentedType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return materialize().appender(implementationTarget);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Representation of an {@link net.bytebuddy.implementation.InvokeDynamic} implementation where the bootstrapped
&nbsp;     * method is passed a {@code this} reference, if available, and any arguments of the instrumented method.
&nbsp;     */
&nbsp;    public static class WithImplicitArguments extends AbstractDelegator {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new dynamic method invocation with implicit arguments.
&nbsp;         *
&nbsp;         * @param bootstrap          The bootstrap method or constructor.
&nbsp;         * @param arguments          The arguments that are provided to the bootstrap method or constructor.
&nbsp;         * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;         * @param terminationHandler A handler that handles the method return.
&nbsp;         * @param assigner           The assigner to be used.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        protected WithImplicitArguments(MethodDescription.InDefinedShape bootstrap,
&nbsp;                                        List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                                        InvocationProvider invocationProvider,
&nbsp;                                        TerminationHandler terminationHandler,
&nbsp;                                        Assigner assigner,
&nbsp;                                        Assigner.Typing typing) {
<b class="fc">&nbsp;            super(bootstrap,</b>
&nbsp;                    arguments,
&nbsp;                    invocationProvider,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an instance of this instrumentation where the bootstrapped method is not passed any arguments.
&nbsp;         *
&nbsp;         * @return This implementation where the bootstrapped method is not passed any arguments.
&nbsp;         */
&nbsp;        public InvokeDynamic withoutArguments() {
<b class="fc">&nbsp;            return new InvokeDynamic(bootstrap,</b>
&nbsp;                    arguments,
<b class="fc">&nbsp;                    invocationProvider.withoutArguments(),</b>
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected InvokeDynamic materialize() {
<b class="fc">&nbsp;            return withoutArguments();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public WithImplicitArguments withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new WithImplicitArguments(bootstrap,</b>
&nbsp;                    arguments,
&nbsp;                    invocationProvider,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Representation of an {@link net.bytebuddy.implementation.InvokeDynamic} implementation where the bootstrapped
&nbsp;     * method is passed a {@code this} reference, if available, and any arguments of the instrumented method and
&nbsp;     * where the invocation target is implicit.
&nbsp;     */
&nbsp;    public static class WithImplicitTarget extends WithImplicitArguments {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new dynamic method invocation with implicit arguments and an implicit invocation target.
&nbsp;         *
&nbsp;         * @param bootstrap          The bootstrap method or constructor.
&nbsp;         * @param arguments          The arguments that are provided to the bootstrap method.
&nbsp;         * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;         * @param terminationHandler A handler that handles the method return.
&nbsp;         * @param assigner           The assigner to be used.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        protected WithImplicitTarget(MethodDescription.InDefinedShape bootstrap,
&nbsp;                                     List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                                     InvocationProvider invocationProvider,
&nbsp;                                     TerminationHandler terminationHandler,
&nbsp;                                     Assigner assigner,
&nbsp;                                     Assigner.Typing typing) {
<b class="fc">&nbsp;            super(bootstrap,</b>
&nbsp;                    arguments,
&nbsp;                    invocationProvider,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Requests the bootstrap method to bind a method with the given return type. The return type
&nbsp;         * is assigned to the intercepted method&#39;s return type.
&nbsp;         *
&nbsp;         * @param returnType The return type to request from the bootstrapping method.
&nbsp;         * @return This implementation where the bootstrap method is requested to bind a method with the given
&nbsp;         * return type.
&nbsp;         */
&nbsp;        public InvokeDynamic.WithImplicitArguments invoke(Class&lt;?&gt; returnType) {
<b class="nc">&nbsp;            return invoke(TypeDescription.ForLoadedType.of(returnType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Requests the bootstrap method to bind a method with the given return type. The return type
&nbsp;         * is assigned to the intercepted method&#39;s return type.
&nbsp;         *
&nbsp;         * @param returnType The return type to request from the bootstrapping method.
&nbsp;         * @return This implementation where the bootstrap method is requested to bind a method with the given
&nbsp;         * return type.
&nbsp;         */
&nbsp;        public InvokeDynamic.WithImplicitArguments invoke(TypeDescription returnType) {
<b class="nc">&nbsp;            return new WithImplicitArguments(bootstrap,</b>
&nbsp;                    arguments,
<b class="nc">&nbsp;                    invocationProvider.withReturnTypeProvider(new InvocationProvider.ReturnTypeProvider.ForExplicitType(returnType)),</b>
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Requests the bootstrap method is passed the given method name.
&nbsp;         *
&nbsp;         * @param methodName The method name to pass to the bootstrapping method.
&nbsp;         * @return This implementation where the bootstrap method is passed the given method name.
&nbsp;         */
&nbsp;        public InvokeDynamic.WithImplicitArguments invoke(String methodName) {
<b class="fc">&nbsp;            return new WithImplicitArguments(bootstrap,</b>
&nbsp;                    arguments,
<b class="fc">&nbsp;                    invocationProvider.withNameProvider(new InvocationProvider.NameProvider.ForExplicitName(methodName)),</b>
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Requests the bootstrap method to bind a method with the given return type. The return type
&nbsp;         * is assigned to the intercepted method&#39;s return type. Also, the bootstrap method is passed the
&nbsp;         * given method name.
&nbsp;         *
&nbsp;         * @param methodName The method name to pass to the bootstrapping method.
&nbsp;         * @param returnType The return type to request from the bootstrapping method.
&nbsp;         * @return This implementation where the bootstrap method is requested to bind a method with the given
&nbsp;         * return type while being passed the given method name.
&nbsp;         */
&nbsp;        public InvokeDynamic.WithImplicitArguments invoke(String methodName, Class&lt;?&gt; returnType) {
<b class="fc">&nbsp;            return invoke(methodName, TypeDescription.ForLoadedType.of(returnType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Requests the bootstrap method to bind a method with the given return type. The return type
&nbsp;         * is assigned to the intercepted method&#39;s return type. Also, the bootstrap method is passed the
&nbsp;         * given method name.
&nbsp;         *
&nbsp;         * @param methodName The method name to pass to the bootstrapping method.
&nbsp;         * @param returnType The return type to request from the bootstrapping method.
&nbsp;         * @return This implementation where the bootstrap method is requested to bind a method with the given
&nbsp;         * return type while being passed the given method name.
&nbsp;         */
&nbsp;        public InvokeDynamic.WithImplicitArguments invoke(String methodName, TypeDescription returnType) {
<b class="fc">&nbsp;            return new WithImplicitArguments(bootstrap,</b>
&nbsp;                    arguments,
&nbsp;                    invocationProvider
<b class="fc">&nbsp;                            .withNameProvider(new InvocationProvider.NameProvider.ForExplicitName(methodName))</b>
<b class="fc">&nbsp;                            .withReturnTypeProvider(new InvocationProvider.ReturnTypeProvider.ForExplicitType(returnType)),</b>
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An {@link InvokeDynamic} invocation where the last argument is assigned its implicit type.
&nbsp;     */
&nbsp;    public abstract static class WithImplicitType extends AbstractDelegator {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new abstract delegator for a dynamic method invocation where the last argument is assigned an implicit type.
&nbsp;         *
&nbsp;         * @param bootstrap          The bootstrap method or constructor.
&nbsp;         * @param arguments          The arguments that are provided to the bootstrap method or constructor.
&nbsp;         * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;         * @param terminationHandler A handler that handles the method return.
&nbsp;         * @param assigner           The assigner to be used.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        protected WithImplicitType(MethodDescription.InDefinedShape bootstrap,
&nbsp;                                   List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                                   InvocationProvider invocationProvider,
&nbsp;                                   TerminationHandler terminationHandler,
&nbsp;                                   Assigner assigner,
&nbsp;                                   Assigner.Typing typing) {
<b class="fc">&nbsp;            super(bootstrap, arguments, invocationProvider, terminationHandler, assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the last value as an instance of the given type.
&nbsp;         *
&nbsp;         * @param type The type to represent to the dynamic method invocation.
&nbsp;         * @return A new dynamic method invocation where the last argument is represented by the given type.
&nbsp;         */
&nbsp;        public InvokeDynamic as(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return as(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the last value as an instance of the given type.
&nbsp;         *
&nbsp;         * @param typeDescription The type to represent to the dynamic method invocation.
&nbsp;         * @return A new dynamic method invocation where the last argument is represented by the given type.
&nbsp;         */
&nbsp;        public abstract InvokeDynamic as(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * A step in the invoke dynamic domain specific language that allows to explicitly specify a field type for a reference value.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;, justification = &quot;Super type implementation covers use case&quot;)
&nbsp;        protected static class OfInstance extends WithImplicitType {
&nbsp;
&nbsp;            /**
&nbsp;             * The value that is supplied as the next argument to the bootstrapped method.
&nbsp;             */
&nbsp;            private final Object value;
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider that represents the argument with an implicit type.
&nbsp;             */
&nbsp;            private final InvocationProvider.ArgumentProvider argumentProvider;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new invoke dynamic instance with an implicit field type for the provided value.
&nbsp;             *
&nbsp;             * @param bootstrap          The bootstrap method or constructor.
&nbsp;             * @param arguments          The arguments that are provided to the bootstrap method or constructor.
&nbsp;             * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;             * @param terminationHandler A handler that handles the method return.
&nbsp;             * @param assigner           The assigner to be used.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param value              The value that is supplied as the next argument to the bootstrapped method.
&nbsp;             */
&nbsp;            protected OfInstance(MethodDescription.InDefinedShape bootstrap,
&nbsp;                                 List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                                 InvocationProvider invocationProvider,
&nbsp;                                 TerminationHandler terminationHandler,
&nbsp;                                 Assigner assigner,
&nbsp;                                 Assigner.Typing typing,
&nbsp;                                 Object value) {
<b class="fc">&nbsp;                super(bootstrap, arguments, invocationProvider, terminationHandler, assigner, typing);</b>
<b class="fc">&nbsp;                this.value = value;</b>
<b class="fc">&nbsp;                this.argumentProvider = InvocationProvider.ArgumentProvider.ForInstance.of(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InvokeDynamic as(TypeDescription typeDescription) {
<b class="fc">&nbsp;                if (!typeDescription.asBoxed().isInstance(value)) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of type &quot; + typeDescription);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new InvokeDynamic(bootstrap,</b>
&nbsp;                        arguments,
<b class="fc">&nbsp;                        invocationProvider.appendArgument(new InvocationProvider.ArgumentProvider.ForInstance(value, typeDescription)),</b>
&nbsp;                        terminationHandler,
&nbsp;                        assigner,
&nbsp;                        typing);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected InvokeDynamic materialize() {
<b class="fc">&nbsp;                return new InvokeDynamic(bootstrap,</b>
&nbsp;                        arguments,
<b class="fc">&nbsp;                        invocationProvider.appendArgument(argumentProvider),</b>
&nbsp;                        terminationHandler,
&nbsp;                        assigner,
&nbsp;                        typing);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An invoke dynamic implementation where the last argument is an implicitly typed method argument.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;, justification = &quot;Super type implementation covers use case&quot;)
&nbsp;        protected static class OfArgument extends WithImplicitType {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of the method argument.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new invoke dynamic instance with an implicit field type for the provided value.
&nbsp;             *
&nbsp;             * @param bootstrap          The bootstrap method or constructor.
&nbsp;             * @param arguments          The arguments that are provided to the bootstrap method or constructor.
&nbsp;             * @param invocationProvider The target provided that identifies the method to be bootstrapped.
&nbsp;             * @param terminationHandler A handler that handles the method return.
&nbsp;             * @param assigner           The assigner to be used.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param index              The index of of the argument to supply to the bootstrapped method.
&nbsp;             */
&nbsp;            protected OfArgument(MethodDescription.InDefinedShape bootstrap,
&nbsp;                                 List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                                 InvocationProvider invocationProvider,
&nbsp;                                 TerminationHandler terminationHandler,
&nbsp;                                 Assigner assigner,
&nbsp;                                 Assigner.Typing typing,
&nbsp;                                 int index) {
<b class="fc">&nbsp;                super(bootstrap, arguments, invocationProvider, terminationHandler, assigner, typing);</b>
<b class="fc">&nbsp;                this.index = index;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InvokeDynamic as(TypeDescription typeDescription) {
<b class="nc">&nbsp;                return new InvokeDynamic(bootstrap,</b>
&nbsp;                        arguments,
<b class="nc">&nbsp;                        invocationProvider.appendArgument(new InvocationProvider.ArgumentProvider.ForMethodParameter.WithExplicitType(index, typeDescription)),</b>
&nbsp;                        terminationHandler,
&nbsp;                        assigner,
&nbsp;                        typing);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected InvokeDynamic materialize() {
<b class="fc">&nbsp;                return new InvokeDynamic(bootstrap,</b>
&nbsp;                        arguments,
<b class="fc">&nbsp;                        invocationProvider.appendArgument(new InvocationProvider.ArgumentProvider.ForMethodParameter(index)),</b>
&nbsp;                        terminationHandler,
&nbsp;                        assigner,
&nbsp;                        typing);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An invoke dynamic implementation where the last argument is an implicitly typed field value.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EQ_DOESNT_OVERRIDE_EQUALS&quot;, justification = &quot;Super type implementation covers use case&quot;)
&nbsp;        protected static class OfField extends WithImplicitType {
&nbsp;
&nbsp;            /**
&nbsp;             * The field name.
&nbsp;             */
&nbsp;            private final String fieldName;
&nbsp;
&nbsp;            /**
&nbsp;             * The field locator factory to use.
&nbsp;             */
&nbsp;            private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new abstract delegator for a dynamic method invocation where the last argument is assigned an implicit type.
&nbsp;             *
&nbsp;             * @param bootstrap           The bootstrap method or constructor.
&nbsp;             * @param arguments           The arguments that are provided to the bootstrap method.
&nbsp;             * @param invocationProvider  The target provided that identifies the method to be bootstrapped.
&nbsp;             * @param terminationHandler  A handler that handles the method return.
&nbsp;             * @param assigner            The assigner to be used.
&nbsp;             * @param typing              Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param fieldName           The field name.
&nbsp;             * @param fieldLocatorFactory The field locator factory to use.
&nbsp;             */
&nbsp;            protected OfField(MethodDescription.InDefinedShape bootstrap,
&nbsp;                              List&lt;? extends JavaConstant&gt; arguments,
&nbsp;                              InvocationProvider invocationProvider,
&nbsp;                              TerminationHandler terminationHandler,
&nbsp;                              Assigner assigner,
&nbsp;                              Assigner.Typing typing,
&nbsp;                              String fieldName,
&nbsp;                              FieldLocator.Factory fieldLocatorFactory) {
<b class="fc">&nbsp;                super(bootstrap, arguments, invocationProvider, terminationHandler, assigner, typing);</b>
<b class="fc">&nbsp;                this.fieldName = fieldName;</b>
<b class="fc">&nbsp;                this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public InvokeDynamic as(TypeDescription typeDescription) {
<b class="fc">&nbsp;                return new InvokeDynamic(bootstrap,</b>
&nbsp;                        arguments,
<b class="fc">&nbsp;                        invocationProvider.appendArgument(new InvocationProvider.ArgumentProvider.ForField.WithExplicitType(fieldName, fieldLocatorFactory, typeDescription)),</b>
&nbsp;                        terminationHandler,
&nbsp;                        assigner,
&nbsp;                        typing);
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected InvokeDynamic materialize() {
<b class="fc">&nbsp;                return new InvokeDynamic(bootstrap,</b>
&nbsp;                        arguments,
<b class="fc">&nbsp;                        invocationProvider.appendArgument(new InvocationProvider.ArgumentProvider.ForField(fieldName, fieldLocatorFactory)),</b>
&nbsp;                        terminationHandler,
&nbsp;                        assigner,
&nbsp;                        typing);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The byte code appender to be used by the {@link net.bytebuddy.implementation.InvokeDynamic} implementation.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;    protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type of the current implementation.
&nbsp;         */
&nbsp;        private final TypeDescription instrumentedType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new byte code appender for an invoke dynamic implementation.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type of the current implementation.
&nbsp;         */
<b class="fc">&nbsp;        public Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;            this.instrumentedType = instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            InvocationProvider.Target.Resolved target = invocationProvider.make(instrumentedMethod).resolve(instrumentedType, assigner, typing);</b>
<b class="fc">&nbsp;            StackManipulation.Size size = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                    target.getStackManipulation(),</b>
<b class="fc">&nbsp;                    MethodInvocation.invoke(bootstrap).dynamic(target.getInternalName(),</b>
<b class="fc">&nbsp;                            target.getReturnType(),</b>
<b class="fc">&nbsp;                            target.getParameterTypes(),</b>
&nbsp;                            arguments),
<b class="fc">&nbsp;                    terminationHandler.resolve(instrumentedMethod, target.getReturnType(), assigner, typing)</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;            return new Size(size.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 15:48</div>
</div>
</body>
</html>
