


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ByteArrayClassLoader</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.loading</a>
</div>

<h1>Coverage Summary for Class: ByteArrayClassLoader (net.bytebuddy.dynamic.loading)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ByteArrayClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (20/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.1%
  </span>
  <span class="absValue">
    (67/72)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ByteArrayClassLoader$1</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$ChildFirst</td>
<td class="coverageStat">
  <span class="percent">
    56.2%
  </span>
  <span class="absValue">
    (9/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.3%
  </span>
  <span class="absValue">
    (45/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$ChildFirst$PrependingEnumeration</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$ClassDefinitionAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (20/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$EmptyEnumeration</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$2MaAeVwg</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$8rafWI7p</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$b3bsoypr</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$d1oYA0gA</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$DXzmPBCg</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$dzvGLEWT</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$eQEHDzKM</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$ErFFllPB</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$fjDmTPhW</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$FOl7Ok3f</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$IEevGSyO</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$JDa6RBPJ</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$kH7kKg1b</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$L0ELMK1I</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$lwTNqJnc</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$qxEaYraK</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$RYbjsGTr</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$T7qPJeHp</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$TCZMqmPm</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$tOQoBypZ</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$Ugr05RiJ</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$uUQinmga</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$wAjGw3A6</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$yUEshfAv</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$zmDDRSqk</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$zMfljQ0b</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$zpURffHr</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$MockitoMock$204387921$auxiliary$Zr9KQamr</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PackageLookupStrategy</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PackageLookupStrategy$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PackageLookupStrategy$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PackageLookupStrategy$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler$UrlDefinitionAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (10/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler$UrlDefinitionAction$ByteArrayUrlStreamHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler$UrlDefinitionAction$ByteArrayUrlStreamHandler$ByteArrayUrlConnection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$PersistenceHandler$UrlDefinitionAction$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SingletonEnumeration</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SynchronizationStrategy</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SynchronizationStrategy$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (9/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SynchronizationStrategy$ForJava7CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SynchronizationStrategy$ForJava8CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SynchronizationStrategy$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteArrayClassLoader$SynchronizationStrategy$Initializable</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (78/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.6%
  </span>
  <span class="absValue">
    (219/275)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic.loading;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.UnsupportedEncodingException;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.*;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * A {@link java.lang.ClassLoader} that is capable of loading explicitly defined classes. The class loader will free
&nbsp; * any binary resources once a class that is defined by its binary data is loaded. This class loader is thread safe since
&nbsp; * the class loading mechanics are only called from synchronized context.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: Instances of this class loader return URLs for their represented class loaders with the &lt;i&gt;bytebuddy&lt;/i&gt; schema.
&nbsp; * These URLs do not represent URIs as two classes with the same name yield identical URLs but might represents different byte
&nbsp; * arrays.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: Any class and package definition is performed using the creator&#39;s {@code java.security.AccessControlContext}.
&nbsp; * &lt;/p&gt;
&nbsp; */
<b class="fc">&nbsp;public class ByteArrayClassLoader extends InjectionClassLoader {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The schema for URLs that represent a class file of byte array class loaders.
&nbsp;     */
&nbsp;    public static final String URL_SCHEMA = &quot;bytebuddy&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that an array should be included from its first index. Improves the source code readability.
&nbsp;     */
&nbsp;    private static final int FROM_BEGINNING = 0;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that a URL does not exist to improve code readability.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final URL NO_URL = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A strategy for locating a package by name.
&nbsp;     */
<b class="fc">&nbsp;    private static final PackageLookupStrategy PACKAGE_LOOKUP_STRATEGY = doPrivileged(PackageLookupStrategy.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The synchronization engine for the executing JVM.
&nbsp;     */
<b class="fc">&nbsp;    protected static final SynchronizationStrategy.Initializable SYNCHRONIZATION_STRATEGY = doPrivileged(SynchronizationStrategy.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;    /*
&nbsp;     * Register class loader as parallel capable if the current VM supports it.
&nbsp;     */
&nbsp;    static {
<b class="fc">&nbsp;        doRegisterAsParallelCapable();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Registers class loader as parallel capable if possible.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Must be invoked from targeting class loader type.&quot;)
&nbsp;    private static void doRegisterAsParallelCapable() {
&nbsp;        try {
<b class="fc">&nbsp;            Method method = ClassLoader.class.getDeclaredMethod(&quot;registerAsParallelCapable&quot;);</b>
<b class="fc">&nbsp;            method.setAccessible(true);</b>
<b class="fc">&nbsp;            method.invoke(null);</b>
<b class="nc">&nbsp;        } catch (Throwable ignored) {</b>
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;     *
&nbsp;     * @param action The action to execute from a privileged context.
&nbsp;     * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;     * @return The action&#39;s resolved value.
&nbsp;     */
&nbsp;    @AccessControllerPlugin.Enhance
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;        return action.run();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A mutable map of type names mapped to their binary representation.
&nbsp;     */
&nbsp;    protected final ConcurrentMap&lt;String, byte[]&gt; typeDefinitions;
&nbsp;
&nbsp;    /**
&nbsp;     * The persistence handler of this class loader.
&nbsp;     */
&nbsp;    protected final PersistenceHandler persistenceHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The protection domain to apply. Might be {@code null} when referencing the default protection domain.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    protected final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;    /**
&nbsp;     * The package definer to be queried for package definitions.
&nbsp;     */
&nbsp;    protected final PackageDefinitionStrategy packageDefinitionStrategy;
&nbsp;
&nbsp;    /**
&nbsp;     * The class file transformer to apply on loaded classes.
&nbsp;     */
&nbsp;    protected final ClassFilePostProcessor classFilePostProcessor;
&nbsp;
&nbsp;    /**
&nbsp;     * The access control context to use for loading classes or {@code null} if this is not supported on the current VM.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    protected final Object accessControlContext;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent          The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param typeDefinitions A map of fully qualified class names pointing to their binary representations.
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent, Map&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;        this(parent, true, typeDefinitions);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent          The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param sealed          {@code true} if this class loader is sealed.
&nbsp;     * @param typeDefinitions A map of fully qualified class names pointing to their binary representations.
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent, boolean sealed, Map&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;        this(parent, sealed, typeDefinitions, PersistenceHandler.LATENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent             The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param typeDefinitions    A map of fully qualified class names pointing to their binary representations.
&nbsp;     * @param persistenceHandler The persistence handler of this class loader.
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent, Map&lt;String, byte[]&gt; typeDefinitions, PersistenceHandler persistenceHandler) {
<b class="fc">&nbsp;        this(parent, true, typeDefinitions, persistenceHandler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent             The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param sealed             {@code true} if this class loader is sealed.
&nbsp;     * @param typeDefinitions    A map of fully qualified class names pointing to their binary representations.
&nbsp;     * @param persistenceHandler The persistence handler of this class loader.
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent, boolean sealed, Map&lt;String, byte[]&gt; typeDefinitions, PersistenceHandler persistenceHandler) {
<b class="fc">&nbsp;        this(parent, sealed, typeDefinitions, ClassLoadingStrategy.NO_PROTECTION_DOMAIN, persistenceHandler, PackageDefinitionStrategy.Trivial.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;     * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;     * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;     * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent,
&nbsp;                                Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                                @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                PersistenceHandler persistenceHandler,
&nbsp;                                PackageDefinitionStrategy packageDefinitionStrategy) {
<b class="fc">&nbsp;        this(parent, true, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param sealed                    {@code true} if this class loader is sealed.
&nbsp;     * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;     * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;     * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;     * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent,
&nbsp;                                boolean sealed,
&nbsp;                                Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                                @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                PersistenceHandler persistenceHandler,
&nbsp;                                PackageDefinitionStrategy packageDefinitionStrategy) {
<b class="fc">&nbsp;        this(parent, sealed, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy, ClassFilePostProcessor.NoOp.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;     * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;     * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;     * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;     * @param classFilePostProcessor    A post processor for class files to apply p
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent,
&nbsp;                                Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                                @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                PersistenceHandler persistenceHandler,
&nbsp;                                PackageDefinitionStrategy packageDefinitionStrategy,
&nbsp;                                ClassFilePostProcessor classFilePostProcessor) {
<b class="nc">&nbsp;        this(parent, true, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy, classFilePostProcessor);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new class loader for a given definition of classes.
&nbsp;     *
&nbsp;     * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;     * @param sealed                    {@code true} if this class loader is sealed.
&nbsp;     * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;     * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;     * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;     * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;     * @param classFilePostProcessor    A post processor for class files to apply p
&nbsp;     */
&nbsp;    public ByteArrayClassLoader(@MaybeNull ClassLoader parent,
&nbsp;                                boolean sealed,
&nbsp;                                Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                                @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                PersistenceHandler persistenceHandler,
&nbsp;                                PackageDefinitionStrategy packageDefinitionStrategy,
&nbsp;                                ClassFilePostProcessor classFilePostProcessor) {
<b class="fc">&nbsp;        super(parent, sealed);</b>
<b class="fc">&nbsp;        this.typeDefinitions = new ConcurrentHashMap&lt;String, byte[]&gt;(typeDefinitions);</b>
<b class="fc">&nbsp;        this.protectionDomain = protectionDomain;</b>
<b class="fc">&nbsp;        this.persistenceHandler = persistenceHandler;</b>
<b class="fc">&nbsp;        this.packageDefinitionStrategy = packageDefinitionStrategy;</b>
<b class="fc">&nbsp;        this.classFilePostProcessor = classFilePostProcessor;</b>
<b class="fc">&nbsp;        accessControlContext = getContext();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#getContext} that is activated if available.
&nbsp;     *
&nbsp;     * @return The current access control context or {@code null} if the current VM does not support it.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @AccessControllerPlugin.Enhance
&nbsp;    private static Object getContext() {
<b class="fc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;     *
&nbsp;     * @param action  The action to execute from a privileged context.
&nbsp;     * @param context The access control context or {@code null} if the current VM does not support it.
&nbsp;     * @param &lt;T&gt;     The type of the action&#39;s resolved value.
&nbsp;     * @return The action&#39;s resolved value.
&nbsp;     */
&nbsp;    @AccessControllerPlugin.Enhance
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action, @MaybeNull @SuppressWarnings(&quot;unused&quot;) Object context) {
<b class="fc">&nbsp;        return action.run();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves a method handle in the scope of the {@link ByteArrayClassLoader} class.
&nbsp;     *
&nbsp;     * @return A method handle for this class.
&nbsp;     * @throws Exception If the method handle facility is not supported by the current virtual machine.
&nbsp;     */
&nbsp;    private static Object methodHandle() throws Exception {
<b class="fc">&nbsp;        return Class.forName(&quot;java.lang.invoke.MethodHandles&quot;).getMethod(&quot;lookup&quot;).invoke(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a given set of class descriptions and their binary representations.
&nbsp;     *
&nbsp;     * @param classLoader The parent class loader.
&nbsp;     * @param types       The unloaded types to be loaded.
&nbsp;     * @return A map of the given type descriptions pointing to their loaded representations.
&nbsp;     */
&nbsp;    public static Map&lt;TypeDescription, Class&lt;?&gt;&gt; load(@MaybeNull ClassLoader classLoader, Map&lt;TypeDescription, byte[]&gt; types) {
<b class="nc">&nbsp;        return load(classLoader,</b>
&nbsp;                types,
&nbsp;                ClassLoadingStrategy.NO_PROTECTION_DOMAIN,
&nbsp;                PersistenceHandler.LATENT,
&nbsp;                PackageDefinitionStrategy.Trivial.INSTANCE,
&nbsp;                false,
&nbsp;                true);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a given set of class descriptions and their binary representations.
&nbsp;     *
&nbsp;     * @param classLoader               The parent class loader.
&nbsp;     * @param types                     The unloaded types to be loaded.
&nbsp;     * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;     * @param persistenceHandler        The persistence handler of the created class loader.
&nbsp;     * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;     * @param forbidExisting            {@code true} if the class loading should throw an exception if a class was already loaded by a parent class loader.
&nbsp;     * @param sealed                    {@code true} if the class loader should be sealed.
&nbsp;     * @return A map of the given type descriptions pointing to their loaded representations.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;    public static Map&lt;TypeDescription, Class&lt;?&gt;&gt; load(@MaybeNull ClassLoader classLoader,
&nbsp;                                                      Map&lt;TypeDescription, byte[]&gt; types,
&nbsp;                                                      @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                                      PersistenceHandler persistenceHandler,
&nbsp;                                                      PackageDefinitionStrategy packageDefinitionStrategy,
&nbsp;                                                      boolean forbidExisting,
&nbsp;                                                      boolean sealed) {
<b class="fc">&nbsp;        Map&lt;String, byte[]&gt; typesByName = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;            typesByName.put(entry.getKey().getName(), entry.getValue());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        classLoader = new ByteArrayClassLoader(classLoader,</b>
&nbsp;                sealed,
&nbsp;                typesByName,
&nbsp;                protectionDomain,
&nbsp;                persistenceHandler,
&nbsp;                packageDefinitionStrategy,
&nbsp;                ClassFilePostProcessor.NoOp.INSTANCE);
<b class="fc">&nbsp;        Map&lt;TypeDescription, Class&lt;?&gt;&gt; result = new LinkedHashMap&lt;TypeDescription, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;        for (TypeDescription typeDescription : types.keySet()) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                Class&lt;?&gt; type = Class.forName(typeDescription.getName(), false, classLoader);</b>
<b class="fc">&nbsp;                if (!GraalImageCode.getCurrent().isNativeImageExecution() &amp;&amp; forbidExisting &amp;&amp; type.getClassLoader() != classLoader) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Class already loaded: &quot; + type);</b>
&nbsp;                }
<b class="fc">&nbsp;                result.put(typeDescription, type);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot load class &quot; + typeDescription, exception);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return result;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    protected Map&lt;String, Class&lt;?&gt;&gt; doDefineClasses(Map&lt;String, byte[]&gt; typeDefinitions) throws ClassNotFoundException {
<b class="fc">&nbsp;        Map&lt;String, byte[]&gt; previous = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, byte[]&gt; entry : typeDefinitions.entrySet()) {</b>
<b class="fc">&nbsp;            previous.put(entry.getKey(), this.typeDefinitions.putIfAbsent(entry.getKey(), entry.getValue()));</b>
<b class="fc">&nbsp;        }</b>
&nbsp;        try {
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; types = new LinkedHashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (String name : typeDefinitions.keySet()) {</b>
<b class="fc">&nbsp;                synchronized (SYNCHRONIZATION_STRATEGY.initialize().getClassLoadingLock(this, name)) {</b>
<b class="fc">&nbsp;                    types.put(name, loadClass(name));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return types;</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            for (Map.Entry&lt;String, byte[]&gt; entry : previous.entrySet()) {</b>
<b class="fc">&nbsp;                if (entry.getValue() == null) {</b>
<b class="fc">&nbsp;                    persistenceHandler.release(entry.getKey(), this.typeDefinitions);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    this.typeDefinitions.put(entry.getKey(), entry.getValue());</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
<b class="fc">&nbsp;        byte[] binaryRepresentation = persistenceHandler.lookup(name, typeDefinitions);</b>
<b class="fc">&nbsp;        if (binaryRepresentation == null) {</b>
<b class="fc">&nbsp;            throw new ClassNotFoundException(name);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return doPrivileged(new ClassDefinitionAction(name, classFilePostProcessor.transform(this,</b>
&nbsp;                    name,
&nbsp;                    protectionDomain,
&nbsp;                    binaryRepresentation)), accessControlContext);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    protected URL findResource(String name) {
<b class="fc">&nbsp;        return persistenceHandler.url(name, typeDefinitions);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    protected Enumeration&lt;URL&gt; findResources(String name) {
<b class="fc">&nbsp;        URL url = persistenceHandler.url(name, typeDefinitions);</b>
<b class="fc">&nbsp;        return url == null</b>
<b class="fc">&nbsp;                ? EmptyEnumeration.INSTANCE</b>
<b class="fc">&nbsp;                : new SingletonEnumeration(url);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the package for a given name.
&nbsp;     *
&nbsp;     * @param name The name of the package.
&nbsp;     * @return A suitable package or {@code null} if no such package exists.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;    private Package doGetPackage(String name) {
<b class="fc">&nbsp;        return getPackage(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An engine for receiving a &lt;i&gt;class loading lock&lt;/i&gt; when loading a class.
&nbsp;     */
&nbsp;    protected interface SynchronizationStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Receives the class loading lock.
&nbsp;         *
&nbsp;         * @param name        The name of the class being loaded.
&nbsp;         * @param classLoader The class loader loading the class.
&nbsp;         * @return The corresponding class loading lock.
&nbsp;         */
&nbsp;        Object getClassLoadingLock(ByteArrayClassLoader classLoader, String name);
&nbsp;
&nbsp;        /**
&nbsp;         * An uninitialized synchronization strategy.
&nbsp;         */
&nbsp;        interface Initializable {
&nbsp;
&nbsp;            /**
&nbsp;             * Initializes this synchronization strategy.
&nbsp;             *
&nbsp;             * @return The synchronization strategy to use.
&nbsp;             */
&nbsp;            SynchronizationStrategy initialize();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A creation action for a synchronization strategy.
&nbsp;         */
<b class="fc">&nbsp;        enum CreationAction implements PrivilegedAction&lt;Initializable&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;            public Initializable run() {
&nbsp;                try {
&nbsp;                    try {
<b class="fc">&nbsp;                        Class&lt;?&gt; methodType = Class.forName(&quot;java.lang.invoke.MethodType&quot;), methodHandle = Class.forName(&quot;java.lang.invoke.MethodHandle&quot;);</b>
<b class="fc">&nbsp;                        return new ForJava8CapableVm(Class.forName(&quot;java.lang.invoke.MethodHandles$Lookup&quot;)</b>
<b class="fc">&nbsp;                                .getMethod(&quot;findVirtual&quot;, Class.class, String.class, methodType)</b>
<b class="fc">&nbsp;                                .invoke(ByteArrayClassLoader.methodHandle(), ClassLoader.class, &quot;getClassLoadingLock&quot;, methodType.getMethod(&quot;methodType&quot;,</b>
&nbsp;                                        Class.class,
<b class="fc">&nbsp;                                        Class[].class).invoke(null, Object.class, new Class&lt;?&gt;[]{String.class})),</b>
<b class="fc">&nbsp;                                methodHandle.getMethod(&quot;bindTo&quot;, Object.class),</b>
<b class="fc">&nbsp;                                methodHandle.getMethod(&quot;invokeWithArguments&quot;, Object[].class));</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
&nbsp;                        // On the bootstrap class loader, a lookup instance cannot be located reflectively. To avoid issuing a warning for accessing
&nbsp;                        // a protected method from outside of a class that is caused if the module system does not offer accessing the method.
<b class="nc">&nbsp;                        return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V9) &amp;&amp; ByteArrayClassLoader.class.getClassLoader() == null</b>
<b class="nc">&nbsp;                                ? SynchronizationStrategy.ForLegacyVm.INSTANCE</b>
<b class="nc">&nbsp;                                : new ForJava7CapableVm(ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                    return SynchronizationStrategy.ForLegacyVm.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A synchronization engine for a VM that is not aware of parallel-capable class loaders.
&nbsp;         */
<b class="fc">&nbsp;        enum ForLegacyVm implements SynchronizationStrategy, Initializable {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object getClassLoadingLock(ByteArrayClassLoader classLoader, String name) {
<b class="fc">&nbsp;                return classLoader;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SynchronizationStrategy initialize() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A synchronization engine for a VM that is aware of parallel-capable class loaders.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForJava7CapableVm implements SynchronizationStrategy, Initializable {
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code ClassLoader#getClassLoadingLock(String)} method.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new synchronization strategy.
&nbsp;             *
&nbsp;             * @param method The {@code ClassLoader#getClassLoadingLock(String)} method.
&nbsp;             */
<b class="nc">&nbsp;            protected ForJava7CapableVm(Method method) {</b>
<b class="nc">&nbsp;                this.method = method;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object getClassLoadingLock(ByteArrayClassLoader classLoader, String name) {
&nbsp;                try {
<b class="nc">&nbsp;                    return method.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;            public SynchronizationStrategy initialize() {
&nbsp;                try {
<b class="nc">&nbsp;                    method.setAccessible(true);</b>
<b class="nc">&nbsp;                    return this;</b>
<b class="nc">&nbsp;                } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                    return ForLegacyVm.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A synchronization engine for a VM that is aware of parallel-capable class loaders using method handles to respect module boundaries.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForJava8CapableVm implements SynchronizationStrategy, Initializable {
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.lang.invoke.MethodHandle} to use.
&nbsp;             */
&nbsp;            private final Object methodHandle;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.lang.invoke.MethodHandle#bindTo(Object)} method.
&nbsp;             */
&nbsp;            private final Method bindTo;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.lang.invoke.MethodHandle#invokeWithArguments(Object[])} method.
&nbsp;             */
&nbsp;            private final Method invokeWithArguments;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new synchronization strategy.
&nbsp;             *
&nbsp;             * @param methodHandle        The {@code java.lang.invoke.MethodHandle} to use.
&nbsp;             * @param bindTo              The {@code java.lang.invoke.MethodHandle#bindTo(Object)} method.
&nbsp;             * @param invokeWithArguments The {@code java.lang.invoke.MethodHandle#invokeWithArguments(Object[])} method.
&nbsp;             */
<b class="fc">&nbsp;            protected ForJava8CapableVm(Object methodHandle, Method bindTo, Method invokeWithArguments) {</b>
<b class="fc">&nbsp;                this.methodHandle = methodHandle;</b>
<b class="fc">&nbsp;                this.bindTo = bindTo;</b>
<b class="fc">&nbsp;                this.invokeWithArguments = invokeWithArguments;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SynchronizationStrategy initialize() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object getClassLoadingLock(ByteArrayClassLoader classLoader, String name) {
&nbsp;                try {
<b class="fc">&nbsp;                    return invokeWithArguments.invoke(bindTo.invoke(methodHandle, classLoader), (Object) new Object[]{name});</b>
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An action for defining a located class that is not yet loaded.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;    protected class ClassDefinitionAction implements PrivilegedAction&lt;Class&lt;?&gt;&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The binary name of the class to define.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The binary representation of the class to be loaded.
&nbsp;         */
&nbsp;        private final byte[] binaryRepresentation;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class definition action.
&nbsp;         *
&nbsp;         * @param name                 The binary name of the class to define.
&nbsp;         * @param binaryRepresentation The binary representation of the class to be loaded.
&nbsp;         */
<b class="fc">&nbsp;        protected ClassDefinitionAction(String name, byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Class&lt;?&gt; run() {
<b class="fc">&nbsp;            int packageIndex = name.lastIndexOf(&#39;.&#39;);</b>
<b class="fc">&nbsp;            if (packageIndex != -1) {</b>
<b class="fc">&nbsp;                String packageName = name.substring(0, packageIndex);</b>
<b class="fc">&nbsp;                PackageDefinitionStrategy.Definition definition = packageDefinitionStrategy.define(ByteArrayClassLoader.this, packageName, name);</b>
<b class="fc">&nbsp;                if (definition.isDefined()) {</b>
<b class="fc">&nbsp;                    Package definedPackage = PACKAGE_LOOKUP_STRATEGY.apply(ByteArrayClassLoader.this, packageName);</b>
<b class="fc">&nbsp;                    if (definedPackage == null) {</b>
<b class="fc">&nbsp;                        definePackage(packageName,</b>
<b class="fc">&nbsp;                                definition.getSpecificationTitle(),</b>
<b class="fc">&nbsp;                                definition.getSpecificationVersion(),</b>
<b class="fc">&nbsp;                                definition.getSpecificationVendor(),</b>
<b class="fc">&nbsp;                                definition.getImplementationTitle(),</b>
<b class="fc">&nbsp;                                definition.getImplementationVersion(),</b>
<b class="fc">&nbsp;                                definition.getImplementationVendor(),</b>
<b class="fc">&nbsp;                                definition.getSealBase());</b>
<b class="fc">&nbsp;                    } else if (!definition.isCompatibleTo(definedPackage)) {</b>
<b class="nc">&nbsp;                        throw new SecurityException(&quot;Sealing violation for package &quot; + packageName);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return defineClass(name, binaryRepresentation, FROM_BEGINNING, binaryRepresentation.length, protectionDomain);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A package lookup strategy for locating a package by name.
&nbsp;     */
&nbsp;    protected interface PackageLookupStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a package for a given byte array class loader and a name.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to locate a package for.
&nbsp;         * @param name        The name of the package.
&nbsp;         * @return A suitable package or {@code null} if no such package exists.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Package apply(ByteArrayClassLoader classLoader, String name);
&nbsp;
&nbsp;        /**
&nbsp;         * A creation action for a package lookup strategy.
&nbsp;         */
<b class="fc">&nbsp;        enum CreationAction implements PrivilegedAction&lt;PackageLookupStrategy&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;            public PackageLookupStrategy run() {
<b class="fc">&nbsp;                if (JavaModule.isSupported()) { // Avoid accidental lookup of method with same name in Java 8 J9 VM.</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return new PackageLookupStrategy.ForJava9CapableVm(ClassLoader.class.getMethod(&quot;getDefinedPackage&quot;, String.class));</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                        return PackageLookupStrategy.ForLegacyVm.INSTANCE;</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    return PackageLookupStrategy.ForLegacyVm.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A package lookup strategy for a VM prior to Java 9.
&nbsp;         */
<b class="fc">&nbsp;        enum ForLegacyVm implements PackageLookupStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Package apply(ByteArrayClassLoader classLoader, String name) {
<b class="fc">&nbsp;                return classLoader.doGetPackage(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A package lookup strategy for Java 9 or newer.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForJava9CapableVm implements PackageLookupStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.lang.ClassLoader#getDefinedPackage(String)} method.
&nbsp;             */
&nbsp;            private final Method getDefinedPackage;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new package lookup strategy for a modern VM.
&nbsp;             *
&nbsp;             * @param getDefinedPackage The {@code java.lang.ClassLoader#getDefinedPackage(String)} method.
&nbsp;             */
<b class="fc">&nbsp;            protected ForJava9CapableVm(Method getDefinedPackage) {</b>
<b class="fc">&nbsp;                this.getDefinedPackage = getDefinedPackage;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Package apply(ByteArrayClassLoader classLoader, String name) {
&nbsp;                try {
<b class="fc">&nbsp;                    return (Package) getDefinedPackage.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A persistence handler decides on whether the byte array that represents a loaded class is exposed by
&nbsp;     * the {@link java.lang.ClassLoader#getResourceAsStream(String)} method.
&nbsp;     */
<b class="fc">&nbsp;    public enum PersistenceHandler {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The manifest persistence handler retains all class file representations and makes them accessible.
&nbsp;         */
<b class="fc">&nbsp;        MANIFEST(true) {</b>
&nbsp;            @Override
&nbsp;            protected byte[] lookup(String name, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;                return typeDefinitions.get(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected URL url(String resourceName, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;                if (!resourceName.endsWith(CLASS_FILE_SUFFIX)) {</b>
<b class="nc">&nbsp;                    return NO_URL;</b>
<b class="fc">&nbsp;                } else if (resourceName.startsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;                    resourceName = resourceName.substring(1);</b>
&nbsp;                }
<b class="fc">&nbsp;                String typeName = resourceName.replace(&#39;/&#39;, &#39;.&#39;).substring(FROM_BEGINNING, resourceName.length() - CLASS_FILE_SUFFIX.length());</b>
<b class="fc">&nbsp;                byte[] binaryRepresentation = typeDefinitions.get(typeName);</b>
<b class="fc">&nbsp;                return binaryRepresentation == null</b>
<b class="fc">&nbsp;                        ? NO_URL</b>
<b class="fc">&nbsp;                        : doPrivileged(new UrlDefinitionAction(resourceName, binaryRepresentation));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected void release(String name, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * The latent persistence handler hides all class file representations and does not make them accessible
&nbsp;         * even before they are loaded.
&nbsp;         */
<b class="fc">&nbsp;        LATENT(false) {</b>
&nbsp;            @Override
&nbsp;            protected byte[] lookup(String name, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;                return typeDefinitions.remove(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected URL url(String resourceName, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;                return NO_URL;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected void release(String name, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions) {
<b class="fc">&nbsp;                typeDefinitions.remove(name);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * The suffix of files in the Java class file format.
&nbsp;         */
&nbsp;        private static final String CLASS_FILE_SUFFIX = &quot;.class&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if this persistence handler represents manifest class file storage.
&nbsp;         */
&nbsp;        private final boolean manifest;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new persistence handler.
&nbsp;         *
&nbsp;         * @param manifest {@code true} if this persistence handler represents manifest class file storage.
&nbsp;         */
<b class="fc">&nbsp;        PersistenceHandler(boolean manifest) {</b>
<b class="fc">&nbsp;            this.manifest = manifest;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if this persistence handler represents manifest class file storage.
&nbsp;         *
&nbsp;         * @return {@code true} if this persistence handler represents manifest class file storage.
&nbsp;         */
&nbsp;        public boolean isManifest() {
<b class="fc">&nbsp;            return manifest;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Performs a lookup of a class file by its name.
&nbsp;         *
&nbsp;         * @param name            The name of the class to be loaded.
&nbsp;         * @param typeDefinitions A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @return The byte array representing the requested class or {@code null} if no such class is known.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected abstract byte[] lookup(String name, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a URL representing a class file.
&nbsp;         *
&nbsp;         * @param resourceName    The name of the requested resource.
&nbsp;         * @param typeDefinitions A mapping of byte arrays by their type names.
&nbsp;         * @return A URL representing the type definition or {@code null} if the requested resource does not represent a class file.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected abstract URL url(String resourceName, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions);
&nbsp;
&nbsp;        /**
&nbsp;         * Removes the binary representation of the supplied type if this class loader is latent.
&nbsp;         *
&nbsp;         * @param name            The name of the type.
&nbsp;         * @param typeDefinitions A mapping of byte arrays by their type names.
&nbsp;         */
&nbsp;        protected abstract void release(String name, ConcurrentMap&lt;String, byte[]&gt; typeDefinitions);
&nbsp;
&nbsp;        /**
&nbsp;         * An action to define a URL that represents a class file.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class UrlDefinitionAction implements PrivilegedAction&lt;URL&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for creating URLs.
&nbsp;             */
<b class="fc">&nbsp;            private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The URL&#39;s encoding character set.
&nbsp;             */
&nbsp;            private static final String ENCODING = &quot;UTF-8&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * A value to define a standard port as Byte Buddy&#39;s URLs do not represent a port.
&nbsp;             */
&nbsp;            private static final int NO_PORT = -1;
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that Byte Buddy&#39;s URLs do not have a file segment.
&nbsp;             */
&nbsp;            private static final String NO_FILE = &quot;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type that this URL represents.
&nbsp;             */
&nbsp;            private final String typeName;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary representation of the type&#39;s class file.
&nbsp;             */
&nbsp;            private final byte[] binaryRepresentation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new URL definition action.
&nbsp;             *
&nbsp;             * @param typeName             The name of the type that this URL represents.
&nbsp;             * @param binaryRepresentation The binary representation of the type&#39;s class file.
&nbsp;             */
<b class="fc">&nbsp;            protected UrlDefinitionAction(String typeName, byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;                this.typeName = typeName;</b>
<b class="fc">&nbsp;                this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;             *
&nbsp;             * @param action The action to execute from a privileged context.
&nbsp;             * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;             * @return The action&#39;s resolved value.
&nbsp;             */
&nbsp;            @AccessControllerPlugin.Enhance
&nbsp;            private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;                return action.run();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public URL run() {
&nbsp;                try {
<b class="fc">&nbsp;                    String path = URLEncoder.encode(typeName.replace(&#39;.&#39;, &#39;/&#39;), ENCODING);</b>
<b class="fc">&nbsp;                    URLStreamHandler handler = new ByteArrayUrlStreamHandler(binaryRepresentation);</b>
<b class="fc">&nbsp;                    URL url = DISPATCHER.of(URI.create(URL_SCHEMA + &quot;://&quot; + path), handler);</b>
<b class="fc">&nbsp;                    return url == null</b>
<b class="fc">&nbsp;                            ? DISPATCHER.make(URL_SCHEMA, path, NO_PORT, NO_FILE, handler)</b>
<b class="nc">&nbsp;                            : url;</b>
<b class="nc">&nbsp;                } catch (MalformedURLException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot create URL for &quot; + typeName, exception);</b>
<b class="nc">&nbsp;                } catch (UnsupportedEncodingException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not find encoding: &quot; + ENCODING, exception);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A stream handler that returns the given binary representation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class ByteArrayUrlStreamHandler extends URLStreamHandler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The binary representation of a type&#39;s class file.
&nbsp;                 */
&nbsp;                private final byte[] binaryRepresentation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new byte array URL stream handler.
&nbsp;                 *
&nbsp;                 * @param binaryRepresentation The binary representation of a type&#39;s class file.
&nbsp;                 */
<b class="fc">&nbsp;                protected ByteArrayUrlStreamHandler(byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;                    this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                protected URLConnection openConnection(URL url) {
<b class="fc">&nbsp;                    return new ByteArrayUrlConnection(url, new ByteArrayInputStream(binaryRepresentation));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A URL connection for a given byte array.
&nbsp;                 */
&nbsp;                protected static class ByteArrayUrlConnection extends URLConnection {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The input stream to return for this connection.
&nbsp;                     */
&nbsp;                    private final InputStream inputStream;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new byte array URL connection.
&nbsp;                     *
&nbsp;                     * @param url         The URL that this connection represents.
&nbsp;                     * @param inputStream The input stream to return from this connection.
&nbsp;                     */
&nbsp;                    protected ByteArrayUrlConnection(URL url, InputStream inputStream) {
<b class="fc">&nbsp;                        super(url);</b>
<b class="fc">&nbsp;                        this.inputStream = inputStream;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void connect() {
<b class="fc">&nbsp;                        connected = true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public InputStream getInputStream() {
<b class="fc">&nbsp;                        connect(); // Mimics the semantics of an actual URL connection.</b>
<b class="fc">&nbsp;                        return inputStream;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for interacting with {@link URL}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.net.URL&quot;)
&nbsp;            protected interface Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a {@link URL}.
&nbsp;                 *
&nbsp;                 * @param protocol The URL&#39;s protocol.
&nbsp;                 * @param host     The host on the URL.
&nbsp;                 * @param port     The port on the URL or a negative value if no port is defined.
&nbsp;                 * @param file     The file on the URL.
&nbsp;                 * @param handler  The stream handler to use.
&nbsp;                 * @return An appropriate URL.
&nbsp;                 * @throws MalformedURLException If the supplied URL is malformed.
&nbsp;                 */
&nbsp;                @JavaDispatcher.IsConstructor
&nbsp;                URL make(String protocol, String host, int port, String file, URLStreamHandler handler) throws MalformedURLException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a URL from an URI, if possible.
&nbsp;                 *
&nbsp;                 * @param uri     The URI to represent.
&nbsp;                 * @param handler The stream handler to attach to that URL.
&nbsp;                 * @return An appropriate URL.
&nbsp;                 * @throws MalformedURLException If the supplied URL is malformed.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @JavaDispatcher.IsStatic
&nbsp;                @JavaDispatcher.Defaults
&nbsp;                URL of(URI uri, URLStreamHandler handler) throws MalformedURLException;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A {@link net.bytebuddy.dynamic.loading.ByteArrayClassLoader} which applies child-first semantics for the
&nbsp;     * given type definitions.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Package definitions remain their parent-first semantics as loaded package definitions do not expose their class loaders.
&nbsp;     * Also, it is not possible to make this class or its subclass parallel-capable as the loading strategy is overridden.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    public static class ChildFirst extends ByteArrayClassLoader {
&nbsp;
&nbsp;        /**
&nbsp;         * The suffix of files in the Java class file format.
&nbsp;         */
&nbsp;        private static final String CLASS_FILE_SUFFIX = &quot;.class&quot;;
&nbsp;
&nbsp;        /*
&nbsp;         * Register class loader as parallel capable if the current VM supports it.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            doRegisterAsParallelCapable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Registers class loader as parallel capable if possible.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Must be invoked from targeting class loader type.&quot;)
&nbsp;        private static void doRegisterAsParallelCapable() {
&nbsp;            try {
<b class="fc">&nbsp;                Method method = ClassLoader.class.getDeclaredMethod(&quot;registerAsParallelCapable&quot;);</b>
<b class="fc">&nbsp;                method.setAccessible(true);</b>
<b class="fc">&nbsp;                method.invoke(null);</b>
<b class="nc">&nbsp;            } catch (Throwable ignored) {</b>
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent          The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param typeDefinitions A map of fully qualified class names pointing to their binary representations.
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent, Map&lt;String, byte[]&gt; typeDefinitions) {
<b class="nc">&nbsp;            super(parent, typeDefinitions);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent          The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param sealed          {@code true} if this class loader is sealed.
&nbsp;         * @param typeDefinitions A map of fully qualified class names pointing to their binary representations.
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent, boolean sealed, Map&lt;String, byte[]&gt; typeDefinitions) {
<b class="nc">&nbsp;            super(parent, sealed, typeDefinitions);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent             The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param typeDefinitions    A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @param persistenceHandler The persistence handler of this class loader.
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent, Map&lt;String, byte[]&gt; typeDefinitions, PersistenceHandler persistenceHandler) {
<b class="nc">&nbsp;            super(parent, typeDefinitions, persistenceHandler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent             The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param sealed             {@code true} if this class loader is sealed.
&nbsp;         * @param typeDefinitions    A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @param persistenceHandler The persistence handler of this class loader.
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent, boolean sealed, Map&lt;String, byte[]&gt; typeDefinitions, PersistenceHandler persistenceHandler) {
<b class="nc">&nbsp;            super(parent, sealed, typeDefinitions, persistenceHandler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;         * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;         * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent,
&nbsp;                          Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                          @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                          PersistenceHandler persistenceHandler,
&nbsp;                          PackageDefinitionStrategy packageDefinitionStrategy) {
<b class="fc">&nbsp;            super(parent, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param sealed                    {@code true} if this class loader is sealed.
&nbsp;         * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;         * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;         * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent,
&nbsp;                          boolean sealed,
&nbsp;                          Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                          @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                          PersistenceHandler persistenceHandler,
&nbsp;                          PackageDefinitionStrategy packageDefinitionStrategy) {
<b class="nc">&nbsp;            super(parent, sealed, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;         * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;         * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;         * @param classFilePostProcessor    A post processor for class files to apply p
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent,
&nbsp;                          Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                          @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                          PersistenceHandler persistenceHandler,
&nbsp;                          PackageDefinitionStrategy packageDefinitionStrategy,
&nbsp;                          ClassFilePostProcessor classFilePostProcessor) {
<b class="nc">&nbsp;            super(parent, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy, classFilePostProcessor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new child-first byte array class loader.
&nbsp;         *
&nbsp;         * @param parent                    The {@link java.lang.ClassLoader} that is the parent of this class loader.
&nbsp;         * @param sealed                    {@code true} if this class loader is sealed.
&nbsp;         * @param typeDefinitions           A map of fully qualified class names pointing to their binary representations.
&nbsp;         * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;         * @param persistenceHandler        The persistence handler of this class loader.
&nbsp;         * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;         * @param classFilePostProcessor    A post processor for class files to apply p
&nbsp;         */
&nbsp;        public ChildFirst(@MaybeNull ClassLoader parent,
&nbsp;                          boolean sealed,
&nbsp;                          Map&lt;String, byte[]&gt; typeDefinitions,
&nbsp;                          @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                          PersistenceHandler persistenceHandler,
&nbsp;                          PackageDefinitionStrategy packageDefinitionStrategy,
&nbsp;                          ClassFilePostProcessor classFilePostProcessor) {
<b class="fc">&nbsp;            super(parent, sealed, typeDefinitions, protectionDomain, persistenceHandler, packageDefinitionStrategy, classFilePostProcessor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a given set of class descriptions and their binary representations using a child-first class loader.
&nbsp;         *
&nbsp;         * @param classLoader The parent class loader.
&nbsp;         * @param types       The unloaded types to be loaded.
&nbsp;         * @return A map of the given type descriptions pointing to their loaded representations.
&nbsp;         */
&nbsp;        public static Map&lt;TypeDescription, Class&lt;?&gt;&gt; load(@MaybeNull ClassLoader classLoader, Map&lt;TypeDescription, byte[]&gt; types) {
<b class="nc">&nbsp;            return load(classLoader,</b>
&nbsp;                    types,
&nbsp;                    ClassLoadingStrategy.NO_PROTECTION_DOMAIN,
&nbsp;                    PersistenceHandler.LATENT,
&nbsp;                    PackageDefinitionStrategy.Trivial.INSTANCE,
&nbsp;                    false,
&nbsp;                    true);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a given set of class descriptions and their binary representations using a child-first class loader.
&nbsp;         *
&nbsp;         * @param classLoader               The parent class loader.
&nbsp;         * @param types                     The unloaded types to be loaded.
&nbsp;         * @param protectionDomain          The protection domain to apply where {@code null} references an implicit protection domain.
&nbsp;         * @param persistenceHandler        The persistence handler of the created class loader.
&nbsp;         * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;         * @param forbidExisting            {@code true} if the class loading should throw an exception if a class was already loaded by a parent class loader.
&nbsp;         * @param sealed                    {@code true} if the class loader should be sealed.
&nbsp;         * @return A map of the given type descriptions pointing to their loaded representations.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;        public static Map&lt;TypeDescription, Class&lt;?&gt;&gt; load(@MaybeNull ClassLoader classLoader,
&nbsp;                                                          Map&lt;TypeDescription, byte[]&gt; types,
&nbsp;                                                          @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                                          PersistenceHandler persistenceHandler,
&nbsp;                                                          PackageDefinitionStrategy packageDefinitionStrategy,
&nbsp;                                                          boolean forbidExisting,
&nbsp;                                                          boolean sealed) {
<b class="fc">&nbsp;            Map&lt;String, byte[]&gt; typesByName = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;                typesByName.put(entry.getKey().getName(), entry.getValue());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            classLoader = new ChildFirst(classLoader,</b>
&nbsp;                    sealed,
&nbsp;                    typesByName,
&nbsp;                    protectionDomain,
&nbsp;                    persistenceHandler,
&nbsp;                    packageDefinitionStrategy,
&nbsp;                    ClassFilePostProcessor.NoOp.INSTANCE);
<b class="fc">&nbsp;            Map&lt;TypeDescription, Class&lt;?&gt;&gt; result = new LinkedHashMap&lt;TypeDescription, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (TypeDescription typeDescription : types.keySet()) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    Class&lt;?&gt; type = Class.forName(typeDescription.getName(), false, classLoader);</b>
<b class="fc">&nbsp;                    if (!GraalImageCode.getCurrent().isNativeImageExecution() &amp;&amp; forbidExisting &amp;&amp; type.getClassLoader() != classLoader) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Class already loaded: &quot; + type);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    result.put(typeDescription, type);</b>
<b class="nc">&nbsp;                } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot load class &quot; + typeDescription, exception);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException {
<b class="fc">&nbsp;            synchronized (SYNCHRONIZATION_STRATEGY.initialize().getClassLoadingLock(this, name)) {</b>
<b class="fc">&nbsp;                Class&lt;?&gt; type = findLoadedClass(name);</b>
<b class="fc">&nbsp;                if (type != null) {</b>
<b class="nc">&nbsp;                    return type;</b>
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    type = findClass(name);</b>
<b class="fc">&nbsp;                    if (resolve) {</b>
<b class="nc">&nbsp;                        resolveClass(type);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return type;</b>
<b class="fc">&nbsp;                } catch (ClassNotFoundException exception) {</b>
&nbsp;                    // If an unknown class is loaded, this implementation causes the findClass method of this instance
&nbsp;                    // to be triggered twice. This is however of minor importance because this would result in a
&nbsp;                    // ClassNotFoundException what does not alter the outcome.
<b class="fc">&nbsp;                    return super.loadClass(name, resolve);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public URL getResource(String name) {
<b class="fc">&nbsp;            URL url = persistenceHandler.url(name, typeDefinitions);</b>
&nbsp;            // If a class resource is defined by this class loader but it is not defined in a manifest manner,
&nbsp;            // the resource of the parent class loader should be shadowed by &#39;null&#39;. Note that the delegation
&nbsp;            // model causes a redundant query to the persistent handler but renders a correct result.
<b class="fc">&nbsp;            return url != null || isShadowed(name)</b>
<b class="fc">&nbsp;                    ? url</b>
<b class="fc">&nbsp;                    : super.getResource(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Enumeration&lt;URL&gt; getResources(String name) throws IOException {
<b class="fc">&nbsp;            URL url = persistenceHandler.url(name, typeDefinitions);</b>
<b class="fc">&nbsp;            return url == null</b>
<b class="fc">&nbsp;                    ? super.getResources(name)</b>
<b class="fc">&nbsp;                    : new PrependingEnumeration(url, super.getResources(name));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if a resource name represents a class file of a class that was loaded by this class loader.
&nbsp;         *
&nbsp;         * @param resourceName The resource name of the class to be exposed as its class file.
&nbsp;         * @return {@code true} if this class represents a class that is being loaded by this class loader.
&nbsp;         */
&nbsp;        private boolean isShadowed(String resourceName) {
<b class="fc">&nbsp;            if (persistenceHandler.isManifest() || !resourceName.endsWith(CLASS_FILE_SUFFIX)) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;            // This synchronization is required to avoid a racing condition to the actual class loading.
<b class="fc">&nbsp;            synchronized (this) {</b>
<b class="fc">&nbsp;                String typeName = resourceName.replace(&#39;/&#39;, &#39;.&#39;).substring(0, resourceName.length() - CLASS_FILE_SUFFIX.length());</b>
<b class="fc">&nbsp;                if (typeDefinitions.containsKey(typeName)) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="fc">&nbsp;                Class&lt;?&gt; loadedClass = findLoadedClass(typeName);</b>
<b class="fc">&nbsp;                return loadedClass != null &amp;&amp; loadedClass.getClassLoader() == this;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An enumeration that prepends an element to another enumeration and skips the last element of the provided enumeration.
&nbsp;         */
&nbsp;        protected static class PrependingEnumeration implements Enumeration&lt;URL&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The next element to return from this enumeration or {@code null} if such an element does not exist.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private URL nextElement;
&nbsp;
&nbsp;            /**
&nbsp;             * The enumeration from which the next elements should be pulled.
&nbsp;             */
&nbsp;            private final Enumeration&lt;URL&gt; enumeration;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new prepending enumeration.
&nbsp;             *
&nbsp;             * @param url         The first element of the enumeration.
&nbsp;             * @param enumeration An enumeration that is used for pulling subsequent urls.
&nbsp;             */
<b class="fc">&nbsp;            protected PrependingEnumeration(URL url, Enumeration&lt;URL&gt; enumeration) {</b>
<b class="fc">&nbsp;                nextElement = url;</b>
<b class="fc">&nbsp;                this.enumeration = enumeration;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean hasMoreElements() {
<b class="fc">&nbsp;                return nextElement != null &amp;&amp; enumeration.hasMoreElements();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public URL nextElement() {
<b class="fc">&nbsp;                if (nextElement != null &amp;&amp; enumeration.hasMoreElements()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return nextElement;</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        nextElement = enumeration.nextElement();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    throw new NoSuchElementException();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An enumeration without any elements.
&nbsp;     */
<b class="fc">&nbsp;    protected enum EmptyEnumeration implements Enumeration&lt;URL&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasMoreElements() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public URL nextElement() {
<b class="fc">&nbsp;            throw new NoSuchElementException();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An enumeration that contains a single element.
&nbsp;     */
&nbsp;    protected static class SingletonEnumeration implements Enumeration&lt;URL&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The current element or {@code null} if this enumeration does not contain further elements.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private URL element;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new singleton enumeration.
&nbsp;         *
&nbsp;         * @param element The only element.
&nbsp;         */
<b class="fc">&nbsp;        protected SingletonEnumeration(URL element) {</b>
<b class="fc">&nbsp;            this.element = element;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasMoreElements() {
<b class="fc">&nbsp;            return element != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public URL nextElement() {
<b class="fc">&nbsp;            if (element == null) {</b>
<b class="fc">&nbsp;                throw new NoSuchElementException();</b>
&nbsp;            } else {
&nbsp;                try {
<b class="fc">&nbsp;                    return element;</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    element = null;</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
