


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ClassInjector</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.loading</a>
</div>

<h1>Coverage Summary for Class: ClassInjector (net.bytebuddy.dynamic.loading)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassInjector</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ClassInjector$1</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$MockitoMock$1759483871</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$MockitoMock$1759483871$auxiliary$OtbXs7XN</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$MockitoMock$1759483871$auxiliary$SGqlMGks</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingInstrumentation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.3%
  </span>
  <span class="absValue">
    (41/60)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingInstrumentation$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingInstrumentation$Target</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingInstrumentation$Target$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingInstrumentation$Target$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (22/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna$Dispatcher$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna$Dispatcher$Jvm</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna$Dispatcher$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingJna$Dispatcher$Windows32BitFunctionMapper</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingLookup</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.9%
  </span>
  <span class="absValue">
    (23/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingLookup$MethodHandles</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingLookup$MethodHandles$Lookup</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.6%
  </span>
  <span class="absValue">
    (50/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (5/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Direct</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.7%
  </span>
  <span class="absValue">
    (6/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Direct$ForJava7CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Direct$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Initializable</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Initializable$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$UsingUnsafeInjection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70.3%
  </span>
  <span class="absValue">
    (83/118)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$UsingUnsafeOverride</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (48/84)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$UsingUnsafeOverride$ForJava7CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$Dispatcher$UsingUnsafeOverride$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingReflection$System</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75.6%
  </span>
  <span class="absValue">
    (31/41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.9%
  </span>
  <span class="absValue">
    (30/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (10/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$Initializable</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Dispatcher$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    19.6%
  </span>
  <span class="absValue">
    (11/56)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$AccessResolver</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$AccessResolver$Default</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$MockitoMock$1553324310</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$MockitoMock$1553324310$auxiliary$Kbj1AgCQ</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$MockitoMock$1553324310$auxiliary$KX2CMAGg</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$MockitoMock$1553324310$auxiliary$mGHO9EST</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$MockitoMock$1553324310$auxiliary$qGNqpgVi</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$Factory$MockitoMock$1553324310$auxiliary$Y2AmSK0q</td>
  </tr>
  <tr>
    <td class="name">ClassInjector$UsingUnsafe$System</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    82.8%
  </span>
  <span class="absValue">
    (125/151)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.9%
  </span>
  <span class="absValue">
    (424/696)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic.loading;
&nbsp;
&nbsp;import com.sun.jna.*;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.MemberRemoval;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.FixedValue;
&nbsp;import net.bytebuddy.implementation.MethodCall;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.nullability.UnknownNull;
&nbsp;import net.bytebuddy.utility.privilege.GetMethodAction;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.net.URL;
&nbsp;import java.security.Permission;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.*;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.any;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * A class injector is capable of injecting classes into a {@link java.lang.ClassLoader} without
&nbsp; * requiring the class loader to being able to explicitly look up these classes.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Important&lt;/b&gt;: Byte Buddy does not supply privileges when injecting code. When using a {@code java.lang.SecurityManager},
&nbsp; * the user of this injector is responsible for providing access to non-public properties.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;public interface ClassInjector {
&nbsp;
&nbsp;    /**
&nbsp;     * A permission for the {@code suppressAccessChecks} permission.
&nbsp;     */
<b class="nc">&nbsp;    Permission SUPPRESS_ACCESS_CHECKS = new ReflectPermission(&quot;suppressAccessChecks&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the default behavior for type injections when a type is already loaded.
&nbsp;     */
&nbsp;    boolean ALLOW_EXISTING_TYPES = false;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if this class injector is available on the current VM.
&nbsp;     *
&nbsp;     * @return {@code true} if this injector is available on the current VM.
&nbsp;     */
&nbsp;    boolean isAlive();
&nbsp;
&nbsp;    /**
&nbsp;     * Injects the given types into the represented class loader.
&nbsp;     *
&nbsp;     * @param types The types to load via injection.
&nbsp;     * @return The loaded types that were passed as arguments.
&nbsp;     */
&nbsp;    Map&lt;TypeDescription, Class&lt;?&gt;&gt; inject(Map&lt;? extends TypeDescription, byte[]&gt; types);
&nbsp;
&nbsp;    /**
&nbsp;     * Injects the given types into the represented class loader using a mapping from name to binary representation.
&nbsp;     *
&nbsp;     * @param types The types to load via injection.
&nbsp;     * @return The loaded types that were passed as arguments.
&nbsp;     */
&nbsp;    Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;? extends String, byte[]&gt; types);
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a class injector.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase implements ClassInjector {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;TypeDescription, Class&lt;?&gt;&gt; inject(Map&lt;? extends TypeDescription, byte[]&gt; types) {
<b class="fc">&nbsp;            Map&lt;String, byte[]&gt; binaryRepresentations = new LinkedHashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;? extends TypeDescription, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;                binaryRepresentations.put(entry.getKey().getName(), entry.getValue());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; loadedTypes = injectRaw(binaryRepresentations);</b>
<b class="fc">&nbsp;            Map&lt;TypeDescription, Class&lt;?&gt;&gt; result = new LinkedHashMap&lt;TypeDescription, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (TypeDescription typeDescription : types.keySet()) {</b>
<b class="fc">&nbsp;                result.put(typeDescription, loadedTypes.get(typeDescription.getName()));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class injector that uses reflective method calls.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class UsingReflection extends AbstractBase {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to use for accessing a class loader via reflection.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher.Initializable DISPATCHER = doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.lang.System} to access the security manager if available.
&nbsp;         */
<b class="fc">&nbsp;        private static final System SYSTEM = doPrivileged(JavaDispatcher.of(System.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code java.lang.SecurityManager#checkPermission} method or {@code null} if not available.
&nbsp;         */
<b class="fc">&nbsp;        private static final Method CHECK_PERMISSION = doPrivileged(new GetMethodAction(&quot;java.lang.SecurityManager&quot;,</b>
&nbsp;                &quot;checkPermission&quot;,
&nbsp;                Permission.class));
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader into which the classes are to be injected.
&nbsp;         */
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * The protection domain that is used when loading classes.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;        /**
&nbsp;         * The package definer to be queried for package definitions.
&nbsp;         */
&nbsp;        private final PackageDefinitionStrategy packageDefinitionStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if an exception should be thrown when attempting to load a type that already exists.
&nbsp;         */
&nbsp;        private final boolean forbidExisting;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new injector for the given {@link java.lang.ClassLoader} and a default {@link java.security.ProtectionDomain} and a
&nbsp;         * trivial {@link PackageDefinitionStrategy} which does not trigger an error when discovering existent classes.
&nbsp;         *
&nbsp;         * @param classLoader The {@link java.lang.ClassLoader} into which new class definitions are to be injected. Must not be the bootstrap loader.
&nbsp;         */
&nbsp;        public UsingReflection(ClassLoader classLoader) {
<b class="fc">&nbsp;            this(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new injector for the given {@link java.lang.ClassLoader} and a default {@link PackageDefinitionStrategy} where the
&nbsp;         * injection of existent classes does not trigger an error.
&nbsp;         *
&nbsp;         * @param classLoader      The {@link java.lang.ClassLoader} into which new class definitions are to be injected. Must not be the bootstrap loader.
&nbsp;         * @param protectionDomain The protection domain to apply during class definition.
&nbsp;         */
&nbsp;        public UsingReflection(ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;            this(classLoader,</b>
&nbsp;                    protectionDomain,
&nbsp;                    PackageDefinitionStrategy.Trivial.INSTANCE,
&nbsp;                    ALLOW_EXISTING_TYPES);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new injector for the given {@link java.lang.ClassLoader} and {@link java.security.ProtectionDomain}.
&nbsp;         *
&nbsp;         * @param classLoader               The {@link java.lang.ClassLoader} into which new class definitions are to be injected.Must  not be the bootstrap loader.
&nbsp;         * @param protectionDomain          The protection domain to apply during class definition.
&nbsp;         * @param packageDefinitionStrategy The package definer to be queried for package definitions.
&nbsp;         * @param forbidExisting            Determines if an exception should be thrown when attempting to load a type that already exists.
&nbsp;         */
&nbsp;        public UsingReflection(ClassLoader classLoader,
&nbsp;                               @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                               PackageDefinitionStrategy packageDefinitionStrategy,
<b class="fc">&nbsp;                               boolean forbidExisting) {</b>
<b class="fc">&nbsp;            if (classLoader == null) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot inject classes into the bootstrap class loader&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
<b class="fc">&nbsp;            this.protectionDomain = protectionDomain;</b>
<b class="fc">&nbsp;            this.packageDefinitionStrategy = packageDefinitionStrategy;</b>
<b class="fc">&nbsp;            this.forbidExisting = forbidExisting;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAlive() {
<b class="fc">&nbsp;            return isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;? extends String, byte[]&gt; types) {
<b class="fc">&nbsp;            Dispatcher dispatcher = DISPATCHER.initialize();</b>
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;? extends String, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;                synchronized (dispatcher.getClassLoadingLock(classLoader, entry.getKey())) {</b>
<b class="fc">&nbsp;                    Class&lt;?&gt; type = dispatcher.findClass(classLoader, entry.getKey());</b>
<b class="fc">&nbsp;                    if (type == null) {</b>
<b class="fc">&nbsp;                        int packageIndex = entry.getKey().lastIndexOf(&#39;.&#39;);</b>
<b class="fc">&nbsp;                        if (packageIndex != -1) {</b>
<b class="fc">&nbsp;                            String packageName = entry.getKey().substring(0, packageIndex);</b>
<b class="fc">&nbsp;                            PackageDefinitionStrategy.Definition definition = packageDefinitionStrategy.define(classLoader, packageName, entry.getKey());</b>
<b class="fc">&nbsp;                            if (definition.isDefined()) {</b>
<b class="fc">&nbsp;                                Package definedPackage = dispatcher.getDefinedPackage(classLoader, packageName);</b>
<b class="fc">&nbsp;                                if (definedPackage == null) {</b>
&nbsp;                                    try {
<b class="fc">&nbsp;                                        dispatcher.definePackage(classLoader,</b>
&nbsp;                                                packageName,
<b class="fc">&nbsp;                                                definition.getSpecificationTitle(),</b>
<b class="fc">&nbsp;                                                definition.getSpecificationVersion(),</b>
<b class="fc">&nbsp;                                                definition.getSpecificationVendor(),</b>
<b class="fc">&nbsp;                                                definition.getImplementationTitle(),</b>
<b class="fc">&nbsp;                                                definition.getImplementationVersion(),</b>
<b class="fc">&nbsp;                                                definition.getImplementationVendor(),</b>
<b class="fc">&nbsp;                                                definition.getSealBase());</b>
<b class="fc">&nbsp;                                    } catch (IllegalStateException exception) {</b>
&nbsp;                                        // Custom classloaders may call getPackage (instead of getDefinedPackage) from
&nbsp;                                        // within definePackage, which can cause the package to be defined in an
&nbsp;                                        // ancestor classloader or find a previously defined one from an ancestor. In
&nbsp;                                        // this case definePackage will also throw since it considers that package
&nbsp;                                        // already loaded and will not allow to define it directly in this classloader.
&nbsp;                                        // To make sure this is the case, call getPackage instead of getDefinedPackage
&nbsp;                                        // here and verify that we actually have a compatible package defined in an
&nbsp;                                        // ancestor classloader. This issue is known to happen on WLS14+JDK11.
<b class="fc">&nbsp;                                        definedPackage = dispatcher.getPackage(classLoader, packageName);</b>
<b class="fc">&nbsp;                                        if (definedPackage == null) {</b>
<b class="nc">&nbsp;                                            throw exception;</b>
<b class="fc">&nbsp;                                        } else if (!definition.isCompatibleTo(definedPackage)) {</b>
<b class="nc">&nbsp;                                            throw new SecurityException(&quot;Sealing violation for package &quot; + packageName + &quot; (getPackage fallback)&quot;);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                    }</b>
<b class="nc">&nbsp;                                } else if (!definition.isCompatibleTo(definedPackage)) {</b>
<b class="nc">&nbsp;                                    throw new SecurityException(&quot;Sealing violation for package &quot; + packageName);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        type = dispatcher.defineClass(classLoader, entry.getKey(), entry.getValue(), protectionDomain);</b>
<b class="fc">&nbsp;                    } else if (forbidExisting) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot inject already loaded type: &quot; + type);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    result.put(entry.getKey(), type);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates if this class injection is available on the current VM.
&nbsp;         *
&nbsp;         * @return {@code true} if this class injection is available.
&nbsp;         */
&nbsp;        public static boolean isAvailable() {
<b class="fc">&nbsp;            return DISPATCHER.isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class injector for the system class loader.
&nbsp;         *
&nbsp;         * @return A class injector for the system class loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofSystemClassLoader() {
<b class="fc">&nbsp;            return new UsingReflection(ClassLoader.getSystemClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for accessing a {@link ClassLoader} reflectively.
&nbsp;         */
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates a class that is currently not defined.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            Class&lt;?&gt; UNDEFINED = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the lock for loading the specified class.
&nbsp;             *
&nbsp;             * @param classLoader the class loader to inject the class into.
&nbsp;             * @param name        The name of the class.
&nbsp;             * @return The lock for loading this class.
&nbsp;             */
&nbsp;            Object getClassLoadingLock(ClassLoader classLoader, String name);
&nbsp;
&nbsp;            /**
&nbsp;             * Looks up a class from the given class loader.
&nbsp;             *
&nbsp;             * @param classLoader The class loader for which a class should be located.
&nbsp;             * @param name        The binary name of the class that should be located.
&nbsp;             * @return The class for the binary name or {@code null} if no such class is defined for the provided class loader.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Class&lt;?&gt; findClass(ClassLoader classLoader, String name);
&nbsp;
&nbsp;            /**
&nbsp;             * Defines a class for the given class loader.
&nbsp;             *
&nbsp;             * @param classLoader          The class loader for which a new class should be defined.
&nbsp;             * @param name                 The binary name of the class that should be defined.
&nbsp;             * @param binaryRepresentation The binary representation of the class.
&nbsp;             * @param protectionDomain     The protection domain for the defined class.
&nbsp;             * @return The defined, loaded class.
&nbsp;             */
&nbsp;            Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;            /**
&nbsp;             * Looks up a package from a class loader. If the operation is not supported, falls back to {@link #getPackage(ClassLoader, String)}
&nbsp;             *
&nbsp;             * @param classLoader The class loader to query.
&nbsp;             * @param name        The binary name of the package.
&nbsp;             * @return The package for the given name as defined by the provided class loader or {@code null} if no such package exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Package getDefinedPackage(ClassLoader classLoader, String name);
&nbsp;
&nbsp;            /**
&nbsp;             * Looks up a package from a class loader or its ancestor.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to query.
&nbsp;             * @param name        The binary name of the package.
&nbsp;             * @return The package for the given name as defined by the provided class loader or its ancestor, or {@code null} if no such package exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Package getPackage(ClassLoader classLoader, String name);
&nbsp;
&nbsp;            /**
&nbsp;             * Defines a package for the given class loader.
&nbsp;             *
&nbsp;             * @param classLoader           The class loader for which a package is to be defined.
&nbsp;             * @param name                  The binary name of the package.
&nbsp;             * @param specificationTitle    The specification title of the package or {@code null} if no specification title exists.
&nbsp;             * @param specificationVersion  The specification version of the package or {@code null} if no specification version exists.
&nbsp;             * @param specificationVendor   The specification vendor of the package or {@code null} if no specification vendor exists.
&nbsp;             * @param implementationTitle   The implementation title of the package or {@code null} if no implementation title exists.
&nbsp;             * @param implementationVersion The implementation version of the package or {@code null} if no implementation version exists.
&nbsp;             * @param implementationVendor  The implementation vendor of the package or {@code null} if no implementation vendor exists.
&nbsp;             * @param sealBase              The seal base URL or {@code null} if the package should not be sealed.
&nbsp;             * @return The defined package.
&nbsp;             */
&nbsp;            Package definePackage(ClassLoader classLoader,
&nbsp;                                  String name,
&nbsp;                                  @MaybeNull String specificationTitle,
&nbsp;                                  @MaybeNull String specificationVersion,
&nbsp;                                  @MaybeNull String specificationVendor,
&nbsp;                                  @MaybeNull String implementationTitle,
&nbsp;                                  @MaybeNull String implementationVersion,
&nbsp;                                  @MaybeNull String implementationVendor,
&nbsp;                                  @MaybeNull URL sealBase);
&nbsp;
&nbsp;            /**
&nbsp;             * Initializes a dispatcher to make non-accessible APIs accessible.
&nbsp;             */
&nbsp;            interface Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates if this dispatcher is available.
&nbsp;                 *
&nbsp;                 * @return {@code true} if this dispatcher is available.
&nbsp;                 */
&nbsp;                boolean isAvailable();
&nbsp;
&nbsp;                /**
&nbsp;                 * Initializes this dispatcher.
&nbsp;                 *
&nbsp;                 * @return The initialized dispatcher.
&nbsp;                 */
&nbsp;                Dispatcher initialize();
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an unsuccessfully loaded method lookup.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Unavailable implements Dispatcher, Initializable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The reason why this dispatcher is not available.
&nbsp;                     */
&nbsp;                    private final String message;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new faulty reflection store.
&nbsp;                     *
&nbsp;                     * @param message The reason why this dispatcher is not available.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Unavailable(String message) {</b>
<b class="fc">&nbsp;                        this.message = message;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isAvailable() {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Dispatcher initialize() {
<b class="fc">&nbsp;                        return this;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                        return classLoader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return classLoader.loadClass(name);</b>
<b class="fc">&nbsp;                        } catch (ClassNotFoundException ignored) {</b>
<b class="fc">&nbsp;                            return UNDEFINED;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot define class using reflection: &quot; + message);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Package getDefinedPackage(ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot get defined package using reflection: &quot; + message);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Package getPackage(ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot get package using reflection: &quot; + message);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Package definePackage(ClassLoader classLoader,
&nbsp;                                                 String name,
&nbsp;                                                 @MaybeNull String specificationTitle,
&nbsp;                                                 @MaybeNull String specificationVersion,
&nbsp;                                                 @MaybeNull String specificationVendor,
&nbsp;                                                 @MaybeNull String implementationTitle,
&nbsp;                                                 @MaybeNull String implementationVersion,
&nbsp;                                                 @MaybeNull String implementationVendor,
&nbsp;                                                 @MaybeNull URL sealBase) {
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot define package using injection: &quot; + message);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A creation action for a dispatcher.
&nbsp;             */
<b class="fc">&nbsp;            enum CreationAction implements PrivilegedAction&lt;Initializable&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                public Initializable run() {
&nbsp;                    try {
<b class="fc">&nbsp;                        if (JavaModule.isSupported()) {</b>
<b class="fc">&nbsp;                            return UsingUnsafe.isAvailable()</b>
<b class="fc">&nbsp;                                    ? UsingUnsafeInjection.make()</b>
<b class="nc">&nbsp;                                    : UsingUnsafeOverride.make();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return Direct.make();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        return new Initializable.Unavailable(exception.getTargetException().getMessage());</b>
<b class="nc">&nbsp;                    } catch (Exception exception) {</b>
<b class="nc">&nbsp;                        return new Initializable.Unavailable(exception.getMessage());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A class injection dispatcher that is using reflection on the {@link ClassLoader} methods.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class Direct implements Dispatcher, Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                 */
&nbsp;                protected final Method findLoadedClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                 */
&nbsp;                protected final Method defineClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                protected final Method getDefinedPackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                 */
&nbsp;                protected final Method getPackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                 */
&nbsp;                protected final Method definePackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new direct injection dispatcher.
&nbsp;                 *
&nbsp;                 * @param findLoadedClass   An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                 * @param defineClass       An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                 * @param getDefinedPackage An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                 * @param getPackage        An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                 * @param definePackage     An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                 */
&nbsp;                protected Direct(Method findLoadedClass,
&nbsp;                                 Method defineClass,
&nbsp;                                 @MaybeNull Method getDefinedPackage,
&nbsp;                                 Method getPackage,
<b class="fc">&nbsp;                                 Method definePackage) {</b>
<b class="fc">&nbsp;                    this.findLoadedClass = findLoadedClass;</b>
<b class="fc">&nbsp;                    this.defineClass = defineClass;</b>
<b class="fc">&nbsp;                    this.getDefinedPackage = getDefinedPackage;</b>
<b class="fc">&nbsp;                    this.getPackage = getPackage;</b>
<b class="fc">&nbsp;                    this.definePackage = definePackage;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a direct dispatcher.
&nbsp;                 *
&nbsp;                 * @return A direct dispatcher for class injection.
&nbsp;                 * @throws Exception If the creation is impossible.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;                protected static Initializable make() throws Exception {
&nbsp;                    Method getDefinedPackage;
<b class="nc">&nbsp;                    if (JavaModule.isSupported()) { // Avoid accidental lookup of method with same name in Java 8 J9 VM.</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            getDefinedPackage = ClassLoader.class.getMethod(&quot;getDefinedPackage&quot;, String.class);</b>
<b class="nc">&nbsp;                        } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                            getDefinedPackage = null;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        getDefinedPackage = null;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Method getPackage = ClassLoader.class.getDeclaredMethod(&quot;getPackage&quot;, String.class);</b>
<b class="nc">&nbsp;                    getPackage.setAccessible(true);</b>
<b class="nc">&nbsp;                    Method findLoadedClass = ClassLoader.class.getDeclaredMethod(&quot;findLoadedClass&quot;, String.class);</b>
<b class="nc">&nbsp;                    findLoadedClass.setAccessible(true);</b>
<b class="nc">&nbsp;                    Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,</b>
&nbsp;                            String.class,
&nbsp;                            byte[].class,
&nbsp;                            int.class,
&nbsp;                            int.class,
&nbsp;                            ProtectionDomain.class);
<b class="nc">&nbsp;                    defineClass.setAccessible(true);</b>
<b class="nc">&nbsp;                    Method definePackage = ClassLoader.class.getDeclaredMethod(&quot;definePackage&quot;,</b>
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            URL.class);
<b class="nc">&nbsp;                    definePackage.setAccessible(true);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Method getClassLoadingLock = ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class);</b>
<b class="nc">&nbsp;                        getClassLoadingLock.setAccessible(true);</b>
<b class="nc">&nbsp;                        return new ForJava7CapableVm(findLoadedClass,</b>
&nbsp;                                defineClass,
&nbsp;                                getDefinedPackage,
&nbsp;                                getPackage,
&nbsp;                                definePackage,
&nbsp;                                getClassLoadingLock);
<b class="nc">&nbsp;                    } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                        return new ForLegacyVm(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher initialize() {
<b class="nc">&nbsp;                    Object securityManager = SYSTEM.getSecurityManager();</b>
<b class="nc">&nbsp;                    if (securityManager != null) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            CHECK_PERMISSION.invoke(securityManager, SUPPRESS_ACCESS_CHECKS);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            return new Dispatcher.Unavailable(exception.getTargetException().getMessage());</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            return new Dispatcher.Unavailable(exception.getMessage());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return (Class&lt;?&gt;) findLoadedClass.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return (Class&lt;?&gt;) defineClass.invoke(classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                    if (getDefinedPackage == null) {</b>
<b class="nc">&nbsp;                        return getPackage(classLoader, name);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="nc">&nbsp;                        return (Package) getDefinedPackage.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return (Package) getPackage.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package definePackage(ClassLoader classLoader,
&nbsp;                                             String name,
&nbsp;                                             @MaybeNull String specificationTitle,
&nbsp;                                             @MaybeNull String specificationVersion,
&nbsp;                                             @MaybeNull String specificationVendor,
&nbsp;                                             @MaybeNull String implementationTitle,
&nbsp;                                             @MaybeNull String implementationVersion,
&nbsp;                                             @MaybeNull String implementationVendor,
&nbsp;                                             @MaybeNull URL sealBase) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return (Package) definePackage.invoke(classLoader,</b>
&nbsp;                                name,
&nbsp;                                specificationTitle,
&nbsp;                                specificationVersion,
&nbsp;                                specificationVendor,
&nbsp;                                implementationTitle,
&nbsp;                                implementationVersion,
&nbsp;                                implementationVendor,
&nbsp;                                sealBase);
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved class dispatcher for a class injector on a VM running at least Java 7.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForJava7CapableVm extends Direct {
&nbsp;
&nbsp;                    /**
&nbsp;                     * An instance of {@code ClassLoader#getClassLoadingLock(String)}.
&nbsp;                     */
&nbsp;                    private final Method getClassLoadingLock;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved reflection store for a VM running at least Java 7.
&nbsp;                     *
&nbsp;                     * @param getClassLoadingLock An instance of {@code ClassLoader#getClassLoadingLock(String)}.
&nbsp;                     * @param findLoadedClass     An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                     * @param defineClass         An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                     * @param getDefinedPackage   An instance of {@code java.lang,ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                     * @param getPackage          An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                     * @param definePackage       An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                     */
&nbsp;                    protected ForJava7CapableVm(Method findLoadedClass,
&nbsp;                                                Method defineClass,
&nbsp;                                                @MaybeNull Method getDefinedPackage,
&nbsp;                                                Method getPackage,
&nbsp;                                                Method definePackage,
&nbsp;                                                Method getClassLoadingLock) {
<b class="nc">&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);</b>
<b class="nc">&nbsp;                        this.getClassLoadingLock = getClassLoadingLock;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                        try {
<b class="nc">&nbsp;                            return getClassLoadingLock.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved class dispatcher for a class injector prior to Java 7.
&nbsp;                 */
&nbsp;                protected static class ForLegacyVm extends Direct {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved reflection store for a VM prior to Java 8.
&nbsp;                     *
&nbsp;                     * @param findLoadedClass   An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                     * @param defineClass       An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                     * @param getDefinedPackage An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                     * @param getPackage        An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                     * @param definePackage     An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                     */
&nbsp;                    protected ForLegacyVm(Method findLoadedClass,
&nbsp;                                          Method defineClass,
&nbsp;                                          @MaybeNull Method getDefinedPackage,
&nbsp;                                          Method getPackage,
&nbsp;                                          Method definePackage) {
<b class="fc">&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                        return classLoader;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An indirect dispatcher that uses a redirection accessor class that was injected into the bootstrap class loader.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class UsingUnsafeInjection implements Dispatcher, Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of the accessor class that is required for using it&#39;s intentionally non-static methods.
&nbsp;                 */
&nbsp;                private final Object accessor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method for using {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                 */
&nbsp;                private final Method findLoadedClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method for using {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                 */
&nbsp;                private final Method defineClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method for using {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                private final Method getDefinedPackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method for using {@link ClassLoader#getPackage(String)}.
&nbsp;                 */
&nbsp;                private final Method getPackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method for using {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                 */
&nbsp;                private final Method definePackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method for using {@code ClassLoader#getClassLoadingLock(String)} or returning the supplied {@link ClassLoader}
&nbsp;                 * if this method does not exist on the current VM.
&nbsp;                 */
&nbsp;                private final Method getClassLoadingLock;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new class loading injection dispatcher using an unsafe injected dispatcher.
&nbsp;                 *
&nbsp;                 * @param accessor            An instance of the accessor class that is required for using it&#39;s intentionally non-static methods.
&nbsp;                 * @param findLoadedClass     An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                 * @param defineClass         An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                 * @param getDefinedPackage   An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                 * @param getPackage          An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                 * @param definePackage       An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                 * @param getClassLoadingLock The accessor method for using {@code ClassLoader#getClassLoadingLock(String)} or returning the
&nbsp;                 *                            supplied {@link ClassLoader} if this method does not exist on the current VM.
&nbsp;                 */
&nbsp;                protected UsingUnsafeInjection(Object accessor,
&nbsp;                                               Method findLoadedClass,
&nbsp;                                               Method defineClass,
&nbsp;                                               @MaybeNull Method getDefinedPackage,
&nbsp;                                               Method getPackage,
&nbsp;                                               Method definePackage,
<b class="fc">&nbsp;                                               Method getClassLoadingLock) {</b>
<b class="fc">&nbsp;                    this.accessor = accessor;</b>
<b class="fc">&nbsp;                    this.findLoadedClass = findLoadedClass;</b>
<b class="fc">&nbsp;                    this.defineClass = defineClass;</b>
<b class="fc">&nbsp;                    this.getDefinedPackage = getDefinedPackage;</b>
<b class="fc">&nbsp;                    this.getPackage = getPackage;</b>
<b class="fc">&nbsp;                    this.definePackage = definePackage;</b>
<b class="fc">&nbsp;                    this.getClassLoadingLock = getClassLoadingLock;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an indirect dispatcher.
&nbsp;                 *
&nbsp;                 * @return An indirect dispatcher for class creation.
&nbsp;                 * @throws Exception If the dispatcher cannot be created.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;                protected static Initializable make() throws Exception {
<b class="fc">&nbsp;                    if (Boolean.parseBoolean(java.lang.System.getProperty(UsingUnsafe.SAFE_PROPERTY, Boolean.toString(GraalImageCode.getCurrent().isDefined())))) {</b>
<b class="nc">&nbsp;                        return new Initializable.Unavailable(&quot;Use of Unsafe was disabled by system property&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Class&lt;?&gt; unsafe = Class.forName(&quot;sun.misc.Unsafe&quot;);</b>
<b class="fc">&nbsp;                    Field theUnsafe = unsafe.getDeclaredField(&quot;theUnsafe&quot;);</b>
<b class="fc">&nbsp;                    theUnsafe.setAccessible(true);</b>
<b class="fc">&nbsp;                    Object unsafeInstance = theUnsafe.get(null);</b>
&nbsp;                    Method getDefinedPackage;
<b class="fc">&nbsp;                    if (JavaModule.isSupported()) { // Avoid accidental lookup of method with same name in Java 8 J9 VM.</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            getDefinedPackage = ClassLoader.class.getDeclaredMethod(&quot;getDefinedPackage&quot;, String.class);</b>
<b class="nc">&nbsp;                        } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                            getDefinedPackage = null;</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        getDefinedPackage = null;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    DynamicType.Builder&lt;?&gt; builder = new ByteBuddy()</b>
<b class="fc">&nbsp;                            .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                            .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="fc">&nbsp;                            .name(ClassLoader.class.getName() + &quot;$ByteBuddyAccessor$V1&quot;)</b>
<b class="fc">&nbsp;                            .defineMethod(&quot;findLoadedClass&quot;, Class.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                            .withParameters(ClassLoader.class, String.class)</b>
<b class="fc">&nbsp;                            .intercept(MethodCall.invoke(ClassLoader.class</b>
<b class="fc">&nbsp;                                            .getDeclaredMethod(&quot;findLoadedClass&quot;, String.class))</b>
<b class="fc">&nbsp;                                    .onArgument(0)</b>
<b class="fc">&nbsp;                                    .withArgument(1))</b>
<b class="fc">&nbsp;                            .defineMethod(&quot;defineClass&quot;, Class.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                            .withParameters(ClassLoader.class, String.class, byte[].class, int.class, int.class,</b>
&nbsp;                                    ProtectionDomain.class)
<b class="fc">&nbsp;                            .intercept(MethodCall.invoke(ClassLoader.class</b>
<b class="fc">&nbsp;                                            .getDeclaredMethod(&quot;defineClass&quot;, String.class, byte[].class, int.class, int.class, ProtectionDomain.class))</b>
<b class="fc">&nbsp;                                    .onArgument(0)</b>
<b class="fc">&nbsp;                                    .withArgument(1, 2, 3, 4, 5))</b>
<b class="fc">&nbsp;                            .defineMethod(&quot;getPackage&quot;, Package.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                            .withParameters(ClassLoader.class, String.class)</b>
<b class="fc">&nbsp;                            .intercept(MethodCall.invoke(ClassLoader.class</b>
<b class="fc">&nbsp;                                            .getDeclaredMethod(&quot;getPackage&quot;, String.class))</b>
<b class="fc">&nbsp;                                    .onArgument(0)</b>
<b class="fc">&nbsp;                                    .withArgument(1))</b>
<b class="fc">&nbsp;                            .defineMethod(&quot;definePackage&quot;, Package.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                            .withParameters(ClassLoader.class, String.class, String.class, String.class, String.class,</b>
&nbsp;                                    String.class, String.class, String.class, URL.class)
<b class="fc">&nbsp;                            .intercept(MethodCall.invoke(ClassLoader.class</b>
<b class="fc">&nbsp;                                            .getDeclaredMethod(&quot;definePackage&quot;, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class))</b>
<b class="fc">&nbsp;                                    .onArgument(0)</b>
<b class="fc">&nbsp;                                    .withArgument(1, 2, 3, 4, 5, 6, 7, 8));</b>
<b class="fc">&nbsp;                    if (getDefinedPackage != null) {</b>
<b class="fc">&nbsp;                        builder = builder</b>
<b class="fc">&nbsp;                                .defineMethod(&quot;getDefinedPackage&quot;, Package.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                                .withParameters(ClassLoader.class, String.class)</b>
<b class="fc">&nbsp;                                .intercept(MethodCall.invoke(getDefinedPackage)</b>
<b class="fc">&nbsp;                                        .onArgument(0)</b>
<b class="fc">&nbsp;                                        .withArgument(1));</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        builder = builder.defineMethod(&quot;getClassLoadingLock&quot;, Object.class, Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                                .withParameters(ClassLoader.class, String.class)</b>
<b class="fc">&nbsp;                                .intercept(MethodCall.invoke(ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class))</b>
<b class="fc">&nbsp;                                        .onArgument(0)</b>
<b class="fc">&nbsp;                                        .withArgument(1));</b>
<b class="nc">&nbsp;                    } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                        builder = builder.defineMethod(&quot;getClassLoadingLock&quot;, Object.class, Visibility.PUBLIC)</b>
<b class="nc">&nbsp;                                .withParameters(ClassLoader.class, String.class)</b>
<b class="nc">&nbsp;                                .intercept(FixedValue.argument(0));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    Class&lt;?&gt; type = builder.make()</b>
<b class="fc">&nbsp;                            .load(ClassLoadingStrategy.BOOTSTRAP_LOADER, new ClassLoadingStrategy.ForUnsafeInjection())</b>
<b class="fc">&nbsp;                            .getLoaded();</b>
<b class="fc">&nbsp;                    return new UsingUnsafeInjection(</b>
<b class="fc">&nbsp;                            unsafe.getMethod(&quot;allocateInstance&quot;, Class.class).invoke(unsafeInstance, type),</b>
<b class="fc">&nbsp;                            type.getMethod(&quot;findLoadedClass&quot;, ClassLoader.class, String.class),</b>
<b class="fc">&nbsp;                            type.getMethod(&quot;defineClass&quot;, ClassLoader.class, String.class, byte[].class, int.class, int.class, ProtectionDomain.class),</b>
<b class="fc">&nbsp;                            getDefinedPackage != null ? type.getMethod(&quot;getDefinedPackage&quot;, ClassLoader.class, String.class) : null,</b>
<b class="fc">&nbsp;                            type.getMethod(&quot;getPackage&quot;, ClassLoader.class, String.class),</b>
<b class="fc">&nbsp;                            type.getMethod(&quot;definePackage&quot;, ClassLoader.class, String.class, String.class, String.class, String.class, String.class, String.class, String.class, URL.class),</b>
<b class="fc">&nbsp;                            type.getMethod(&quot;getClassLoadingLock&quot;, ClassLoader.class, String.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher initialize() {
<b class="fc">&nbsp;                    Object securityManager = SYSTEM.getSecurityManager();</b>
<b class="fc">&nbsp;                    if (securityManager != null) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            CHECK_PERMISSION.invoke(securityManager, SUPPRESS_ACCESS_CHECKS);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            return new Dispatcher.Unavailable(exception.getTargetException().getMessage());</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            return new Dispatcher.Unavailable(exception.getMessage());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return getClassLoadingLock.invoke(accessor, classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Class&lt;?&gt;) findLoadedClass.invoke(accessor, classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Class&lt;?&gt;) defineClass.invoke(accessor, classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="fc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                    if (getDefinedPackage == null) {</b>
<b class="nc">&nbsp;                        return getPackage(classLoader, name);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Package) getDefinedPackage.invoke(accessor, classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Package) getPackage.invoke(accessor, classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package definePackage(ClassLoader classLoader,
&nbsp;                                             String name,
&nbsp;                                             @MaybeNull String specificationTitle,
&nbsp;                                             @MaybeNull String specificationVersion,
&nbsp;                                             @MaybeNull String specificationVendor,
&nbsp;                                             @MaybeNull String implementationTitle,
&nbsp;                                             @MaybeNull String implementationVersion,
&nbsp;                                             @MaybeNull String implementationVendor,
&nbsp;                                             @MaybeNull URL sealBase) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Package) definePackage.invoke(accessor,</b>
&nbsp;                                classLoader,
&nbsp;                                name,
&nbsp;                                specificationTitle,
&nbsp;                                specificationVersion,
&nbsp;                                specificationVendor,
&nbsp;                                implementationTitle,
&nbsp;                                implementationVersion,
&nbsp;                                implementationVendor,
&nbsp;                                sealBase);
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="fc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher implementation that uses {@code sun.misc.Unsafe#putBoolean} to set the {@link AccessibleObject} field
&nbsp;             * for making methods accessible.
&nbsp;             */
&nbsp;            abstract class UsingUnsafeOverride implements Dispatcher, Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                 */
&nbsp;                protected final Method findLoadedClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                 */
&nbsp;                protected final Method defineClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                protected final Method getDefinedPackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                 */
&nbsp;                protected final Method getPackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                 */
&nbsp;                protected final Method definePackage;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new unsafe field injecting injection dispatcher.
&nbsp;                 *
&nbsp;                 * @param findLoadedClass   An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                 * @param defineClass       An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                 * @param getDefinedPackage An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                 * @param getPackage        An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                 * @param definePackage     An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                 */
&nbsp;                protected UsingUnsafeOverride(Method findLoadedClass,
&nbsp;                                              Method defineClass,
&nbsp;                                              @MaybeNull Method getDefinedPackage,
&nbsp;                                              Method getPackage,
<b class="fc">&nbsp;                                              Method definePackage) {</b>
<b class="fc">&nbsp;                    this.findLoadedClass = findLoadedClass;</b>
<b class="fc">&nbsp;                    this.defineClass = defineClass;</b>
<b class="fc">&nbsp;                    this.getDefinedPackage = getDefinedPackage;</b>
<b class="fc">&nbsp;                    this.getPackage = getPackage;</b>
<b class="fc">&nbsp;                    this.definePackage = definePackage;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new initializable class injector using an unsafe field injection.
&nbsp;                 *
&nbsp;                 * @return An appropriate initializable.
&nbsp;                 * @throws Exception If the injector cannot be created.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;DP_DO_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;                protected static Initializable make() throws Exception {
<b class="fc">&nbsp;                    if (Boolean.parseBoolean(java.lang.System.getProperty(UsingUnsafe.SAFE_PROPERTY, Boolean.toString(GraalImageCode.getCurrent().isDefined())))) {</b>
<b class="nc">&nbsp;                        return new Initializable.Unavailable(&quot;Use of Unsafe was disabled by system property&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Class&lt;?&gt; unsafeType = Class.forName(&quot;sun.misc.Unsafe&quot;);</b>
<b class="fc">&nbsp;                    Field theUnsafe = unsafeType.getDeclaredField(&quot;theUnsafe&quot;);</b>
<b class="fc">&nbsp;                    theUnsafe.setAccessible(true);</b>
<b class="fc">&nbsp;                    Object unsafe = theUnsafe.get(null);</b>
&nbsp;                    Field override;
&nbsp;                    try {
<b class="fc">&nbsp;                        override = AccessibleObject.class.getDeclaredField(&quot;override&quot;);</b>
<b class="fc">&nbsp;                    } catch (NoSuchFieldException ignored) {</b>
&nbsp;                        // Since Java 12, the override field is hidden from the reflection API. To circumvent this, we
&nbsp;                        // create a mirror class of AccessibleObject that defines the same fields and has the same field
&nbsp;                        // layout such that the override field will receive the same class offset. Doing so, we can write to
&nbsp;                        // the offset location and still set a value to it, despite it being hidden from the reflection API.
<b class="fc">&nbsp;                        override = new ByteBuddy()</b>
<b class="fc">&nbsp;                                .redefine(AccessibleObject.class)</b>
<b class="fc">&nbsp;                                .name(&quot;net.bytebuddy.mirror.&quot; + AccessibleObject.class.getSimpleName())</b>
<b class="fc">&nbsp;                                .noNestMate()</b>
<b class="fc">&nbsp;                                .visit(new MemberRemoval().stripInvokables(any()))</b>
<b class="fc">&nbsp;                                .make()</b>
<b class="fc">&nbsp;                                .load(AccessibleObject.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER.with(AccessibleObject.class.getProtectionDomain()))</b>
<b class="fc">&nbsp;                                .getLoaded()</b>
<b class="fc">&nbsp;                                .getDeclaredField(&quot;override&quot;);</b>
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    long offset = (Long) unsafeType</b>
<b class="fc">&nbsp;                            .getMethod(&quot;objectFieldOffset&quot;, Field.class)</b>
<b class="fc">&nbsp;                            .invoke(unsafe, override);</b>
<b class="fc">&nbsp;                    Method putBoolean = unsafeType.getMethod(&quot;putBoolean&quot;, Object.class, long.class, boolean.class);</b>
&nbsp;                    Method getDefinedPackage;
<b class="fc">&nbsp;                    if (JavaModule.isSupported()) { // Avoid accidental lookup of method with same name in Java 8 J9 VM.</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            getDefinedPackage = ClassLoader.class.getMethod(&quot;getDefinedPackage&quot;, String.class);</b>
<b class="nc">&nbsp;                        } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                            getDefinedPackage = null;</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        getDefinedPackage = null;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Method getPackage = ClassLoader.class.getDeclaredMethod(&quot;getPackage&quot;, String.class);</b>
<b class="fc">&nbsp;                    putBoolean.invoke(unsafe, getPackage, offset, true);</b>
<b class="fc">&nbsp;                    Method findLoadedClass = ClassLoader.class.getDeclaredMethod(&quot;findLoadedClass&quot;, String.class);</b>
<b class="fc">&nbsp;                    Method defineClass = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;,</b>
&nbsp;                            String.class,
&nbsp;                            byte[].class,
&nbsp;                            int.class,
&nbsp;                            int.class,
&nbsp;                            ProtectionDomain.class);
<b class="fc">&nbsp;                    Method definePackage = ClassLoader.class.getDeclaredMethod(&quot;definePackage&quot;,</b>
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            String.class,
&nbsp;                            URL.class);
<b class="fc">&nbsp;                    putBoolean.invoke(unsafe, defineClass, offset, true);</b>
<b class="fc">&nbsp;                    putBoolean.invoke(unsafe, findLoadedClass, offset, true);</b>
<b class="fc">&nbsp;                    putBoolean.invoke(unsafe, definePackage, offset, true);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        Method getClassLoadingLock = ClassLoader.class.getDeclaredMethod(&quot;getClassLoadingLock&quot;, String.class);</b>
<b class="fc">&nbsp;                        putBoolean.invoke(unsafe, getClassLoadingLock, offset, true);</b>
<b class="fc">&nbsp;                        return new ForJava7CapableVm(findLoadedClass,</b>
&nbsp;                                defineClass,
&nbsp;                                getDefinedPackage,
&nbsp;                                getPackage,
&nbsp;                                definePackage,
&nbsp;                                getClassLoadingLock);
<b class="nc">&nbsp;                    } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                        return new ForLegacyVm(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher initialize() {
<b class="fc">&nbsp;                    Object securityManager = SYSTEM.getSecurityManager();</b>
<b class="fc">&nbsp;                    if (securityManager != null) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            CHECK_PERMISSION.invoke(securityManager, SUPPRESS_ACCESS_CHECKS);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            return new Dispatcher.Unavailable(exception.getTargetException().getMessage());</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            return new Dispatcher.Unavailable(exception.getMessage());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Class&lt;?&gt;) findLoadedClass.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Class&lt;?&gt;) defineClass.invoke(classLoader, name, binaryRepresentation, 0, binaryRepresentation.length, protectionDomain);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                    if (getDefinedPackage == null) {</b>
<b class="nc">&nbsp;                        return getPackage(classLoader, name);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Package) getDefinedPackage.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return (Package) getPackage.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package definePackage(ClassLoader classLoader,
&nbsp;                                             String name,
&nbsp;                                             @MaybeNull String specificationTitle,
&nbsp;                                             @MaybeNull String specificationVersion,
&nbsp;                                             @MaybeNull String specificationVendor,
&nbsp;                                             @MaybeNull String implementationTitle,
&nbsp;                                             @MaybeNull String implementationVersion,
&nbsp;                                             @MaybeNull String implementationVendor,
&nbsp;                                             @MaybeNull URL sealBase) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Package) definePackage.invoke(classLoader,</b>
&nbsp;                                name,
&nbsp;                                specificationTitle,
&nbsp;                                specificationVersion,
&nbsp;                                specificationVendor,
&nbsp;                                implementationTitle,
&nbsp;                                implementationVersion,
&nbsp;                                implementationVendor,
&nbsp;                                sealBase);
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved class dispatcher using unsafe field injection for a class injector on a VM running at least Java 7.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForJava7CapableVm extends UsingUnsafeOverride {
&nbsp;
&nbsp;                    /**
&nbsp;                     * An instance of {@code ClassLoader#getClassLoadingLock(String)}.
&nbsp;                     */
&nbsp;                    private final Method getClassLoadingLock;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved class injector using unsafe field injection for a VM running at least Java 7.
&nbsp;                     *
&nbsp;                     * @param getClassLoadingLock An instance of {@code ClassLoader#getClassLoadingLock(String)}.
&nbsp;                     * @param findLoadedClass     An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                     * @param defineClass         An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                     * @param getDefinedPackage   An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                     * @param getPackage          An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                     * @param definePackage       An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                     */
&nbsp;                    protected ForJava7CapableVm(Method findLoadedClass,
&nbsp;                                                Method defineClass,
&nbsp;                                                @MaybeNull Method getDefinedPackage,
&nbsp;                                                Method getPackage,
&nbsp;                                                Method definePackage,
&nbsp;                                                Method getClassLoadingLock) {
<b class="fc">&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);</b>
<b class="fc">&nbsp;                        this.getClassLoadingLock = getClassLoadingLock;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
&nbsp;                        try {
<b class="nc">&nbsp;                            return getClassLoadingLock.invoke(classLoader, name);</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved class dispatcher using unsafe field injection for a class injector prior to Java 7.
&nbsp;                 */
&nbsp;                protected static class ForLegacyVm extends UsingUnsafeOverride {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved class injector using unsafe field injection for a VM prior to Java 7.
&nbsp;                     *
&nbsp;                     * @param findLoadedClass   An instance of {@link ClassLoader#findLoadedClass(String)}.
&nbsp;                     * @param defineClass       An instance of {@link ClassLoader#defineClass(String, byte[], int, int, ProtectionDomain)}.
&nbsp;                     * @param getDefinedPackage An instance of {@code java.lang.ClassLoader#getDefinedPackage(String)}. May be {@code null}.
&nbsp;                     * @param getPackage        An instance of {@link ClassLoader#getPackage(String)}.
&nbsp;                     * @param definePackage     An instance of {@link ClassLoader#definePackage(String, String, String, String, String, String, String, URL)}.
&nbsp;                     */
&nbsp;                    protected ForLegacyVm(Method findLoadedClass,
&nbsp;                                          Method defineClass,
&nbsp;                                          @MaybeNull Method getDefinedPackage,
&nbsp;                                          Method getPackage,
&nbsp;                                          Method definePackage) {
<b class="nc">&nbsp;                        super(findLoadedClass, defineClass, getDefinedPackage, getPackage, definePackage);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Object getClassLoadingLock(ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                        return classLoader;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an unsuccessfully loaded method lookup.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Unavailable implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The error message being displayed.
&nbsp;                 */
&nbsp;                private final String message;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a dispatcher for a VM that does not support reflective injection.
&nbsp;                 *
&nbsp;                 * @param message The error message being displayed.
&nbsp;                 */
<b class="fc">&nbsp;                protected Unavailable(String message) {</b>
<b class="fc">&nbsp;                    this.message = message;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Object getClassLoadingLock(ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                    return classLoader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; findClass(ClassLoader classLoader, String name) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return classLoader.loadClass(name);</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                        return UNDEFINED;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot define class using reflection: &quot; + message);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package getDefinedPackage(ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot get defined package using reflection: &quot; + message);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package getPackage(ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot get package using reflection: &quot; + message);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Package definePackage(ClassLoader classLoader,
&nbsp;                                             String name,
&nbsp;                                             @MaybeNull String specificationTitle,
&nbsp;                                             @MaybeNull String specificationVersion,
&nbsp;                                             @MaybeNull String specificationVendor,
&nbsp;                                             @MaybeNull String implementationTitle,
&nbsp;                                             @MaybeNull String implementationVersion,
&nbsp;                                             @MaybeNull String implementationVendor,
&nbsp;                                             @MaybeNull URL sealBase) {
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot define package using injection: &quot; + message);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy of {@code java.lang.System}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.System&quot;)
&nbsp;        protected interface System {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the current security manager or {@code null} if not available.
&nbsp;             *
&nbsp;             * @return The current security manager or {@code null} if not available.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @JavaDispatcher.IsStatic
&nbsp;            @JavaDispatcher.Defaults
&nbsp;            Object getSecurityManager();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A class injector that uses a {@code java.lang.invoke.MethodHandles$Lookup} object for defining a class.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This functionality is only available starting from Java 9.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class UsingLookup extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to interacting with instances of {@code java.lang.invoke.MethodHandles}.
&nbsp;         */
<b class="fc">&nbsp;        private static final MethodHandles METHOD_HANDLES = doPrivileged(JavaDispatcher.of(MethodHandles.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to interacting with {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;         */
<b class="fc">&nbsp;        private static final MethodHandles.Lookup METHOD_HANDLES_LOOKUP = doPrivileged(JavaDispatcher.of(MethodHandles.Lookup.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates a lookup instance&#39;s package lookup mode.
&nbsp;         */
&nbsp;        private static final int PACKAGE_LOOKUP = 0x8;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code java.lang.invoke.MethodHandles$Lookup} to use.
&nbsp;         */
&nbsp;        private final Object lookup;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class injector using a lookup instance.
&nbsp;         *
&nbsp;         * @param lookup The {@code java.lang.invoke.MethodHandles$Lookup} instance to use.
&nbsp;         */
<b class="fc">&nbsp;        protected UsingLookup(Object lookup) {</b>
<b class="fc">&nbsp;            this.lookup = lookup;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates class injector that defines a class using a method handle lookup.
&nbsp;         *
&nbsp;         * @param lookup The {@code java.lang.invoke.MethodHandles$Lookup} instance to use.
&nbsp;         * @return An appropriate class injector.
&nbsp;         */
&nbsp;        public static UsingLookup of(Object lookup) {
<b class="fc">&nbsp;            if (!isAvailable()) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;The current VM does not support class definition via method handle lookups&quot;);</b>
<b class="fc">&nbsp;            } else if (!JavaType.METHOD_HANDLES_LOOKUP.isInstance(lookup)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a method handle lookup: &quot; + lookup);</b>
<b class="fc">&nbsp;            } else if ((METHOD_HANDLES_LOOKUP.lookupModes(lookup) &amp; PACKAGE_LOOKUP) == 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Lookup does not imply package-access: &quot; + lookup);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new UsingLookup(lookup);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the lookup type this injector is based upon.
&nbsp;         *
&nbsp;         * @return The lookup type.
&nbsp;         */
&nbsp;        public Class&lt;?&gt; lookupType() {
<b class="fc">&nbsp;            return METHOD_HANDLES_LOOKUP.lookupClass(lookup);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this injector to use the supplied type&#39;s scope.
&nbsp;         *
&nbsp;         * @param type The type to resolve the access scope for.
&nbsp;         * @return An new injector with the specified scope.
&nbsp;         */
&nbsp;        public UsingLookup in(Class&lt;?&gt; type) {
&nbsp;            try {
<b class="fc">&nbsp;                return new UsingLookup(METHOD_HANDLES.privateLookupIn(type, lookup));</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot access &quot; + type.getName() + &quot; from &quot; + lookup, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAlive() {
<b class="fc">&nbsp;            return isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;? extends String, byte[]&gt; types) {
<b class="fc">&nbsp;            PackageDescription target = TypeDescription.ForLoadedType.of(lookupType()).getPackage();</b>
<b class="fc">&nbsp;            if (target == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot inject array or primitive type&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;? extends String, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;                int index = entry.getKey().lastIndexOf(&#39;.&#39;);</b>
<b class="fc">&nbsp;                if (!target.getName().equals(index == -1 ? &quot;&quot; : entry.getKey().substring(0, index))) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(entry.getKey() + &quot; must be defined in the same package as &quot; + lookup);</b>
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    result.put(entry.getKey(), METHOD_HANDLES_LOOKUP.defineClass(lookup, entry.getValue()));</b>
<b class="nc">&nbsp;                } catch (Exception exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(exception);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the current VM is capable of defining classes using a method handle lookup.
&nbsp;         *
&nbsp;         * @return {@code true} if the current VM is capable of defining classes using a lookup.
&nbsp;         */
&nbsp;        public static boolean isAvailable() {
<b class="fc">&nbsp;            return JavaType.MODULE.isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for {@code java.lang.invoke.MethodHandles}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandles&quot;)
&nbsp;        protected interface MethodHandles {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the supplied lookup instance&#39;s access scope for the supplied type.
&nbsp;             *
&nbsp;             * @param type   The type to resolve the scope for.
&nbsp;             * @param lookup The lookup to resolve.
&nbsp;             * @return An appropriate lookup instance.
&nbsp;             * @throws IllegalAccessException If an illegal access occurs.
&nbsp;             */
&nbsp;            @JavaDispatcher.IsStatic
&nbsp;            Object privateLookupIn(Class&lt;?&gt; type, @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandles$Lookup&quot;) Object lookup) throws IllegalAccessException;
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandles$Lookup&quot;)
&nbsp;            interface Lookup {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the lookup type for a given method handle lookup.
&nbsp;                 *
&nbsp;                 * @param lookup The lookup instance.
&nbsp;                 * @return The lookup type.
&nbsp;                 */
&nbsp;                Class&lt;?&gt; lookupClass(Object lookup);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a lookup objects lookup types.
&nbsp;                 *
&nbsp;                 * @param lookup The lookup instance.
&nbsp;                 * @return The modifiers indicating the instance&#39;s lookup modes.
&nbsp;                 */
&nbsp;                int lookupModes(Object lookup);
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines the represented class.
&nbsp;                 *
&nbsp;                 * @param lookup               The lookup instance.
&nbsp;                 * @param binaryRepresentation The binary representation.
&nbsp;                 * @return The defined class.
&nbsp;                 * @throws IllegalAccessException If the definition implies an illegal access.
&nbsp;                 */
&nbsp;                Class&lt;?&gt; defineClass(Object lookup, byte[] binaryRepresentation) throws IllegalAccessException;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class injector that uses {@code sun.misc.Unsafe} or {@code jdk.internal.misc.Unsafe} to inject classes.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class UsingUnsafe extends AbstractBase {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * If this property is set, Byte Buddy does not make use of any {@code Unsafe} class.
&nbsp;         */
&nbsp;        public static final String SAFE_PROPERTY = &quot;net.bytebuddy.safe&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to use.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher.Initializable DISPATCHER = doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.lang.System} to access the security manager if available.
&nbsp;         */
<b class="fc">&nbsp;        private static final System SYSTEM = doPrivileged(JavaDispatcher.of(System.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code java.lang.SecurityManager#checkPermission} method or {@code null} if not available.
&nbsp;         */
<b class="fc">&nbsp;        private static final Method CHECK_PERMISSION = doPrivileged(new GetMethodAction(&quot;java.lang.SecurityManager&quot;,</b>
&nbsp;                &quot;checkPermission&quot;,
&nbsp;                Permission.class));
&nbsp;
&nbsp;        /**
&nbsp;         * A lock for the bootstrap loader when injecting.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object BOOTSTRAP_LOADER_LOCK = new Object();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * The protection domain to use or {@code null} for no protection domain.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to use.
&nbsp;         */
&nbsp;        private final Dispatcher.Initializable dispatcher;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new unsafe injector for the given class loader with a default protection domain.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         */
&nbsp;        public UsingUnsafe(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            this(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new unsafe injector for the given class loader with a default protection domain.
&nbsp;         *
&nbsp;         * @param classLoader      The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         * @param protectionDomain The protection domain to use or {@code null} for no protection domain.
&nbsp;         */
&nbsp;        public UsingUnsafe(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;            this(classLoader, protectionDomain, DISPATCHER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new unsafe injector for the given class loader with a default protection domain.
&nbsp;         *
&nbsp;         * @param classLoader      The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         * @param protectionDomain The protection domain to use or {@code null} for no protection domain.
&nbsp;         * @param dispatcher       The dispatcher to use.
&nbsp;         */
<b class="fc">&nbsp;        protected UsingUnsafe(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain, Dispatcher.Initializable dispatcher) {</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
<b class="fc">&nbsp;            this.protectionDomain = protectionDomain;</b>
<b class="fc">&nbsp;            this.dispatcher = dispatcher;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAlive() {
<b class="fc">&nbsp;            return dispatcher.isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;? extends String, byte[]&gt; types) {
<b class="fc">&nbsp;            Dispatcher dispatcher = this.dispatcher.initialize();</b>
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            synchronized (classLoader == null</b>
<b class="fc">&nbsp;                    ? BOOTSTRAP_LOADER_LOCK</b>
<b class="fc">&nbsp;                    : classLoader) {</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;? extends String, byte[]&gt; entry : types.entrySet()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        result.put(entry.getKey(), Class.forName(entry.getKey(), false, classLoader));</b>
<b class="fc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            result.put(entry.getKey(), dispatcher.defineClass(classLoader, entry.getKey(), entry.getValue(), protectionDomain));</b>
<b class="nc">&nbsp;                        } catch (RuntimeException exception) { // The bootstrap loader lock might be replicated throughout multiple class loaders.</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                result.put(entry.getKey(), Class.forName(entry.getKey(), false, classLoader));</b>
<b class="nc">&nbsp;                            } catch (ClassNotFoundException ignored2) {</b>
<b class="nc">&nbsp;                                throw exception;</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } catch (Error error) { // The bootstrap loader lock might be replicated throughout multiple class loaders.</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                result.put(entry.getKey(), Class.forName(entry.getKey(), false, classLoader));</b>
<b class="nc">&nbsp;                            } catch (ClassNotFoundException ignored2) {</b>
<b class="nc">&nbsp;                                throw error;</b>
<b class="nc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if unsafe class injection is available on the current VM.
&nbsp;         *
&nbsp;         * @return {@code true} if unsafe class injection is available on the current VM.
&nbsp;         */
&nbsp;        public static boolean isAvailable() {
<b class="fc">&nbsp;            return DISPATCHER.isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an unsafe class injector for the system class loader.
&nbsp;         *
&nbsp;         * @return A class injector for the system class loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofSystemLoader() {
<b class="fc">&nbsp;            return new UsingUnsafe(ClassLoader.getSystemClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an unsafe class injector for the platform class loader. For VMs of version 8 or older,
&nbsp;         * the extension class loader is represented instead.
&nbsp;         *
&nbsp;         * @return A class injector for the platform class loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofPlatformLoader() {
<b class="fc">&nbsp;            return new UsingUnsafe(ClassLoader.getSystemClassLoader().getParent());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an unsafe class injector for the boot class loader.
&nbsp;         *
&nbsp;         * @return A class injector for the boot loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofBootLoader() {
<b class="fc">&nbsp;            return new UsingUnsafe(ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for using {@code sun.misc.Unsafe} or {@code jdk.internal.misc.Unsafe}.
&nbsp;         */
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Defines a class.
&nbsp;             *
&nbsp;             * @param classLoader          The class loader to inject the class into.
&nbsp;             * @param name                 The type&#39;s name.
&nbsp;             * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;             * @param protectionDomain     The type&#39;s protection domain.
&nbsp;             * @return The defined class.
&nbsp;             */
&nbsp;            Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader,
&nbsp;                                 String name,
&nbsp;                                 byte[] binaryRepresentation,
&nbsp;                                 @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;            /**
&nbsp;             * A class injection dispatcher that is not yet initialized.
&nbsp;             */
&nbsp;            interface Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Checks if unsafe class injection is available on the current VM.
&nbsp;                 *
&nbsp;                 * @return {@code true} if unsafe class injection is available.
&nbsp;                 */
&nbsp;                boolean isAvailable();
&nbsp;
&nbsp;                /**
&nbsp;                 * Initializes the dispatcher.
&nbsp;                 *
&nbsp;                 * @return The initialized dispatcher.
&nbsp;                 */
&nbsp;                Dispatcher initialize();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A privileged action for creating a dispatcher.
&nbsp;             */
<b class="fc">&nbsp;            enum CreationAction implements PrivilegedAction&lt;Initializable&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                public Initializable run() {
<b class="fc">&nbsp;                    if (Boolean.parseBoolean(java.lang.System.getProperty(SAFE_PROPERTY, Boolean.toString(GraalImageCode.getCurrent().isDefined())))) {</b>
<b class="nc">&nbsp;                        return new Unavailable(&quot;Use of Unsafe was disabled by system property&quot;);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        Class&lt;?&gt; unsafeType = Class.forName(&quot;sun.misc.Unsafe&quot;);</b>
<b class="fc">&nbsp;                        Field theUnsafe = unsafeType.getDeclaredField(&quot;theUnsafe&quot;);</b>
<b class="fc">&nbsp;                        theUnsafe.setAccessible(true);</b>
<b class="fc">&nbsp;                        Object unsafe = theUnsafe.get(null);</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            Method defineClass = unsafeType.getMethod(&quot;defineClass&quot;,</b>
&nbsp;                                    String.class,
&nbsp;                                    byte[].class,
&nbsp;                                    int.class,
&nbsp;                                    int.class,
&nbsp;                                    ClassLoader.class,
&nbsp;                                    ProtectionDomain.class);
<b class="nc">&nbsp;                            defineClass.setAccessible(true);</b>
<b class="nc">&nbsp;                            return new Enabled(unsafe, defineClass);</b>
<b class="fc">&nbsp;                        } catch (Exception exception) {</b>
&nbsp;                            try {
&nbsp;                                Field override;
&nbsp;                                try {
<b class="fc">&nbsp;                                    override = AccessibleObject.class.getDeclaredField(&quot;override&quot;);</b>
<b class="fc">&nbsp;                                } catch (NoSuchFieldException ignored) {</b>
&nbsp;                                    // Since Java 12, the override field is hidden from the reflection API. To circumvent this, we
&nbsp;                                    // create a mirror class of AccessibleObject that defines the same fields and has the same field
&nbsp;                                    // layout such that the override field will receive the same class offset. Doing so, we can write to
&nbsp;                                    // the offset location and still set a value to it, despite it being hidden from the reflection API.
<b class="fc">&nbsp;                                    override = new ByteBuddy()</b>
<b class="fc">&nbsp;                                            .redefine(AccessibleObject.class)</b>
<b class="fc">&nbsp;                                            .name(&quot;net.bytebuddy.mirror.&quot; + AccessibleObject.class.getSimpleName())</b>
<b class="fc">&nbsp;                                            .noNestMate()</b>
<b class="fc">&nbsp;                                            .visit(new MemberRemoval().stripInvokables(any()))</b>
<b class="fc">&nbsp;                                            .make()</b>
<b class="fc">&nbsp;                                            .load(AccessibleObject.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER.with(AccessibleObject.class.getProtectionDomain()))</b>
<b class="fc">&nbsp;                                            .getLoaded()</b>
<b class="fc">&nbsp;                                            .getDeclaredField(&quot;override&quot;);</b>
<b class="nc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                long offset = (Long) unsafeType</b>
<b class="fc">&nbsp;                                        .getMethod(&quot;objectFieldOffset&quot;, Field.class)</b>
<b class="fc">&nbsp;                                        .invoke(unsafe, override);</b>
<b class="fc">&nbsp;                                Method putBoolean = unsafeType.getMethod(&quot;putBoolean&quot;, Object.class, long.class, boolean.class);</b>
<b class="fc">&nbsp;                                Class&lt;?&gt; internalUnsafe = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);</b>
<b class="fc">&nbsp;                                Field theUnsafeInternal = internalUnsafe.getDeclaredField(&quot;theUnsafe&quot;);</b>
<b class="fc">&nbsp;                                putBoolean.invoke(unsafe, theUnsafeInternal, offset, true);</b>
<b class="fc">&nbsp;                                Method defineClassInternal = internalUnsafe.getMethod(&quot;defineClass&quot;,</b>
&nbsp;                                        String.class,
&nbsp;                                        byte[].class,
&nbsp;                                        int.class,
&nbsp;                                        int.class,
&nbsp;                                        ClassLoader.class,
&nbsp;                                        ProtectionDomain.class);
<b class="fc">&nbsp;                                putBoolean.invoke(unsafe, defineClassInternal, offset, true);</b>
<b class="fc">&nbsp;                                return new Enabled(theUnsafeInternal.get(null), defineClassInternal);</b>
<b class="nc">&nbsp;                            } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                                throw exception;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (Exception exception) {</b>
<b class="nc">&nbsp;                        return new Unavailable(exception.getMessage());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An enabled dispatcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Enabled implements Dispatcher, Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * An instance of {@code sun.misc.Unsafe} or {@code jdk.internal.misc.Unsafe}.
&nbsp;                 */
&nbsp;                private final Object unsafe;
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code sun.misc.Unsafe#defineClass} or {@code jdk.internal.misc.Unsafe#defineClass} method.
&nbsp;                 */
&nbsp;                private final Method defineClass;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an enabled dispatcher.
&nbsp;                 *
&nbsp;                 * @param unsafe      An instance of {@code sun.misc.Unsafe} or {@code jdk.internal.misc.Unsafe}.
&nbsp;                 * @param defineClass The {@code sun.misc.Unsafe#defineClass} or {@code jdk.internal.misc.Unsafe#defineClass} method.
&nbsp;                 */
<b class="fc">&nbsp;                protected Enabled(Object unsafe, Method defineClass) {</b>
<b class="fc">&nbsp;                    this.unsafe = unsafe;</b>
<b class="fc">&nbsp;                    this.defineClass = defineClass;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher initialize() {
<b class="fc">&nbsp;                    Object securityManager = SYSTEM.getSecurityManager();</b>
<b class="fc">&nbsp;                    if (securityManager != null) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            CHECK_PERMISSION.invoke(securityManager, SUPPRESS_ACCESS_CHECKS);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            return new Unavailable(exception.getTargetException().getMessage());</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            return new Unavailable(exception.getMessage());</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return (Class&lt;?&gt;) defineClass.invoke(unsafe,</b>
&nbsp;                                name,
&nbsp;                                binaryRepresentation,
<b class="fc">&nbsp;                                0,</b>
<b class="fc">&nbsp;                                binaryRepresentation.length,</b>
&nbsp;                                classLoader,
&nbsp;                                protectionDomain);
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A disabled dispatcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Unavailable implements Dispatcher, Initializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The reason why this dispatcher is not available.
&nbsp;                 */
&nbsp;                private final String message;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a disabled dispatcher.
&nbsp;                 *
&nbsp;                 * @param message The reason why this dispatcher is not available.
&nbsp;                 */
<b class="fc">&nbsp;                protected Unavailable(String message) {</b>
<b class="fc">&nbsp;                    this.message = message;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher initialize() {
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;Could not access Unsafe class: &quot; + message);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
<b class="nc">&nbsp;                    throw new UnsupportedOperationException(&quot;Could not access Unsafe class: &quot; + message);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a {@link ClassInjector} that uses {@code sun.misc.Unsafe} if available but attempts a fallback
&nbsp;         * to using {@code jdk.internal.misc.Unsafe} if the {@code jdk.internal} module is not resolved or unavailable.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The dispatcher to use.
&nbsp;             */
&nbsp;            private final Dispatcher.Initializable dispatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new factory for an unsafe class injector that uses Byte Buddy&#39;s privileges to
&nbsp;             * accessing {@code jdk.internal.misc.Unsafe} if available.
&nbsp;             */
&nbsp;            public Factory() {
<b class="fc">&nbsp;                this(AccessResolver.Default.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new factory for an unsafe class injector.
&nbsp;             *
&nbsp;             * @param accessResolver The access resolver to use.
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
<b class="fc">&nbsp;            public Factory(AccessResolver accessResolver) {</b>
&nbsp;                Dispatcher.Initializable dispatcher;
<b class="fc">&nbsp;                if (DISPATCHER.isAvailable()) {</b>
<b class="fc">&nbsp;                    dispatcher = DISPATCHER;</b>
&nbsp;                } else {
&nbsp;                    try {
<b class="nc">&nbsp;                        Class&lt;?&gt; unsafeType = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);</b>
<b class="nc">&nbsp;                        Field theUnsafe = unsafeType.getDeclaredField(&quot;theUnsafe&quot;);</b>
<b class="nc">&nbsp;                        accessResolver.apply(theUnsafe);</b>
<b class="nc">&nbsp;                        Object unsafe = theUnsafe.get(null);</b>
<b class="nc">&nbsp;                        Method defineClass = unsafeType.getMethod(&quot;defineClass&quot;,</b>
&nbsp;                                String.class,
&nbsp;                                byte[].class,
&nbsp;                                int.class,
&nbsp;                                int.class,
&nbsp;                                ClassLoader.class,
&nbsp;                                ProtectionDomain.class);
<b class="nc">&nbsp;                        accessResolver.apply(defineClass);</b>
<b class="nc">&nbsp;                        dispatcher = new Dispatcher.Enabled(unsafe, defineClass);</b>
<b class="nc">&nbsp;                    } catch (Exception exception) {</b>
<b class="nc">&nbsp;                        dispatcher = new Dispatcher.Unavailable(exception.getMessage());</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                this.dispatcher = dispatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new factory.
&nbsp;             *
&nbsp;             * @param dispatcher The dispatcher to use.
&nbsp;             */
<b class="nc">&nbsp;            protected Factory(Dispatcher.Initializable dispatcher) {</b>
<b class="nc">&nbsp;                this.dispatcher = dispatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an injection strategy that uses unsafe injection if available and also attempts to open and use
&nbsp;             * {@code jdk.internal.misc.Unsafe} as a fallback. This method generates a new class and module for opening the
&nbsp;             * internal package to avoid its exposure to any non-trusted code.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use for opening the internal package if required.
&nbsp;             * @return An appropriate injection strategy.
&nbsp;             */
&nbsp;            public static Factory resolve(Instrumentation instrumentation) {
<b class="fc">&nbsp;                return resolve(instrumentation, false);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an injection strategy that uses unsafe injection if available and also attempts to open and use
&nbsp;             * {@code jdk.internal.misc.Unsafe} as a fallback.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use for opening the internal package if required.
&nbsp;             * @param local           {@code false} if a new class should in a separated class loader and module should be created for
&nbsp;             *                        opening the {@code jdk.internal.misc} package. This way, the internal package is not exposed to any
&nbsp;             *                        other classes within this class&#39;s module.
&nbsp;             * @return An appropriate injection strategy.
&nbsp;             */
&nbsp;            @SuppressFBWarnings(
&nbsp;                    value = {&quot;REC_CATCH_EXCEPTION&quot;, &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Exception intends to trigger disabled injection strategy. Modules are assumed if module system is supported.&quot;)
&nbsp;            public static Factory resolve(Instrumentation instrumentation, boolean local) {
<b class="fc">&nbsp;                if (ClassInjector.UsingUnsafe.isAvailable() || !JavaModule.isSupported()) {</b>
<b class="fc">&nbsp;                    return new Factory();</b>
&nbsp;                } else {
&nbsp;                    try {
<b class="nc">&nbsp;                        Class&lt;?&gt; type = Class.forName(&quot;jdk.internal.misc.Unsafe&quot;);</b>
<b class="nc">&nbsp;                        PackageDescription packageDescription = new PackageDescription.ForLoadedPackage(type.getPackage());</b>
<b class="nc">&nbsp;                        JavaModule source = JavaModule.ofType(type), target = JavaModule.ofType(ClassInjector.UsingUnsafe.class);</b>
<b class="nc">&nbsp;                        if (source.isOpened(packageDescription, target)) {</b>
<b class="nc">&nbsp;                            return new Factory();</b>
<b class="nc">&nbsp;                        } else if (local) {</b>
<b class="nc">&nbsp;                            JavaModule module = JavaModule.ofType(AccessResolver.Default.class);</b>
<b class="nc">&nbsp;                            UsingInstrumentation.redefineModule(instrumentation,</b>
&nbsp;                                    source,
<b class="nc">&nbsp;                                    Collections.singleton(module),</b>
<b class="nc">&nbsp;                                    Collections.&lt;String, Set&lt;JavaModule&gt;&gt;emptyMap(),</b>
<b class="nc">&nbsp;                                    Collections.singletonMap(packageDescription.getName(), Collections.singleton(module)),</b>
<b class="nc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;&gt;emptySet(),</b>
<b class="nc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt;emptyMap());</b>
<b class="nc">&nbsp;                            return new Factory();</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            Class&lt;? extends AccessResolver&gt; resolver = new ByteBuddy()</b>
<b class="nc">&nbsp;                                    .subclass(AccessResolver.class)</b>
<b class="nc">&nbsp;                                    .method(named(&quot;apply&quot;))</b>
<b class="nc">&nbsp;                                    .intercept(MethodCall.invoke(AccessibleObject.class.getMethod(&quot;setAccessible&quot;, boolean.class))</b>
<b class="nc">&nbsp;                                            .onArgument(0)</b>
<b class="nc">&nbsp;                                            .with(true))</b>
<b class="nc">&nbsp;                                    .make()</b>
<b class="nc">&nbsp;                                    .load(AccessResolver.class.getClassLoader(), ClassLoadingStrategy.Default.WRAPPER.with(AccessResolver.class.getProtectionDomain()))</b>
<b class="nc">&nbsp;                                    .getLoaded();</b>
<b class="nc">&nbsp;                            JavaModule module = JavaModule.ofType(resolver);</b>
<b class="nc">&nbsp;                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation,</b>
&nbsp;                                    source,
<b class="nc">&nbsp;                                    Collections.singleton(module),</b>
<b class="nc">&nbsp;                                    Collections.&lt;String, Set&lt;JavaModule&gt;&gt;emptyMap(),</b>
<b class="nc">&nbsp;                                    Collections.singletonMap(packageDescription.getName(), Collections.singleton(module)),</b>
<b class="nc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;&gt;emptySet(),</b>
<b class="nc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt;emptyMap());</b>
<b class="nc">&nbsp;                            return new ClassInjector.UsingUnsafe.Factory(resolver.getConstructor().newInstance());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (Exception exception) {</b>
<b class="nc">&nbsp;                        return new Factory(new Dispatcher.Unavailable(exception.getMessage()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if this factory creates a valid dispatcher.
&nbsp;             *
&nbsp;             * @return {@code true} if this factory creates a valid dispatcher.
&nbsp;             */
&nbsp;            public boolean isAvailable() {
<b class="fc">&nbsp;                return dispatcher.isAvailable();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new class injector for the given class loader without a {@link ProtectionDomain}.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to inject into or {@code null} to inject into the bootstrap loader.
&nbsp;             * @return An appropriate class injector.
&nbsp;             */
&nbsp;            public ClassInjector make(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                return make(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new class injector for the given class loader and protection domain.
&nbsp;             *
&nbsp;             * @param classLoader      The class loader to inject into or {@code null} to inject into the bootstrap loader.
&nbsp;             * @param protectionDomain The protection domain to apply or {@code null} if no protection domain should be used.
&nbsp;             * @return An appropriate class injector.
&nbsp;             */
&nbsp;            public ClassInjector make(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return new UsingUnsafe(classLoader, protectionDomain, dispatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An access resolver that invokes {@link AccessibleObject#setAccessible(boolean)} to {@code true} in a given privilege scope.
&nbsp;             */
&nbsp;            public interface AccessResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this access resolver.
&nbsp;                 *
&nbsp;                 * @param accessibleObject The accessible object to make accessible.
&nbsp;                 */
&nbsp;                void apply(AccessibleObject accessibleObject);
&nbsp;
&nbsp;                /**
&nbsp;                 * A default access resolver that uses Byte Buddy&#39;s privilege scope.
&nbsp;                 */
<b class="fc">&nbsp;                enum Default implements AccessResolver {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply(AccessibleObject accessibleObject) {
<b class="nc">&nbsp;                        accessibleObject.setAccessible(true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy of {@code java.lang.System}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.System&quot;)
&nbsp;        protected interface System {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the current security manager or {@code null} if not available.
&nbsp;             *
&nbsp;             * @return The current security manager or {@code null} if not available.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @JavaDispatcher.IsStatic
&nbsp;            @JavaDispatcher.Defaults
&nbsp;            Object getSecurityManager();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class injector using a {@link java.lang.instrument.Instrumentation} to append to either the boot classpath
&nbsp;     * or the system class path.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class UsingInstrumentation extends AbstractBase {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The jar file name extension.
&nbsp;         */
&nbsp;        private static final String JAR = &quot;jar&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The class file extension.
&nbsp;         */
&nbsp;        private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interacting with the instrumentation API.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumentation to use for appending to the class path or the boot path.
&nbsp;         */
&nbsp;        private final Instrumentation instrumentation;
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the target path to which classes are to be appended.
&nbsp;         */
&nbsp;        private final Target target;
&nbsp;
&nbsp;        /**
&nbsp;         * The folder to be used for storing jar files.
&nbsp;         */
&nbsp;        private final File folder;
&nbsp;
&nbsp;        /**
&nbsp;         * A random string generator for creating file names.
&nbsp;         */
&nbsp;        private final RandomString randomString;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an instrumentation-based class injector.
&nbsp;         *
&nbsp;         * @param folder          The folder to be used for storing jar files.
&nbsp;         * @param target          A representation of the target path to which classes are to be appended.
&nbsp;         * @param instrumentation The instrumentation to use for appending to the class path or the boot path.
&nbsp;         * @param randomString    The random string generator to use.
&nbsp;         */
&nbsp;        protected UsingInstrumentation(File folder,
&nbsp;                                       Target target,
&nbsp;                                       Instrumentation instrumentation,
<b class="fc">&nbsp;                                       RandomString randomString) {</b>
<b class="fc">&nbsp;            this.folder = folder;</b>
<b class="fc">&nbsp;            this.target = target;</b>
<b class="fc">&nbsp;            this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;            this.randomString = randomString;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Modifies a module&#39;s properties using {@link Instrumentation}.
&nbsp;         *
&nbsp;         * @param instrumentation The {@link Instrumentation} instance to use for applying the modification.
&nbsp;         * @param target          The target module that should be modified.
&nbsp;         * @param reads           A set of additional modules this module should read.
&nbsp;         * @param exports         A map of packages to export to a set of modules.
&nbsp;         * @param opens           A map of packages to open to a set of modules.
&nbsp;         * @param uses            A set of provider interfaces to use by this module.
&nbsp;         * @param provides        A map of provider interfaces to provide by this module mapped to the provider implementations.
&nbsp;         */
&nbsp;        public static void redefineModule(Instrumentation instrumentation,
&nbsp;                                          JavaModule target,
&nbsp;                                          Set&lt;JavaModule&gt; reads,
&nbsp;                                          Map&lt;String, Set&lt;JavaModule&gt;&gt; exports,
&nbsp;                                          Map&lt;String, Set&lt;JavaModule&gt;&gt; opens,
&nbsp;                                          Set&lt;Class&lt;?&gt;&gt; uses,
&nbsp;                                          Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; provides) {
<b class="fc">&nbsp;            if (!DISPATCHER.isModifiableModule(instrumentation, target.unwrap())) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot modify module: &quot; + target);</b>
&nbsp;            }
<b class="fc">&nbsp;            Set&lt;Object&gt; unwrappedReads = new HashSet&lt;Object&gt;();</b>
<b class="fc">&nbsp;            for (JavaModule read : reads) {</b>
<b class="fc">&nbsp;                unwrappedReads.add(read.unwrap());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            Map&lt;String, Set&lt;?&gt;&gt; unwrappedExports = new HashMap&lt;String, Set&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;String, Set&lt;JavaModule&gt;&gt; entry : exports.entrySet()) {</b>
<b class="nc">&nbsp;                Set&lt;Object&gt; modules = new HashSet&lt;Object&gt;();</b>
<b class="nc">&nbsp;                for (JavaModule module : entry.getValue()) {</b>
<b class="nc">&nbsp;                    modules.add(module.unwrap());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                unwrappedExports.put(entry.getKey(), modules);</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            Map&lt;String, Set&lt;?&gt;&gt; unwrappedOpens = new HashMap&lt;String, Set&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;String, Set&lt;JavaModule&gt;&gt; entry : opens.entrySet()) {</b>
<b class="nc">&nbsp;                Set&lt;Object&gt; modules = new HashSet&lt;Object&gt;();</b>
<b class="nc">&nbsp;                for (JavaModule module : entry.getValue()) {</b>
<b class="nc">&nbsp;                    modules.add(module.unwrap());</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                unwrappedOpens.put(entry.getKey(), modules);</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            DISPATCHER.redefineModule(instrumentation, target.unwrap(), unwrappedReads, unwrappedExports, unwrappedOpens, uses, provides);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an instrumentation-based class injector.
&nbsp;         *
&nbsp;         * @param folder          The folder to be used for storing jar files.
&nbsp;         * @param target          A representation of the target path to which classes are to be appended.
&nbsp;         * @param instrumentation The instrumentation to use for appending to the class path or the boot path.
&nbsp;         * @return An appropriate class injector that applies instrumentation.
&nbsp;         */
&nbsp;        public static ClassInjector of(File folder, Target target, Instrumentation instrumentation) {
<b class="fc">&nbsp;            return new UsingInstrumentation(folder, target, instrumentation, new RandomString());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAlive() {
<b class="fc">&nbsp;            return isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;? extends String, byte[]&gt; types) {
<b class="fc">&nbsp;            File file = new File(folder, JAR + randomString.nextString() + &quot;.&quot; + JAR);</b>
&nbsp;            try {
<b class="fc">&nbsp;                if (!file.createNewFile()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot create file &quot; + file);</b>
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(file));</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        for (Map.Entry&lt;? extends String, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;                            jarOutputStream.putNextEntry(new JarEntry(entry.getKey().replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION));</b>
<b class="fc">&nbsp;                            jarOutputStream.write(entry.getValue());</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        jarOutputStream.close();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    JarFile jarFile = new JarFile(file, false);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        target.inject(instrumentation, jarFile);</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        jarFile.close();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                    for (String name : types.keySet()) {</b>
<b class="fc">&nbsp;                        result.put(name, Class.forName(name, false, target.getClassLoader()));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return result;</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    if (!file.delete()) {</b>
<b class="fc">&nbsp;                        file.deleteOnExit();</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } catch (IOException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot write jar file to disk&quot;, exception);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot load injected class&quot;, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if this class injector is available on this VM.
&nbsp;         *
&nbsp;         * @return {@code true} if this class injector is available on this VM.
&nbsp;         */
&nbsp;        public static boolean isAvailable() {
<b class="fc">&nbsp;            return ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V6);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with the instrumentation API.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.instrument.Instrumentation&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Appends a jar file to the bootstrap class loader.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to interact with.
&nbsp;             * @param jarFile         The jar file to append.
&nbsp;             */
&nbsp;            void appendToBootstrapClassLoaderSearch(Instrumentation instrumentation, JarFile jarFile);
&nbsp;
&nbsp;            /**
&nbsp;             * Appends a jar file to the system class loader.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to interact with.
&nbsp;             * @param jarFile         The jar file to append.
&nbsp;             */
&nbsp;            void appendToSystemClassLoaderSearch(Instrumentation instrumentation, JarFile jarFile);
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if a module is modifiable.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use for checking for modifiability.
&nbsp;             * @param module          The {@code java.lang.Module} to examine.
&nbsp;             * @return {@code true} if the supplied module is modifiable.
&nbsp;             */
&nbsp;            boolean isModifiableModule(Instrumentation instrumentation, @JavaDispatcher.Proxied(&quot;java.lang.Module&quot;) Object module);
&nbsp;
&nbsp;            /**
&nbsp;             * Redefines an existing module.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to redefine.
&nbsp;             * @param module          The {@code java.lang.Module} to redefine.
&nbsp;             * @param reads           A set of {@code java.lang.Module}s that are to be read additionally.
&nbsp;             * @param exports         A map of packages to a set of {@code java.lang.Module}s to read additionally.
&nbsp;             * @param opens           A map of packages to a set of {@code java.lang.Module}s to open to additionally.
&nbsp;             * @param uses            A list of types to use additionally.
&nbsp;             * @param provides        A list of types to their implementations to offer additionally.
&nbsp;             */
&nbsp;            void redefineModule(Instrumentation instrumentation,
&nbsp;                                @JavaDispatcher.Proxied(&quot;java.lang.Module&quot;) Object module,
&nbsp;                                Set&lt;?&gt; reads,
&nbsp;                                Map&lt;String, Set&lt;?&gt;&gt; exports,
&nbsp;                                Map&lt;String, Set&lt;?&gt;&gt; opens,
&nbsp;                                Set&lt;Class&lt;?&gt;&gt; uses,
&nbsp;                                Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; provides);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the target to which Java classes should be appended to.
&nbsp;         */
<b class="fc">&nbsp;        public enum Target {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Representation of the bootstrap class loader.
&nbsp;             */
<b class="fc">&nbsp;            BOOTSTRAP(null) {</b>
&nbsp;                @Override
&nbsp;                protected void inject(Instrumentation instrumentation, JarFile jarFile) {
<b class="fc">&nbsp;                    DISPATCHER.appendToBootstrapClassLoaderSearch(instrumentation, jarFile);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Representation of the system class loader.
&nbsp;             */
<b class="fc">&nbsp;            SYSTEM(ClassLoader.getSystemClassLoader()) {</b>
&nbsp;                @Override
&nbsp;                protected void inject(Instrumentation instrumentation, JarFile jarFile) {
<b class="fc">&nbsp;                    DISPATCHER.appendToSystemClassLoaderSearch(instrumentation, jarFile);</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader to load classes from.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final ClassLoader classLoader;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new injection target.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to load classes from.
&nbsp;             */
<b class="fc">&nbsp;            Target(@MaybeNull ClassLoader classLoader) {</b>
<b class="fc">&nbsp;                this.classLoader = classLoader;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the class loader to load classes from.
&nbsp;             *
&nbsp;             * @return The class loader to load classes from.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            protected ClassLoader getClassLoader() {
<b class="fc">&nbsp;                return classLoader;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Adds the given classes to the represented class loader.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use.
&nbsp;             * @param jarFile         The jar file to append.
&nbsp;             */
&nbsp;            protected abstract void inject(Instrumentation instrumentation, JarFile jarFile);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class injector using JNA to invoke JNI&#39;s define class utility for defining a class. This injector is only
&nbsp;     * available if JNA is available on the class loader. Some JVM implementations might not support this injection
&nbsp;     * method.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class UsingJna extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to use.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = doPrivileged(Dispatcher.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A lock for the bootstrap loader when injecting.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object BOOTSTRAP_LOADER_LOCK = new Object();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * The protection domain to use or {@code null} for no protection domain.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new unsafe injector for the given class loader with a default protection domain.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         */
&nbsp;        public UsingJna(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            this(classLoader, ClassLoadingStrategy.NO_PROTECTION_DOMAIN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new JNA injector for the given class loader with a default protection domain.
&nbsp;         *
&nbsp;         * @param classLoader      The class loader to inject classes into or {@code null} for the bootstrap loader.
&nbsp;         * @param protectionDomain The protection domain to use or {@code null} for no protection domain.
&nbsp;         */
<b class="fc">&nbsp;        public UsingJna(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
<b class="fc">&nbsp;            this.protectionDomain = protectionDomain;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if JNA class injection is available on the current VM.
&nbsp;         *
&nbsp;         * @return {@code true} if JNA class injection is available on the current VM.
&nbsp;         */
&nbsp;        public static boolean isAvailable() {
<b class="fc">&nbsp;            return DISPATCHER.isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an JNA class injector for the system class loader.
&nbsp;         *
&nbsp;         * @return A class injector for the system class loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofSystemLoader() {
<b class="fc">&nbsp;            return new UsingJna(ClassLoader.getSystemClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an JNA class injector for the platform class loader. For VMs of version 8 or older,
&nbsp;         * the extension class loader is represented instead.
&nbsp;         *
&nbsp;         * @return A class injector for the platform class loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofPlatformLoader() {
<b class="fc">&nbsp;            return new UsingJna(ClassLoader.getSystemClassLoader().getParent());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an JNA class injector for the boot class loader.
&nbsp;         *
&nbsp;         * @return A class injector for the boot loader.
&nbsp;         */
&nbsp;        public static ClassInjector ofBootLoader() {
<b class="fc">&nbsp;            return new UsingJna(ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAlive() {
<b class="fc">&nbsp;            return DISPATCHER.isAvailable();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;String, Class&lt;?&gt;&gt; injectRaw(Map&lt;? extends String, byte[]&gt; types) {
<b class="fc">&nbsp;            Map&lt;String, Class&lt;?&gt;&gt; result = new HashMap&lt;String, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            synchronized (classLoader == null</b>
<b class="nc">&nbsp;                    ? BOOTSTRAP_LOADER_LOCK</b>
<b class="fc">&nbsp;                    : classLoader) {</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;? extends String, byte[]&gt; entry : types.entrySet()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        result.put(entry.getKey(), Class.forName(entry.getKey(), false, classLoader));</b>
<b class="fc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="fc">&nbsp;                        result.put(entry.getKey(), DISPATCHER.defineClass(classLoader, entry.getKey(), entry.getValue(), protectionDomain));</b>
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for JNA class injection.
&nbsp;         */
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if this dispatcher is available for use.
&nbsp;             *
&nbsp;             * @return {@code true} if this dispatcher is available for use.
&nbsp;             */
&nbsp;            boolean isAvailable();
&nbsp;
&nbsp;            /**
&nbsp;             * Defines a class.
&nbsp;             *
&nbsp;             * @param classLoader          The class loader or {@code null} if a class should be injected into the bootstrap loader.
&nbsp;             * @param name                 The class&#39;s name.
&nbsp;             * @param binaryRepresentation The class&#39;s class file.
&nbsp;             * @param protectionDomain     The protection domain to use or {@code null} if no protection domain should be used.
&nbsp;             * @return The class that was defined.
&nbsp;             */
&nbsp;            Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader,
&nbsp;                                 String name,
&nbsp;                                 byte[] binaryRepresentation,
&nbsp;                                 @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;            /**
&nbsp;             * An action for creating a JNA dispatcher.
&nbsp;             */
<b class="fc">&nbsp;            enum CreationAction implements PrivilegedAction&lt;Dispatcher&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;                public Dispatcher run() {
<b class="fc">&nbsp;                    if (System.getProperty(&quot;java.vm.name&quot;, &quot;&quot;).toUpperCase(Locale.US).contains(&quot;J9&quot;)) {</b>
<b class="nc">&nbsp;                        return new Unavailable(&quot;J9 does not support JNA-based class definition&quot;);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        Map&lt;String, Object&gt; options = new HashMap&lt;String, Object&gt;();</b>
<b class="fc">&nbsp;                        options.put(Library.OPTION_ALLOW_OBJECTS, Boolean.TRUE);</b>
<b class="fc">&nbsp;                        if (Platform.isWindows() &amp;&amp; !Platform.is64Bit()) {</b>
<b class="nc">&nbsp;                            options.put(Library.OPTION_FUNCTION_MAPPER, Windows32BitFunctionMapper.INSTANCE);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Enabled(Native.loadLibrary(&quot;jvm&quot;, Jvm.class, options));</b>
<b class="nc">&nbsp;                    } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                        return new Unavailable(throwable.getMessage());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A mapper for 32-bit Windows functions where names are defined with different convention.
&nbsp;             */
<b class="nc">&nbsp;            enum Windows32BitFunctionMapper implements FunctionMapper {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getFunctionName(NativeLibrary library, Method method) {
<b class="nc">&nbsp;                    if (method.getName().equals(&quot;JVM_DefineClass&quot;)) {</b>
<b class="nc">&nbsp;                        return &quot;_JVM_DefineClass@24&quot;;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return method.getName();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An enabled dispatcher for JNA-based class injection.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Enabled implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The JNA-dispatcher to use for invoking JNI&#39;s class definition utilities.
&nbsp;                 */
&nbsp;                private final Jvm jvm;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher for a JNI&#39;s class definition utilities.
&nbsp;                 *
&nbsp;                 * @param jvm The JNA-dispatcher to use for invoking JNI&#39;s class definition utilities.
&nbsp;                 */
<b class="fc">&nbsp;                protected Enabled(Jvm jvm) {</b>
<b class="fc">&nbsp;                    this.jvm = jvm;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return jvm.JVM_DefineClass(JNIEnv.CURRENT,</b>
<b class="fc">&nbsp;                            name.replace(&#39;.&#39;, &#39;/&#39;),</b>
&nbsp;                            classLoader,
&nbsp;                            binaryRepresentation,
&nbsp;                            binaryRepresentation.length,
&nbsp;                            protectionDomain);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An unavailable dispatcher for JNA-based class injection.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Unavailable implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The exception&#39;s error message when attempting to resolve the JNA dispatcher.
&nbsp;                 */
&nbsp;                private final String error;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new unavailable JNA-based class injector.
&nbsp;                 *
&nbsp;                 * @param error The exception&#39;s error message when attempting to resolve the JNA dispatcher.
&nbsp;                 */
<b class="fc">&nbsp;                protected Unavailable(String error) {</b>
<b class="fc">&nbsp;                    this.error = error;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; defineClass(@MaybeNull ClassLoader classLoader, String name, byte[] binaryRepresentation, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;JNA is not available and JNA-based injection cannot be used: &quot; + error);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A JNA dispatcher for the JVM&#39;s &lt;i&gt;JVM_DefineClass&lt;/i&gt; method.
&nbsp;             */
&nbsp;            interface Jvm extends Library {
&nbsp;
&nbsp;                /**
&nbsp;                 * Defines a new class into a given class loader.
&nbsp;                 *
&nbsp;                 * @param env                  The JNI environment.
&nbsp;                 * @param name                 The internal name of the class.
&nbsp;                 * @param classLoader          The class loader to inject into or {@code null} if injecting into the bootstrap loader.
&nbsp;                 * @param binaryRepresentation The class&#39;s binary representation.
&nbsp;                 * @param length               The length of the class&#39;s binary representation.
&nbsp;                 * @param protectionDomain     The protection domain or {@code null} if no explicit protection domain should be used.
&nbsp;                 * @return The class that was defined.
&nbsp;                 * @throws LastErrorException If an error occurs during injection.
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                Class&lt;?&gt; JVM_DefineClass(JNIEnv env,
&nbsp;                                         String name,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         byte[] binaryRepresentation,
&nbsp;                                         int length,
&nbsp;                                         @MaybeNull ProtectionDomain protectionDomain) throws LastErrorException;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
