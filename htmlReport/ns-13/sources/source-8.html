


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > PackageDefinitionStrategy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.loading</a>
</div>

<h1>Coverage Summary for Class: PackageDefinitionStrategy (net.bytebuddy.dynamic.loading)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$Definition</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$Definition$Simple</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48.7%
  </span>
  <span class="absValue">
    (19/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$Definition$Trivial</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$Definition$Undefined</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.3%
  </span>
  <span class="absValue">
    (29/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator$ForFixedValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator$ForTypeResourceUrl</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator$MockitoMock$205089496</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator$MockitoMock$205089496$auxiliary$1w1J4tSq</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator$MockitoMock$205089496$auxiliary$rjnTmZ5I</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$ManifestReading$SealBaseLocator$NonSealing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$MockitoMock$86196660</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$MockitoMock$86196660$auxiliary$2hA7sLfN</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$MockitoMock$86196660$auxiliary$AtxLPJZK</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">PackageDefinitionStrategy$Trivial</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (45/55)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (81/139)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic.loading;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URI;
&nbsp;import java.net.URL;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.jar.Attributes;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.Manifest;
&nbsp;
&nbsp;/**
&nbsp; * A package definer is responsible for defining a package&#39;s properties when a class of a new package is loaded. Also,
&nbsp; * a package definer can choose not to define a package at all.
&nbsp; */
&nbsp;public interface PackageDefinitionStrategy {
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a package definition for a given package.
&nbsp;     *
&nbsp;     * @param classLoader The class loader for which this package is being defined.
&nbsp;     * @param packageName The name of the package.
&nbsp;     * @param typeName    The name of the type being loaded that triggered the package definition.
&nbsp;     * @return A definition of the package.
&nbsp;     */
&nbsp;    Definition define(ClassLoader classLoader, String packageName, String typeName);
&nbsp;
&nbsp;    /**
&nbsp;     * A package definer that does not define any package.
&nbsp;     */
<b class="fc">&nbsp;    enum NoOp implements PackageDefinitionStrategy {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Definition define(ClassLoader classLoader, String packageName, String typeName) {
<b class="fc">&nbsp;            return Definition.Undefined.INSTANCE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A package definer that only defines packages without any meta data.
&nbsp;     */
<b class="fc">&nbsp;    enum Trivial implements PackageDefinitionStrategy {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Definition define(ClassLoader classLoader, String packageName, String typeName) {
<b class="fc">&nbsp;            return Definition.Trivial.INSTANCE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A definition of a package.
&nbsp;     */
&nbsp;    interface Definition {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates if a package should be defined at all.
&nbsp;         *
&nbsp;         * @return {@code true} if the package is to be defined.
&nbsp;         */
&nbsp;        boolean isDefined();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the package specification&#39;s title or {@code null} if no such title exists. This method must only be called
&nbsp;         * for defined package definitions.
&nbsp;         *
&nbsp;         * @return The package specification&#39;s title.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String getSpecificationTitle();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the package specification&#39;s version or {@code null} if no such version exists. This method must only be called
&nbsp;         * for defined package definitions.
&nbsp;         *
&nbsp;         * @return The package specification&#39;s version.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String getSpecificationVersion();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the package specification&#39;s vendor or {@code null} if no such vendor exists. This method must only be called
&nbsp;         * for defined package definitions.
&nbsp;         *
&nbsp;         * @return The package specification&#39;s vendor.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String getSpecificationVendor();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the package implementation&#39;s title or {@code null} if no such title exists. This method must only be called
&nbsp;         * for defined package definitions.
&nbsp;         *
&nbsp;         * @return The package implementation&#39;s title.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String getImplementationTitle();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the package implementation&#39;s version or {@code null} if no such version exists. This method must only be called
&nbsp;         * for defined package definitions.
&nbsp;         *
&nbsp;         * @return The package implementation&#39;s version.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String getImplementationVersion();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the package implementation&#39;s vendor or {@code null} if no such vendor exists. This method must only be called
&nbsp;         * for defined package definitions.
&nbsp;         *
&nbsp;         * @return The package implementation&#39;s vendor.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String getImplementationVendor();
&nbsp;
&nbsp;        /**
&nbsp;         * The URL representing the seal base. This method must only be called for defined package definitions.
&nbsp;         *
&nbsp;         * @return The seal base of the package.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        URL getSealBase();
&nbsp;
&nbsp;        /**
&nbsp;         * Validates that this package definition is compatible to a previously defined package. This method must only be
&nbsp;         * called for defined package definitions.
&nbsp;         *
&nbsp;         * @param definedPackage The previously defined package.
&nbsp;         * @return {@code false} if this package and the defined package&#39;s sealing information are not compatible.
&nbsp;         */
&nbsp;        boolean isCompatibleTo(Package definedPackage);
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical implementation of an undefined package.
&nbsp;         */
<b class="fc">&nbsp;        enum Undefined implements Definition {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isDefined() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSpecificationTitle() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSpecificationVersion() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSpecificationVendor() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getImplementationTitle() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getImplementationVersion() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getImplementationVendor() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public URL getSealBase() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot read property of undefined package&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isCompatibleTo(Package definedPackage) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot check compatibility to undefined package&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A package definer that defines packages without any meta data.
&nbsp;         */
<b class="fc">&nbsp;        enum Trivial implements Definition {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An empty value of a package&#39;s property.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final String NO_VALUE = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an unsealed package.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final URL NOT_SEALED = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isDefined() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getSpecificationTitle() {
<b class="fc">&nbsp;                return NO_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getSpecificationVersion() {
<b class="fc">&nbsp;                return NO_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getSpecificationVendor() {
<b class="fc">&nbsp;                return NO_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getImplementationTitle() {
<b class="fc">&nbsp;                return NO_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getImplementationVersion() {
<b class="fc">&nbsp;                return NO_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getImplementationVendor() {
<b class="fc">&nbsp;                return NO_VALUE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public URL getSealBase() {
<b class="fc">&nbsp;                return NOT_SEALED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isCompatibleTo(Package definedPackage) {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple package definition where any property is represented by a value.
&nbsp;         */
&nbsp;        class Simple implements Definition {
&nbsp;
&nbsp;            /**
&nbsp;             * The seal base or {@code null} if the package is not sealed.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            protected final URL sealBase;
&nbsp;
&nbsp;            /**
&nbsp;             * The package specification&#39;s title or {@code null} if no such title exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String specificationTitle;
&nbsp;
&nbsp;            /**
&nbsp;             * The package specification&#39;s version or {@code null} if no such version exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String specificationVersion;
&nbsp;
&nbsp;            /**
&nbsp;             * The package specification&#39;s vendor or {@code null} if no such vendor exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String specificationVendor;
&nbsp;
&nbsp;            /**
&nbsp;             * The package implementation&#39;s title or {@code null} if no such title exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String implementationTitle;
&nbsp;
&nbsp;            /**
&nbsp;             * The package implementation&#39;s version or {@code null} if no such version exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String implementationVersion;
&nbsp;
&nbsp;            /**
&nbsp;             * The package implementation&#39;s vendor or {@code null} if no such vendor exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String implementationVendor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new simple package definition.
&nbsp;             *
&nbsp;             * @param specificationTitle    The package specification&#39;s title or {@code null} if no such title exists.
&nbsp;             * @param specificationVersion  The package specification&#39;s version or {@code null} if no such version exists.
&nbsp;             * @param specificationVendor   The package specification&#39;s vendor or {@code null} if no such vendor exists.
&nbsp;             * @param implementationTitle   The package implementation&#39;s title or {@code null} if no such title exists.
&nbsp;             * @param implementationVersion The package implementation&#39;s version or {@code null} if no such version exists.
&nbsp;             * @param implementationVendor  The package implementation&#39;s vendor or {@code null} if no such vendor exists.
&nbsp;             * @param sealBase              The seal base or {@code null} if the package is not sealed.
&nbsp;             */
&nbsp;            public Simple(@MaybeNull String specificationTitle,
&nbsp;                          @MaybeNull String specificationVersion,
&nbsp;                          @MaybeNull String specificationVendor,
&nbsp;                          @MaybeNull String implementationTitle,
&nbsp;                          @MaybeNull String implementationVersion,
&nbsp;                          @MaybeNull String implementationVendor,
<b class="fc">&nbsp;                          @MaybeNull URL sealBase) {</b>
<b class="fc">&nbsp;                this.specificationTitle = specificationTitle;</b>
<b class="fc">&nbsp;                this.specificationVersion = specificationVersion;</b>
<b class="fc">&nbsp;                this.specificationVendor = specificationVendor;</b>
<b class="fc">&nbsp;                this.implementationTitle = implementationTitle;</b>
<b class="fc">&nbsp;                this.implementationVersion = implementationVersion;</b>
<b class="fc">&nbsp;                this.implementationVendor = implementationVendor;</b>
<b class="fc">&nbsp;                this.sealBase = sealBase;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isDefined() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getSpecificationTitle() {
<b class="fc">&nbsp;                return specificationTitle;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getSpecificationVersion() {
<b class="fc">&nbsp;                return specificationVersion;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getSpecificationVendor() {
<b class="fc">&nbsp;                return specificationVendor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getImplementationTitle() {
<b class="fc">&nbsp;                return implementationTitle;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getImplementationVersion() {
<b class="fc">&nbsp;                return implementationVersion;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getImplementationVendor() {
<b class="fc">&nbsp;                return implementationVendor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public URL getSealBase() {
<b class="fc">&nbsp;                return sealBase;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isCompatibleTo(Package definedPackage) {
<b class="fc">&nbsp;                if (sealBase == null) {</b>
<b class="fc">&nbsp;                    return !definedPackage.isSealed();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return definedPackage.isSealed(sealBase);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;DMI_BLOCKING_METHODS_ON_URL&quot;, justification = &quot;Package sealing relies on URL equality.&quot;)
&nbsp;            public int hashCode() {
<b class="nc">&nbsp;                int result = specificationTitle != null ? specificationTitle.hashCode() : 0;</b>
<b class="nc">&nbsp;                result = 31 * result + (specificationVersion != null ? specificationVersion.hashCode() : 0);</b>
<b class="nc">&nbsp;                result = 31 * result + (specificationVendor != null ? specificationVendor.hashCode() : 0);</b>
<b class="nc">&nbsp;                result = 31 * result + (implementationTitle != null ? implementationTitle.hashCode() : 0);</b>
<b class="nc">&nbsp;                result = 31 * result + (implementationVersion != null ? implementationVersion.hashCode() : 0);</b>
<b class="nc">&nbsp;                result = 31 * result + (implementationVendor != null ? implementationVendor.hashCode() : 0);</b>
<b class="nc">&nbsp;                result = 31 * result + (sealBase != null ? sealBase.hashCode() : 0);</b>
<b class="nc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;DMI_BLOCKING_METHODS_ON_URL&quot;, justification = &quot;Package sealing relies on URL equality.&quot;)
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="nc">&nbsp;                Simple simple = (Simple) other;</b>
<b class="nc">&nbsp;                return !(specificationTitle != null ? !specificationTitle.equals(simple.specificationTitle) : simple.specificationTitle != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(specificationVersion != null ? !specificationVersion.equals(simple.specificationVersion) : simple.specificationVersion != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(specificationVendor != null ? !specificationVendor.equals(simple.specificationVendor) : simple.specificationVendor != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(implementationTitle != null ? !implementationTitle.equals(simple.implementationTitle) : simple.implementationTitle != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(implementationVersion != null ? !implementationVersion.equals(simple.implementationVersion) : simple.implementationVersion != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(implementationVendor != null ? !implementationVendor.equals(simple.implementationVendor) : simple.implementationVendor != null)</b>
<b class="nc">&nbsp;                        &amp;&amp; !(sealBase != null ? !sealBase.equals(simple.sealBase) : simple.sealBase != null);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A package definer that reads a class loader&#39;s manifest file.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class ManifestReading implements PackageDefinitionStrategy {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A URL defined a non-sealed package.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        private static final URL NOT_SEALED = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Contains all attributes that are relevant for defining a package.
&nbsp;         */
<b class="fc">&nbsp;        private static final Attributes.Name[] ATTRIBUTE_NAMES = new Attributes.Name[]{</b>
&nbsp;                Attributes.Name.SPECIFICATION_TITLE,
&nbsp;                Attributes.Name.SPECIFICATION_VERSION,
&nbsp;                Attributes.Name.SPECIFICATION_VENDOR,
&nbsp;                Attributes.Name.IMPLEMENTATION_TITLE,
&nbsp;                Attributes.Name.IMPLEMENTATION_VERSION,
&nbsp;                Attributes.Name.IMPLEMENTATION_VENDOR,
&nbsp;                Attributes.Name.SEALED
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * A locator for a sealed package&#39;s URL.
&nbsp;         */
&nbsp;        private final SealBaseLocator sealBaseLocator;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a manifest reading package definition strategy that attempts to extract sealing information from a defined class&#39;s URL.
&nbsp;         */
&nbsp;        public ManifestReading() {
<b class="nc">&nbsp;            this(new SealBaseLocator.ForTypeResourceUrl());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new package definer that reads a class loader&#39;s manifest file.
&nbsp;         *
&nbsp;         * @param sealBaseLocator A locator for a sealed package&#39;s URL.
&nbsp;         */
<b class="fc">&nbsp;        public ManifestReading(SealBaseLocator sealBaseLocator) {</b>
<b class="fc">&nbsp;            this.sealBaseLocator = sealBaseLocator;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Definition define(ClassLoader classLoader, String packageName, String typeName) {
<b class="fc">&nbsp;            InputStream inputStream = classLoader.getResourceAsStream(JarFile.MANIFEST_NAME);</b>
<b class="fc">&nbsp;            if (inputStream != null) {</b>
&nbsp;                try {
&nbsp;                    try {
<b class="fc">&nbsp;                        Manifest manifest = new Manifest(inputStream);</b>
<b class="fc">&nbsp;                        Map&lt;Attributes.Name, String&gt; values = new HashMap&lt;Attributes.Name, String&gt;();</b>
<b class="fc">&nbsp;                        Attributes mainAttributes = manifest.getMainAttributes();</b>
<b class="fc">&nbsp;                        if (mainAttributes != null) {</b>
<b class="fc">&nbsp;                            for (Attributes.Name attributeName : ATTRIBUTE_NAMES) {</b>
<b class="fc">&nbsp;                                values.put(attributeName, mainAttributes.getValue(attributeName));</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        Attributes attributes = manifest.getAttributes(packageName.replace(&#39;.&#39;, &#39;/&#39;).concat(&quot;/&quot;));</b>
<b class="fc">&nbsp;                        if (attributes != null) {</b>
<b class="fc">&nbsp;                            for (Attributes.Name attributeName : ATTRIBUTE_NAMES) {</b>
<b class="fc">&nbsp;                                String value = attributes.getValue(attributeName);</b>
<b class="fc">&nbsp;                                if (value != null) {</b>
<b class="fc">&nbsp;                                    values.put(attributeName, value);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        return new Definition.Simple(values.get(Attributes.Name.SPECIFICATION_TITLE),</b>
<b class="fc">&nbsp;                                values.get(Attributes.Name.SPECIFICATION_VERSION),</b>
<b class="fc">&nbsp;                                values.get(Attributes.Name.SPECIFICATION_VENDOR),</b>
<b class="fc">&nbsp;                                values.get(Attributes.Name.IMPLEMENTATION_TITLE),</b>
<b class="fc">&nbsp;                                values.get(Attributes.Name.IMPLEMENTATION_VERSION),</b>
<b class="fc">&nbsp;                                values.get(Attributes.Name.IMPLEMENTATION_VENDOR),</b>
<b class="fc">&nbsp;                                Boolean.parseBoolean(values.get(Attributes.Name.SEALED))</b>
<b class="nc">&nbsp;                                        ? sealBaseLocator.findSealBase(classLoader, typeName)</b>
<b class="fc">&nbsp;                                        : NOT_SEALED);</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        inputStream.close();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (IOException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Error while reading manifest file&quot;, exception);</b>
&nbsp;                }
&nbsp;            } else {
<b class="fc">&nbsp;                return Definition.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A locator for a seal base URL.
&nbsp;         */
&nbsp;        public interface SealBaseLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * Locates the URL that should be used for sealing a package.
&nbsp;             *
&nbsp;             * @param classLoader The class loader loading the package.
&nbsp;             * @param typeName    The name of the type being loaded that triggered the package definition.
&nbsp;             * @return The URL that is used for sealing a package or {@code null} if the package should not be sealed.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            URL findSealBase(ClassLoader classLoader, String typeName);
&nbsp;
&nbsp;            /**
&nbsp;             * A seal base locator that never seals a package.
&nbsp;             */
<b class="fc">&nbsp;            enum NonSealing implements SealBaseLocator {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public URL findSealBase(ClassLoader classLoader, String typeName) {
<b class="fc">&nbsp;                    return NOT_SEALED;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A seal base locator that seals all packages with a fixed URL.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForFixedValue implements SealBaseLocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The seal base URL.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final URL sealBase;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new seal base locator for a fixed URL.
&nbsp;                 *
&nbsp;                 * @param sealBase The seal base URL.
&nbsp;                 */
<b class="nc">&nbsp;                public ForFixedValue(@MaybeNull URL sealBase) {</b>
<b class="nc">&nbsp;                    this.sealBase = sealBase;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public URL findSealBase(ClassLoader classLoader, String typeName) {
<b class="nc">&nbsp;                    return sealBase;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;DMI_BLOCKING_METHODS_ON_URL&quot;, justification = &quot;Package sealing relies on URL equality.&quot;)
&nbsp;                public int hashCode() {
<b class="nc">&nbsp;                    return sealBase == null</b>
<b class="nc">&nbsp;                            ? 17</b>
<b class="nc">&nbsp;                            : sealBase.hashCode();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;DMI_BLOCKING_METHODS_ON_URL&quot;, justification = &quot;Package sealing relies on URL equality.&quot;)
&nbsp;                public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                    if (this == other) {</b>
<b class="nc">&nbsp;                        return true;</b>
<b class="nc">&nbsp;                    } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    ForFixedValue forFixedValue = (ForFixedValue) other;</b>
<b class="nc">&nbsp;                    return sealBase == null</b>
<b class="nc">&nbsp;                            ? forFixedValue.sealBase == null</b>
<b class="nc">&nbsp;                            : sealBase.equals(forFixedValue.sealBase);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A seal base locator that imitates the behavior of a {@link java.net.URLClassLoader}, i.e. tries
&nbsp;             * to deduct the base from a class&#39;s resource URL.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForTypeResourceUrl implements SealBaseLocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * An index to indicate to a {@link String} manipulation that the initial slash should be excluded.
&nbsp;                 */
&nbsp;                private static final int EXCLUDE_INITIAL_SLASH = 1;
&nbsp;
&nbsp;                /**
&nbsp;                 * The file extension for a class file.
&nbsp;                 */
&nbsp;                private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The protocol name of a jar file.
&nbsp;                 */
&nbsp;                private static final String JAR_FILE = &quot;jar&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The protocol name of a file system link.
&nbsp;                 */
&nbsp;                private static final String FILE_SYSTEM = &quot;file&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The protocol name of a Java 9 runtime image.
&nbsp;                 */
&nbsp;                private static final String RUNTIME_IMAGE = &quot;jrt&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The seal base locator to fallback to when a resource is not found or an unexpected URL protocol is discovered.
&nbsp;                 */
&nbsp;                private final SealBaseLocator fallback;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new seal base locator that attempts deduction from a type&#39;s URL while using a
&nbsp;                 * {@link net.bytebuddy.dynamic.loading.PackageDefinitionStrategy.ManifestReading.SealBaseLocator.NonSealing} seal base locator
&nbsp;                 * as a fallback.
&nbsp;                 */
&nbsp;                public ForTypeResourceUrl() {
<b class="nc">&nbsp;                    this(NonSealing.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new seal base locator that attempts deduction from a type&#39;s URL.
&nbsp;                 *
&nbsp;                 * @param fallback The seal base locator to fallback to when a resource is not found or an unexpected URL protocol is discovered.
&nbsp;                 */
<b class="nc">&nbsp;                public ForTypeResourceUrl(SealBaseLocator fallback) {</b>
<b class="nc">&nbsp;                    this.fallback = fallback;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public URL findSealBase(ClassLoader classLoader, String typeName) {
<b class="nc">&nbsp;                    URL url = classLoader.getResource(typeName.replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="nc">&nbsp;                    if (url != null) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            if (url.getProtocol().equals(JAR_FILE)) {</b>
<b class="nc">&nbsp;                                return URI.create(url.getPath().substring(0, url.getPath().indexOf(&#39;!&#39;))).toURL();</b>
<b class="nc">&nbsp;                            } else if (url.getProtocol().equals(FILE_SYSTEM)) {</b>
<b class="nc">&nbsp;                                return url;</b>
<b class="nc">&nbsp;                            } else if (url.getProtocol().equals(RUNTIME_IMAGE)) {</b>
<b class="nc">&nbsp;                                String path = url.getPath();</b>
<b class="nc">&nbsp;                                int modulePathIndex = path.indexOf(&#39;/&#39;, EXCLUDE_INITIAL_SLASH);</b>
<b class="nc">&nbsp;                                return modulePathIndex == -1</b>
<b class="nc">&nbsp;                                        ? url</b>
<b class="nc">&nbsp;                                        : URI.create(RUNTIME_IMAGE + &quot;:&quot; + path.substring(0, modulePathIndex)).toURL();</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch (MalformedURLException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Unexpected URL: &quot; + url, exception);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return fallback.findSealBase(classLoader, typeName);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
