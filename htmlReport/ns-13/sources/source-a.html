


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > TypeWriter</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: TypeWriter (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">TypeWriter$Default</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (6/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.3%
  </span>
  <span class="absValue">
    (45/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ClassDumpAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ClassDumpAction$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ClassDumpAction$Dispatcher$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ClassDumpAction$Dispatcher$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForCreation</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    47.6%
  </span>
  <span class="absValue">
    (39/82)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForCreation$CreationClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForCreation$ImplementationContextClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.9%
  </span>
  <span class="absValue">
    (17/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$ContextRegistry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$RegistryContextClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithDecorationOnly</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithDecorationOnly$DecorationClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithDecorationOnly$LazyFieldList</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$FrameWriter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$FrameWriter$Active</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$FrameWriter$Expanding</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$FrameWriter$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$WithDrain</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$WithDrain$WithActiveRecord</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$WithDrain$WithoutActiveRecord</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$WithoutDrain</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$WithoutDrain$WithActiveRecord</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Appending$WithoutDrain$WithoutActiveRecord</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$InitializationHandler$Creating</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$OpenedClassRemapper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    52.4%
  </span>
  <span class="absValue">
    (11/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.2%
  </span>
  <span class="absValue">
    (80/221)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor$AttributeObtainingFieldVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor$AttributeObtainingMethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor$AttributeObtainingRecordComponentVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ForInlining$WithFullProcessing$RedefinitionClassVisitor$CodePreservingMethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$SignatureKey</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$UnresolvedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (5/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    27.5%
  </span>
  <span class="absValue">
    (25/91)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$Compound</td>
<td class="coverageStat">
  <span class="percent">
    17.6%
  </span>
  <span class="absValue">
    (3/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.8%
  </span>
  <span class="absValue">
    (12/55)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$ForAnnotation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$ForClass</td>
<td class="coverageStat">
  <span class="percent">
    26.3%
  </span>
  <span class="absValue">
    (5/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    31.8%
  </span>
  <span class="absValue">
    (7/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$ForClassFileVersion</td>
<td class="coverageStat">
  <span class="percent">
    17.6%
  </span>
  <span class="absValue">
    (3/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    13.5%
  </span>
  <span class="absValue">
    (5/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$ForInterface</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$ForPackageType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$Constraint$ForRecord</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$ValidatingFieldVisitor</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$Default$ValidatingClassVisitor$ValidatingMethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$FieldPool</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$FieldPool$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$FieldPool$Record</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$FieldPool$Record$ForExplicitField</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.7%
  </span>
  <span class="absValue">
    (14/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$FieldPool$Record$ForImplicitField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$AccessBridgeWrapper</td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (1/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    9.1%
  </span>
  <span class="absValue">
    (4/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$AccessBridgeWrapper$AccessorBridge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$AccessBridgeWrapper$BridgeTarget</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (13/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod$OfVisibilityBridge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod$OfVisibilityBridge$VisibilityBridge</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod$WithAnnotationDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod$WithBody</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForDefinedMethod$WithoutBody</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$ForNonImplementedMethod</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (3/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (5/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$MethodPool$Record$Sort</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$RecordComponentPool</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$RecordComponentPool$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$RecordComponentPool$Record</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$RecordComponentPool$Record$ForExplicitRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeWriter$RecordComponentPool$Record$ForImplicitRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    18.7%
  </span>
  <span class="absValue">
    (80/427)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    24.4%
  </span>
  <span class="absValue">
    (320/1314)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.*;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.TypeResolutionStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.MethodRebaseResolver;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.RebaseImplementationTarget;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.SubclassImplementationTarget;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.implementation.attribute.*;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DefaultValue;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.nullability.UnknownNull;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;import net.bytebuddy.utility.visitor.ContextClassVisitor;
&nbsp;import net.bytebuddy.utility.visitor.MetadataAwareClassVisitor;
&nbsp;import org.objectweb.asm.*;
&nbsp;import org.objectweb.asm.commons.ClassRemapper;
&nbsp;import org.objectweb.asm.commons.Remapper;
&nbsp;import org.objectweb.asm.commons.SimpleRemapper;
&nbsp;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.PrivilegedExceptionAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A type writer is a utility for writing an actual class file using the ASM library.
&nbsp; *
&nbsp; * @param &lt;T&gt; The best known loaded type for the dynamically created type.
&nbsp; */
&nbsp;public interface TypeWriter&lt;T&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * A system property that indicates a folder for Byte Buddy to dump class files of all types that it creates.
&nbsp;     * If this property is not set, Byte Buddy does not dump any class files. This property is only read a single
&nbsp;     * time which is why it must be set on application start-up.
&nbsp;     */
&nbsp;    String DUMP_PROPERTY = &quot;net.bytebuddy.dump&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates the dynamic type that is described by this type writer.
&nbsp;     *
&nbsp;     * @param typeResolver The type resolution strategy to use.
&nbsp;     * @return An unloaded dynamic type that describes the created type.
&nbsp;     */
&nbsp;    DynamicType.Unloaded&lt;T&gt; make(TypeResolutionStrategy.Resolved typeResolver);
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps another ASM class visitor with a visitor that represents this ASM class writer.
&nbsp;     *
&nbsp;     * @param classVisitor The class visitor to wrap.
&nbsp;     * @param writerFlags  The ASM writer flags to consider.
&nbsp;     * @param readerFlags  The ASM reader flags to consider.
&nbsp;     * @return The supplied class visitor wrapped by this type writer.
&nbsp;     */
&nbsp;    ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags);
&nbsp;
&nbsp;    /**
&nbsp;     * An field pool that allows a lookup for how to implement a field.
&nbsp;     */
&nbsp;    interface FieldPool {
&nbsp;
&nbsp;        /**
&nbsp;         * Looks up a handler entry for a given field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field being processed.
&nbsp;         * @return A handler entry for the given field.
&nbsp;         */
&nbsp;        Record target(FieldDescription fieldDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * An entry of a field pool that describes how a field is implemented.
&nbsp;         *
&nbsp;         * @see net.bytebuddy.dynamic.scaffold.TypeWriter.FieldPool
&nbsp;         */
&nbsp;        interface Record {
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if this record is implicit, i.e is not defined by a {@link FieldPool}.
&nbsp;             *
&nbsp;             * @return {@code true} if this record is implicit.
&nbsp;             */
&nbsp;            boolean isImplicit();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the field that this record represents.
&nbsp;             *
&nbsp;             * @return The field that this record represents.
&nbsp;             */
&nbsp;            FieldDescription getField();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the field attribute appender for a given field.
&nbsp;             *
&nbsp;             * @return The attribute appender to be applied on the given field.
&nbsp;             */
&nbsp;            FieldAttributeAppender getFieldAppender();
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the default value that this record represents. This is not possible for implicit records.
&nbsp;             *
&nbsp;             * @param defaultValue The default value that was defined previously or {@code null} if no default value is defined.
&nbsp;             * @return The default value for the represented field or {@code null} if no default value is to be defined.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Object resolveDefault(@MaybeNull Object defaultValue);
&nbsp;
&nbsp;            /**
&nbsp;             * Writes this entry to a given class visitor.
&nbsp;             *
&nbsp;             * @param classVisitor                 The class visitor to which this entry is to be written to.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotations.
&nbsp;             */
&nbsp;            void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this record to a field visitor. This is not possible for implicit records.
&nbsp;             *
&nbsp;             * @param fieldVisitor                 The field visitor onto which this record is to be applied.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to use for annotations.
&nbsp;             */
&nbsp;            void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * A record for a simple field without a default value where all of the field&#39;s declared annotations are appended.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForImplicitField implements Record {
&nbsp;
&nbsp;                /**
&nbsp;                 * The implemented field.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new record for a simple field.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The described field.
&nbsp;                 */
<b class="nc">&nbsp;                public ForImplicitField(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isImplicit() {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDescription getField() {
<b class="nc">&nbsp;                    return fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldAttributeAppender getFieldAppender() {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;An implicit field record does not expose a field appender: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Object resolveDefault(@MaybeNull Object defaultValue) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;An implicit field record does not expose a default value: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(fieldDescription.getActualModifiers(),</b>
<b class="nc">&nbsp;                            fieldDescription.getInternalName(),</b>
<b class="nc">&nbsp;                            fieldDescription.getDescriptor(),</b>
<b class="nc">&nbsp;                            fieldDescription.getGenericSignature(),</b>
&nbsp;                            FieldDescription.NO_DEFAULT_VALUE);
<b class="nc">&nbsp;                    if (fieldVisitor != null) {</b>
<b class="nc">&nbsp;                        FieldAttributeAppender.ForInstrumentedField.INSTANCE.apply(fieldVisitor,</b>
&nbsp;                                fieldDescription,
<b class="nc">&nbsp;                                annotationValueFilterFactory.on(fieldDescription));</b>
<b class="nc">&nbsp;                        fieldVisitor.visitEnd();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;An implicit field record is not intended for partial application: &quot; + this);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A record for a rich field with attributes and a potential default value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForExplicitField implements Record {
&nbsp;
&nbsp;                /**
&nbsp;                 * The attribute appender for the field.
&nbsp;                 */
&nbsp;                private final FieldAttributeAppender attributeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s default value.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Object defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * The implemented field.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a record for a rich field.
&nbsp;                 *
&nbsp;                 * @param attributeAppender The attribute appender for the field.
&nbsp;                 * @param defaultValue      The field&#39;s default value.
&nbsp;                 * @param fieldDescription  The implemented field.
&nbsp;                 */
&nbsp;                public ForExplicitField(FieldAttributeAppender attributeAppender,
&nbsp;                                        @MaybeNull Object defaultValue,
<b class="fc">&nbsp;                                        FieldDescription fieldDescription) {</b>
<b class="fc">&nbsp;                    this.attributeAppender = attributeAppender;</b>
<b class="fc">&nbsp;                    this.defaultValue = defaultValue;</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isImplicit() {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDescription getField() {
<b class="nc">&nbsp;                    return fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldAttributeAppender getFieldAppender() {
<b class="nc">&nbsp;                    return attributeAppender;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Object resolveDefault(@MaybeNull Object defaultValue) {
<b class="fc">&nbsp;                    return this.defaultValue == null</b>
<b class="fc">&nbsp;                            ? defaultValue</b>
<b class="nc">&nbsp;                            : this.defaultValue;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(fieldDescription.getActualModifiers(),</b>
<b class="fc">&nbsp;                            fieldDescription.getInternalName(),</b>
<b class="fc">&nbsp;                            fieldDescription.getDescriptor(),</b>
<b class="fc">&nbsp;                            fieldDescription.getGenericSignature(),</b>
<b class="fc">&nbsp;                            resolveDefault(FieldDescription.NO_DEFAULT_VALUE));</b>
<b class="fc">&nbsp;                    if (fieldVisitor != null) {</b>
<b class="fc">&nbsp;                        attributeAppender.apply(fieldVisitor, fieldDescription, annotationValueFilterFactory.on(fieldDescription));</b>
<b class="fc">&nbsp;                        fieldVisitor.visitEnd();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(FieldVisitor fieldVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    attributeAppender.apply(fieldVisitor, fieldDescription, annotationValueFilterFactory.on(fieldDescription));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A field pool that does not allow any look ups.
&nbsp;         */
<b class="nc">&nbsp;        enum Disabled implements FieldPool {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Record target(FieldDescription fieldDescription) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot look up field from disabled pool&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An method pool that allows a lookup for how to implement a method.
&nbsp;     */
&nbsp;    interface MethodPool {
&nbsp;
&nbsp;        /**
&nbsp;         * Looks up a handler entry for a given method.
&nbsp;         *
&nbsp;         * @param methodDescription The method being processed.
&nbsp;         * @return A handler entry for the given method.
&nbsp;         */
&nbsp;        Record target(MethodDescription methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * An entry of a method pool that describes how a method is implemented.
&nbsp;         *
&nbsp;         * @see net.bytebuddy.dynamic.scaffold.TypeWriter.MethodPool
&nbsp;         */
&nbsp;        interface Record {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the sort of this method instrumentation.
&nbsp;             *
&nbsp;             * @return The sort of this method instrumentation.
&nbsp;             */
&nbsp;            Sort getSort();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the method that is implemented where the returned method resembles a potential transformation. An implemented
&nbsp;             * method is only defined if a method is not {@link Record.Sort#SKIPPED}.
&nbsp;             *
&nbsp;             * @return The implemented method.
&nbsp;             */
&nbsp;            MethodDescription getMethod();
&nbsp;
&nbsp;            /**
&nbsp;             * The visibility to enforce for this method.
&nbsp;             *
&nbsp;             * @return The visibility to enforce for this method.
&nbsp;             */
&nbsp;            Visibility getVisibility();
&nbsp;
&nbsp;            /**
&nbsp;             * Prepends the given method appender to this entry.
&nbsp;             *
&nbsp;             * @param byteCodeAppender The byte code appender to prepend.
&nbsp;             * @return This entry with the given code prepended.
&nbsp;             */
&nbsp;            Record prepend(ByteCodeAppender byteCodeAppender);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this method entry. This method can always be called and might be a no-op.
&nbsp;             *
&nbsp;             * @param classVisitor                 The class visitor to which this entry should be applied.
&nbsp;             * @param implementationContext        The implementation context to which this entry should be applied.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotations.
&nbsp;             */
&nbsp;            void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the head of this entry. Applying an entry is only possible if a method is defined, i.e. the sort of this entry is not
&nbsp;             * {@link Record.Sort#SKIPPED}.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor to which this entry should be applied.
&nbsp;             */
&nbsp;            void applyHead(MethodVisitor methodVisitor);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the body of this entry. Applying the body of an entry is only possible if a method is implemented, i.e. the sort of this
&nbsp;             * entry is {@link Record.Sort#IMPLEMENTED}.
&nbsp;             *
&nbsp;             * @param methodVisitor                The method visitor to which this entry should be applied.
&nbsp;             * @param implementationContext        The implementation context to which this entry should be applied.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotations.
&nbsp;             */
&nbsp;            void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the attributes of this entry. Applying the body of an entry is only possible if a method is implemented, i.e. the sort of this
&nbsp;             * entry is {@link Record.Sort#DEFINED}.
&nbsp;             *
&nbsp;             * @param methodVisitor                The method visitor to which this entry should be applied.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotations.
&nbsp;             */
&nbsp;            void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the code of this entry. Applying the body of an entry is only possible if a method is implemented, i.e. the sort of this
&nbsp;             * entry is {@link Record.Sort#IMPLEMENTED}.
&nbsp;             *
&nbsp;             * @param methodVisitor         The method visitor to which this entry should be applied.
&nbsp;             * @param implementationContext The implementation context to which this entry should be applied.
&nbsp;             * @return The size requirements of the implemented code.
&nbsp;             */
&nbsp;            ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext);
&nbsp;
&nbsp;            /**
&nbsp;             * The sort of an entry.
&nbsp;             */
<b class="fc">&nbsp;            enum Sort {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a method that should not be implemented or retained in its original state.
&nbsp;                 */
<b class="fc">&nbsp;                SKIPPED(false, false),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a method that should be defined but is abstract or native, i.e. does not define any byte code.
&nbsp;                 */
<b class="fc">&nbsp;                DEFINED(true, false),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a method that is implemented in byte code.
&nbsp;                 */
<b class="fc">&nbsp;                IMPLEMENTED(true, true);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates if this sort defines a method, with or without byte code.
&nbsp;                 */
&nbsp;                private final boolean define;
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates if this sort defines byte code.
&nbsp;                 */
&nbsp;                private final boolean implement;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new sort.
&nbsp;                 *
&nbsp;                 * @param define    Indicates if this sort defines a method, with or without byte code.
&nbsp;                 * @param implement Indicates if this sort defines byte code.
&nbsp;                 */
<b class="fc">&nbsp;                Sort(boolean define, boolean implement) {</b>
<b class="fc">&nbsp;                    this.define = define;</b>
<b class="fc">&nbsp;                    this.implement = implement;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates if this sort defines a method, with or without byte code.
&nbsp;                 *
&nbsp;                 * @return {@code true} if this sort defines a method, with or without byte code.
&nbsp;                 */
&nbsp;                public boolean isDefined() {
<b class="nc">&nbsp;                    return define;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates if this sort defines byte code.
&nbsp;                 *
&nbsp;                 * @return {@code true} if this sort defines byte code.
&nbsp;                 */
&nbsp;                public boolean isImplemented() {
<b class="fc">&nbsp;                    return implement;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A canonical implementation of a method that is not declared but inherited by the instrumented type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForNonImplementedMethod implements Record {
&nbsp;
&nbsp;                /**
&nbsp;                 * The undefined method.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new undefined record.
&nbsp;                 *
&nbsp;                 * @param methodDescription The undefined method.
&nbsp;                 */
<b class="fc">&nbsp;                public ForNonImplementedMethod(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot apply body for non-implemented method on &quot; + methodDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot apply code for non-implemented method on &quot; + methodDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot apply head for non-implemented method on &quot; + methodDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDescription getMethod() {
<b class="nc">&nbsp;                    return methodDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Visibility getVisibility() {
<b class="nc">&nbsp;                    return methodDescription.getVisibility();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sort getSort() {
<b class="nc">&nbsp;                    return Sort.SKIPPED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="fc">&nbsp;                    return new ForDefinedMethod.WithBody(methodDescription, new ByteCodeAppender.Compound(byteCodeAppender,</b>
<b class="fc">&nbsp;                            new ByteCodeAppender.Simple(DefaultValue.of(methodDescription.getReturnType()), MethodReturn.of(methodDescription.getReturnType()))));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A base implementation of an abstract entry that defines a method.
&nbsp;             */
<b class="fc">&nbsp;            abstract class ForDefinedMethod implements Record {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                    MethodVisitor methodVisitor = classVisitor.visitMethod(getMethod().getActualModifiers(getSort().isImplemented(), getVisibility()),</b>
<b class="fc">&nbsp;                            getMethod().getInternalName(),</b>
<b class="fc">&nbsp;                            getMethod().getDescriptor(),</b>
<b class="fc">&nbsp;                            getMethod().getGenericSignature(),</b>
<b class="fc">&nbsp;                            getMethod().getExceptionTypes().asErasures().toInternalNames());</b>
<b class="fc">&nbsp;                    if (methodVisitor != null) {</b>
<b class="fc">&nbsp;                        ParameterList&lt;?&gt; parameterList = getMethod().getParameters();</b>
<b class="fc">&nbsp;                        if (parameterList.hasExplicitMetaData()) {</b>
<b class="fc">&nbsp;                            for (ParameterDescription parameterDescription : parameterList) {</b>
<b class="nc">&nbsp;                                methodVisitor.visitParameter(parameterDescription.getName(), parameterDescription.getModifiers());</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="fc">&nbsp;                        applyHead(methodVisitor);</b>
<b class="fc">&nbsp;                        applyBody(methodVisitor, implementationContext, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                        methodVisitor.visitEnd();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes an entry that defines a method as byte code.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithBody extends ForDefinedMethod {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implemented method.
&nbsp;                     */
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The byte code appender to apply.
&nbsp;                     */
&nbsp;                    private final ByteCodeAppender byteCodeAppender;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method attribute appender to apply.
&nbsp;                     */
&nbsp;                    private final MethodAttributeAppender methodAttributeAppender;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented method&#39;s minimum visibility.
&nbsp;                     */
&nbsp;                    private final Visibility visibility;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new record for an implemented method without attributes or a modifier resolver.
&nbsp;                     *
&nbsp;                     * @param methodDescription The implemented method.
&nbsp;                     * @param byteCodeAppender  The byte code appender to apply.
&nbsp;                     */
&nbsp;                    public WithBody(MethodDescription methodDescription, ByteCodeAppender byteCodeAppender) {
<b class="fc">&nbsp;                        this(methodDescription, byteCodeAppender, MethodAttributeAppender.NoOp.INSTANCE, methodDescription.getVisibility());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new entry for a method that defines a method as byte code.
&nbsp;                     *
&nbsp;                     * @param methodDescription       The implemented method.
&nbsp;                     * @param byteCodeAppender        The byte code appender to apply.
&nbsp;                     * @param methodAttributeAppender The method attribute appender to apply.
&nbsp;                     * @param visibility              The represented method&#39;s minimum visibility.
&nbsp;                     */
&nbsp;                    public WithBody(MethodDescription methodDescription,
&nbsp;                                    ByteCodeAppender byteCodeAppender,
&nbsp;                                    MethodAttributeAppender methodAttributeAppender,
<b class="fc">&nbsp;                                    Visibility visibility) {</b>
<b class="fc">&nbsp;                        this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                        this.byteCodeAppender = byteCodeAppender;</b>
<b class="fc">&nbsp;                        this.methodAttributeAppender = methodAttributeAppender;</b>
<b class="fc">&nbsp;                        this.visibility = visibility;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription getMethod() {
<b class="fc">&nbsp;                        return methodDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="fc">&nbsp;                        return Sort.IMPLEMENTED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Visibility getVisibility() {
<b class="fc">&nbsp;                        return visibility;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                        applyAttributes(methodVisitor, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                        methodVisitor.visitCode();</b>
<b class="fc">&nbsp;                        ByteCodeAppender.Size size = applyCode(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                        methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilterFactory.on(methodDescription));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;                        return byteCodeAppender.apply(methodVisitor, implementationContext, methodDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                        return new WithBody(methodDescription,</b>
&nbsp;                                new ByteCodeAppender.Compound(byteCodeAppender, this.byteCodeAppender),
&nbsp;                                methodAttributeAppender,
&nbsp;                                visibility);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes an entry that defines a method but without byte code and without an annotation value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithoutBody extends ForDefinedMethod {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implemented method.
&nbsp;                     */
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method attribute appender to apply.
&nbsp;                     */
&nbsp;                    private final MethodAttributeAppender methodAttributeAppender;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented method&#39;s minimum visibility.
&nbsp;                     */
&nbsp;                    private final Visibility visibility;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new entry for a method that is defines but does not append byte code, i.e. is native or abstract.
&nbsp;                     *
&nbsp;                     * @param methodDescription       The implemented method.
&nbsp;                     * @param methodAttributeAppender The method attribute appender to apply.
&nbsp;                     * @param visibility              The represented method&#39;s minimum visibility.
&nbsp;                     */
<b class="nc">&nbsp;                    public WithoutBody(MethodDescription methodDescription, MethodAttributeAppender methodAttributeAppender, Visibility visibility) {</b>
<b class="nc">&nbsp;                        this.methodDescription = methodDescription;</b>
<b class="nc">&nbsp;                        this.methodAttributeAppender = methodAttributeAppender;</b>
<b class="nc">&nbsp;                        this.visibility = visibility;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription getMethod() {
<b class="nc">&nbsp;                        return methodDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="nc">&nbsp;                        return Sort.DEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Visibility getVisibility() {
<b class="nc">&nbsp;                        return visibility;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                        applyAttributes(methodVisitor, annotationValueFilterFactory);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                        methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilterFactory.on(methodDescription));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot apply code for abstract method on &quot; + methodDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot prepend code for abstract method on &quot; + methodDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes an entry that defines a method with a default annotation value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithAnnotationDefaultValue extends ForDefinedMethod {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implemented method.
&nbsp;                     */
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation value to define.
&nbsp;                     */
&nbsp;                    private final AnnotationValue&lt;?, ?&gt; annotationValue;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method attribute appender to apply.
&nbsp;                     */
&nbsp;                    private final MethodAttributeAppender methodAttributeAppender;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new entry for defining a method with a default annotation value.
&nbsp;                     *
&nbsp;                     * @param methodDescription       The implemented method.
&nbsp;                     * @param annotationValue         The annotation value to define.
&nbsp;                     * @param methodAttributeAppender The method attribute appender to apply.
&nbsp;                     */
&nbsp;                    public WithAnnotationDefaultValue(MethodDescription methodDescription,
&nbsp;                                                      AnnotationValue&lt;?, ?&gt; annotationValue,
<b class="nc">&nbsp;                                                      MethodAttributeAppender methodAttributeAppender) {</b>
<b class="nc">&nbsp;                        this.methodDescription = methodDescription;</b>
<b class="nc">&nbsp;                        this.annotationValue = annotationValue;</b>
<b class="nc">&nbsp;                        this.methodAttributeAppender = methodAttributeAppender;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription getMethod() {
<b class="nc">&nbsp;                        return methodDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="nc">&nbsp;                        return Sort.DEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Visibility getVisibility() {
<b class="nc">&nbsp;                        return methodDescription.getVisibility();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                        if (!methodDescription.isDefaultValue(annotationValue)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot set &quot; + annotationValue + &quot; as default for &quot; + methodDescription);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        AnnotationVisitor annotationVisitor = methodVisitor.visitAnnotationDefault();</b>
<b class="nc">&nbsp;                        AnnotationAppender.Default.apply(annotationVisitor,</b>
<b class="nc">&nbsp;                                methodDescription.getReturnType().asErasure(),</b>
&nbsp;                                AnnotationAppender.NO_NAME,
<b class="nc">&nbsp;                                annotationValue.resolve());</b>
<b class="nc">&nbsp;                        annotationVisitor.visitEnd();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                        methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilterFactory.on(methodDescription));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot apply attributes for default value on &quot; + methodDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot apply code for default value on &quot; + methodDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot prepend code for default value on &quot; + methodDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A record for a visibility bridge.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class OfVisibilityBridge extends ForDefinedMethod implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The visibility bridge.
&nbsp;                     */
&nbsp;                    private final MethodDescription visibilityBridge;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method the visibility bridge invokes.
&nbsp;                     */
&nbsp;                    private final MethodDescription bridgeTarget;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type on which the bridge method is invoked.
&nbsp;                     */
&nbsp;                    private final TypeDescription bridgeType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The attribute appender to apply to the visibility bridge.
&nbsp;                     */
&nbsp;                    private final MethodAttributeAppender attributeAppender;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new record for a visibility bridge.
&nbsp;                     *
&nbsp;                     * @param visibilityBridge  The visibility bridge.
&nbsp;                     * @param bridgeTarget      The method the visibility bridge invokes.
&nbsp;                     * @param bridgeType        The type of the instrumented type.
&nbsp;                     * @param attributeAppender The attribute appender to apply to the visibility bridge.
&nbsp;                     */
&nbsp;                    protected OfVisibilityBridge(MethodDescription visibilityBridge,
&nbsp;                                                 MethodDescription bridgeTarget,
&nbsp;                                                 TypeDescription bridgeType,
<b class="nc">&nbsp;                                                 MethodAttributeAppender attributeAppender) {</b>
<b class="nc">&nbsp;                        this.visibilityBridge = visibilityBridge;</b>
<b class="nc">&nbsp;                        this.bridgeTarget = bridgeTarget;</b>
<b class="nc">&nbsp;                        this.bridgeType = bridgeType;</b>
<b class="nc">&nbsp;                        this.attributeAppender = attributeAppender;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a record for a visibility bridge.
&nbsp;                     *
&nbsp;                     * @param instrumentedType  The instrumented type.
&nbsp;                     * @param bridgeTarget      The target method of the visibility bridge.
&nbsp;                     * @param attributeAppender The attribute appender to apply to the visibility bridge.
&nbsp;                     * @return A record describing the visibility bridge.
&nbsp;                     */
&nbsp;                    public static Record of(TypeDescription instrumentedType, MethodDescription bridgeTarget, MethodAttributeAppender attributeAppender) {
&nbsp;                        // Default method bridges must be dispatched on an implemented interface type, not considering the declaring type.
<b class="nc">&nbsp;                        TypeDefinition bridgeType = null;</b>
<b class="nc">&nbsp;                        if (bridgeTarget.isDefaultMethod()) {</b>
<b class="nc">&nbsp;                            TypeDescription declaringType = bridgeTarget.getDeclaringType().asErasure();</b>
<b class="nc">&nbsp;                            for (TypeDescription interfaceType : instrumentedType.getInterfaces().asErasures().filter(isSubTypeOf(declaringType))) {</b>
<b class="nc">&nbsp;                                if (bridgeType == null || declaringType.isAssignableTo(bridgeType.asErasure())) {</b>
<b class="nc">&nbsp;                                    bridgeType = interfaceType;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                        // Non-default method or default method that is inherited by a super class.
<b class="nc">&nbsp;                        if (bridgeType == null) {</b>
<b class="nc">&nbsp;                            bridgeType = instrumentedType.getSuperClass();</b>
<b class="nc">&nbsp;                            if (bridgeType == null) {</b>
<b class="nc">&nbsp;                                bridgeType = TypeDescription.ForLoadedType.of(Object.class);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        return new OfVisibilityBridge(new VisibilityBridge(instrumentedType, bridgeTarget),</b>
&nbsp;                                bridgeTarget,
<b class="nc">&nbsp;                                bridgeType.asErasure(),</b>
&nbsp;                                attributeAppender);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription getMethod() {
<b class="nc">&nbsp;                        return visibilityBridge;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="nc">&nbsp;                        return Sort.IMPLEMENTED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Visibility getVisibility() {
<b class="nc">&nbsp;                        return bridgeTarget.getVisibility();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                        return new ForDefinedMethod.WithBody(visibilityBridge,</b>
&nbsp;                                new ByteCodeAppender.Compound(this, byteCodeAppender),
&nbsp;                                attributeAppender,
<b class="nc">&nbsp;                                bridgeTarget.getVisibility());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyBody(MethodVisitor methodVisitor, Implementation.Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                        applyAttributes(methodVisitor, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                        methodVisitor.visitCode();</b>
<b class="nc">&nbsp;                        ByteCodeAppender.Size size = applyCode(methodVisitor, implementationContext);</b>
<b class="nc">&nbsp;                        methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                        attributeAppender.apply(methodVisitor, visibilityBridge, annotationValueFilterFactory.on(visibilityBridge));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="nc">&nbsp;                        return apply(methodVisitor, implementationContext, visibilityBridge);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                        return new ByteCodeAppender.Simple(</b>
<b class="nc">&nbsp;                                MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
<b class="nc">&nbsp;                                MethodInvocation.invoke(bridgeTarget).special(bridgeType),</b>
<b class="nc">&nbsp;                                MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="nc">&nbsp;                        ).apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A method describing a visibility bridge.
&nbsp;                     */
&nbsp;                    protected static class VisibilityBridge extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The instrumented type.
&nbsp;                         */
&nbsp;                        private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method that is the target of the bridge.
&nbsp;                         */
&nbsp;                        private final MethodDescription bridgeTarget;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new visibility bridge.
&nbsp;                         *
&nbsp;                         * @param instrumentedType The instrumented type.
&nbsp;                         * @param bridgeTarget     The method that is the target of the bridge.
&nbsp;                         */
<b class="nc">&nbsp;                        protected VisibilityBridge(TypeDescription instrumentedType, MethodDescription bridgeTarget) {</b>
<b class="nc">&nbsp;                            this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                            this.bridgeTarget = bridgeTarget;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @Nonnull
&nbsp;                        public TypeDescription getDeclaringType() {
<b class="nc">&nbsp;                            return instrumentedType;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="nc">&nbsp;                            return new ParameterList.Explicit.ForTypes(this, bridgeTarget.getParameters().asTypeList().asRawTypes());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription.Generic getReturnType() {
<b class="nc">&nbsp;                            return bridgeTarget.getReturnType().asRawType();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getExceptionTypes() {
<b class="nc">&nbsp;                            return bridgeTarget.getExceptionTypes().asRawTypes();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                            return AnnotationValue.UNDEFINED;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getTypeVariables() {
<b class="nc">&nbsp;                            return new TypeList.Generic.Empty();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                            return bridgeTarget.getDeclaredAnnotations();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public int getModifiers() {
<b class="nc">&nbsp;                            return (bridgeTarget.getModifiers() | Opcodes.ACC_SYNTHETIC | Opcodes.ACC_BRIDGE) &amp; ~Opcodes.ACC_NATIVE;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public String getInternalName() {
<b class="nc">&nbsp;                            return bridgeTarget.getName();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A wrapper that appends accessor bridges for a method&#39;s implementation. The bridges are only added if
&nbsp;             * {@link net.bytebuddy.dynamic.scaffold.TypeWriter.MethodPool.Record#apply(ClassVisitor, Implementation.Context, AnnotationValueFilter.Factory)}
&nbsp;             * is invoked such that bridges are not appended for methods that are rebased or redefined as such types already have bridge methods in place.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class AccessBridgeWrapper implements Record {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegate for implementing the bridge&#39;s target.
&nbsp;                 */
&nbsp;                private final Record delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type that defines the bridge methods and the bridge target.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The target of the bridge method.
&nbsp;                 */
&nbsp;                private final MethodDescription bridgeTarget;
&nbsp;
&nbsp;                /**
&nbsp;                 * A collection of all tokens representing all bridge methods.
&nbsp;                 */
&nbsp;                private final Set&lt;MethodDescription.TypeToken&gt; bridgeTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * The attribute appender being applied for the bridge target.
&nbsp;                 */
&nbsp;                private final MethodAttributeAppender attributeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a wrapper for adding accessor bridges.
&nbsp;                 *
&nbsp;                 * @param delegate          The delegate for implementing the bridge&#39;s target.
&nbsp;                 * @param instrumentedType  The instrumented type that defines the bridge methods and the bridge target.
&nbsp;                 * @param bridgeTarget      The target of the bridge method.
&nbsp;                 * @param bridgeTypes       A collection of all tokens representing all bridge methods.
&nbsp;                 * @param attributeAppender The attribute appender being applied for the bridge target.
&nbsp;                 */
&nbsp;                protected AccessBridgeWrapper(Record delegate,
&nbsp;                                              TypeDescription instrumentedType,
&nbsp;                                              MethodDescription bridgeTarget,
&nbsp;                                              Set&lt;MethodDescription.TypeToken&gt; bridgeTypes,
<b class="nc">&nbsp;                                              MethodAttributeAppender attributeAppender) {</b>
<b class="nc">&nbsp;                    this.delegate = delegate;</b>
<b class="nc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                    this.bridgeTarget = bridgeTarget;</b>
<b class="nc">&nbsp;                    this.bridgeTypes = bridgeTypes;</b>
<b class="nc">&nbsp;                    this.attributeAppender = attributeAppender;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Wraps the given record in an accessor bridge wrapper if necessary.
&nbsp;                 *
&nbsp;                 * @param delegate          The delegate for implementing the bridge&#39;s target.
&nbsp;                 * @param instrumentedType  The instrumented type that defines the bridge methods and the bridge target.
&nbsp;                 * @param bridgeTarget      The bridge methods&#39; target methods.
&nbsp;                 * @param bridgeTypes       A collection of all tokens representing all bridge methods.
&nbsp;                 * @param attributeAppender The attribute appender being applied for the bridge target.
&nbsp;                 * @return The given record wrapped by a bridge method wrapper if necessary.
&nbsp;                 */
&nbsp;                public static Record of(Record delegate,
&nbsp;                                        TypeDescription instrumentedType,
&nbsp;                                        MethodDescription bridgeTarget,
&nbsp;                                        Set&lt;MethodDescription.TypeToken&gt; bridgeTypes,
&nbsp;                                        MethodAttributeAppender attributeAppender) {
<b class="fc">&nbsp;                    Set&lt;MethodDescription.TypeToken&gt; compatibleBridgeTypes = new HashSet&lt;MethodDescription.TypeToken&gt;();</b>
<b class="fc">&nbsp;                    for (MethodDescription.TypeToken bridgeType : bridgeTypes) {</b>
<b class="nc">&nbsp;                        if (bridgeTarget.isBridgeCompatible(bridgeType)) {</b>
<b class="nc">&nbsp;                            compatibleBridgeTypes.add(bridgeType);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return compatibleBridgeTypes.isEmpty() || (instrumentedType.isInterface() &amp;&amp; !delegate.getSort().isImplemented())</b>
<b class="fc">&nbsp;                            ? delegate</b>
<b class="nc">&nbsp;                            : new AccessBridgeWrapper(delegate, instrumentedType, bridgeTarget, compatibleBridgeTypes, attributeAppender);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sort getSort() {
<b class="nc">&nbsp;                    return delegate.getSort();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDescription getMethod() {
<b class="nc">&nbsp;                    return bridgeTarget;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Visibility getVisibility() {
<b class="nc">&nbsp;                    return delegate.getVisibility();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="nc">&nbsp;                    return new AccessBridgeWrapper(delegate.prepend(byteCodeAppender), instrumentedType, bridgeTarget, bridgeTypes, attributeAppender);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor,
&nbsp;                                  Implementation.Context implementationContext,
&nbsp;                                  AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    delegate.apply(classVisitor, implementationContext, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                    for (MethodDescription.TypeToken bridgeType : bridgeTypes) {</b>
<b class="nc">&nbsp;                        MethodDescription.InDefinedShape bridgeMethod = new AccessorBridge(bridgeTarget, bridgeType, instrumentedType);</b>
<b class="nc">&nbsp;                        MethodDescription.InDefinedShape bridgeTarget = new BridgeTarget(this.bridgeTarget, instrumentedType);</b>
<b class="nc">&nbsp;                        MethodVisitor methodVisitor = classVisitor.visitMethod(bridgeMethod.getActualModifiers(true, getVisibility()),</b>
<b class="nc">&nbsp;                                bridgeMethod.getInternalName(),</b>
<b class="nc">&nbsp;                                bridgeMethod.getDescriptor(),</b>
&nbsp;                                MethodDescription.NON_GENERIC_SIGNATURE,
<b class="nc">&nbsp;                                bridgeMethod.getExceptionTypes().asErasures().toInternalNames());</b>
<b class="nc">&nbsp;                        if (methodVisitor != null) {</b>
<b class="nc">&nbsp;                            attributeAppender.apply(methodVisitor, bridgeMethod, annotationValueFilterFactory.on(instrumentedType));</b>
<b class="nc">&nbsp;                            methodVisitor.visitCode();</b>
<b class="nc">&nbsp;                            ByteCodeAppender.Size size = new ByteCodeAppender.Simple(</b>
<b class="nc">&nbsp;                                    MethodVariableAccess.allArgumentsOf(bridgeMethod).asBridgeOf(bridgeTarget).prependThisReference(),</b>
<b class="nc">&nbsp;                                    MethodInvocation.invoke(bridgeTarget).virtual(instrumentedType),</b>
<b class="nc">&nbsp;                                    bridgeTarget.getReturnType().asErasure().isAssignableTo(bridgeMethod.getReturnType().asErasure())</b>
<b class="nc">&nbsp;                                            ? StackManipulation.Trivial.INSTANCE</b>
<b class="nc">&nbsp;                                            : TypeCasting.to(bridgeMethod.getReturnType().asErasure()),</b>
<b class="nc">&nbsp;                                    MethodReturn.of(bridgeMethod.getReturnType())</b>
<b class="nc">&nbsp;                            ).apply(methodVisitor, implementationContext, bridgeMethod);</b>
<b class="nc">&nbsp;                            methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());</b>
<b class="nc">&nbsp;                            methodVisitor.visitEnd();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    delegate.applyHead(methodVisitor);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyBody(MethodVisitor methodVisitor,
&nbsp;                                      Implementation.Context implementationContext,
&nbsp;                                      AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    delegate.applyBody(methodVisitor, implementationContext, annotationValueFilterFactory);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    delegate.applyAttributes(methodVisitor, annotationValueFilterFactory);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender.Size applyCode(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="nc">&nbsp;                    return delegate.applyCode(methodVisitor, implementationContext);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A method representing an accessor bridge method.
&nbsp;                 */
&nbsp;                protected static class AccessorBridge extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target method of the bridge.
&nbsp;                     */
&nbsp;                    private final MethodDescription bridgeTarget;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The bridge&#39;s type token.
&nbsp;                     */
&nbsp;                    private final MethodDescription.TypeToken bridgeType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type defining the bridge target.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new accessor bridge method.
&nbsp;                     *
&nbsp;                     * @param bridgeTarget     The target method of the bridge.
&nbsp;                     * @param bridgeType       The bridge&#39;s type token.
&nbsp;                     * @param instrumentedType The instrumented type defining the bridge target.
&nbsp;                     */
<b class="nc">&nbsp;                    protected AccessorBridge(MethodDescription bridgeTarget, TypeToken bridgeType, TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                        this.bridgeTarget = bridgeTarget;</b>
<b class="nc">&nbsp;                        this.bridgeType = bridgeType;</b>
<b class="nc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @Nonnull
&nbsp;                    public TypeDescription getDeclaringType() {
<b class="nc">&nbsp;                        return instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="nc">&nbsp;                        return new ParameterList.Explicit.ForTypes(this, bridgeType.getParameterTypes());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription.Generic getReturnType() {
<b class="nc">&nbsp;                        return bridgeType.getReturnType().asGenericType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic getExceptionTypes() {
<b class="nc">&nbsp;                        return bridgeTarget.getExceptionTypes().accept(TypeDescription.Generic.Visitor.TypeErasing.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                        return AnnotationValue.UNDEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic getTypeVariables() {
<b class="nc">&nbsp;                        return new TypeList.Generic.Empty();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        return new AnnotationList.Empty();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getModifiers() {
<b class="nc">&nbsp;                        return (bridgeTarget.getModifiers() | Opcodes.ACC_BRIDGE | Opcodes.ACC_SYNTHETIC) &amp; ~(Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getInternalName() {
<b class="nc">&nbsp;                        return bridgeTarget.getInternalName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A method representing a bridge&#39;s target method in its defined shape.
&nbsp;                 */
&nbsp;                protected static class BridgeTarget extends MethodDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target method of the bridge.
&nbsp;                     */
&nbsp;                    private final MethodDescription bridgeTarget;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type defining the bridge target.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new bridge target.
&nbsp;                     *
&nbsp;                     * @param bridgeTarget     The target method of the bridge.
&nbsp;                     * @param instrumentedType The instrumented type defining the bridge target.
&nbsp;                     */
<b class="nc">&nbsp;                    protected BridgeTarget(MethodDescription bridgeTarget, TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                        this.bridgeTarget = bridgeTarget;</b>
<b class="nc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @Nonnull
&nbsp;                    public TypeDescription getDeclaringType() {
<b class="nc">&nbsp;                        return instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="nc">&nbsp;                        return new ParameterList.ForTokens(this, bridgeTarget.getParameters().asTokenList(is(instrumentedType)));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription.Generic getReturnType() {
<b class="nc">&nbsp;                        return bridgeTarget.getReturnType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic getExceptionTypes() {
<b class="nc">&nbsp;                        return bridgeTarget.getExceptionTypes();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                        return bridgeTarget.getDefaultValue();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic getTypeVariables() {
<b class="nc">&nbsp;                        return bridgeTarget.getTypeVariables();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        return bridgeTarget.getDeclaredAnnotations();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getModifiers() {
<b class="nc">&nbsp;                        return bridgeTarget.getModifiers();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getInternalName() {
<b class="nc">&nbsp;                        return bridgeTarget.getInternalName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An record component pool that allows a lookup for how to implement a record component.
&nbsp;     */
&nbsp;    interface RecordComponentPool {
&nbsp;
&nbsp;        /**
&nbsp;         * Looks up a handler entry for a given record component.
&nbsp;         *
&nbsp;         * @param recordComponentDescription The record component being processed.
&nbsp;         * @return A handler entry for the given record component.
&nbsp;         */
&nbsp;        Record target(RecordComponentDescription recordComponentDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * An entry of a record component pool that describes how a record component is implemented.
&nbsp;         *
&nbsp;         * @see RecordComponentPool
&nbsp;         */
&nbsp;        interface Record {
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if this record is implicit, i.e is not defined by a {@link RecordComponentPool}.
&nbsp;             *
&nbsp;             * @return {@code true} if this record is implicit.
&nbsp;             */
&nbsp;            boolean isImplicit();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the record component that this record represents.
&nbsp;             *
&nbsp;             * @return The record component that this record represents.
&nbsp;             */
&nbsp;            RecordComponentDescription getRecordComponent();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the record component attribute appender for a given record component.
&nbsp;             *
&nbsp;             * @return The record component appender to be applied on the given field.
&nbsp;             */
&nbsp;            RecordComponentAttributeAppender getRecordComponentAppender();
&nbsp;
&nbsp;            /**
&nbsp;             * Writes this record to a given class visitor.
&nbsp;             *
&nbsp;             * @param classVisitor                 The class visitor to which this record is to be written to.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotations.
&nbsp;             */
&nbsp;            void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this record to a record component visitor. This is not possible for implicit records.
&nbsp;             *
&nbsp;             * @param recordComponentVisitor       The record component visitor onto which this record is to be applied.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to use for annotations.
&nbsp;             */
&nbsp;            void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * A record for a simple field without a default value where all of the record component&#39;s declared annotations are appended.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForImplicitRecordComponent implements Record {
&nbsp;
&nbsp;                /**
&nbsp;                 * The implemented record component.
&nbsp;                 */
&nbsp;                private final RecordComponentDescription recordComponentDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new record for a simple record component.
&nbsp;                 *
&nbsp;                 * @param recordComponentDescription The described record component.
&nbsp;                 */
<b class="nc">&nbsp;                public ForImplicitRecordComponent(RecordComponentDescription recordComponentDescription) {</b>
<b class="nc">&nbsp;                    this.recordComponentDescription = recordComponentDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isImplicit() {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDescription getRecordComponent() {
<b class="nc">&nbsp;                    return recordComponentDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentAttributeAppender getRecordComponentAppender() {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;An implicit field record does not expose a field appender: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(recordComponentDescription.getActualName(),</b>
<b class="nc">&nbsp;                            recordComponentDescription.getDescriptor(),</b>
<b class="nc">&nbsp;                            recordComponentDescription.getGenericSignature());</b>
<b class="nc">&nbsp;                    if (recordComponentVisitor != null) {</b>
<b class="nc">&nbsp;                        RecordComponentAttributeAppender.ForInstrumentedRecordComponent.INSTANCE.apply(recordComponentVisitor,</b>
&nbsp;                                recordComponentDescription,
<b class="nc">&nbsp;                                annotationValueFilterFactory.on(recordComponentDescription));</b>
<b class="nc">&nbsp;                        recordComponentVisitor.visitEnd();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;An implicit field record is not intended for partial application: &quot; + this);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A record for a rich record component with attributes.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForExplicitRecordComponent implements Record {
&nbsp;
&nbsp;                /**
&nbsp;                 * The attribute appender for the record component.
&nbsp;                 */
&nbsp;                private final RecordComponentAttributeAppender attributeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * The implemented record component.
&nbsp;                 */
&nbsp;                private final RecordComponentDescription recordComponentDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a record for a rich record component.
&nbsp;                 *
&nbsp;                 * @param attributeAppender          The attribute appender for the record component.
&nbsp;                 * @param recordComponentDescription The implemented record component.
&nbsp;                 */
<b class="nc">&nbsp;                public ForExplicitRecordComponent(RecordComponentAttributeAppender attributeAppender, RecordComponentDescription recordComponentDescription) {</b>
<b class="nc">&nbsp;                    this.attributeAppender = attributeAppender;</b>
<b class="nc">&nbsp;                    this.recordComponentDescription = recordComponentDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isImplicit() {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDescription getRecordComponent() {
<b class="nc">&nbsp;                    return recordComponentDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentAttributeAppender getRecordComponentAppender() {
<b class="nc">&nbsp;                    return attributeAppender;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    RecordComponentVisitor recordComponentVisitor = classVisitor.visitRecordComponent(recordComponentDescription.getActualName(),</b>
<b class="nc">&nbsp;                            recordComponentDescription.getDescriptor(),</b>
<b class="nc">&nbsp;                            recordComponentDescription.getGenericSignature());</b>
<b class="nc">&nbsp;                    if (recordComponentVisitor != null) {</b>
<b class="nc">&nbsp;                        attributeAppender.apply(recordComponentVisitor, recordComponentDescription, annotationValueFilterFactory.on(recordComponentDescription));</b>
<b class="nc">&nbsp;                        recordComponentVisitor.visitEnd();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(RecordComponentVisitor recordComponentVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                    attributeAppender.apply(recordComponentVisitor, recordComponentDescription, annotationValueFilterFactory.on(recordComponentDescription));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A record component pool that does not allow any look ups.
&nbsp;         */
<b class="nc">&nbsp;        enum Disabled implements RecordComponentPool {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Record target(RecordComponentDescription recordComponentDescription) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot look up record component from disabled pool&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A default implementation of a {@link net.bytebuddy.dynamic.scaffold.TypeWriter}.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The best known loaded type for the dynamically created type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;    abstract class Default&lt;S&gt; implements TypeWriter&lt;S&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates an empty reference in a class file which is expressed by {@code null}.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        private static final String NO_REFERENCE = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A folder for dumping class files or {@code null} if no dump should be generated.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected static final String DUMP_FOLDER;
&nbsp;
&nbsp;        /*
&nbsp;         * Reads the dumping property that is set at program start up. This might cause an error because of security constraints.
&nbsp;         */
&nbsp;        static {
&nbsp;            String dumpFolder;
&nbsp;            try {
<b class="fc">&nbsp;                dumpFolder = doPrivileged(new GetSystemPropertyAction(DUMP_PROPERTY));</b>
<b class="nc">&nbsp;            } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                dumpFolder = null;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            DUMP_FOLDER = dumpFolder;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type to be created.
&nbsp;         */
&nbsp;        protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;        /**
&nbsp;         * The class file specified by the user.
&nbsp;         */
&nbsp;        protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;        /**
&nbsp;         * The field pool to use.
&nbsp;         */
&nbsp;        protected final FieldPool fieldPool;
&nbsp;
&nbsp;        /**
&nbsp;         * The record component pool to use.
&nbsp;         */
&nbsp;        protected final RecordComponentPool recordComponentPool;
&nbsp;
&nbsp;        /**
&nbsp;         * The explicit auxiliary types to add to the created type.
&nbsp;         */
&nbsp;        protected final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type&#39;s declared fields.
&nbsp;         */
&nbsp;        protected final FieldList&lt;FieldDescription.InDefinedShape&gt; fields;
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type&#39;s methods that are declared or inherited.
&nbsp;         */
&nbsp;        protected final MethodList&lt;?&gt; methods;
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented methods relevant to this type creation.
&nbsp;         */
&nbsp;        protected final MethodList&lt;?&gt; instrumentedMethods;
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type&#39;s record components.
&nbsp;         */
&nbsp;        protected final RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents;
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded type initializer to apply onto the created type after loading.
&nbsp;         */
&nbsp;        protected final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * The type initializer to include in the created type&#39;s type initializer.
&nbsp;         */
&nbsp;        protected final TypeInitializer typeInitializer;
&nbsp;
&nbsp;        /**
&nbsp;         * The type attribute appender to apply onto the instrumented type.
&nbsp;         */
&nbsp;        protected final TypeAttributeAppender typeAttributeAppender;
&nbsp;
&nbsp;        /**
&nbsp;         * The ASM visitor wrapper to apply onto the class writer.
&nbsp;         */
&nbsp;        protected final AsmVisitorWrapper asmVisitorWrapper;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation value filter factory to apply.
&nbsp;         */
&nbsp;        protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation retention to apply.
&nbsp;         */
&nbsp;        protected final AnnotationRetention annotationRetention;
&nbsp;
&nbsp;        /**
&nbsp;         * The naming strategy for auxiliary types to apply.
&nbsp;         */
&nbsp;        protected final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation context factory to apply.
&nbsp;         */
&nbsp;        protected final Implementation.Context.Factory implementationContextFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if a type should be explicitly validated.
&nbsp;         */
&nbsp;        protected final TypeValidation typeValidation;
&nbsp;
&nbsp;        /**
&nbsp;         * The class writer strategy to use.
&nbsp;         */
&nbsp;        protected final ClassWriterStrategy classWriterStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The type pool to use for computing stack map frames, if required.
&nbsp;         */
&nbsp;        protected final TypePool typePool;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default type writer.
&nbsp;         *
&nbsp;         * @param instrumentedType             The instrumented type to be created.
&nbsp;         * @param classFileVersion             The class file specified by the user.
&nbsp;         * @param fieldPool                    The field pool to use.
&nbsp;         * @param recordComponentPool          The record component pool to use.
&nbsp;         * @param auxiliaryTypes               The explicit auxiliary types to add to the created type.
&nbsp;         * @param fields                       The instrumented type&#39;s declared fields.
&nbsp;         * @param methods                      The instrumented type&#39;s declared and virtually inherited methods.
&nbsp;         * @param instrumentedMethods          The instrumented methods relevant to this type creation.
&nbsp;         * @param recordComponents             The instrumented type&#39;s record components.
&nbsp;         * @param loadedTypeInitializer        The loaded type initializer to apply onto the created type after loading.
&nbsp;         * @param typeInitializer              The type initializer to include in the created type&#39;s type initializer.
&nbsp;         * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;         * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;         * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;         * @param annotationRetention          The annotation retention to apply.
&nbsp;         * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;         * @param implementationContextFactory The implementation context factory to apply.
&nbsp;         * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;         * @param classWriterStrategy          The class writer strategy to use.
&nbsp;         * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;         */
&nbsp;        protected Default(TypeDescription instrumentedType,
&nbsp;                          ClassFileVersion classFileVersion,
&nbsp;                          FieldPool fieldPool,
&nbsp;                          RecordComponentPool recordComponentPool,
&nbsp;                          List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                          FieldList&lt;FieldDescription.InDefinedShape&gt; fields,
&nbsp;                          MethodList&lt;?&gt; methods,
&nbsp;                          MethodList&lt;?&gt; instrumentedMethods,
&nbsp;                          RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents,
&nbsp;                          LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                          TypeInitializer typeInitializer,
&nbsp;                          TypeAttributeAppender typeAttributeAppender,
&nbsp;                          AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                          AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                          AnnotationRetention annotationRetention,
&nbsp;                          AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                          Implementation.Context.Factory implementationContextFactory,
&nbsp;                          TypeValidation typeValidation,
&nbsp;                          ClassWriterStrategy classWriterStrategy,
<b class="fc">&nbsp;                          TypePool typePool) {</b>
<b class="fc">&nbsp;            this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;            this.classFileVersion = classFileVersion;</b>
<b class="fc">&nbsp;            this.fieldPool = fieldPool;</b>
<b class="fc">&nbsp;            this.recordComponentPool = recordComponentPool;</b>
<b class="fc">&nbsp;            this.auxiliaryTypes = auxiliaryTypes;</b>
<b class="fc">&nbsp;            this.fields = fields;</b>
<b class="fc">&nbsp;            this.methods = methods;</b>
<b class="fc">&nbsp;            this.instrumentedMethods = instrumentedMethods;</b>
<b class="fc">&nbsp;            this.recordComponents = recordComponents;</b>
<b class="fc">&nbsp;            this.loadedTypeInitializer = loadedTypeInitializer;</b>
<b class="fc">&nbsp;            this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;            this.typeAttributeAppender = typeAttributeAppender;</b>
<b class="fc">&nbsp;            this.asmVisitorWrapper = asmVisitorWrapper;</b>
<b class="fc">&nbsp;            this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;</b>
<b class="fc">&nbsp;            this.annotationValueFilterFactory = annotationValueFilterFactory;</b>
<b class="fc">&nbsp;            this.annotationRetention = annotationRetention;</b>
<b class="fc">&nbsp;            this.implementationContextFactory = implementationContextFactory;</b>
<b class="fc">&nbsp;            this.typeValidation = typeValidation;</b>
<b class="fc">&nbsp;            this.classWriterStrategy = classWriterStrategy;</b>
<b class="fc">&nbsp;            this.typePool = typePool;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         * @throws Exception If an exception occurs.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedExceptionAction&lt;T&gt; action) throws Exception {
<b class="nc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type writer for creating a new type.
&nbsp;         *
&nbsp;         * @param methodRegistry               The compiled method registry to use.
&nbsp;         * @param auxiliaryTypes               A list of explicitly required auxiliary types.
&nbsp;         * @param fieldPool                    The field pool to use.
&nbsp;         * @param recordComponentPool          The record component pool to use.
&nbsp;         * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;         * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;         * @param classFileVersion             The class file version to use when no explicit class file version is applied.
&nbsp;         * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;         * @param annotationRetention          The annotation retention to apply.
&nbsp;         * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;         * @param implementationContextFactory The implementation context factory to apply.
&nbsp;         * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;         * @param classWriterStrategy          The class writer strategy to use.
&nbsp;         * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;         * @param &lt;U&gt;                          A loaded type that the instrumented type guarantees to subclass.
&nbsp;         * @return A suitable type writer.
&nbsp;         */
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forCreation(MethodRegistry.Compiled methodRegistry,
&nbsp;                                                    List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                                    FieldPool fieldPool,
&nbsp;                                                    RecordComponentPool recordComponentPool,
&nbsp;                                                    TypeAttributeAppender typeAttributeAppender,
&nbsp;                                                    AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                                    ClassFileVersion classFileVersion,
&nbsp;                                                    AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                    AnnotationRetention annotationRetention,
&nbsp;                                                    AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                    Implementation.Context.Factory implementationContextFactory,
&nbsp;                                                    TypeValidation typeValidation,
&nbsp;                                                    ClassWriterStrategy classWriterStrategy,
&nbsp;                                                    TypePool typePool) {
<b class="fc">&nbsp;            return new ForCreation&lt;U&gt;(methodRegistry.getInstrumentedType(),</b>
&nbsp;                    classFileVersion,
&nbsp;                    fieldPool,
&nbsp;                    methodRegistry,
&nbsp;                    recordComponentPool,
&nbsp;                    auxiliaryTypes,
<b class="fc">&nbsp;                    methodRegistry.getInstrumentedType().getDeclaredFields(),</b>
<b class="fc">&nbsp;                    methodRegistry.getMethods(),</b>
<b class="fc">&nbsp;                    methodRegistry.getInstrumentedMethods(),</b>
<b class="fc">&nbsp;                    methodRegistry.getInstrumentedType().getRecordComponents(),</b>
<b class="fc">&nbsp;                    methodRegistry.getLoadedTypeInitializer(),</b>
<b class="fc">&nbsp;                    methodRegistry.getTypeInitializer(),</b>
&nbsp;                    typeAttributeAppender,
&nbsp;                    asmVisitorWrapper,
&nbsp;                    annotationValueFilterFactory,
&nbsp;                    annotationRetention,
&nbsp;                    auxiliaryTypeNamingStrategy,
&nbsp;                    implementationContextFactory,
&nbsp;                    typeValidation,
&nbsp;                    classWriterStrategy,
&nbsp;                    typePool);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type writer for redefining a type.
&nbsp;         *
&nbsp;         * @param methodRegistry               The compiled method registry to use.
&nbsp;         * @param auxiliaryTypes               A list of explicitly required auxiliary types.
&nbsp;         * @param fieldPool                    The field pool to use.
&nbsp;         * @param recordComponentPool          The record component pool to use.
&nbsp;         * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;         * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;         * @param classFileVersion             The class file version to use when no explicit class file version is applied.
&nbsp;         * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;         * @param annotationRetention          The annotation retention to apply.
&nbsp;         * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;         * @param implementationContextFactory The implementation context factory to apply.
&nbsp;         * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;         * @param classWriterStrategy          The class writer strategy to use.
&nbsp;         * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;         * @param originalType                 The original type that is being redefined or rebased.
&nbsp;         * @param classFileLocator             The class file locator for locating the original type&#39;s class file.
&nbsp;         * @param &lt;U&gt;                          A loaded type that the instrumented type guarantees to subclass.
&nbsp;         * @return A suitable type writer.
&nbsp;         */
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forRedefinition(MethodRegistry.Prepared methodRegistry,
&nbsp;                                                        List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                                        FieldPool fieldPool,
&nbsp;                                                        RecordComponentPool recordComponentPool,
&nbsp;                                                        TypeAttributeAppender typeAttributeAppender,
&nbsp;                                                        AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                                        ClassFileVersion classFileVersion,
&nbsp;                                                        AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                        AnnotationRetention annotationRetention,
&nbsp;                                                        AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                        Implementation.Context.Factory implementationContextFactory,
&nbsp;                                                        TypeValidation typeValidation,
&nbsp;                                                        ClassWriterStrategy classWriterStrategy,
&nbsp;                                                        TypePool typePool,
&nbsp;                                                        TypeDescription originalType,
&nbsp;                                                        ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;            return new ForInlining.WithFullProcessing&lt;U&gt;(methodRegistry.getInstrumentedType(),</b>
&nbsp;                    classFileVersion,
&nbsp;                    fieldPool,
&nbsp;                    recordComponentPool,
&nbsp;                    auxiliaryTypes,
<b class="fc">&nbsp;                    methodRegistry.getInstrumentedType().getDeclaredFields(),</b>
<b class="fc">&nbsp;                    methodRegistry.getMethods(),</b>
<b class="fc">&nbsp;                    methodRegistry.getInstrumentedMethods(),</b>
<b class="fc">&nbsp;                    methodRegistry.getInstrumentedType().getRecordComponents(),</b>
<b class="fc">&nbsp;                    methodRegistry.getLoadedTypeInitializer(),</b>
<b class="fc">&nbsp;                    methodRegistry.getTypeInitializer(),</b>
&nbsp;                    typeAttributeAppender,
&nbsp;                    asmVisitorWrapper,
&nbsp;                    annotationValueFilterFactory,
&nbsp;                    annotationRetention,
&nbsp;                    auxiliaryTypeNamingStrategy,
&nbsp;                    implementationContextFactory,
&nbsp;                    typeValidation,
&nbsp;                    classWriterStrategy,
&nbsp;                    typePool,
&nbsp;                    originalType,
&nbsp;                    classFileLocator,
&nbsp;                    methodRegistry,
&nbsp;                    SubclassImplementationTarget.Factory.LEVEL_TYPE,
&nbsp;                    MethodRebaseResolver.Disabled.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type writer for rebasing a type.
&nbsp;         *
&nbsp;         * @param methodRegistry               The compiled method registry to use.
&nbsp;         * @param auxiliaryTypes               A list of explicitly required auxiliary types.
&nbsp;         * @param fieldPool                    The field pool to use.
&nbsp;         * @param recordComponentPool          The record component pool to use.
&nbsp;         * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;         * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;         * @param classFileVersion             The class file version to use when no explicit class file version is applied.
&nbsp;         * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;         * @param annotationRetention          The annotation retention to apply.
&nbsp;         * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;         * @param implementationContextFactory The implementation context factory to apply.
&nbsp;         * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;         * @param classWriterStrategy          The class writer strategy to use.
&nbsp;         * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;         * @param originalType                 The original type that is being redefined or rebased.
&nbsp;         * @param classFileLocator             The class file locator for locating the original type&#39;s class file.
&nbsp;         * @param methodRebaseResolver         The method rebase resolver to use for rebasing names.
&nbsp;         * @param &lt;U&gt;                          A loaded type that the instrumented type guarantees to subclass.
&nbsp;         * @return A suitable type writer.
&nbsp;         */
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forRebasing(MethodRegistry.Prepared methodRegistry,
&nbsp;                                                    List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                                    FieldPool fieldPool,
&nbsp;                                                    RecordComponentPool recordComponentPool,
&nbsp;                                                    TypeAttributeAppender typeAttributeAppender,
&nbsp;                                                    AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                                    ClassFileVersion classFileVersion,
&nbsp;                                                    AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                    AnnotationRetention annotationRetention,
&nbsp;                                                    AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                    Implementation.Context.Factory implementationContextFactory,
&nbsp;                                                    TypeValidation typeValidation,
&nbsp;                                                    ClassWriterStrategy classWriterStrategy,
&nbsp;                                                    TypePool typePool,
&nbsp;                                                    TypeDescription originalType,
&nbsp;                                                    ClassFileLocator classFileLocator,
&nbsp;                                                    MethodRebaseResolver methodRebaseResolver) {
<b class="nc">&nbsp;            return new ForInlining.WithFullProcessing&lt;U&gt;(methodRegistry.getInstrumentedType(),</b>
&nbsp;                    classFileVersion,
&nbsp;                    fieldPool,
&nbsp;                    recordComponentPool,
<b class="nc">&nbsp;                    CompoundList.of(auxiliaryTypes, methodRebaseResolver.getAuxiliaryTypes()),</b>
<b class="nc">&nbsp;                    methodRegistry.getInstrumentedType().getDeclaredFields(),</b>
<b class="nc">&nbsp;                    methodRegistry.getMethods(),</b>
<b class="nc">&nbsp;                    methodRegistry.getInstrumentedMethods(),</b>
<b class="nc">&nbsp;                    methodRegistry.getInstrumentedType().getRecordComponents(),</b>
<b class="nc">&nbsp;                    methodRegistry.getLoadedTypeInitializer(),</b>
<b class="nc">&nbsp;                    methodRegistry.getTypeInitializer(),</b>
&nbsp;                    typeAttributeAppender,
&nbsp;                    asmVisitorWrapper,
&nbsp;                    annotationValueFilterFactory,
&nbsp;                    annotationRetention,
&nbsp;                    auxiliaryTypeNamingStrategy,
&nbsp;                    implementationContextFactory,
&nbsp;                    typeValidation,
&nbsp;                    classWriterStrategy,
&nbsp;                    typePool,
&nbsp;                    originalType,
&nbsp;                    classFileLocator,
&nbsp;                    methodRegistry,
&nbsp;                    new RebaseImplementationTarget.Factory(methodRebaseResolver),
&nbsp;                    methodRebaseResolver);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type writer for decorating a type.
&nbsp;         *
&nbsp;         * @param instrumentedType             The instrumented type.
&nbsp;         * @param classFileVersion             The class file version to use when no explicit class file version is applied.
&nbsp;         * @param auxiliaryTypes               A list of explicitly required auxiliary types.
&nbsp;         * @param methods                      The methods to instrument.
&nbsp;         * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;         * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;         * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;         * @param annotationRetention          The annotation retention to apply.
&nbsp;         * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;         * @param implementationContextFactory The implementation context factory to apply.
&nbsp;         * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;         * @param classWriterStrategy          The class writer strategy to use.
&nbsp;         * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;         * @param classFileLocator             The class file locator for locating the original type&#39;s class file.
&nbsp;         * @param &lt;U&gt;                          A loaded type that the instrumented type guarantees to subclass.
&nbsp;         * @return A suitable type writer.
&nbsp;         */
&nbsp;        public static &lt;U&gt; TypeWriter&lt;U&gt; forDecoration(TypeDescription instrumentedType,
&nbsp;                                                      ClassFileVersion classFileVersion,
&nbsp;                                                      List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                                      List&lt;? extends MethodDescription&gt; methods,
&nbsp;                                                      TypeAttributeAppender typeAttributeAppender,
&nbsp;                                                      AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                                      AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                      AnnotationRetention annotationRetention,
&nbsp;                                                      AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                      Implementation.Context.Factory implementationContextFactory,
&nbsp;                                                      TypeValidation typeValidation,
&nbsp;                                                      ClassWriterStrategy classWriterStrategy,
&nbsp;                                                      TypePool typePool,
&nbsp;                                                      ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;            return new ForInlining.WithDecorationOnly&lt;U&gt;(instrumentedType,</b>
&nbsp;                    classFileVersion,
&nbsp;                    auxiliaryTypes,
&nbsp;                    new MethodList.Explicit&lt;MethodDescription&gt;(methods),
&nbsp;                    typeAttributeAppender,
&nbsp;                    asmVisitorWrapper,
&nbsp;                    annotationValueFilterFactory,
&nbsp;                    annotationRetention,
&nbsp;                    auxiliaryTypeNamingStrategy,
&nbsp;                    implementationContextFactory,
&nbsp;                    typeValidation,
&nbsp;                    classWriterStrategy,
&nbsp;                    typePool,
&nbsp;                    classFileLocator);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Setting a debugging property should never change the program outcome.&quot;)
&nbsp;        public DynamicType.Unloaded&lt;S&gt; make(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
<b class="fc">&nbsp;            ClassDumpAction.Dispatcher dispatcher = DUMP_FOLDER == null</b>
<b class="fc">&nbsp;                    ? ClassDumpAction.Dispatcher.Disabled.INSTANCE</b>
<b class="nc">&nbsp;                    : new ClassDumpAction.Dispatcher.Enabled(DUMP_FOLDER, System.currentTimeMillis());</b>
<b class="fc">&nbsp;            UnresolvedType unresolvedType = create(typeResolutionStrategy.injectedInto(typeInitializer), dispatcher);</b>
<b class="fc">&nbsp;            dispatcher.dump(instrumentedType, false, unresolvedType.getBinaryRepresentation());</b>
<b class="fc">&nbsp;            return unresolvedType.toDynamicType(typeResolutionStrategy);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an unresolved version of the dynamic type.
&nbsp;         *
&nbsp;         * @param typeInitializer The type initializer to use.
&nbsp;         * @param dispatcher      A dispatcher for dumping class files.
&nbsp;         * @return An unresolved type.
&nbsp;         */
&nbsp;        protected abstract UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * An unresolved type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class UnresolvedType {
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s binary representation.
&nbsp;             */
&nbsp;            private final byte[] binaryRepresentation;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of auxiliary types for this unresolved type.
&nbsp;             */
&nbsp;            private final List&lt;? extends DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new unresolved type.
&nbsp;             *
&nbsp;             * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;             * @param auxiliaryTypes       A list of auxiliary types for this unresolved type.
&nbsp;             */
<b class="fc">&nbsp;            protected UnresolvedType(byte[] binaryRepresentation, List&lt;? extends DynamicType&gt; auxiliaryTypes) {</b>
<b class="fc">&nbsp;                this.binaryRepresentation = binaryRepresentation;</b>
<b class="fc">&nbsp;                this.auxiliaryTypes = auxiliaryTypes;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves this type to a dynamic type.
&nbsp;             *
&nbsp;             * @param typeResolutionStrategy The type resolution strategy to apply.
&nbsp;             * @return A dynamic type representing the inlined type.
&nbsp;             */
&nbsp;            protected DynamicType.Unloaded&lt;S&gt; toDynamicType(TypeResolutionStrategy.Resolved typeResolutionStrategy) {
<b class="fc">&nbsp;                return new DynamicType.Default.Unloaded&lt;S&gt;(instrumentedType,</b>
&nbsp;                        binaryRepresentation,
&nbsp;                        loadedTypeInitializer,
<b class="fc">&nbsp;                        CompoundList.of(Default.this.auxiliaryTypes, auxiliaryTypes),</b>
&nbsp;                        typeResolutionStrategy);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the binary representation of this unresolved type.
&nbsp;             *
&nbsp;             * @return The binary representation of this unresolved type.
&nbsp;             */
&nbsp;            protected byte[] getBinaryRepresentation() {
<b class="fc">&nbsp;                return binaryRepresentation;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A key to represent a unique signature.
&nbsp;         */
&nbsp;        protected static class SignatureKey {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented internal name.
&nbsp;             */
&nbsp;            private final String internalName;
&nbsp;
&nbsp;            /**
&nbsp;             * The represented descriptor.
&nbsp;             */
&nbsp;            private final String descriptor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new signature key.
&nbsp;             *
&nbsp;             * @param internalName The represented internal name.
&nbsp;             * @param descriptor   The represented descriptor.
&nbsp;             */
<b class="fc">&nbsp;            public SignatureKey(String internalName, String descriptor) {</b>
<b class="fc">&nbsp;                this.internalName = internalName;</b>
<b class="fc">&nbsp;                this.descriptor = descriptor;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                if (this == other) return true;</b>
<b class="nc">&nbsp;                if (other == null || getClass() != other.getClass()) return false;</b>
<b class="nc">&nbsp;                SignatureKey that = (SignatureKey) other;</b>
<b class="nc">&nbsp;                return internalName.equals(that.internalName) &amp;&amp; descriptor.equals(that.descriptor);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return 17 + internalName.hashCode() + 31 * descriptor.hashCode();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A class validator that validates that a class only defines members that are appropriate for the sort of the generated class.
&nbsp;         */
<b class="nc">&nbsp;        protected static class ValidatingClassVisitor extends ClassVisitor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a method has no method parameters.
&nbsp;             */
&nbsp;            private static final String NO_PARAMETERS = &quot;()&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a method returns void.
&nbsp;             */
&nbsp;            private static final String RETURNS_VOID = &quot;V&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the {@link String} type.
&nbsp;             */
&nbsp;            private static final String STRING_DESCRIPTOR = &quot;Ljava/lang/String;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a field is ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final FieldVisitor IGNORE_FIELD = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a method is ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final MethodVisitor IGNORE_METHOD = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The constraint to assert the members against. The constraint is first defined when the general class information is visited.
&nbsp;             */
&nbsp;            @UnknownNull
&nbsp;            private Constraint constraint;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a validating class visitor.
&nbsp;             *
&nbsp;             * @param classVisitor The class visitor to which any calls are delegated to.
&nbsp;             */
&nbsp;            protected ValidatingClassVisitor(ClassVisitor classVisitor) {
<b class="fc">&nbsp;                super(OpenedClassReader.ASM_API, classVisitor);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Adds a validating visitor if type validation is enabled.
&nbsp;             *
&nbsp;             * @param classVisitor   The original class visitor.
&nbsp;             * @param typeValidation The type validation state.
&nbsp;             * @return A class visitor that applies type validation if this is required.
&nbsp;             */
&nbsp;            protected static ClassVisitor of(ClassVisitor classVisitor, TypeValidation typeValidation) {
<b class="fc">&nbsp;                return typeValidation.isEnabled()</b>
<b class="fc">&nbsp;                        ? new ValidatingClassVisitor(classVisitor)</b>
<b class="fc">&nbsp;                        : classVisitor;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visit(int version, int modifiers, String name, @MaybeNull String signature, @MaybeNull String superName, @MaybeNull String[] interfaceInternalName) {
<b class="fc">&nbsp;                ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(version);</b>
<b class="fc">&nbsp;                List&lt;Constraint&gt; constraints = new ArrayList&lt;Constraint&gt;();</b>
<b class="fc">&nbsp;                constraints.add(new Constraint.ForClassFileVersion(classFileVersion));</b>
<b class="fc">&nbsp;                if (name.endsWith(&#39;/&#39; + PackageDescription.PACKAGE_CLASS_NAME)) {</b>
<b class="nc">&nbsp;                    constraints.add(Constraint.ForPackageType.INSTANCE);</b>
<b class="fc">&nbsp;                } else if ((modifiers &amp; Opcodes.ACC_ANNOTATION) != 0) {</b>
<b class="nc">&nbsp;                    if (!classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define an annotation type for class file version &quot; + classFileVersion);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    constraints.add(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8)</b>
<b class="nc">&nbsp;                            ? Constraint.ForAnnotation.JAVA_8</b>
<b class="nc">&nbsp;                            : Constraint.ForAnnotation.CLASSIC);</b>
<b class="fc">&nbsp;                } else if ((modifiers &amp; Opcodes.ACC_INTERFACE) != 0) {</b>
<b class="nc">&nbsp;                    constraints.add(classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8)</b>
<b class="nc">&nbsp;                            ? Constraint.ForInterface.JAVA_8</b>
<b class="nc">&nbsp;                            : Constraint.ForInterface.CLASSIC);</b>
<b class="fc">&nbsp;                } else if ((modifiers &amp; Opcodes.ACC_ABSTRACT) != 0) {</b>
<b class="nc">&nbsp;                    constraints.add(Constraint.ForClass.ABSTRACT);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    constraints.add(Constraint.ForClass.MANIFEST);</b>
&nbsp;                }
&nbsp;                boolean record;
<b class="fc">&nbsp;                if ((modifiers &amp; Opcodes.ACC_RECORD) != 0) {</b>
<b class="nc">&nbsp;                    constraints.add(Constraint.ForRecord.INSTANCE);</b>
<b class="nc">&nbsp;                    record = true;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    record = false;</b>
&nbsp;                }
<b class="fc">&nbsp;                constraint = new Constraint.Compound(constraints);</b>
<b class="fc">&nbsp;                constraint.assertType(modifiers, interfaceInternalName != null, signature != null);</b>
<b class="fc">&nbsp;                if (record) {</b>
<b class="nc">&nbsp;                    constraint.assertRecord();</b>
&nbsp;                }
<b class="fc">&nbsp;                super.visit(version, modifiers, name, signature, superName, interfaceInternalName);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitPermittedSubclass(String permittedSubclass) {
<b class="nc">&nbsp;                constraint.assertPermittedSubclass();</b>
<b class="nc">&nbsp;                super.visitPermittedSubclass(permittedSubclass);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                constraint.assertAnnotation();</b>
<b class="nc">&nbsp;                return super.visitAnnotation(descriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                constraint.assertTypeAnnotation();</b>
<b class="nc">&nbsp;                return super.visitTypeAnnotation(typeReference, typePath, descriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitNestHost(String nestHost) {
<b class="nc">&nbsp;                constraint.assertNestMate();</b>
<b class="nc">&nbsp;                super.visitNestHost(nestHost);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitNestMember(String nestMember) {
<b class="nc">&nbsp;                constraint.assertNestMate();</b>
<b class="nc">&nbsp;                super.visitNestMember(nestMember);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            public FieldVisitor visitField(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
<b class="fc">&nbsp;                if (value != null) {</b>
&nbsp;                    Class&lt;?&gt; type;
<b class="nc">&nbsp;                    switch (descriptor.charAt(0)) {</b>
&nbsp;                        case &#39;Z&#39;:
&nbsp;                        case &#39;B&#39;:
&nbsp;                        case &#39;C&#39;:
&nbsp;                        case &#39;S&#39;:
&nbsp;                        case &#39;I&#39;:
<b class="nc">&nbsp;                            type = Integer.class;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case &#39;J&#39;:
<b class="nc">&nbsp;                            type = Long.class;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case &#39;F&#39;:
<b class="nc">&nbsp;                            type = Float.class;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        case &#39;D&#39;:
<b class="nc">&nbsp;                            type = Double.class;</b>
<b class="nc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            if (!descriptor.equals(STRING_DESCRIPTOR)) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define a default value for type of field &quot; + name);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            type = String.class;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (!type.isInstance(value)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Field &quot; + name + &quot; defines an incompatible default value &quot; + value);</b>
<b class="nc">&nbsp;                    } else if (type == Integer.class) {</b>
&nbsp;                        int minimum, maximum;
<b class="nc">&nbsp;                        switch (descriptor.charAt(0)) {</b>
&nbsp;                            case &#39;Z&#39;:
<b class="nc">&nbsp;                                minimum = 0;</b>
<b class="nc">&nbsp;                                maximum = 1;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case &#39;B&#39;:
<b class="nc">&nbsp;                                minimum = Byte.MIN_VALUE;</b>
<b class="nc">&nbsp;                                maximum = Byte.MAX_VALUE;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case &#39;C&#39;:
<b class="nc">&nbsp;                                minimum = Character.MIN_VALUE;</b>
<b class="nc">&nbsp;                                maximum = Character.MAX_VALUE;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case &#39;S&#39;:
<b class="nc">&nbsp;                                minimum = Short.MIN_VALUE;</b>
<b class="nc">&nbsp;                                maximum = Short.MAX_VALUE;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            default:
<b class="nc">&nbsp;                                minimum = Integer.MIN_VALUE;</b>
<b class="nc">&nbsp;                                maximum = Integer.MAX_VALUE;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if ((Integer) value &lt; minimum || (Integer) value &gt; maximum) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Field &quot; + name + &quot; defines an incompatible default value &quot; + value);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                constraint.assertField(name,</b>
&nbsp;                        (modifiers &amp; Opcodes.ACC_PUBLIC) != 0,
&nbsp;                        (modifiers &amp; Opcodes.ACC_STATIC) != 0,
&nbsp;                        (modifiers &amp; Opcodes.ACC_FINAL) != 0,
&nbsp;                        signature != null);
<b class="fc">&nbsp;                FieldVisitor fieldVisitor = super.visitField(modifiers, name, descriptor, signature, value);</b>
<b class="fc">&nbsp;                return fieldVisitor == null</b>
<b class="nc">&nbsp;                        ? IGNORE_FIELD</b>
<b class="fc">&nbsp;                        : new ValidatingFieldVisitor(fieldVisitor);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            public MethodVisitor visitMethod(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull String[] exceptionInternalName) {
<b class="nc">&nbsp;                constraint.assertMethod(name,</b>
&nbsp;                        (modifiers &amp; Opcodes.ACC_ABSTRACT) != 0,
&nbsp;                        (modifiers &amp; Opcodes.ACC_PUBLIC) != 0,
&nbsp;                        (modifiers &amp; Opcodes.ACC_PRIVATE) != 0,
&nbsp;                        (modifiers &amp; Opcodes.ACC_STATIC) != 0,
<b class="nc">&nbsp;                        !name.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)</b>
<b class="nc">&nbsp;                                &amp;&amp; !name.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)</b>
&nbsp;                                &amp;&amp; (modifiers &amp; (Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC)) == 0,
<b class="nc">&nbsp;                        name.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME),</b>
<b class="nc">&nbsp;                        !descriptor.startsWith(NO_PARAMETERS) || descriptor.endsWith(RETURNS_VOID),</b>
&nbsp;                        signature != null);
<b class="nc">&nbsp;                MethodVisitor methodVisitor = super.visitMethod(modifiers, name, descriptor, signature, exceptionInternalName);</b>
<b class="nc">&nbsp;                return methodVisitor == null</b>
<b class="nc">&nbsp;                        ? IGNORE_METHOD</b>
<b class="nc">&nbsp;                        : new ValidatingMethodVisitor(methodVisitor, name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A constraint for members that are legal for a given type.
&nbsp;             */
&nbsp;            protected interface Constraint {
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts if the type can legally represent a package description.
&nbsp;                 *
&nbsp;                 * @param modifier          The modifier that is to be written to the type.
&nbsp;                 * @param definesInterfaces {@code true} if this type implements at least one interface.
&nbsp;                 * @param isGeneric         {@code true} if this type defines a generic type signature.
&nbsp;                 */
&nbsp;                void assertType(int modifier, boolean definesInterfaces, boolean isGeneric);
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts a field for being valid.
&nbsp;                 *
&nbsp;                 * @param name      The name of the field.
&nbsp;                 * @param isPublic  {@code true} if this field is public.
&nbsp;                 * @param isStatic  {@code true} if this field is static.
&nbsp;                 * @param isFinal   {@code true} if this field is final.
&nbsp;                 * @param isGeneric {@code true} if this field defines a generic signature.
&nbsp;                 */
&nbsp;                void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric);
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts a method for being valid.
&nbsp;                 *
&nbsp;                 * @param name                       The name of the method.
&nbsp;                 * @param isAbstract                 {@code true} if the method is abstract.
&nbsp;                 * @param isPublic                   {@code true} if this method is public.
&nbsp;                 * @param isPrivate                  {@code true} if this method is private.
&nbsp;                 * @param isStatic                   {@code true} if this method is static.
&nbsp;                 * @param isVirtual                  {@code true} if this method is virtual.
&nbsp;                 * @param isConstructor              {@code true} if this method is a constructor.
&nbsp;                 * @param isDefaultValueIncompatible {@code true} if a method&#39;s signature cannot describe an annotation property method.
&nbsp;                 * @param isGeneric                  {@code true} if this method defines a generic signature.
&nbsp;                 */
&nbsp;                void assertMethod(String name,
&nbsp;                                  boolean isAbstract,
&nbsp;                                  boolean isPublic,
&nbsp;                                  boolean isPrivate,
&nbsp;                                  boolean isStatic,
&nbsp;                                  boolean isVirtual,
&nbsp;                                  boolean isConstructor,
&nbsp;                                  boolean isDefaultValueIncompatible,
&nbsp;                                  boolean isGeneric);
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the legitimacy of an annotation for the instrumented type.
&nbsp;                 */
&nbsp;                void assertAnnotation();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the legitimacy of a type annotation for the instrumented type.
&nbsp;                 */
&nbsp;                void assertTypeAnnotation();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts if a default value is legal for a method.
&nbsp;                 *
&nbsp;                 * @param name The name of the method.
&nbsp;                 */
&nbsp;                void assertDefaultValue(String name);
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts if it is legal to invoke a default method from a type.
&nbsp;                 */
&nbsp;                void assertDefaultMethodCall();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability to store a type constant in the class&#39;s constant pool.
&nbsp;                 */
&nbsp;                void assertTypeInConstantPool();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability to store a method type constant in the class&#39;s constant pool.
&nbsp;                 */
&nbsp;                void assertMethodTypeInConstantPool();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability to store a method handle in the class&#39;s constant pool.
&nbsp;                 */
&nbsp;                void assertHandleInConstantPool();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability to invoke a method dynamically.
&nbsp;                 */
&nbsp;                void assertInvokeDynamic();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability of executing a subroutine.
&nbsp;                 */
&nbsp;                void assertSubRoutine();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability of storing a dynamic value in the constant pool.
&nbsp;                 */
&nbsp;                void assertDynamicValueInConstantPool();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the capability of storing nest mate information.
&nbsp;                 */
&nbsp;                void assertNestMate();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the presence of a record component.
&nbsp;                 */
&nbsp;                void assertRecord();
&nbsp;
&nbsp;                /**
&nbsp;                 * Asserts the presence of a permitted subclass.
&nbsp;                 */
&nbsp;                void assertPermittedSubclass();
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the constraint of a class type.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForClass implements Constraint {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents the constraints of a non-abstract class.
&nbsp;                     */
<b class="fc">&nbsp;                    MANIFEST(true),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents the constraints of an abstract class.
&nbsp;                     */
<b class="fc">&nbsp;                    ABSTRACT(false);</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if this instance represents the constraints a non-abstract class.
&nbsp;                     */
&nbsp;                    private final boolean manifestType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new constraint for a class.
&nbsp;                     *
&nbsp;                     * @param manifestType {@code true} if this instance represents a non-abstract class.
&nbsp;                     */
<b class="fc">&nbsp;                    ForClass(boolean manifestType) {</b>
<b class="fc">&nbsp;                        this.manifestType = manifestType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isDefaultValueIncompatible,
&nbsp;                                             boolean isGeneric) {
<b class="nc">&nbsp;                        if (isAbstract &amp;&amp; manifestType) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define abstract method &#39;&quot; + name + &quot;&#39; for non-abstract class&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define default value for &#39;&quot; + name + &quot;&#39; for non-annotation type&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the constraint of a package type.
&nbsp;                 */
<b class="nc">&nbsp;                enum ForPackageType implements Constraint {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define a field for a package description type&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isNoDefaultValue,
&nbsp;                                             boolean isGeneric) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define a method for a package description type&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                        /* do nothing, implicit by forbidding methods */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
<b class="nc">&nbsp;                        if (modifier != PackageDescription.PACKAGE_MODIFIERS) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;A package description type must define &quot; + PackageDescription.PACKAGE_MODIFIERS + &quot; as modifier&quot;);</b>
<b class="nc">&nbsp;                        } else if (definesInterfaces) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot implement interface for package type&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the constraint of an interface type.
&nbsp;                 */
<b class="nc">&nbsp;                enum ForInterface implements Constraint {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * An interface type with the constraints for the Java versions 5 to 7.
&nbsp;                     */
<b class="nc">&nbsp;                    CLASSIC(true),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * An interface type with the constraints for the Java versions 8+.
&nbsp;                     */
<b class="nc">&nbsp;                    JAVA_8(false);</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if this instance represents a classic interface type (pre Java 8).
&nbsp;                     */
&nbsp;                    private final boolean classic;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a constraint for an interface type.
&nbsp;                     *
&nbsp;                     * @param classic {@code true} if this instance represents a classic interface (pre Java 8).
&nbsp;                     */
<b class="nc">&nbsp;                    ForInterface(boolean classic) {</b>
<b class="nc">&nbsp;                        this.classic = classic;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
<b class="nc">&nbsp;                        if (!isStatic || !isPublic || !isFinal) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot only define public, static, final field &#39;&quot; + name + &quot;&#39; for interface type&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isDefaultValueIncompatible,
&nbsp;                                             boolean isGeneric) {
<b class="nc">&nbsp;                        if (!name.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {</b>
<b class="nc">&nbsp;                            if (isConstructor) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define constructor for interface type&quot;);</b>
<b class="nc">&nbsp;                            } else if (classic &amp;&amp; !isPublic) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define non-public method &#39;&quot; + name + &quot;&#39; for interface type&quot;);</b>
<b class="nc">&nbsp;                            } else if (classic &amp;&amp; !isVirtual) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define non-virtual method &#39;&quot; + name + &quot;&#39; for a pre-Java 8 interface type&quot;);</b>
<b class="nc">&nbsp;                            } else if (classic &amp;&amp; !isAbstract) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define default method &#39;&quot; + name + &quot;&#39; for pre-Java 8 interface type&quot;);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define default value for &#39;&quot; + name + &quot;&#39; for non-annotation type&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the constraint of a record type.
&nbsp;                 */
<b class="nc">&nbsp;                enum ForRecord implements Constraint {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isDefaultValueIncompatible,
&nbsp;                                             boolean isGeneric) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
<b class="nc">&nbsp;                        if ((modifier &amp; Opcodes.ACC_ABSTRACT) != 0) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define a record class as abstract&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the constraint of an annotation type.
&nbsp;                 */
<b class="nc">&nbsp;                enum ForAnnotation implements Constraint {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation type with the constraints for the Java versions 5 to 7.
&nbsp;                     */
<b class="nc">&nbsp;                    CLASSIC(true),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation type with the constraints for the Java versions 8+.
&nbsp;                     */
<b class="nc">&nbsp;                    JAVA_8(false);</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if this instance represents a classic annotation type (pre Java 8).
&nbsp;                     */
&nbsp;                    private final boolean classic;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a constraint for an annotation type.
&nbsp;                     *
&nbsp;                     * @param classic {@code true} if this instance represents a classic annotation type (pre Java 8).
&nbsp;                     */
<b class="nc">&nbsp;                    ForAnnotation(boolean classic) {</b>
<b class="nc">&nbsp;                        this.classic = classic;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
<b class="nc">&nbsp;                        if (!isStatic || !isPublic || !isFinal) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot only define public, static, final field &#39;&quot; + name + &quot;&#39; for interface type&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isDefaultValueIncompatible,
&nbsp;                                             boolean isGeneric) {
<b class="nc">&nbsp;                        if (!name.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {</b>
<b class="nc">&nbsp;                            if (isConstructor) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define constructor for interface type&quot;);</b>
<b class="nc">&nbsp;                            } else if (classic &amp;&amp; !isVirtual) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define non-virtual method &#39;&quot; + name + &quot;&#39; for a pre-Java 8 annotation type&quot;);</b>
<b class="nc">&nbsp;                            } else if (!isStatic &amp;&amp; isDefaultValueIncompatible) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot define method &#39;&quot; + name + &quot;&#39; with the given signature as an annotation type method&quot;);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
<b class="nc">&nbsp;                        if ((modifier &amp; Opcodes.ACC_INTERFACE) == 0) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define annotation type without interface modifier&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the constraint implied by a class file version.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForClassFileVersion implements Constraint {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The enforced class file version.
&nbsp;                     */
&nbsp;                    private final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new constraint for the given class file version.
&nbsp;                     *
&nbsp;                     * @param classFileVersion The enforced class file version.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForClassFileVersion(ClassFileVersion classFileVersion) {</b>
<b class="fc">&nbsp;                        this.classFileVersion = classFileVersion;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifiers, boolean definesInterfaces, boolean isGeneric) {
<b class="fc">&nbsp;                        if ((modifiers &amp; Opcodes.ACC_ANNOTATION) != 0 &amp;&amp; !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define annotation type for class file version &quot; + classFileVersion);</b>
<b class="fc">&nbsp;                        } else if (isGeneric &amp;&amp; !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) { // JSR14 allows for generic 1.4 classes.</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define a generic type for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
<b class="fc">&nbsp;                        if (isGeneric &amp;&amp; !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) { // JSR14 allows for generic 1.4 classes.</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define generic field &#39;&quot; + name + &quot;&#39; for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isDefaultValueIncompatible,
&nbsp;                                             boolean isGeneric) {
<b class="nc">&nbsp;                        if (isGeneric &amp;&amp; !classFileVersion.isAtLeast(ClassFileVersion.JAVA_V4)) { // JSR14 allows for generic 1.4 classes.</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define generic method &#39;&quot; + name + &quot;&#39; for class file version &quot; + classFileVersion);</b>
<b class="nc">&nbsp;                        } else if (!isVirtual &amp;&amp; isAbstract) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define static or non-virtual method &#39;&quot; + name + &quot;&#39; to be abstract&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write annotations for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write type annotations for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
&nbsp;                        /* do nothing, implicitly checked by type assertion */
<b class="nc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V8)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke default method for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write type to constant pool for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write method type to constant pool for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write method handle to constant pool for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V7)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write invoke dynamic instruction for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
<b class="nc">&nbsp;                        if (classFileVersion.isGreaterThan(ClassFileVersion.JAVA_V5)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write subroutine for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V11)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write dynamic constant for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V11)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define nest mate for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V14)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define record for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
<b class="nc">&nbsp;                        if (classFileVersion.isLessThan(ClassFileVersion.JAVA_V17)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define permitted subclasses for class file version &quot; + classFileVersion);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A constraint implementation that summarizes several constraints.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Compound implements Constraint {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of constraints that is enforced in the given order.
&nbsp;                     */
&nbsp;                    private final List&lt;Constraint&gt; constraints;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new compound constraint.
&nbsp;                     *
&nbsp;                     * @param constraints A list of constraints that is enforced in the given order.
&nbsp;                     */
<b class="fc">&nbsp;                    public Compound(List&lt;? extends Constraint&gt; constraints) {</b>
<b class="fc">&nbsp;                        this.constraints = new ArrayList&lt;Constraint&gt;();</b>
<b class="fc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="fc">&nbsp;                            if (constraint instanceof Compound) {</b>
<b class="nc">&nbsp;                                this.constraints.addAll(((Compound) constraint).constraints);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                this.constraints.add(constraint);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertType(int modifier, boolean definesInterfaces, boolean isGeneric) {
<b class="fc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="fc">&nbsp;                            constraint.assertType(modifier, definesInterfaces, isGeneric);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertField(String name, boolean isPublic, boolean isStatic, boolean isFinal, boolean isGeneric) {
<b class="fc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="fc">&nbsp;                            constraint.assertField(name, isPublic, isStatic, isFinal, isGeneric);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethod(String name,
&nbsp;                                             boolean isAbstract,
&nbsp;                                             boolean isPublic,
&nbsp;                                             boolean isPrivate,
&nbsp;                                             boolean isStatic,
&nbsp;                                             boolean isVirtual,
&nbsp;                                             boolean isConstructor,
&nbsp;                                             boolean isDefaultValueIncompatible,
&nbsp;                                             boolean isGeneric) {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertMethod(name,</b>
&nbsp;                                    isAbstract,
&nbsp;                                    isPublic,
&nbsp;                                    isPrivate,
&nbsp;                                    isStatic,
&nbsp;                                    isVirtual,
&nbsp;                                    isConstructor,
&nbsp;                                    isDefaultValueIncompatible,
&nbsp;                                    isGeneric);
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultValue(String name) {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertDefaultValue(name);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDefaultMethodCall() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertDefaultMethodCall();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertAnnotation() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertAnnotation();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeAnnotation() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertTypeAnnotation();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertTypeInConstantPool() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertTypeInConstantPool();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertMethodTypeInConstantPool() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertMethodTypeInConstantPool();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertHandleInConstantPool() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertHandleInConstantPool();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertInvokeDynamic() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertInvokeDynamic();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertSubRoutine() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertSubRoutine();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertDynamicValueInConstantPool() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertDynamicValueInConstantPool();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertNestMate() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertNestMate();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertRecord() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertRecord();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void assertPermittedSubclass() {
<b class="nc">&nbsp;                        for (Constraint constraint : constraints) {</b>
<b class="nc">&nbsp;                            constraint.assertPermittedSubclass();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field validator for checking default values.
&nbsp;             */
&nbsp;            protected class ValidatingFieldVisitor extends FieldVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a validating field visitor.
&nbsp;                 *
&nbsp;                 * @param fieldVisitor The field visitor to which any calls are delegated to.
&nbsp;                 */
<b class="fc">&nbsp;                protected ValidatingFieldVisitor(FieldVisitor fieldVisitor) {</b>
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API, fieldVisitor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                    constraint.assertAnnotation();</b>
<b class="nc">&nbsp;                    return super.visitAnnotation(descriptor, visible);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method validator for checking default values.
&nbsp;             */
&nbsp;            protected class ValidatingMethodVisitor extends MethodVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the method being visited.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a validating method visitor.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor to which any calls are delegated to.
&nbsp;                 * @param name          The name of the method being visited.
&nbsp;                 */
<b class="nc">&nbsp;                protected ValidatingMethodVisitor(MethodVisitor methodVisitor, String name) {</b>
<b class="nc">&nbsp;                    super(OpenedClassReader.ASM_API, methodVisitor);</b>
<b class="nc">&nbsp;                    this.name = name;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                    constraint.assertAnnotation();</b>
<b class="nc">&nbsp;                    return super.visitAnnotation(descriptor, visible);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
<b class="nc">&nbsp;                    constraint.assertDefaultValue(name);</b>
<b class="nc">&nbsp;                    return super.visitAnnotationDefault();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;SF_SWITCH_NO_DEFAULT&quot;, justification = &quot;Fall through to default case is intentional.&quot;)
&nbsp;                public void visitLdcInsn(Object value) {
<b class="nc">&nbsp;                    if (value instanceof Type) {</b>
<b class="nc">&nbsp;                        Type type = (Type) value;</b>
<b class="nc">&nbsp;                        switch (type.getSort()) {</b>
&nbsp;                            case Type.OBJECT:
&nbsp;                            case Type.ARRAY:
<b class="nc">&nbsp;                                constraint.assertTypeInConstantPool();</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            case Type.METHOD:
<b class="nc">&nbsp;                                constraint.assertMethodTypeInConstantPool();</b>
&nbsp;                                break;
&nbsp;                        }
<b class="nc">&nbsp;                    } else if (value instanceof Handle) {</b>
<b class="nc">&nbsp;                        constraint.assertHandleInConstantPool();</b>
<b class="nc">&nbsp;                    } else if (value instanceof ConstantDynamic) {</b>
<b class="nc">&nbsp;                        constraint.assertDynamicValueInConstantPool();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    super.visitLdcInsn(value);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitMethodInsn(int opcode, String owner, String name, String descriptor, boolean isInterface) {
<b class="nc">&nbsp;                    if (isInterface &amp;&amp; opcode == Opcodes.INVOKESPECIAL) {</b>
<b class="nc">&nbsp;                        constraint.assertDefaultMethodCall();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    super.visitMethodInsn(opcode, owner, name, descriptor, isInterface);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitInvokeDynamicInsn(String name, String descriptor, Handle bootstrapMethod, Object... bootstrapArgument) {
<b class="nc">&nbsp;                    constraint.assertInvokeDynamic();</b>
<b class="nc">&nbsp;                    for (Object constant : bootstrapArgument) {</b>
<b class="nc">&nbsp;                        if (constant instanceof ConstantDynamic) {</b>
<b class="nc">&nbsp;                            constraint.assertDynamicValueInConstantPool();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    super.visitInvokeDynamicInsn(name, descriptor, bootstrapMethod, bootstrapArgument);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitJumpInsn(int opcode, Label label) {
<b class="nc">&nbsp;                    if (opcode == Opcodes.JSR) {</b>
<b class="nc">&nbsp;                        constraint.assertSubRoutine();</b>
&nbsp;                    }
<b class="nc">&nbsp;                    super.visitJumpInsn(opcode, label);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type writer that inlines the created type into an existing class file.
&nbsp;         *
&nbsp;         * @param &lt;U&gt; The best known loaded type for the dynamically created type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        public abstract static class ForInlining&lt;U&gt; extends Default&lt;U&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a field should be ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final FieldVisitor IGNORE_FIELD = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a method should be ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final MethodVisitor IGNORE_METHOD = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a record component should be ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final RecordComponentVisitor IGNORE_RECORD_COMPONENT = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that an annotation should be ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final AnnotationVisitor IGNORE_ANNOTATION = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The original type&#39;s description.
&nbsp;             */
&nbsp;            protected final TypeDescription originalType;
&nbsp;
&nbsp;            /**
&nbsp;             * The class file locator for locating the original type&#39;s class file.
&nbsp;             */
&nbsp;            protected final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new inlining type writer.
&nbsp;             *
&nbsp;             * @param instrumentedType             The instrumented type to be created.
&nbsp;             * @param classFileVersion             The class file specified by the user.
&nbsp;             * @param fieldPool                    The field pool to use.
&nbsp;             * @param recordComponentPool          The record component pool to use.
&nbsp;             * @param auxiliaryTypes               The explicit auxiliary types to add to the created type.
&nbsp;             * @param fields                       The instrumented type&#39;s declared fields.
&nbsp;             * @param methods                      The instrumented type&#39;s declared and virtually inherited methods.
&nbsp;             * @param instrumentedMethods          The instrumented methods relevant to this type creation.
&nbsp;             * @param recordComponents             The instrumented type&#39;s record components.
&nbsp;             * @param loadedTypeInitializer        The loaded type initializer to apply onto the created type after loading.
&nbsp;             * @param typeInitializer              The type initializer to include in the created type&#39;s type initializer.
&nbsp;             * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;             * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;             * @param annotationRetention          The annotation retention to apply.
&nbsp;             * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;             * @param implementationContextFactory The implementation context factory to apply.
&nbsp;             * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;             * @param classWriterStrategy          The class writer strategy to use.
&nbsp;             * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;             * @param originalType                 The original type&#39;s description.
&nbsp;             * @param classFileLocator             The class file locator for locating the original type&#39;s class file.
&nbsp;             */
&nbsp;            protected ForInlining(TypeDescription instrumentedType,
&nbsp;                                  ClassFileVersion classFileVersion,
&nbsp;                                  FieldPool fieldPool,
&nbsp;                                  RecordComponentPool recordComponentPool,
&nbsp;                                  List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                  FieldList&lt;FieldDescription.InDefinedShape&gt; fields,
&nbsp;                                  MethodList&lt;?&gt; methods,
&nbsp;                                  MethodList&lt;?&gt; instrumentedMethods,
&nbsp;                                  RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents,
&nbsp;                                  LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                                  TypeInitializer typeInitializer,
&nbsp;                                  TypeAttributeAppender typeAttributeAppender,
&nbsp;                                  AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                  AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                  AnnotationRetention annotationRetention,
&nbsp;                                  AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                  Implementation.Context.Factory implementationContextFactory,
&nbsp;                                  TypeValidation typeValidation,
&nbsp;                                  ClassWriterStrategy classWriterStrategy,
&nbsp;                                  TypePool typePool,
&nbsp;                                  TypeDescription originalType,
&nbsp;                                  ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                super(instrumentedType,</b>
&nbsp;                        classFileVersion,
&nbsp;                        fieldPool,
&nbsp;                        recordComponentPool,
&nbsp;                        auxiliaryTypes,
&nbsp;                        fields,
&nbsp;                        methods,
&nbsp;                        instrumentedMethods,
&nbsp;                        recordComponents,
&nbsp;                        loadedTypeInitializer,
&nbsp;                        typeInitializer,
&nbsp;                        typeAttributeAppender,
&nbsp;                        asmVisitorWrapper,
&nbsp;                        annotationValueFilterFactory,
&nbsp;                        annotationRetention,
&nbsp;                        auxiliaryTypeNamingStrategy,
&nbsp;                        implementationContextFactory,
&nbsp;                        typeValidation,
&nbsp;                        classWriterStrategy,
&nbsp;                        typePool);
<b class="fc">&nbsp;                this.originalType = originalType;</b>
<b class="fc">&nbsp;                this.classFileLocator = classFileLocator;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
<b class="nc">&nbsp;                ContextRegistry contextRegistry = new ContextRegistry();</b>
<b class="nc">&nbsp;                return new RegistryContextClassVisitor(writeTo(ValidatingClassVisitor.of(classVisitor, typeValidation),</b>
&nbsp;                        typeInitializer,
&nbsp;                        contextRegistry,
<b class="nc">&nbsp;                        asmVisitorWrapper.mergeWriter(writerFlags),</b>
<b class="nc">&nbsp;                        asmVisitorWrapper.mergeReader(readerFlags)), contextRegistry);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher) {
&nbsp;                try {
<b class="fc">&nbsp;                    int writerFlags = asmVisitorWrapper.mergeWriter(AsmVisitorWrapper.NO_FLAGS);</b>
<b class="fc">&nbsp;                    int readerFlags = asmVisitorWrapper.mergeReader(AsmVisitorWrapper.NO_FLAGS);</b>
<b class="fc">&nbsp;                    byte[] binaryRepresentation = classFileLocator.locate(originalType.getName()).resolve();</b>
<b class="fc">&nbsp;                    dispatcher.dump(instrumentedType, true, binaryRepresentation);</b>
<b class="fc">&nbsp;                    ClassReader classReader = OpenedClassReader.of(binaryRepresentation);</b>
<b class="fc">&nbsp;                    ClassWriter classWriter = classWriterStrategy.resolve(writerFlags, typePool, classReader);</b>
<b class="fc">&nbsp;                    ContextRegistry contextRegistry = new ContextRegistry();</b>
<b class="fc">&nbsp;                    classReader.accept(writeTo(ValidatingClassVisitor.of(classWriter, typeValidation),</b>
&nbsp;                            typeInitializer,
&nbsp;                            contextRegistry,
&nbsp;                            writerFlags,
&nbsp;                            readerFlags), readerFlags);
<b class="fc">&nbsp;                    return new UnresolvedType(classWriter.toByteArray(), contextRegistry.getAuxiliaryTypes());</b>
<b class="nc">&nbsp;                } catch (IOException exception) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(&quot;The class file could not be written&quot;, exception);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class visitor which weaves all changes and additions on the fly.
&nbsp;             *
&nbsp;             * @param classVisitor    The class visitor to which this entry is to be written to.
&nbsp;             * @param typeInitializer The type initializer to apply.
&nbsp;             * @param contextRegistry A context registry to register the lazily created implementation context to.
&nbsp;             * @param writerFlags     The writer flags being used.
&nbsp;             * @param readerFlags     The reader flags being used.
&nbsp;             * @return A class visitor which is capable of applying the changes.
&nbsp;             */
&nbsp;            protected abstract ClassVisitor writeTo(ClassVisitor classVisitor,
&nbsp;                                                    TypeInitializer typeInitializer,
&nbsp;                                                    ContextRegistry contextRegistry,
&nbsp;                                                    int writerFlags,
&nbsp;                                                    int readerFlags);
&nbsp;
&nbsp;            /**
&nbsp;             * A context class visitor based on a {@link ContextRegistry}.
&nbsp;             */
&nbsp;            protected class RegistryContextClassVisitor extends ContextClassVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The context registry to use.
&nbsp;                 */
&nbsp;                private final ContextRegistry contextRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new context class visitor based on a {@link ContextRegistry}.
&nbsp;                 *
&nbsp;                 * @param classVisitor    The class visitor to delegate to.
&nbsp;                 * @param contextRegistry The context registry to use.
&nbsp;                 */
<b class="nc">&nbsp;                protected RegistryContextClassVisitor(ClassVisitor classVisitor, ContextRegistry contextRegistry) {</b>
<b class="nc">&nbsp;                    super(classVisitor);</b>
<b class="nc">&nbsp;                    this.contextRegistry = contextRegistry;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;DynamicType&gt; getAuxiliaryTypes() {
<b class="nc">&nbsp;                    return CompoundList.of(auxiliaryTypes, contextRegistry.getAuxiliaryTypes());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public LoadedTypeInitializer getLoadedTypeInitializer() {
<b class="nc">&nbsp;                    return loadedTypeInitializer;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A context registry allows to extract auxiliary types from a lazily created implementation context.
&nbsp;             */
<b class="fc">&nbsp;            protected static class ContextRegistry {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation context that is used for creating a class or {@code null} if it was not registered.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                private Implementation.Context.ExtractableView implementationContext;
&nbsp;
&nbsp;                /**
&nbsp;                 * Registers the implementation context.
&nbsp;                 *
&nbsp;                 * @param implementationContext The implementation context.
&nbsp;                 */
&nbsp;                public void setImplementationContext(Implementation.Context.ExtractableView implementationContext) {
<b class="fc">&nbsp;                    this.implementationContext = implementationContext;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the auxiliary types that were registered during class creation. This method must only be called after
&nbsp;                 * a class was created.
&nbsp;                 *
&nbsp;                 * @return The auxiliary types that were registered during class creation
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR&quot;, justification = &quot;Lazy value definition is intended.&quot;)
&nbsp;                public List&lt;DynamicType&gt; getAuxiliaryTypes() {
<b class="fc">&nbsp;                    return implementationContext.getAuxiliaryTypes();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A default type writer that reprocesses a type completely.
&nbsp;             *
&nbsp;             * @param &lt;V&gt; The best known loaded type for the dynamically created type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class WithFullProcessing&lt;V&gt; extends ForInlining&lt;V&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * An empty array to indicate missing frames.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Object[] EMPTY = new Object[0];</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The method registry to use.
&nbsp;                 */
&nbsp;                private final MethodRegistry.Prepared methodRegistry;
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation target factory to use.
&nbsp;                 */
&nbsp;                private final Implementation.Target.Factory implementationTargetFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method rebase resolver to use for rebasing methods.
&nbsp;                 */
&nbsp;                private final MethodRebaseResolver methodRebaseResolver;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new inlining type writer that fully reprocesses a type.
&nbsp;                 *
&nbsp;                 * @param instrumentedType             The instrumented type to be created.
&nbsp;                 * @param classFileVersion             The class file specified by the user.
&nbsp;                 * @param fieldPool                    The field pool to use.
&nbsp;                 * @param recordComponentPool          The record component pool to use.
&nbsp;                 * @param auxiliaryTypes               The explicit auxiliary types to add to the created type.
&nbsp;                 * @param fields                       The instrumented type&#39;s declared fields.
&nbsp;                 * @param methods                      The instrumented type&#39;s declared and virtually inherited methods.
&nbsp;                 * @param instrumentedMethods          The instrumented methods relevant to this type creation.
&nbsp;                 * @param recordComponents             The instrumented type&#39;s record components.
&nbsp;                 * @param loadedTypeInitializer        The loaded type initializer to apply onto the created type after loading.
&nbsp;                 * @param typeInitializer              The type initializer to include in the created type&#39;s type initializer.
&nbsp;                 * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;                 * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;                 * @param annotationRetention          The annotation retention to apply.
&nbsp;                 * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;                 * @param implementationContextFactory The implementation context factory to apply.
&nbsp;                 * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;                 * @param classWriterStrategy          The class writer strategy to use.
&nbsp;                 * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;                 * @param originalType                 The original type&#39;s description.
&nbsp;                 * @param classFileLocator             The class file locator for locating the original type&#39;s class file.
&nbsp;                 * @param methodRegistry               The method registry to use.
&nbsp;                 * @param implementationTargetFactory  The implementation target factory to use.
&nbsp;                 * @param methodRebaseResolver         The method rebase resolver to use for rebasing methods.
&nbsp;                 */
&nbsp;                protected WithFullProcessing(TypeDescription instrumentedType,
&nbsp;                                             ClassFileVersion classFileVersion,
&nbsp;                                             FieldPool fieldPool,
&nbsp;                                             RecordComponentPool recordComponentPool,
&nbsp;                                             List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                             FieldList&lt;FieldDescription.InDefinedShape&gt; fields,
&nbsp;                                             MethodList&lt;?&gt; methods, MethodList&lt;?&gt; instrumentedMethods,
&nbsp;                                             RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents,
&nbsp;                                             LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                                             TypeInitializer typeInitializer,
&nbsp;                                             TypeAttributeAppender typeAttributeAppender,
&nbsp;                                             AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                             AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                             AnnotationRetention annotationRetention,
&nbsp;                                             AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                             Implementation.Context.Factory implementationContextFactory,
&nbsp;                                             TypeValidation typeValidation,
&nbsp;                                             ClassWriterStrategy classWriterStrategy,
&nbsp;                                             TypePool typePool,
&nbsp;                                             TypeDescription originalType,
&nbsp;                                             ClassFileLocator classFileLocator,
&nbsp;                                             MethodRegistry.Prepared methodRegistry,
&nbsp;                                             Implementation.Target.Factory implementationTargetFactory,
&nbsp;                                             MethodRebaseResolver methodRebaseResolver) {
<b class="fc">&nbsp;                    super(instrumentedType,</b>
&nbsp;                            classFileVersion,
&nbsp;                            fieldPool,
&nbsp;                            recordComponentPool,
&nbsp;                            auxiliaryTypes,
&nbsp;                            fields,
&nbsp;                            methods,
&nbsp;                            instrumentedMethods,
&nbsp;                            recordComponents,
&nbsp;                            loadedTypeInitializer,
&nbsp;                            typeInitializer,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            implementationContextFactory,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            typePool,
&nbsp;                            originalType,
&nbsp;                            classFileLocator);
<b class="fc">&nbsp;                    this.methodRegistry = methodRegistry;</b>
<b class="fc">&nbsp;                    this.implementationTargetFactory = implementationTargetFactory;</b>
<b class="fc">&nbsp;                    this.methodRebaseResolver = methodRebaseResolver;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                protected ClassVisitor writeTo(ClassVisitor classVisitor, TypeInitializer typeInitializer, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {
<b class="fc">&nbsp;                    classVisitor = new RedefinitionClassVisitor(classVisitor, typeInitializer, contextRegistry, writerFlags, readerFlags);</b>
<b class="fc">&nbsp;                    return originalType.getName().equals(instrumentedType.getName())</b>
<b class="nc">&nbsp;                            ? classVisitor</b>
<b class="fc">&nbsp;                            : new OpenedClassRemapper(classVisitor, new SimpleRemapper(originalType.getInternalName(), instrumentedType.getInternalName()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A {@link ClassRemapper} that uses the Byte Buddy-defined API version.
&nbsp;                 */
&nbsp;                protected static class OpenedClassRemapper extends ClassRemapper {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new opened class remapper.
&nbsp;                     *
&nbsp;                     * @param classVisitor The class visitor to wrap
&nbsp;                     * @param remapper     The remapper to apply.
&nbsp;                     */
&nbsp;                    protected OpenedClassRemapper(ClassVisitor classVisitor, Remapper remapper) {
<b class="fc">&nbsp;                        super(OpenedClassReader.ASM_API, classVisitor, remapper);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An initialization handler is responsible for handling the creation of the type initializer.
&nbsp;                 */
&nbsp;                protected interface InitializationHandler {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Invoked upon completion of writing the instrumented type.
&nbsp;                     *
&nbsp;                     * @param classVisitor          The class visitor to write any methods to.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     */
&nbsp;                    void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An initialization handler that creates a new type initializer.
&nbsp;                     */
&nbsp;                    class Creating extends TypeInitializer.Drain.Default implements InitializationHandler {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new creating initialization handler.
&nbsp;                         *
&nbsp;                         * @param instrumentedType             The instrumented type.
&nbsp;                         * @param methodPool                   The method pool to use.
&nbsp;                         * @param annotationValueFilterFactory The annotation value filter factory to use.
&nbsp;                         */
&nbsp;                        protected Creating(TypeDescription instrumentedType,
&nbsp;                                           MethodPool methodPool,
&nbsp;                                           AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                            super(instrumentedType, methodPool, annotationValueFilterFactory);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
<b class="fc">&nbsp;                            implementationContext.drain(this, classVisitor, annotationValueFilterFactory);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An initialization handler that appends code to a previously visited type initializer.
&nbsp;                     */
&nbsp;                    abstract class Appending extends MethodVisitor implements InitializationHandler, TypeInitializer.Drain {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The instrumented type.
&nbsp;                         */
&nbsp;                        protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method pool record for the type initializer.
&nbsp;                         */
&nbsp;                        protected final MethodPool.Record record;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The used annotation value filter factory.
&nbsp;                         */
&nbsp;                        protected final AnnotationValueFilter.Factory annotationValueFilterFactory;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The frame writer to use.
&nbsp;                         */
&nbsp;                        protected final FrameWriter frameWriter;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The currently recorded stack size.
&nbsp;                         */
&nbsp;                        protected int stackSize;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The currently recorded local variable length.
&nbsp;                         */
&nbsp;                        protected int localVariableLength;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new appending initialization handler.
&nbsp;                         *
&nbsp;                         * @param methodVisitor                The underlying method visitor.
&nbsp;                         * @param instrumentedType             The instrumented type.
&nbsp;                         * @param record                       The method pool record for the type initializer.
&nbsp;                         * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                         * @param requireFrames                {@code true} if the visitor is required to add frames.
&nbsp;                         * @param expandFrames                 {@code true} if the visitor is required to expand any added frame.
&nbsp;                         */
&nbsp;                        protected Appending(MethodVisitor methodVisitor,
&nbsp;                                            TypeDescription instrumentedType,
&nbsp;                                            MethodPool.Record record,
&nbsp;                                            AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                            boolean requireFrames,
&nbsp;                                            boolean expandFrames) {
<b class="nc">&nbsp;                            super(OpenedClassReader.ASM_API, methodVisitor);</b>
<b class="nc">&nbsp;                            this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                            this.record = record;</b>
<b class="nc">&nbsp;                            this.annotationValueFilterFactory = annotationValueFilterFactory;</b>
<b class="nc">&nbsp;                            if (!requireFrames) {</b>
<b class="nc">&nbsp;                                frameWriter = FrameWriter.NoOp.INSTANCE;</b>
<b class="nc">&nbsp;                            } else if (expandFrames) {</b>
<b class="nc">&nbsp;                                frameWriter = FrameWriter.Expanding.INSTANCE;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                frameWriter = new FrameWriter.Active();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves an initialization handler.
&nbsp;                         *
&nbsp;                         * @param enabled                      {@code true} if the implementation context is enabled, i.e. any {@link TypeInitializer} might be active.
&nbsp;                         * @param methodVisitor                The delegation method visitor.
&nbsp;                         * @param instrumentedType             The instrumented type.
&nbsp;                         * @param methodPool                   The method pool to use.
&nbsp;                         * @param annotationValueFilterFactory The annotation value filter factory to use.
&nbsp;                         * @param requireFrames                {@code true} if frames must be computed.
&nbsp;                         * @param expandFrames                 {@code true} if frames must be expanded.
&nbsp;                         * @return An initialization handler which is also guaranteed to be a {@link MethodVisitor}.
&nbsp;                         */
&nbsp;                        protected static InitializationHandler of(boolean enabled,
&nbsp;                                                                  MethodVisitor methodVisitor,
&nbsp;                                                                  TypeDescription instrumentedType,
&nbsp;                                                                  MethodPool methodPool,
&nbsp;                                                                  AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                                  boolean requireFrames,
&nbsp;                                                                  boolean expandFrames) {
<b class="nc">&nbsp;                            return enabled</b>
<b class="nc">&nbsp;                                    ? withDrain(methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, requireFrames, expandFrames)</b>
<b class="nc">&nbsp;                                    : withoutDrain(methodVisitor, instrumentedType, methodPool, annotationValueFilterFactory, requireFrames, expandFrames);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves an initialization handler with a drain.
&nbsp;                         *
&nbsp;                         * @param methodVisitor                The delegation method visitor.
&nbsp;                         * @param instrumentedType             The instrumented type.
&nbsp;                         * @param methodPool                   The method pool to use.
&nbsp;                         * @param annotationValueFilterFactory The annotation value filter factory to use.
&nbsp;                         * @param requireFrames                {@code true} if frames must be computed.
&nbsp;                         * @param expandFrames                 {@code true} if frames must be expanded.
&nbsp;                         * @return An initialization handler which is also guaranteed to be a {@link MethodVisitor}.
&nbsp;                         */
&nbsp;                        private static WithDrain withDrain(MethodVisitor methodVisitor,
&nbsp;                                                           TypeDescription instrumentedType,
&nbsp;                                                           MethodPool methodPool,
&nbsp;                                                           AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                           boolean requireFrames,
&nbsp;                                                           boolean expandFrames) {
<b class="nc">&nbsp;                            MethodPool.Record record = methodPool.target(new MethodDescription.Latent.TypeInitializer(instrumentedType));</b>
<b class="nc">&nbsp;                            return record.getSort().isImplemented()</b>
<b class="nc">&nbsp;                                    ? new WithDrain.WithActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames)</b>
<b class="nc">&nbsp;                                    : new WithDrain.WithoutActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves an initialization handler without a drain.
&nbsp;                         *
&nbsp;                         * @param methodVisitor                The delegation method visitor.
&nbsp;                         * @param instrumentedType             The instrumented type.
&nbsp;                         * @param methodPool                   The method pool to use.
&nbsp;                         * @param annotationValueFilterFactory The annotation value filter factory to use.
&nbsp;                         * @param requireFrames                {@code true} if frames must be computed.
&nbsp;                         * @param expandFrames                 {@code true} if frames must be expanded.
&nbsp;                         * @return An initialization handler which is also guaranteed to be a {@link MethodVisitor}.
&nbsp;                         */
&nbsp;                        private static WithoutDrain withoutDrain(MethodVisitor methodVisitor,
&nbsp;                                                                 TypeDescription instrumentedType,
&nbsp;                                                                 MethodPool methodPool,
&nbsp;                                                                 AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                                 boolean requireFrames,
&nbsp;                                                                 boolean expandFrames) {
<b class="nc">&nbsp;                            MethodPool.Record record = methodPool.target(new MethodDescription.Latent.TypeInitializer(instrumentedType));</b>
<b class="nc">&nbsp;                            return record.getSort().isImplemented()</b>
<b class="nc">&nbsp;                                    ? new WithoutDrain.WithActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames)</b>
<b class="nc">&nbsp;                                    : new WithoutDrain.WithoutActiveRecord(methodVisitor, instrumentedType, record, annotationValueFilterFactory);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitCode() {
<b class="nc">&nbsp;                            record.applyAttributes(mv, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                            super.visitCode();</b>
<b class="nc">&nbsp;                            onStart();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Invoked after the user code was visited.
&nbsp;                         */
&nbsp;                        protected abstract void onStart();
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
<b class="nc">&nbsp;                            super.visitFrame(type, localVariableLength, localVariable, stackSize, stack);</b>
<b class="nc">&nbsp;                            frameWriter.onFrame(type, localVariableLength);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitMaxs(int stackSize, int localVariableLength) {
<b class="nc">&nbsp;                            this.stackSize = stackSize;</b>
<b class="nc">&nbsp;                            this.localVariableLength = localVariableLength;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public abstract void visitEnd();
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void apply(ClassVisitor classVisitor, TypeInitializer typeInitializer, Implementation.Context implementationContext) {
<b class="nc">&nbsp;                            ByteCodeAppender.Size size = typeInitializer.apply(mv, implementationContext, new MethodDescription.Latent.TypeInitializer(instrumentedType));</b>
<b class="nc">&nbsp;                            stackSize = Math.max(stackSize, size.getOperandStackSize());</b>
<b class="nc">&nbsp;                            localVariableLength = Math.max(localVariableLength, size.getLocalVariableSize());</b>
<b class="nc">&nbsp;                            onComplete(implementationContext);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Invoked upon completion of writing the type initializer.
&nbsp;                         *
&nbsp;                         * @param implementationContext The implementation context to use.
&nbsp;                         */
&nbsp;                        protected abstract void onComplete(Implementation.Context implementationContext);
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void complete(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {
<b class="nc">&nbsp;                            implementationContext.drain(this, classVisitor, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                            mv.visitMaxs(stackSize, localVariableLength);</b>
<b class="nc">&nbsp;                            mv.visitEnd();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A frame writer is responsible for adding empty frames on jump instructions.
&nbsp;                         */
&nbsp;                        protected interface FrameWriter {
&nbsp;
&nbsp;                            /**
&nbsp;                             * An empty array.
&nbsp;                             */
<b class="nc">&nbsp;                            Object[] EMPTY = new Object[0];</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * Informs this frame writer of an observed frame.
&nbsp;                             *
&nbsp;                             * @param type                The frame type.
&nbsp;                             * @param localVariableLength The length of the local variables array.
&nbsp;                             */
&nbsp;                            void onFrame(int type, int localVariableLength);
&nbsp;
&nbsp;                            /**
&nbsp;                             * Emits an empty frame.
&nbsp;                             *
&nbsp;                             * @param methodVisitor The method visitor to write the frame to.
&nbsp;                             */
&nbsp;                            void emitFrame(MethodVisitor methodVisitor);
&nbsp;
&nbsp;                            /**
&nbsp;                             * A non-operational frame writer.
&nbsp;                             */
<b class="nc">&nbsp;                            enum NoOp implements FrameWriter {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="nc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public void onFrame(int type, int localVariableLength) {
&nbsp;                                    /* do nothing */
<b class="nc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public void emitFrame(MethodVisitor methodVisitor) {
&nbsp;                                    /* do nothing */
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A frame writer that creates an expanded frame.
&nbsp;                             */
<b class="nc">&nbsp;                            enum Expanding implements FrameWriter {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="nc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public void onFrame(int type, int localVariableLength) {
&nbsp;                                    /* do nothing */
<b class="nc">&nbsp;                                }</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public void emitFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                                    methodVisitor.visitFrame(Opcodes.F_NEW, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
<b class="nc">&nbsp;                                    methodVisitor.visitInsn(Opcodes.NOP);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An active frame writer that creates the most efficient frame.
&nbsp;                             */
<b class="nc">&nbsp;                            class Active implements FrameWriter {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The current length of the current local variable array.
&nbsp;                                 */
&nbsp;                                private int currentLocalVariableLength;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public void onFrame(int type, int localVariableLength) {
<b class="nc">&nbsp;                                    switch (type) {</b>
&nbsp;                                        case Opcodes.F_SAME:
&nbsp;                                        case Opcodes.F_SAME1:
<b class="nc">&nbsp;                                            break;</b>
&nbsp;                                        case Opcodes.F_APPEND:
<b class="nc">&nbsp;                                            currentLocalVariableLength += localVariableLength;</b>
<b class="nc">&nbsp;                                            break;</b>
&nbsp;                                        case Opcodes.F_CHOP:
<b class="nc">&nbsp;                                            currentLocalVariableLength -= localVariableLength;</b>
<b class="nc">&nbsp;                                            break;</b>
&nbsp;                                        case Opcodes.F_NEW:
&nbsp;                                        case Opcodes.F_FULL:
<b class="nc">&nbsp;                                            currentLocalVariableLength = localVariableLength;</b>
<b class="nc">&nbsp;                                            break;</b>
&nbsp;                                        default:
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Unexpected frame type: &quot; + type);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public void emitFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                                    if (currentLocalVariableLength == 0) {</b>
<b class="nc">&nbsp;                                        methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
<b class="nc">&nbsp;                                    } else if (currentLocalVariableLength &gt; 3) {</b>
<b class="nc">&nbsp;                                        methodVisitor.visitFrame(Opcodes.F_FULL, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentLocalVariableLength, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    methodVisitor.visitInsn(Opcodes.NOP);</b>
<b class="nc">&nbsp;                                    currentLocalVariableLength = 0;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An initialization handler that appends code to a previously visited type initializer without allowing active
&nbsp;                         * {@link TypeInitializer} registrations.
&nbsp;                         */
&nbsp;                        protected abstract static class WithoutDrain extends Appending {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new appending initialization handler without a drain.
&nbsp;                             *
&nbsp;                             * @param methodVisitor                The underlying method visitor.
&nbsp;                             * @param instrumentedType             The instrumented type.
&nbsp;                             * @param record                       The method pool record for the type initializer.
&nbsp;                             * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                             * @param requireFrames                {@code true} if the visitor is required to add frames.
&nbsp;                             * @param expandFrames                 {@code true} if the visitor is required to expand any added frame.
&nbsp;                             */
&nbsp;                            protected WithoutDrain(MethodVisitor methodVisitor,
&nbsp;                                                   TypeDescription instrumentedType,
&nbsp;                                                   MethodPool.Record record,
&nbsp;                                                   AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                   boolean requireFrames,
&nbsp;                                                   boolean expandFrames) {
<b class="nc">&nbsp;                                super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected void onStart() {
&nbsp;                                /* do nothing */
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void visitEnd() {
&nbsp;                                /* do nothing */
<b class="nc">&nbsp;                            }</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * An initialization handler that appends code to a previously visited type initializer without allowing active
&nbsp;                             * {@link TypeInitializer} registrations and without an active record.
&nbsp;                             */
&nbsp;                            protected static class WithoutActiveRecord extends WithoutDrain {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new appending initialization handler without a drain and without an active record.
&nbsp;                                 *
&nbsp;                                 * @param methodVisitor                The underlying method visitor.
&nbsp;                                 * @param instrumentedType             The instrumented type.
&nbsp;                                 * @param record                       The method pool record for the type initializer.
&nbsp;                                 * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                                 */
&nbsp;                                protected WithoutActiveRecord(MethodVisitor methodVisitor,
&nbsp;                                                              TypeDescription instrumentedType,
&nbsp;                                                              MethodPool.Record record,
&nbsp;                                                              AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="nc">&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, false, false);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected void onComplete(Implementation.Context implementationContext) {
&nbsp;                                    /* do nothing */
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An initialization handler that appends code to a previously visited type initializer without allowing active
&nbsp;                             * {@link TypeInitializer} registrations and with an active record.
&nbsp;                             */
&nbsp;                            protected static class WithActiveRecord extends WithoutDrain {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The label that indicates the beginning of the active record.
&nbsp;                                 */
&nbsp;                                private final Label label;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new appending initialization handler without a drain and with an active record.
&nbsp;                                 *
&nbsp;                                 * @param methodVisitor                The underlying method visitor.
&nbsp;                                 * @param instrumentedType             The instrumented type.
&nbsp;                                 * @param record                       The method pool record for the type initializer.
&nbsp;                                 * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                                 * @param requireFrames                {@code true} if the visitor is required to add frames.
&nbsp;                                 * @param expandFrames                 {@code true} if the visitor is required to expand any added frame.
&nbsp;                                 */
&nbsp;                                protected WithActiveRecord(MethodVisitor methodVisitor,
&nbsp;                                                           TypeDescription instrumentedType,
&nbsp;                                                           MethodPool.Record record,
&nbsp;                                                           AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                           boolean requireFrames,
&nbsp;                                                           boolean expandFrames) {
<b class="nc">&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);</b>
<b class="nc">&nbsp;                                    label = new Label();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public void visitInsn(int opcode) {
<b class="nc">&nbsp;                                    if (opcode == Opcodes.RETURN) {</b>
<b class="nc">&nbsp;                                        mv.visitJumpInsn(Opcodes.GOTO, label);</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        super.visitInsn(opcode);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected void onComplete(Implementation.Context implementationContext) {
<b class="nc">&nbsp;                                    mv.visitLabel(label);</b>
<b class="nc">&nbsp;                                    frameWriter.emitFrame(mv);</b>
<b class="nc">&nbsp;                                    ByteCodeAppender.Size size = record.applyCode(mv, implementationContext);</b>
<b class="nc">&nbsp;                                    stackSize = Math.max(stackSize, size.getOperandStackSize());</b>
<b class="nc">&nbsp;                                    localVariableLength = Math.max(localVariableLength, size.getLocalVariableSize());</b>
&nbsp;                                }
&nbsp;
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An initialization handler that appends code to a previously visited type initializer with allowing active
&nbsp;                         * {@link TypeInitializer} registrations.
&nbsp;                         */
&nbsp;                        protected abstract static class WithDrain extends Appending {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A label marking the beginning of the appended code.
&nbsp;                             */
&nbsp;                            protected final Label appended;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A label marking the beginning og the original type initializer&#39;s code.
&nbsp;                             */
&nbsp;                            protected final Label original;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new appending initialization handler with a drain.
&nbsp;                             *
&nbsp;                             * @param methodVisitor                The underlying method visitor.
&nbsp;                             * @param instrumentedType             The instrumented type.
&nbsp;                             * @param record                       The method pool record for the type initializer.
&nbsp;                             * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                             * @param requireFrames                {@code true} if the visitor is required to add frames.
&nbsp;                             * @param expandFrames                 {@code true} if the visitor is required to expand any added frame.
&nbsp;                             */
&nbsp;                            protected WithDrain(MethodVisitor methodVisitor,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodPool.Record record,
&nbsp;                                                AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                boolean requireFrames,
&nbsp;                                                boolean expandFrames) {
<b class="nc">&nbsp;                                super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);</b>
<b class="nc">&nbsp;                                appended = new Label();</b>
<b class="nc">&nbsp;                                original = new Label();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected void onStart() {
<b class="nc">&nbsp;                                mv.visitJumpInsn(Opcodes.GOTO, appended);</b>
<b class="nc">&nbsp;                                mv.visitLabel(original);</b>
<b class="nc">&nbsp;                                frameWriter.emitFrame(mv);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public void visitEnd() {
<b class="nc">&nbsp;                                mv.visitLabel(appended);</b>
<b class="nc">&nbsp;                                frameWriter.emitFrame(mv);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected void onComplete(Implementation.Context implementationContext) {
<b class="nc">&nbsp;                                mv.visitJumpInsn(Opcodes.GOTO, original);</b>
<b class="nc">&nbsp;                                onAfterComplete(implementationContext);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Invoked after completion of writing the type initializer.
&nbsp;                             *
&nbsp;                             * @param implementationContext The implementation context to use.
&nbsp;                             */
&nbsp;                            protected abstract void onAfterComplete(Implementation.Context implementationContext);
&nbsp;
&nbsp;                            /**
&nbsp;                             * A code appending initialization handler with a drain that does not apply an explicit record.
&nbsp;                             */
&nbsp;                            protected static class WithoutActiveRecord extends WithDrain {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new appending initialization handler with a drain and without an active record.
&nbsp;                                 *
&nbsp;                                 * @param methodVisitor                The underlying method visitor.
&nbsp;                                 * @param instrumentedType             The instrumented type.
&nbsp;                                 * @param record                       The method pool record for the type initializer.
&nbsp;                                 * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                                 * @param requireFrames                {@code true} if the visitor is required to add frames.
&nbsp;                                 * @param expandFrames                 {@code true} if the visitor is required to expand any added frame.
&nbsp;                                 */
&nbsp;                                protected WithoutActiveRecord(MethodVisitor methodVisitor,
&nbsp;                                                              TypeDescription instrumentedType,
&nbsp;                                                              MethodPool.Record record,
&nbsp;                                                              AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                              boolean requireFrames,
&nbsp;                                                              boolean expandFrames) {
<b class="nc">&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected void onAfterComplete(Implementation.Context implementationContext) {
&nbsp;                                    /* do nothing */
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A code appending initialization handler with a drain that applies an explicit record.
&nbsp;                             */
&nbsp;                            protected static class WithActiveRecord extends WithDrain {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A label indicating the beginning of the record&#39;s code.
&nbsp;                                 */
&nbsp;                                private final Label label;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new appending initialization handler with a drain and with an active record.
&nbsp;                                 *
&nbsp;                                 * @param methodVisitor                The underlying method visitor.
&nbsp;                                 * @param instrumentedType             The instrumented type.
&nbsp;                                 * @param record                       The method pool record for the type initializer.
&nbsp;                                 * @param annotationValueFilterFactory The used annotation value filter factory.
&nbsp;                                 * @param requireFrames                {@code true} if the visitor is required to add frames.
&nbsp;                                 * @param expandFrames                 {@code true} if the visitor is required to expand any added frame.
&nbsp;                                 */
&nbsp;                                protected WithActiveRecord(MethodVisitor methodVisitor,
&nbsp;                                                           TypeDescription instrumentedType,
&nbsp;                                                           MethodPool.Record record,
&nbsp;                                                           AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                                           boolean requireFrames,
&nbsp;                                                           boolean expandFrames) {
<b class="nc">&nbsp;                                    super(methodVisitor, instrumentedType, record, annotationValueFilterFactory, requireFrames, expandFrames);</b>
<b class="nc">&nbsp;                                    label = new Label();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                public void visitInsn(int opcode) {
<b class="nc">&nbsp;                                    if (opcode == Opcodes.RETURN) {</b>
<b class="nc">&nbsp;                                        mv.visitJumpInsn(Opcodes.GOTO, label);</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        super.visitInsn(opcode);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected void onAfterComplete(Implementation.Context implementationContext) {
<b class="nc">&nbsp;                                    mv.visitLabel(label);</b>
<b class="nc">&nbsp;                                    frameWriter.emitFrame(mv);</b>
<b class="nc">&nbsp;                                    ByteCodeAppender.Size size = record.applyCode(mv, implementationContext);</b>
<b class="nc">&nbsp;                                    stackSize = Math.max(stackSize, size.getOperandStackSize());</b>
<b class="nc">&nbsp;                                    localVariableLength = Math.max(localVariableLength, size.getLocalVariableSize());</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A class visitor which is capable of applying a redefinition of an existing class file.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR&quot;, justification = &quot;Field access order is implied by ASM.&quot;)
<b class="nc">&nbsp;                protected class RedefinitionClassVisitor extends MetadataAwareClassVisitor {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type initializer to apply.
&nbsp;                     */
&nbsp;                    private final TypeInitializer typeInitializer;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A context registry to register the lazily created implementation context to.
&nbsp;                     */
&nbsp;                    private final ContextRegistry contextRegistry;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The writer flags being used.
&nbsp;                     */
&nbsp;                    private final int writerFlags;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The reader flags being used.
&nbsp;                     */
&nbsp;                    private final int readerFlags;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of fields to write by their unique signature.
&nbsp;                     */
&nbsp;                    private final LinkedHashMap&lt;SignatureKey, FieldDescription&gt; declarableFields;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of methods to write by their unique signature.
&nbsp;                     */
&nbsp;                    private final LinkedHashMap&lt;SignatureKey, MethodDescription&gt; declarableMethods;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of record components to write by their names.
&nbsp;                     */
&nbsp;                    private final LinkedHashMap&lt;String, RecordComponentDescription&gt; declarableRecordComponents;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A set of internal names of all nest members not yet defined by this type. If this type is not a nest host, this set is empty.
&nbsp;                     */
&nbsp;                    private final Set&lt;String&gt; nestMembers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the internal names of all declared types to their description.
&nbsp;                     */
&nbsp;                    private final LinkedHashMap&lt;String, TypeDescription&gt; declaredTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of internal names of permitted subclasses to include.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    private final Set&lt;String&gt; permittedSubclasses;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method pool to use or {@code null} if the pool was not yet initialized.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private MethodPool methodPool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The initialization handler to use or {@code null} if the handler was not yet initialized.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private InitializationHandler initializationHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implementation context for this class creation or {@code null} if it was not yet created.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private Implementation.Context.ExtractableView implementationContext;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the modifiers for deprecation should be retained.
&nbsp;                     */
&nbsp;                    private boolean retainDeprecationModifiers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a class visitor which is capable of redefining an existent class on the fly.
&nbsp;                     *
&nbsp;                     * @param classVisitor    The underlying class visitor to which writes are delegated.
&nbsp;                     * @param typeInitializer The type initializer to apply.
&nbsp;                     * @param contextRegistry A context registry to register the lazily created implementation context to.
&nbsp;                     * @param writerFlags     The writer flags being used.
&nbsp;                     * @param readerFlags     The reader flags being used.
&nbsp;                     */
&nbsp;                    protected RedefinitionClassVisitor(ClassVisitor classVisitor,
&nbsp;                                                       TypeInitializer typeInitializer,
&nbsp;                                                       ContextRegistry contextRegistry,
&nbsp;                                                       int writerFlags,
<b class="fc">&nbsp;                                                       int readerFlags) {</b>
<b class="fc">&nbsp;                        super(OpenedClassReader.ASM_API, classVisitor);</b>
<b class="fc">&nbsp;                        this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;                        this.contextRegistry = contextRegistry;</b>
<b class="fc">&nbsp;                        this.writerFlags = writerFlags;</b>
<b class="fc">&nbsp;                        this.readerFlags = readerFlags;</b>
<b class="fc">&nbsp;                        declarableFields = new LinkedHashMap&lt;SignatureKey, FieldDescription&gt;((int) Math.ceil(fields.size() / 0.75));</b>
<b class="fc">&nbsp;                        for (FieldDescription fieldDescription : fields) {</b>
<b class="nc">&nbsp;                            declarableFields.put(new SignatureKey(fieldDescription.getInternalName(), fieldDescription.getDescriptor()), fieldDescription);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        declarableMethods = new LinkedHashMap&lt;SignatureKey, MethodDescription&gt;((int) Math.ceil(instrumentedMethods.size() / 0.75));</b>
<b class="fc">&nbsp;                        for (MethodDescription methodDescription : instrumentedMethods) {</b>
<b class="nc">&nbsp;                            declarableMethods.put(new SignatureKey(methodDescription.getInternalName(), methodDescription.getDescriptor()), methodDescription);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        declarableRecordComponents = new LinkedHashMap&lt;String, RecordComponentDescription&gt;((int) Math.ceil(recordComponents.size() / 0.75));</b>
<b class="fc">&nbsp;                        for (RecordComponentDescription recordComponentDescription : recordComponents) {</b>
<b class="nc">&nbsp;                            declarableRecordComponents.put(recordComponentDescription.getActualName(), recordComponentDescription);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        if (instrumentedType.isNestHost()) {</b>
<b class="fc">&nbsp;                            nestMembers = new LinkedHashSet&lt;String&gt;((int) Math.ceil(instrumentedType.getNestMembers().size() / 0.75));</b>
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : instrumentedType.getNestMembers().filter(not(is(instrumentedType)))) {</b>
<b class="nc">&nbsp;                                nestMembers.add(typeDescription.getInternalName());</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            nestMembers = Collections.emptySet();</b>
&nbsp;                        }
<b class="fc">&nbsp;                        declaredTypes = new LinkedHashMap&lt;String, TypeDescription&gt;((int) Math.ceil(instrumentedType.getDeclaredTypes().size() / 0.75));</b>
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : instrumentedType.getDeclaredTypes()) {</b>
<b class="fc">&nbsp;                            declaredTypes.put(typeDescription.getInternalName(), typeDescription);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        if (instrumentedType.isSealed()) {</b>
<b class="nc">&nbsp;                            permittedSubclasses = new LinkedHashSet&lt;String&gt;((int) Math.ceil(instrumentedType.getPermittedSubtypes().size() / 0.75));</b>
<b class="nc">&nbsp;                            for (TypeDescription typeDescription : instrumentedType.getPermittedSubtypes()) {</b>
<b class="nc">&nbsp;                                permittedSubclasses.add(typeDescription.getInternalName());</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            permittedSubclasses = null;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Relying on correlated type properties.&quot;)
&nbsp;                    public void visit(int classFileVersionNumber,
&nbsp;                                      int modifiers,
&nbsp;                                      String internalName,
&nbsp;                                      String genericSignature,
&nbsp;                                      String superClassInternalName,
&nbsp;                                      String[] interfaceTypeInternalName) {
<b class="fc">&nbsp;                        ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersionNumber);</b>
<b class="fc">&nbsp;                        methodPool = methodRegistry.compile(implementationTargetFactory, classFileVersion);</b>
<b class="fc">&nbsp;                        initializationHandler = new InitializationHandler.Creating(instrumentedType, methodPool, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                        implementationContext = implementationContextFactory.make(instrumentedType,</b>
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                typeInitializer,
&nbsp;                                classFileVersion,
&nbsp;                                WithFullProcessing.this.classFileVersion,
<b class="fc">&nbsp;                                (writerFlags &amp; ClassWriter.COMPUTE_FRAMES) == 0 &amp;&amp; classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="fc">&nbsp;                                        ? ((readerFlags &amp; ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND)</b>
<b class="nc">&nbsp;                                        : Implementation.Context.FrameGeneration.DISABLED);</b>
<b class="fc">&nbsp;                        retainDeprecationModifiers = classFileVersion.isLessThan(ClassFileVersion.JAVA_V5);</b>
<b class="fc">&nbsp;                        contextRegistry.setImplementationContext(implementationContext);</b>
<b class="fc">&nbsp;                        cv = asmVisitorWrapper.wrap(instrumentedType,</b>
&nbsp;                                cv,
&nbsp;                                implementationContext,
&nbsp;                                typePool,
&nbsp;                                fields,
&nbsp;                                methods,
&nbsp;                                writerFlags,
&nbsp;                                readerFlags);
<b class="fc">&nbsp;                        cv.visit(classFileVersionNumber,</b>
<b class="fc">&nbsp;                                instrumentedType.getActualModifiers((modifiers &amp; Opcodes.ACC_SUPER) != 0 &amp;&amp; !instrumentedType.isInterface())</b>
<b class="fc">&nbsp;                                        | resolveDeprecationModifiers(modifiers)</b>
&nbsp;                                        // Anonymous types might not preserve their class file&#39;s final modifier via their inner class modifier.
<b class="fc">&nbsp;                                        | (((modifiers &amp; Opcodes.ACC_FINAL) != 0 &amp;&amp; instrumentedType.isAnonymousType()) ? Opcodes.ACC_FINAL : 0),</b>
<b class="fc">&nbsp;                                instrumentedType.getInternalName(),</b>
<b class="fc">&nbsp;                                TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                                        ? genericSignature</b>
<b class="fc">&nbsp;                                        : instrumentedType.getGenericSignature(),</b>
<b class="fc">&nbsp;                                instrumentedType.getSuperClass() == null</b>
<b class="nc">&nbsp;                                        ? (instrumentedType.isInterface() ? TypeDescription.ForLoadedType.of(Object.class).getInternalName() : NO_REFERENCE)</b>
<b class="fc">&nbsp;                                        : instrumentedType.getSuperClass().asErasure().getInternalName(),</b>
<b class="fc">&nbsp;                                instrumentedType.getInterfaces().asErasures().toInternalNames());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitNestHost(String nestHost) {
<b class="nc">&nbsp;                        onNestHost();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onNestHost() {
<b class="fc">&nbsp;                        if (!instrumentedType.isNestHost()) {</b>
<b class="nc">&nbsp;                            cv.visitNestHost(instrumentedType.getNestHost().getInternalName());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitPermittedSubclass(String permittedSubclass) {
<b class="nc">&nbsp;                        if (permittedSubclasses != null &amp;&amp; permittedSubclasses.remove(permittedSubclass)) {</b>
<b class="nc">&nbsp;                            cv.visitPermittedSubclass(permittedSubclass);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitOuterClass(String owner, @MaybeNull String name, @MaybeNull String descriptor) {
&nbsp;                        try { // The Groovy compiler often gets this attribute wrong such that this safety just retains it.
<b class="nc">&nbsp;                            onOuterType();</b>
<b class="nc">&nbsp;                        } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;                            cv.visitOuterClass(owner, name, descriptor);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH&quot;, justification = &quot;Relying on correlated type properties.&quot;)
&nbsp;                    protected void onOuterType() {
<b class="fc">&nbsp;                        MethodDescription.InDefinedShape enclosingMethod = instrumentedType.getEnclosingMethod();</b>
<b class="fc">&nbsp;                        if (enclosingMethod != null) {</b>
<b class="nc">&nbsp;                            cv.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(),</b>
<b class="nc">&nbsp;                                    enclosingMethod.getInternalName(),</b>
<b class="nc">&nbsp;                                    enclosingMethod.getDescriptor());</b>
<b class="fc">&nbsp;                        } else if (instrumentedType.isLocalType() || instrumentedType.isAnonymousType()) {</b>
<b class="nc">&nbsp;                            cv.visitOuterClass(instrumentedType.getEnclosingType().getInternalName(), NO_REFERENCE, NO_REFERENCE);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onAfterAttributes() {
<b class="fc">&nbsp;                        typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected AnnotationVisitor onVisitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                        return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                ? cv.visitTypeAnnotation(typeReference, typePath, descriptor, visible)</b>
<b class="nc">&nbsp;                                : IGNORE_ANNOTATION;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected AnnotationVisitor onVisitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                        return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                ? cv.visitAnnotation(descriptor, visible)</b>
<b class="nc">&nbsp;                                : IGNORE_ANNOTATION;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected RecordComponentVisitor onVisitRecordComponent(String name, String descriptor, @MaybeNull String genericSignature) {
<b class="nc">&nbsp;                        RecordComponentDescription recordComponentDescription = declarableRecordComponents.remove(name);</b>
<b class="nc">&nbsp;                        if (recordComponentDescription != null) {</b>
<b class="nc">&nbsp;                            RecordComponentPool.Record record = recordComponentPool.target(recordComponentDescription);</b>
<b class="nc">&nbsp;                            if (!record.isImplicit()) {</b>
<b class="nc">&nbsp;                                return redefine(record, genericSignature);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        return cv.visitRecordComponent(name, descriptor, genericSignature);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Redefines a record component using the given explicit record component pool record.
&nbsp;                     *
&nbsp;                     * @param record           The record component pool record to apply during visitation of the existing record.
&nbsp;                     * @param genericSignature The record component&#39;s original generic signature which can be {@code null}.
&nbsp;                     * @return A record component visitor for visiting the existing record component definition.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    protected RecordComponentVisitor redefine(RecordComponentPool.Record record, @MaybeNull String genericSignature) {
<b class="nc">&nbsp;                        RecordComponentDescription recordComponentDescription = record.getRecordComponent();</b>
<b class="nc">&nbsp;                        RecordComponentVisitor recordComponentVisitor = cv.visitRecordComponent(recordComponentDescription.getActualName(),</b>
<b class="nc">&nbsp;                                recordComponentDescription.getDescriptor(),</b>
<b class="nc">&nbsp;                                TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                                        ? genericSignature</b>
<b class="nc">&nbsp;                                        : recordComponentDescription.getGenericSignature());</b>
<b class="nc">&nbsp;                        return recordComponentVisitor == null</b>
<b class="nc">&nbsp;                                ? IGNORE_RECORD_COMPONENT</b>
<b class="nc">&nbsp;                                : new AttributeObtainingRecordComponentVisitor(recordComponentVisitor, record);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected FieldVisitor onVisitField(int modifiers,
&nbsp;                                                        String internalName,
&nbsp;                                                        String descriptor,
&nbsp;                                                        @MaybeNull String genericSignature,
&nbsp;                                                        @MaybeNull Object value) {
<b class="fc">&nbsp;                        FieldDescription fieldDescription = declarableFields.remove(new SignatureKey(internalName, descriptor));</b>
<b class="fc">&nbsp;                        if (fieldDescription != null) {</b>
<b class="nc">&nbsp;                            FieldPool.Record record = fieldPool.target(fieldDescription);</b>
<b class="nc">&nbsp;                            if (!record.isImplicit()) {</b>
<b class="nc">&nbsp;                                return redefine(record, value, modifiers, genericSignature);</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        return cv.visitField(modifiers, internalName, descriptor, genericSignature, value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Redefines a field using the given explicit field pool record and default value.
&nbsp;                     *
&nbsp;                     * @param record           The field pool value to apply during visitation of the existing field.
&nbsp;                     * @param value            The default value to write onto the field which might be {@code null}.
&nbsp;                     * @param modifiers        The original modifiers of the transformed field.
&nbsp;                     * @param genericSignature The field&#39;s original generic signature which can be {@code null}.
&nbsp;                     * @return A field visitor for visiting the existing field definition.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    protected FieldVisitor redefine(FieldPool.Record record, @MaybeNull Object value, int modifiers, @MaybeNull String genericSignature) {
<b class="nc">&nbsp;                        FieldDescription instrumentedField = record.getField();</b>
<b class="nc">&nbsp;                        FieldVisitor fieldVisitor = cv.visitField(instrumentedField.getActualModifiers() | resolveDeprecationModifiers(modifiers),</b>
<b class="nc">&nbsp;                                instrumentedField.getInternalName(),</b>
<b class="nc">&nbsp;                                instrumentedField.getDescriptor(),</b>
<b class="nc">&nbsp;                                TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                                        ? genericSignature</b>
<b class="nc">&nbsp;                                        : instrumentedField.getGenericSignature(),</b>
<b class="nc">&nbsp;                                record.resolveDefault(value));</b>
<b class="nc">&nbsp;                        return fieldVisitor == null</b>
<b class="nc">&nbsp;                                ? IGNORE_FIELD</b>
<b class="nc">&nbsp;                                : new AttributeObtainingFieldVisitor(fieldVisitor, record);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected MethodVisitor onVisitMethod(int modifiers,
&nbsp;                                                          String internalName,
&nbsp;                                                          String descriptor,
&nbsp;                                                          @MaybeNull String genericSignature,
&nbsp;                                                          @MaybeNull String[] exceptionName) {
<b class="fc">&nbsp;                        if (internalName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {</b>
<b class="fc">&nbsp;                            MethodVisitor methodVisitor = cv.visitMethod(modifiers, internalName, descriptor, genericSignature, exceptionName);</b>
<b class="fc">&nbsp;                            return methodVisitor == null</b>
<b class="fc">&nbsp;                                    ? IGNORE_METHOD</b>
<b class="nc">&nbsp;                                    : (MethodVisitor) (initializationHandler = InitializationHandler.Appending.of(implementationContext.isEnabled(),</b>
&nbsp;                                    methodVisitor,
&nbsp;                                    instrumentedType,
&nbsp;                                    methodPool,
&nbsp;                                    annotationValueFilterFactory,
<b class="nc">&nbsp;                                    (writerFlags &amp; ClassWriter.COMPUTE_FRAMES) == 0 &amp;&amp; implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V6),</b>
&nbsp;                                    (readerFlags &amp; ClassReader.EXPAND_FRAMES) != 0));
&nbsp;                        } else {
<b class="fc">&nbsp;                            MethodDescription methodDescription = declarableMethods.remove(new SignatureKey(internalName, descriptor));</b>
<b class="fc">&nbsp;                            return methodDescription == null</b>
<b class="fc">&nbsp;                                    ? cv.visitMethod(modifiers, internalName, descriptor, genericSignature, exceptionName)</b>
<b class="nc">&nbsp;                                    : redefine(methodDescription, (modifiers &amp; Opcodes.ACC_ABSTRACT) != 0, modifiers, genericSignature);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Redefines a given method if this is required by looking up a potential implementation from the
&nbsp;                     * {@link net.bytebuddy.dynamic.scaffold.TypeWriter.MethodPool}.
&nbsp;                     *
&nbsp;                     * @param methodDescription The method being considered for redefinition.
&nbsp;                     * @param abstractOrigin    {@code true} if the original method is abstract, i.e. there is no implementation to preserve.
&nbsp;                     * @param modifiers         The original modifiers of the transformed method.
&nbsp;                     * @param genericSignature  The method&#39;s original generic signature which can be {@code null}.
&nbsp;                     * @return A method visitor which is capable of consuming the original method.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    protected MethodVisitor redefine(MethodDescription methodDescription, boolean abstractOrigin, int modifiers, @MaybeNull String genericSignature) {
<b class="nc">&nbsp;                        MethodPool.Record record = methodPool.target(methodDescription);</b>
<b class="nc">&nbsp;                        if (!record.getSort().isDefined()) {</b>
<b class="nc">&nbsp;                            return cv.visitMethod(methodDescription.getActualModifiers() | resolveDeprecationModifiers(modifiers),</b>
<b class="nc">&nbsp;                                    methodDescription.getInternalName(),</b>
<b class="nc">&nbsp;                                    methodDescription.getDescriptor(),</b>
<b class="nc">&nbsp;                                    TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                                            ? genericSignature</b>
<b class="nc">&nbsp;                                            : methodDescription.getGenericSignature(),</b>
<b class="nc">&nbsp;                                    methodDescription.getExceptionTypes().asErasures().toInternalNames());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        MethodDescription implementedMethod = record.getMethod();</b>
<b class="nc">&nbsp;                        MethodVisitor methodVisitor = cv.visitMethod(ModifierContributor.Resolver</b>
<b class="nc">&nbsp;                                        .of(Collections.singleton(record.getVisibility()))</b>
<b class="nc">&nbsp;                                        .resolve(implementedMethod.getActualModifiers(record.getSort().isImplemented())) | resolveDeprecationModifiers(modifiers),</b>
<b class="nc">&nbsp;                                implementedMethod.getInternalName(),</b>
<b class="nc">&nbsp;                                implementedMethod.getDescriptor(),</b>
<b class="nc">&nbsp;                                TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                                        ? genericSignature</b>
<b class="nc">&nbsp;                                        : implementedMethod.getGenericSignature(),</b>
<b class="nc">&nbsp;                                implementedMethod.getExceptionTypes().asErasures().toInternalNames());</b>
<b class="nc">&nbsp;                        if (methodVisitor == null) {</b>
<b class="nc">&nbsp;                            return IGNORE_METHOD;</b>
<b class="nc">&nbsp;                        } else if (abstractOrigin) {</b>
<b class="nc">&nbsp;                            return new AttributeObtainingMethodVisitor(methodVisitor, record);</b>
<b class="nc">&nbsp;                        } else if (methodDescription.isNative()) {</b>
<b class="nc">&nbsp;                            MethodRebaseResolver.Resolution resolution = methodRebaseResolver.resolve(implementedMethod.asDefined());</b>
<b class="nc">&nbsp;                            if (resolution.isRebased()) {</b>
<b class="nc">&nbsp;                                MethodVisitor rebasedMethodVisitor = super.visitMethod(resolution.getResolvedMethod().getActualModifiers()</b>
<b class="nc">&nbsp;                                                | resolveDeprecationModifiers(modifiers),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getInternalName(),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getDescriptor(),</b>
<b class="nc">&nbsp;                                        TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                                                ? genericSignature</b>
<b class="nc">&nbsp;                                                : implementedMethod.getGenericSignature(),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getExceptionTypes().asErasures().toInternalNames());</b>
<b class="nc">&nbsp;                                if (rebasedMethodVisitor != null) {</b>
<b class="nc">&nbsp;                                    rebasedMethodVisitor.visitEnd();</b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            return new AttributeObtainingMethodVisitor(methodVisitor, record);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return new CodePreservingMethodVisitor(methodVisitor, record, methodRebaseResolver.resolve(implementedMethod.asDefined()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
<b class="fc">&nbsp;                        if (!internalName.equals(instrumentedType.getInternalName())) {</b>
<b class="fc">&nbsp;                            TypeDescription declaredType = declaredTypes.remove(internalName);</b>
<b class="fc">&nbsp;                            if (declaredType == null) {</b>
<b class="fc">&nbsp;                                cv.visitInnerClass(internalName, outerName, innerName, modifiers);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                cv.visitInnerClass(internalName,</b>
&nbsp;                                        // The second condition is added to retain the structure of some Java 6 compiled classes
<b class="fc">&nbsp;                                        declaredType.isMemberType() || outerName != null &amp;&amp; innerName == null &amp;&amp; declaredType.isAnonymousType()</b>
<b class="fc">&nbsp;                                                ? instrumentedType.getInternalName()</b>
<b class="nc">&nbsp;                                                : NO_REFERENCE,</b>
<b class="fc">&nbsp;                                        declaredType.isAnonymousType()</b>
<b class="nc">&nbsp;                                                ? NO_REFERENCE</b>
<b class="fc">&nbsp;                                                : declaredType.getSimpleName(),</b>
<b class="fc">&nbsp;                                        declaredType.getModifiers());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitNestMember(String nestMember) {
<b class="fc">&nbsp;                        if (instrumentedType.isNestHost() &amp;&amp; nestMembers.remove(nestMember)) {</b>
<b class="nc">&nbsp;                            cv.visitNestMember(nestMember);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitEnd() {
<b class="fc">&nbsp;                        for (String nestMember : nestMembers) {</b>
<b class="nc">&nbsp;                            cv.visitNestMember(nestMember);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        if (permittedSubclasses != null) {</b>
<b class="nc">&nbsp;                            for (String permittedSubclass : permittedSubclasses) {</b>
<b class="nc">&nbsp;                                cv.visitPermittedSubclass(permittedSubclass);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="fc">&nbsp;                        TypeDescription declaringType = instrumentedType.getDeclaringType();</b>
<b class="fc">&nbsp;                        if (declaringType != null) {</b>
<b class="nc">&nbsp;                            cv.visitInnerClass(instrumentedType.getInternalName(),</b>
<b class="nc">&nbsp;                                    declaringType.getInternalName(),</b>
<b class="nc">&nbsp;                                    instrumentedType.getSimpleName(),</b>
<b class="nc">&nbsp;                                    instrumentedType.getModifiers());</b>
<b class="fc">&nbsp;                        } else if (instrumentedType.isLocalType()) {</b>
<b class="nc">&nbsp;                            cv.visitInnerClass(instrumentedType.getInternalName(),</b>
<b class="nc">&nbsp;                                    NO_REFERENCE,</b>
<b class="nc">&nbsp;                                    instrumentedType.getSimpleName(),</b>
<b class="nc">&nbsp;                                    instrumentedType.getModifiers());</b>
<b class="fc">&nbsp;                        } else if (instrumentedType.isAnonymousType()) {</b>
<b class="nc">&nbsp;                            cv.visitInnerClass(instrumentedType.getInternalName(),</b>
<b class="nc">&nbsp;                                    NO_REFERENCE,</b>
<b class="nc">&nbsp;                                    NO_REFERENCE,</b>
<b class="nc">&nbsp;                                    instrumentedType.getModifiers());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : declaredTypes.values()) {</b>
<b class="nc">&nbsp;                            cv.visitInnerClass(typeDescription.getInternalName(),</b>
<b class="nc">&nbsp;                                    typeDescription.isMemberType()</b>
<b class="nc">&nbsp;                                            ? instrumentedType.getInternalName()</b>
<b class="nc">&nbsp;                                            : NO_REFERENCE,</b>
<b class="nc">&nbsp;                                    typeDescription.isAnonymousType()</b>
<b class="nc">&nbsp;                                            ? NO_REFERENCE</b>
<b class="nc">&nbsp;                                            : typeDescription.getSimpleName(),</b>
<b class="nc">&nbsp;                                    typeDescription.getModifiers());</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        for (RecordComponentDescription recordComponent : declarableRecordComponents.values()) {</b>
<b class="nc">&nbsp;                            recordComponentPool.target(recordComponent).apply(cv, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        for (FieldDescription fieldDescription : declarableFields.values()) {</b>
<b class="nc">&nbsp;                            fieldPool.target(fieldDescription).apply(cv, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        for (MethodDescription methodDescription : declarableMethods.values()) {</b>
<b class="nc">&nbsp;                            methodPool.target(methodDescription).apply(cv, implementationContext, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        initializationHandler.complete(cv, implementationContext);</b>
<b class="fc">&nbsp;                        cv.visitEnd();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@link Opcodes#ACC_DEPRECATED} if the current class file version only represents deprecated methods using modifiers
&nbsp;                     * that are not exposed in the type description API what is true for class files before Java 5 and if the supplied modifiers indicate
&nbsp;                     * deprecation.
&nbsp;                     *
&nbsp;                     * @param modifiers The original modifiers.
&nbsp;                     * @return {@link Opcodes#ACC_DEPRECATED} if the supplied modifiers imply deprecation.
&nbsp;                     */
&nbsp;                    private int resolveDeprecationModifiers(int modifiers) {
<b class="fc">&nbsp;                        return retainDeprecationModifiers &amp;&amp; (modifiers &amp; Opcodes.ACC_DEPRECATED) != 0</b>
<b class="nc">&nbsp;                                ? Opcodes.ACC_DEPRECATED</b>
<b class="fc">&nbsp;                                : ModifierContributor.EMPTY_MASK;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A field visitor that obtains all attributes and annotations of a field that is found in the
&nbsp;                     * class file but that discards all code.
&nbsp;                     */
&nbsp;                    protected class AttributeObtainingFieldVisitor extends FieldVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The field pool record to apply onto the field visitor.
&nbsp;                         */
&nbsp;                        private final FieldPool.Record record;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new attribute obtaining field visitor.
&nbsp;                         *
&nbsp;                         * @param fieldVisitor The field visitor to delegate to.
&nbsp;                         * @param record       The field pool record to apply onto the field visitor.
&nbsp;                         */
<b class="nc">&nbsp;                        protected AttributeObtainingFieldVisitor(FieldVisitor fieldVisitor, FieldPool.Record record) {</b>
<b class="nc">&nbsp;                            super(OpenedClassReader.ASM_API, fieldVisitor);</b>
<b class="nc">&nbsp;                            this.record = record;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitAnnotation(descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitEnd() {
<b class="nc">&nbsp;                            record.apply(fv, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                            super.visitEnd();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A record component visitor that obtains all attributes and annotations of a record component that is found
&nbsp;                     * in the class file but discards all code.
&nbsp;                     */
&nbsp;                    protected class AttributeObtainingRecordComponentVisitor extends RecordComponentVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The record component pool record to apply onto the record component visitor.
&nbsp;                         */
&nbsp;                        private final RecordComponentPool.Record record;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new attribute obtaining record component visitor.
&nbsp;                         *
&nbsp;                         * @param recordComponentVisitor The record component visitor to delegate to.
&nbsp;                         * @param record                 The record component pool record to apply onto the record component visitor.
&nbsp;                         */
<b class="nc">&nbsp;                        protected AttributeObtainingRecordComponentVisitor(RecordComponentVisitor recordComponentVisitor, RecordComponentPool.Record record) {</b>
<b class="nc">&nbsp;                            super(OpenedClassReader.ASM_API, recordComponentVisitor);</b>
<b class="nc">&nbsp;                            this.record = record;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitAnnotation(descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitEnd() {
<b class="nc">&nbsp;                            record.apply(getDelegate(), annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                            super.visitEnd();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A method visitor that preserves the code of a method in the class file by copying it into a rebased
&nbsp;                     * method while copying all attributes and annotations to the actual method.
&nbsp;                     */
&nbsp;                    protected class CodePreservingMethodVisitor extends MethodVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method visitor of the actual method.
&nbsp;                         */
&nbsp;                        private final MethodVisitor actualMethodVisitor;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method pool entry to apply.
&nbsp;                         */
&nbsp;                        private final MethodPool.Record record;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The resolution of a potential rebased method.
&nbsp;                         */
&nbsp;                        private final MethodRebaseResolver.Resolution resolution;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new code preserving method visitor.
&nbsp;                         *
&nbsp;                         * @param actualMethodVisitor The method visitor of the actual method.
&nbsp;                         * @param record              The method pool entry to apply.
&nbsp;                         * @param resolution          The resolution of the method rebase resolver in use.
&nbsp;                         */
&nbsp;                        protected CodePreservingMethodVisitor(MethodVisitor actualMethodVisitor,
&nbsp;                                                              MethodPool.Record record,
<b class="nc">&nbsp;                                                              MethodRebaseResolver.Resolution resolution) {</b>
<b class="nc">&nbsp;                            super(OpenedClassReader.ASM_API, actualMethodVisitor);</b>
<b class="nc">&nbsp;                            this.actualMethodVisitor = actualMethodVisitor;</b>
<b class="nc">&nbsp;                            this.record = record;</b>
<b class="nc">&nbsp;                            this.resolution = resolution;</b>
<b class="nc">&nbsp;                            record.applyHead(actualMethodVisitor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitAnnotationDefault() {
<b class="nc">&nbsp;                            return IGNORE_ANNOTATION; // Annotation types can never be rebased.</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitAnnotation(descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitAnnotableParameterCount(int count, boolean visible) {
<b class="nc">&nbsp;                            if (annotationRetention.isEnabled()) {</b>
<b class="nc">&nbsp;                                super.visitAnnotableParameterCount(count, visible);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitParameterAnnotation(index, descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitCode() {
<b class="nc">&nbsp;                            record.applyBody(actualMethodVisitor, implementationContext, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                            actualMethodVisitor.visitEnd();</b>
<b class="nc">&nbsp;                            if (resolution.isRebased()) {</b>
<b class="nc">&nbsp;                                mv = cv.visitMethod(resolution.getResolvedMethod().getActualModifiers(),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getInternalName(),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getDescriptor(),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getGenericSignature(),</b>
<b class="nc">&nbsp;                                        resolution.getResolvedMethod().getExceptionTypes().asErasures().toInternalNames());</b>
<b class="nc">&nbsp;                                super.visitCode();</b>
<b class="nc">&nbsp;                                if (!resolution.getAppendedParameters().isEmpty() &amp;&amp; implementationContext.getFrameGeneration().isActive()) {</b>
<b class="nc">&nbsp;                                    if (implementationContext.getFrameGeneration() == Implementation.Context.FrameGeneration.GENERATE &amp;&amp; resolution.getAppendedParameters().size() &lt; 4) {</b>
<b class="nc">&nbsp;                                        super.visitFrame(Opcodes.F_CHOP, resolution.getAppendedParameters().size(), EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        Object[] frame = new Object[resolution.getResolvedMethod().getParameters().size()</b>
<b class="nc">&nbsp;                                                - resolution.getAppendedParameters().size()</b>
&nbsp;                                                + 1];
<b class="nc">&nbsp;                                        frame[0] = Opcodes.UNINITIALIZED_THIS;</b>
<b class="nc">&nbsp;                                        for (int index = 1; index &lt; frame.length; index++) {</b>
<b class="nc">&nbsp;                                            TypeDefinition typeDefinition = resolution.getResolvedMethod()</b>
<b class="nc">&nbsp;                                                    .getParameters()</b>
<b class="nc">&nbsp;                                                    .get(index - 1)</b>
<b class="nc">&nbsp;                                                    .getType();</b>
<b class="nc">&nbsp;                                            if (typeDefinition.represents(boolean.class)</b>
<b class="nc">&nbsp;                                                    || typeDefinition.represents(byte.class)</b>
<b class="nc">&nbsp;                                                    || typeDefinition.represents(short.class)</b>
<b class="nc">&nbsp;                                                    || typeDefinition.represents(char.class)</b>
<b class="nc">&nbsp;                                                    || typeDefinition.represents(int.class)) {</b>
<b class="nc">&nbsp;                                                frame[index] = Opcodes.INTEGER;</b>
<b class="nc">&nbsp;                                            } else if (typeDefinition.represents(long.class)) {</b>
<b class="nc">&nbsp;                                                frame[index] = Opcodes.LONG;</b>
<b class="nc">&nbsp;                                            } else if (typeDefinition.represents(float.class)) {</b>
<b class="nc">&nbsp;                                                frame[index] = Opcodes.FLOAT;</b>
<b class="nc">&nbsp;                                            } else if (typeDefinition.represents(double.class)) {</b>
<b class="nc">&nbsp;                                                frame[index] = Opcodes.DOUBLE;</b>
&nbsp;                                            } else {
<b class="nc">&nbsp;                                                frame[index] = typeDefinition.asErasure().getInternalName();</b>
&nbsp;                                            }
&nbsp;                                        }
<b class="nc">&nbsp;                                        super.visitFrame((readerFlags &amp; ClassReader.EXPAND_FRAMES) == 0</b>
<b class="nc">&nbsp;                                                ? Opcodes.F_FULL</b>
<b class="nc">&nbsp;                                                : Opcodes.F_NEW, frame.length, frame, EMPTY.length, EMPTY);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    super.visitInsn(Opcodes.NOP);</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="nc">&nbsp;                                mv = IGNORE_METHOD;</b>
<b class="nc">&nbsp;                                super.visitCode();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitMaxs(int stackSize, int localVariableLength) {
<b class="nc">&nbsp;                            super.visitMaxs(stackSize, Math.max(localVariableLength, resolution.getResolvedMethod().getStackSize()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A method visitor that obtains all attributes and annotations of a method that is found in the
&nbsp;                     * class file but that discards all code.
&nbsp;                     */
&nbsp;                    protected class AttributeObtainingMethodVisitor extends MethodVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method visitor to which the actual method is to be written to.
&nbsp;                         */
&nbsp;                        private final MethodVisitor actualMethodVisitor;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method pool entry to apply.
&nbsp;                         */
&nbsp;                        private final MethodPool.Record record;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new attribute obtaining method visitor.
&nbsp;                         *
&nbsp;                         * @param actualMethodVisitor The method visitor of the actual method.
&nbsp;                         * @param record              The method pool entry to apply.
&nbsp;                         */
<b class="nc">&nbsp;                        protected AttributeObtainingMethodVisitor(MethodVisitor actualMethodVisitor, MethodPool.Record record) {</b>
<b class="nc">&nbsp;                            super(OpenedClassReader.ASM_API, actualMethodVisitor);</b>
<b class="nc">&nbsp;                            this.actualMethodVisitor = actualMethodVisitor;</b>
<b class="nc">&nbsp;                            this.record = record;</b>
<b class="nc">&nbsp;                            record.applyHead(actualMethodVisitor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitAnnotationDefault() {
<b class="nc">&nbsp;                            return IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitTypeAnnotation(typeReference, typePath, descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitAnnotation(descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitAnnotableParameterCount(int count, boolean visible) {
<b class="nc">&nbsp;                            if (annotationRetention.isEnabled()) {</b>
<b class="nc">&nbsp;                                super.visitAnnotableParameterCount(count, visible);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                    ? super.visitParameterAnnotation(index, descriptor, visible)</b>
<b class="nc">&nbsp;                                    : IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitCode() {
<b class="nc">&nbsp;                            mv = IGNORE_METHOD;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitEnd() {
<b class="nc">&nbsp;                            record.applyBody(actualMethodVisitor, implementationContext, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                            actualMethodVisitor.visitEnd();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A default type writer that only applies a type decoration.
&nbsp;             *
&nbsp;             * @param &lt;V&gt; The best known loaded type for the dynamically created type.
&nbsp;             */
&nbsp;            protected static class WithDecorationOnly&lt;V&gt; extends ForInlining&lt;V&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new inlining type writer that only applies a decoration.
&nbsp;                 *
&nbsp;                 * @param instrumentedType             The instrumented type to be created.
&nbsp;                 * @param classFileVersion             The class file specified by the user.
&nbsp;                 * @param auxiliaryTypes               The explicit auxiliary types to add to the created type.
&nbsp;                 * @param methods                      The instrumented type&#39;s declared and virtually inherited methods.
&nbsp;                 * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;                 * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;                 * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;                 * @param annotationRetention          The annotation retention to apply.
&nbsp;                 * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;                 * @param implementationContextFactory The implementation context factory to apply.
&nbsp;                 * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;                 * @param classWriterStrategy          The class writer strategy to use.
&nbsp;                 * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;                 * @param classFileLocator             The class file locator for locating the original type&#39;s class file.
&nbsp;                 */
&nbsp;                protected WithDecorationOnly(TypeDescription instrumentedType,
&nbsp;                                             ClassFileVersion classFileVersion,
&nbsp;                                             List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                             MethodList&lt;?&gt; methods,
&nbsp;                                             TypeAttributeAppender typeAttributeAppender,
&nbsp;                                             AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                             AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                             AnnotationRetention annotationRetention,
&nbsp;                                             AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                             Implementation.Context.Factory implementationContextFactory,
&nbsp;                                             TypeValidation typeValidation,
&nbsp;                                             ClassWriterStrategy classWriterStrategy,
&nbsp;                                             TypePool typePool,
&nbsp;                                             ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;                    super(instrumentedType,</b>
&nbsp;                            classFileVersion,
&nbsp;                            FieldPool.Disabled.INSTANCE,
&nbsp;                            RecordComponentPool.Disabled.INSTANCE,
&nbsp;                            auxiliaryTypes,
&nbsp;                            new LazyFieldList(instrumentedType),
&nbsp;                            methods,
&nbsp;                            new MethodList.Empty&lt;MethodDescription&gt;(),
&nbsp;                            new RecordComponentList.Empty&lt;RecordComponentDescription.InDefinedShape&gt;(),
&nbsp;                            LoadedTypeInitializer.NoOp.INSTANCE,
&nbsp;                            TypeInitializer.None.INSTANCE,
&nbsp;                            typeAttributeAppender,
&nbsp;                            asmVisitorWrapper,
&nbsp;                            annotationValueFilterFactory,
&nbsp;                            annotationRetention,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            implementationContextFactory,
&nbsp;                            typeValidation,
&nbsp;                            classWriterStrategy,
&nbsp;                            typePool,
&nbsp;                            instrumentedType,
&nbsp;                            classFileLocator);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                protected ClassVisitor writeTo(ClassVisitor classVisitor,
&nbsp;                                               TypeInitializer typeInitializer,
&nbsp;                                               ContextRegistry contextRegistry,
&nbsp;                                               int writerFlags,
&nbsp;                                               int readerFlags) {
<b class="nc">&nbsp;                    if (typeInitializer.isDefined()) {</b>
<b class="nc">&nbsp;                        throw new UnsupportedOperationException(&quot;Cannot apply a type initializer for a decoration&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new DecorationClassVisitor(classVisitor, contextRegistry, writerFlags, readerFlags);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A field list that only reads fields lazy to avoid an eager lookup since fields are often not required.
&nbsp;                 */
&nbsp;                protected static class LazyFieldList extends FieldList.AbstractBase&lt;FieldDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a lazy field list.
&nbsp;                     *
&nbsp;                     * @param instrumentedType The instrumented type.
&nbsp;                     */
<b class="nc">&nbsp;                    protected LazyFieldList(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDescription.InDefinedShape get(int index) {
<b class="nc">&nbsp;                        return instrumentedType.getDeclaredFields().get(index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="nc">&nbsp;                        return instrumentedType.getDeclaredFields().size();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A class visitor that decorates an existing type.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR&quot;, justification = &quot;Field access order is implied by ASM.&quot;)
&nbsp;                protected class DecorationClassVisitor extends MetadataAwareClassVisitor implements TypeInitializer.Drain {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A context registry to register the lazily created implementation context to.
&nbsp;                     */
&nbsp;                    private final ContextRegistry contextRegistry;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The writer flags being used.
&nbsp;                     */
&nbsp;                    private final int writerFlags;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The reader flags being used.
&nbsp;                     */
&nbsp;                    private final int readerFlags;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implementation context to use or {@code null} if the context is not yet initialized.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private Implementation.Context.ExtractableView implementationContext;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a class visitor which is capable of decorating an existent class on the fly.
&nbsp;                     *
&nbsp;                     * @param classVisitor    The underlying class visitor to which writes are delegated.
&nbsp;                     * @param contextRegistry A context registry to register the lazily created implementation context to.
&nbsp;                     * @param writerFlags     The writer flags being used.
&nbsp;                     * @param readerFlags     The reader flags being used.
&nbsp;                     */
<b class="nc">&nbsp;                    protected DecorationClassVisitor(ClassVisitor classVisitor, ContextRegistry contextRegistry, int writerFlags, int readerFlags) {</b>
<b class="nc">&nbsp;                        super(OpenedClassReader.ASM_API, classVisitor);</b>
<b class="nc">&nbsp;                        this.contextRegistry = contextRegistry;</b>
<b class="nc">&nbsp;                        this.writerFlags = writerFlags;</b>
<b class="nc">&nbsp;                        this.readerFlags = readerFlags;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void visit(int classFileVersionNumber,
&nbsp;                                      int modifiers,
&nbsp;                                      String internalName,
&nbsp;                                      String genericSignature,
&nbsp;                                      String superClassInternalName,
&nbsp;                                      String[] interfaceTypeInternalName) {
<b class="nc">&nbsp;                        ClassFileVersion classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersionNumber);</b>
<b class="nc">&nbsp;                        implementationContext = implementationContextFactory.make(instrumentedType,</b>
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                typeInitializer,
&nbsp;                                classFileVersion,
&nbsp;                                WithDecorationOnly.this.classFileVersion,
<b class="nc">&nbsp;                                (writerFlags &amp; ClassWriter.COMPUTE_FRAMES) == 0 &amp;&amp; classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="nc">&nbsp;                                        ? ((readerFlags &amp; ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND)</b>
<b class="nc">&nbsp;                                        : Implementation.Context.FrameGeneration.DISABLED);</b>
<b class="nc">&nbsp;                        contextRegistry.setImplementationContext(implementationContext);</b>
<b class="nc">&nbsp;                        cv = asmVisitorWrapper.wrap(instrumentedType,</b>
&nbsp;                                cv,
&nbsp;                                implementationContext,
&nbsp;                                typePool,
&nbsp;                                fields,
&nbsp;                                methods,
&nbsp;                                writerFlags,
&nbsp;                                readerFlags);
<b class="nc">&nbsp;                        cv.visit(classFileVersionNumber, modifiers, internalName, genericSignature, superClassInternalName, interfaceTypeInternalName);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected AnnotationVisitor onVisitTypeAnnotation(int typeReference, TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                        return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                ? cv.visitTypeAnnotation(typeReference, typePath, descriptor, visible)</b>
<b class="nc">&nbsp;                                : IGNORE_ANNOTATION;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    protected AnnotationVisitor onVisitAnnotation(String descriptor, boolean visible) {
<b class="nc">&nbsp;                        return annotationRetention.isEnabled()</b>
<b class="nc">&nbsp;                                ? cv.visitAnnotation(descriptor, visible)</b>
<b class="nc">&nbsp;                                : IGNORE_ANNOTATION;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onAfterAttributes() {
<b class="nc">&nbsp;                        typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void onVisitEnd() {
<b class="nc">&nbsp;                        implementationContext.drain(this, cv, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                        cv.visitEnd();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply(ClassVisitor classVisitor, TypeInitializer typeInitializer, Implementation.Context implementationContext) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type writer that creates a class file that is not based upon another, existing class.
&nbsp;         *
&nbsp;         * @param &lt;U&gt; The best known loaded type for the dynamically created type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;        public static class ForCreation&lt;U&gt; extends Default&lt;U&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The method pool to use.
&nbsp;             */
&nbsp;            private final MethodPool methodPool;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default type writer for creating a new type that is not based on an existing class file.
&nbsp;             *
&nbsp;             * @param instrumentedType             The instrumented type to be created.
&nbsp;             * @param classFileVersion             The class file version to write the instrumented type in and to apply when creating auxiliary types.
&nbsp;             * @param fieldPool                    The field pool to use.
&nbsp;             * @param methodPool                   The method pool to use.
&nbsp;             * @param recordComponentPool          The record component pool to use.
&nbsp;             * @param auxiliaryTypes               A list of auxiliary types to add to the created type.
&nbsp;             * @param fields                       The instrumented type&#39;s declared fields.
&nbsp;             * @param methods                      The instrumented type&#39;s declared and virtually inherited methods.
&nbsp;             * @param instrumentedMethods          The instrumented methods relevant to this type creation.
&nbsp;             * @param recordComponents             The instrumented type&#39;s record components.
&nbsp;             * @param loadedTypeInitializer        The loaded type initializer to apply onto the created type after loading.
&nbsp;             * @param typeInitializer              The type initializer to include in the created type&#39;s type initializer.
&nbsp;             * @param typeAttributeAppender        The type attribute appender to apply onto the instrumented type.
&nbsp;             * @param asmVisitorWrapper            The ASM visitor wrapper to apply onto the class writer.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply.
&nbsp;             * @param annotationRetention          The annotation retention to apply.
&nbsp;             * @param auxiliaryTypeNamingStrategy  The naming strategy for auxiliary types to apply.
&nbsp;             * @param implementationContextFactory The implementation context factory to apply.
&nbsp;             * @param typeValidation               Determines if a type should be explicitly validated.
&nbsp;             * @param classWriterStrategy          The class writer strategy to use.
&nbsp;             * @param typePool                     The type pool to use for computing stack map frames, if required.
&nbsp;             */
&nbsp;            protected ForCreation(TypeDescription instrumentedType,
&nbsp;                                  ClassFileVersion classFileVersion,
&nbsp;                                  FieldPool fieldPool,
&nbsp;                                  MethodPool methodPool,
&nbsp;                                  RecordComponentPool recordComponentPool,
&nbsp;                                  List&lt;? extends DynamicType&gt; auxiliaryTypes,
&nbsp;                                  FieldList&lt;FieldDescription.InDefinedShape&gt; fields,
&nbsp;                                  MethodList&lt;?&gt; methods,
&nbsp;                                  MethodList&lt;?&gt; instrumentedMethods,
&nbsp;                                  RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; recordComponents,
&nbsp;                                  LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                                  TypeInitializer typeInitializer,
&nbsp;                                  TypeAttributeAppender typeAttributeAppender,
&nbsp;                                  AsmVisitorWrapper asmVisitorWrapper,
&nbsp;                                  AnnotationValueFilter.Factory annotationValueFilterFactory,
&nbsp;                                  AnnotationRetention annotationRetention,
&nbsp;                                  AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                  Implementation.Context.Factory implementationContextFactory,
&nbsp;                                  TypeValidation typeValidation,
&nbsp;                                  ClassWriterStrategy classWriterStrategy,
&nbsp;                                  TypePool typePool) {
<b class="fc">&nbsp;                super(instrumentedType,</b>
&nbsp;                        classFileVersion,
&nbsp;                        fieldPool,
&nbsp;                        recordComponentPool,
&nbsp;                        auxiliaryTypes,
&nbsp;                        fields,
&nbsp;                        methods,
&nbsp;                        instrumentedMethods,
&nbsp;                        recordComponents,
&nbsp;                        loadedTypeInitializer,
&nbsp;                        typeInitializer,
&nbsp;                        typeAttributeAppender,
&nbsp;                        asmVisitorWrapper,
&nbsp;                        annotationValueFilterFactory,
&nbsp;                        annotationRetention,
&nbsp;                        auxiliaryTypeNamingStrategy,
&nbsp;                        implementationContextFactory,
&nbsp;                        typeValidation,
&nbsp;                        classWriterStrategy,
&nbsp;                        typePool);
<b class="fc">&nbsp;                this.methodPool = methodPool;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ContextClassVisitor wrap(ClassVisitor classVisitor, int writerFlags, int readerFlags) {
<b class="nc">&nbsp;                Implementation.Context.ExtractableView implementationContext = implementationContextFactory.make(instrumentedType,</b>
&nbsp;                        auxiliaryTypeNamingStrategy,
&nbsp;                        typeInitializer,
&nbsp;                        classFileVersion,
&nbsp;                        classFileVersion,
<b class="nc">&nbsp;                        (writerFlags &amp; ClassWriter.COMPUTE_FRAMES) == 0 &amp;&amp; classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="nc">&nbsp;                                ? ((readerFlags &amp; ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND)</b>
<b class="nc">&nbsp;                                : Implementation.Context.FrameGeneration.DISABLED);</b>
<b class="nc">&nbsp;                return new ImplementationContextClassVisitor(new CreationClassVisitor(asmVisitorWrapper.wrap(instrumentedType,</b>
<b class="nc">&nbsp;                        ValidatingClassVisitor.of(classVisitor, typeValidation),</b>
&nbsp;                        implementationContext,
&nbsp;                        typePool,
&nbsp;                        fields,
&nbsp;                        methods,
<b class="nc">&nbsp;                        asmVisitorWrapper.mergeWriter(writerFlags),</b>
<b class="nc">&nbsp;                        asmVisitorWrapper.mergeReader(readerFlags)), implementationContext), implementationContext);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Relying on correlated type properties.&quot;)
&nbsp;            protected UnresolvedType create(TypeInitializer typeInitializer, ClassDumpAction.Dispatcher dispatcher) {
<b class="fc">&nbsp;                int writerFlags = asmVisitorWrapper.mergeWriter(AsmVisitorWrapper.NO_FLAGS), readerFlags = asmVisitorWrapper.mergeReader(AsmVisitorWrapper.NO_FLAGS);</b>
<b class="fc">&nbsp;                ClassWriter classWriter = classWriterStrategy.resolve(writerFlags, typePool);</b>
<b class="fc">&nbsp;                Implementation.Context.ExtractableView implementationContext = implementationContextFactory.make(instrumentedType,</b>
&nbsp;                        auxiliaryTypeNamingStrategy,
&nbsp;                        typeInitializer,
&nbsp;                        classFileVersion,
&nbsp;                        classFileVersion,
<b class="fc">&nbsp;                        (writerFlags &amp; ClassWriter.COMPUTE_FRAMES) == 0 &amp;&amp; classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="fc">&nbsp;                                ? ((readerFlags &amp; ClassReader.EXPAND_FRAMES) == 0 ? Implementation.Context.FrameGeneration.GENERATE : Implementation.Context.FrameGeneration.EXPAND)</b>
<b class="nc">&nbsp;                                : Implementation.Context.FrameGeneration.DISABLED);</b>
<b class="fc">&nbsp;                ClassVisitor classVisitor = asmVisitorWrapper.wrap(instrumentedType,</b>
<b class="fc">&nbsp;                        ValidatingClassVisitor.of(classWriter, typeValidation),</b>
&nbsp;                        implementationContext,
&nbsp;                        typePool,
&nbsp;                        fields,
&nbsp;                        methods,
&nbsp;                        writerFlags,
&nbsp;                        readerFlags);
<b class="fc">&nbsp;                classVisitor.visit(classFileVersion.getMinorMajorVersion(),</b>
<b class="fc">&nbsp;                        instrumentedType.getActualModifiers(!instrumentedType.isInterface()),</b>
<b class="fc">&nbsp;                        instrumentedType.getInternalName(),</b>
<b class="fc">&nbsp;                        instrumentedType.getGenericSignature(),</b>
<b class="fc">&nbsp;                        (instrumentedType.getSuperClass() == null</b>
<b class="nc">&nbsp;                                ? TypeDescription.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;                                : instrumentedType.getSuperClass().asErasure()).getInternalName(),</b>
<b class="fc">&nbsp;                        instrumentedType.getInterfaces().asErasures().toInternalNames());</b>
<b class="fc">&nbsp;                if (!instrumentedType.isNestHost()) {</b>
<b class="nc">&nbsp;                    classVisitor.visitNestHost(instrumentedType.getNestHost().getInternalName());</b>
&nbsp;                }
<b class="fc">&nbsp;                MethodDescription.InDefinedShape enclosingMethod = instrumentedType.getEnclosingMethod();</b>
<b class="fc">&nbsp;                if (enclosingMethod != null) {</b>
<b class="nc">&nbsp;                    classVisitor.visitOuterClass(enclosingMethod.getDeclaringType().getInternalName(),</b>
<b class="nc">&nbsp;                            enclosingMethod.getInternalName(),</b>
<b class="nc">&nbsp;                            enclosingMethod.getDescriptor());</b>
<b class="fc">&nbsp;                } else if (instrumentedType.isLocalType() || instrumentedType.isAnonymousType()) {</b>
<b class="nc">&nbsp;                    classVisitor.visitOuterClass(instrumentedType.getEnclosingType().getInternalName(), NO_REFERENCE, NO_REFERENCE);</b>
&nbsp;                }
<b class="fc">&nbsp;                typeAttributeAppender.apply(classVisitor, instrumentedType, annotationValueFilterFactory.on(instrumentedType));</b>
<b class="fc">&nbsp;                if (instrumentedType.isNestHost()) {</b>
<b class="fc">&nbsp;                    for (TypeDescription typeDescription : instrumentedType.getNestMembers().filter(not(is(instrumentedType)))) {</b>
<b class="nc">&nbsp;                        classVisitor.visitNestMember(typeDescription.getInternalName());</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                for (TypeDescription typeDescription : instrumentedType.getPermittedSubtypes()) {</b>
<b class="nc">&nbsp;                    classVisitor.visitPermittedSubclass(typeDescription.getInternalName());</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                TypeDescription declaringType = instrumentedType.getDeclaringType();</b>
<b class="fc">&nbsp;                if (declaringType != null) {</b>
<b class="nc">&nbsp;                    classVisitor.visitInnerClass(instrumentedType.getInternalName(),</b>
<b class="nc">&nbsp;                            declaringType.getInternalName(),</b>
<b class="nc">&nbsp;                            instrumentedType.getSimpleName(),</b>
<b class="nc">&nbsp;                            instrumentedType.getModifiers());</b>
<b class="fc">&nbsp;                } else if (instrumentedType.isLocalType()) {</b>
<b class="nc">&nbsp;                    classVisitor.visitInnerClass(instrumentedType.getInternalName(),</b>
<b class="nc">&nbsp;                            NO_REFERENCE,</b>
<b class="nc">&nbsp;                            instrumentedType.getSimpleName(),</b>
<b class="nc">&nbsp;                            instrumentedType.getModifiers());</b>
<b class="fc">&nbsp;                } else if (instrumentedType.isAnonymousType()) {</b>
<b class="nc">&nbsp;                    classVisitor.visitInnerClass(instrumentedType.getInternalName(),</b>
<b class="nc">&nbsp;                            NO_REFERENCE,</b>
<b class="nc">&nbsp;                            NO_REFERENCE,</b>
<b class="nc">&nbsp;                            instrumentedType.getModifiers());</b>
&nbsp;                }
<b class="fc">&nbsp;                for (TypeDescription typeDescription : instrumentedType.getDeclaredTypes()) {</b>
<b class="nc">&nbsp;                    classVisitor.visitInnerClass(typeDescription.getInternalName(),</b>
<b class="nc">&nbsp;                            typeDescription.isMemberType()</b>
<b class="nc">&nbsp;                                    ? instrumentedType.getInternalName()</b>
<b class="nc">&nbsp;                                    : NO_REFERENCE,</b>
<b class="nc">&nbsp;                            typeDescription.isAnonymousType()</b>
<b class="nc">&nbsp;                                    ? NO_REFERENCE</b>
<b class="nc">&nbsp;                                    : typeDescription.getSimpleName(),</b>
<b class="nc">&nbsp;                            typeDescription.getModifiers());</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (RecordComponentDescription recordComponentDescription : recordComponents) {</b>
<b class="nc">&nbsp;                    recordComponentPool.target(recordComponentDescription).apply(classVisitor, annotationValueFilterFactory);</b>
<b class="nc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (FieldDescription fieldDescription : fields) {</b>
<b class="fc">&nbsp;                    fieldPool.target(fieldDescription).apply(classVisitor, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (MethodDescription methodDescription : instrumentedMethods) {</b>
<b class="fc">&nbsp;                    methodPool.target(methodDescription).apply(classVisitor, implementationContext, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                implementationContext.drain(new TypeInitializer.Drain.Default(instrumentedType,</b>
&nbsp;                        methodPool,
&nbsp;                        annotationValueFilterFactory), classVisitor, annotationValueFilterFactory);
<b class="fc">&nbsp;                classVisitor.visitEnd();</b>
<b class="fc">&nbsp;                return new UnresolvedType(classWriter.toByteArray(), implementationContext.getAuxiliaryTypes());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A class visitor that applies the subclass creation as a wrapper.
&nbsp;             */
&nbsp;            protected class CreationClassVisitor extends MetadataAwareClassVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation context to apply.
&nbsp;                 */
&nbsp;                private final Implementation.Context.ExtractableView implementationContext;
&nbsp;
&nbsp;                /**
&nbsp;                 * The declared types that have been visited.
&nbsp;                 */
<b class="nc">&nbsp;                private final Set&lt;String&gt; declaredTypes = new HashSet&lt;String&gt;();</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The signatures of all fields that were explicitly visited.
&nbsp;                 */
<b class="nc">&nbsp;                private final Set&lt;SignatureKey&gt; visitedFields = new HashSet&lt;SignatureKey&gt;();</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The signature of all methods that were explicitly visited.
&nbsp;                 */
<b class="nc">&nbsp;                private final Set&lt;SignatureKey&gt; visitedMethods = new HashSet&lt;SignatureKey&gt;();</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new wrapper visitor.
&nbsp;                 *
&nbsp;                 * @param classVisitor          The class visitor being wrapped.
&nbsp;                 * @param implementationContext The implementation context to apply.
&nbsp;                 */
<b class="nc">&nbsp;                protected CreationClassVisitor(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {</b>
<b class="nc">&nbsp;                    super(OpenedClassReader.ASM_API, classVisitor);</b>
<b class="nc">&nbsp;                    this.implementationContext = implementationContext;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onAfterAttributes() {
<b class="nc">&nbsp;                    typeAttributeAppender.apply(cv, instrumentedType, annotationValueFilterFactory.on(instrumentedType));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onVisitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
<b class="nc">&nbsp;                    declaredTypes.add(internalName);</b>
<b class="nc">&nbsp;                    super.onVisitInnerClass(internalName, outerName, innerName, modifiers);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected FieldVisitor onVisitField(int modifiers, String name, String descriptor, @MaybeNull String signature, @MaybeNull Object value) {
<b class="nc">&nbsp;                    visitedFields.add(new SignatureKey(name, descriptor));</b>
<b class="nc">&nbsp;                    return super.onVisitField(modifiers, name, descriptor, signature, value);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected MethodVisitor onVisitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
<b class="nc">&nbsp;                    visitedMethods.add(new SignatureKey(internalName, descriptor));</b>
<b class="nc">&nbsp;                    return super.onVisitMethod(modifiers, internalName, descriptor, signature, exception);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onVisitEnd() {
<b class="nc">&nbsp;                    for (TypeDescription typeDescription : instrumentedType.getDeclaredTypes()) {</b>
<b class="nc">&nbsp;                        if (!declaredTypes.contains(typeDescription.getInternalName())) {</b>
<b class="nc">&nbsp;                            cv.visitInnerClass(typeDescription.getInternalName(),</b>
<b class="nc">&nbsp;                                    typeDescription.isMemberType()</b>
<b class="nc">&nbsp;                                            ? instrumentedType.getInternalName()</b>
<b class="nc">&nbsp;                                            : NO_REFERENCE,</b>
<b class="nc">&nbsp;                                    typeDescription.isAnonymousType()</b>
<b class="nc">&nbsp;                                            ? NO_REFERENCE</b>
<b class="nc">&nbsp;                                            : typeDescription.getSimpleName(),</b>
<b class="nc">&nbsp;                                    typeDescription.getModifiers());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    for (FieldDescription fieldDescription : fields) {</b>
<b class="nc">&nbsp;                        if (!visitedFields.contains(new SignatureKey(fieldDescription.getName(), fieldDescription.getDescriptor()))) {</b>
<b class="nc">&nbsp;                            fieldPool.target(fieldDescription).apply(cv, annotationValueFilterFactory);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    for (MethodDescription methodDescription : instrumentedMethods) {</b>
<b class="nc">&nbsp;                        if (!visitedMethods.contains(new SignatureKey(methodDescription.getInternalName(), methodDescription.getDescriptor()))) {</b>
<b class="nc">&nbsp;                            methodPool.target(methodDescription).apply(cv, implementationContext, annotationValueFilterFactory);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    implementationContext.drain(new TypeInitializer.Drain.Default(instrumentedType,</b>
<b class="nc">&nbsp;                            methodPool,</b>
&nbsp;                            annotationValueFilterFactory), cv, annotationValueFilterFactory);
<b class="nc">&nbsp;                    super.onVisitEnd();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A context class visitor based on an {@link Implementation.Context}.
&nbsp;             */
&nbsp;            protected class ImplementationContextClassVisitor extends ContextClassVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation context to use.
&nbsp;                 */
&nbsp;                private final Implementation.Context.ExtractableView implementationContext;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a context class loader based on an {@link Implementation.Context}.
&nbsp;                 *
&nbsp;                 * @param classVisitor          The class visitor to delegate to.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 */
<b class="nc">&nbsp;                protected ImplementationContextClassVisitor(ClassVisitor classVisitor, Implementation.Context.ExtractableView implementationContext) {</b>
<b class="nc">&nbsp;                    super(classVisitor);</b>
<b class="nc">&nbsp;                    this.implementationContext = implementationContext;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public List&lt;DynamicType&gt; getAuxiliaryTypes() {
<b class="nc">&nbsp;                    return CompoundList.of(auxiliaryTypes, implementationContext.getAuxiliaryTypes());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public LoadedTypeInitializer getLoadedTypeInitializer() {
<b class="nc">&nbsp;                    return loadedTypeInitializer;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An action to write a class file to the dumping location.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ClassDumpAction implements PrivilegedExceptionAction&lt;Void&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that nothing is returned from this action.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="nc">&nbsp;            private static final Void NOTHING = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The target folder for writing the class file to.
&nbsp;             */
&nbsp;            private final String target;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the dumped class file is an input to a class transformation.
&nbsp;             */
&nbsp;            private final boolean original;
&nbsp;
&nbsp;            /**
&nbsp;             * The suffix to append to the dumped class file.
&nbsp;             */
&nbsp;            private final long suffix;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s binary representation.
&nbsp;             */
&nbsp;            private final byte[] binaryRepresentation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new class dump action.
&nbsp;             *
&nbsp;             * @param target               The target folder for writing the class file to.
&nbsp;             * @param instrumentedType     The instrumented type.
&nbsp;             * @param original             {@code true} if the dumped class file is an input to a class transformation.
&nbsp;             * @param suffix               The suffix to append to the dumped class file.
&nbsp;             * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;             */
<b class="nc">&nbsp;            protected ClassDumpAction(String target, TypeDescription instrumentedType, boolean original, long suffix, byte[] binaryRepresentation) {</b>
<b class="nc">&nbsp;                this.target = target;</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                this.original = original;</b>
<b class="nc">&nbsp;                this.suffix = suffix;</b>
<b class="nc">&nbsp;                this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Void run() throws Exception {
<b class="nc">&nbsp;                OutputStream outputStream = new FileOutputStream(new File(target, instrumentedType.getName()</b>
<b class="nc">&nbsp;                        + (original ? &quot;-original.&quot; : &quot;.&quot;)</b>
&nbsp;                        + suffix
&nbsp;                        + &quot;.class&quot;));
&nbsp;                try {
<b class="nc">&nbsp;                    outputStream.write(binaryRepresentation);</b>
<b class="nc">&nbsp;                    return NOTHING;</b>
&nbsp;                } finally {
<b class="nc">&nbsp;                    outputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for dumping class files to the file system.
&nbsp;             */
&nbsp;            protected interface Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Dumps a class file to the file system.
&nbsp;                 *
&nbsp;                 * @param instrumentedType     The type to dump.
&nbsp;                 * @param original             {@code true} if the class file is in its original state.
&nbsp;                 * @param binaryRepresentation The class file&#39;s binary representation.
&nbsp;                 */
&nbsp;                void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation);
&nbsp;
&nbsp;                /**
&nbsp;                 * A disabled dispatcher that does not dump any class files.
&nbsp;                 */
<b class="fc">&nbsp;                enum Disabled implements Dispatcher {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An enabled dispatcher that dumps class files to a given folder.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Enabled implements Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The folder to write class files to.
&nbsp;                     */
&nbsp;                    private final String folder;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The timestamp to append.
&nbsp;                     */
&nbsp;                    private final long timestamp;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new dispatcher for dumping class files.
&nbsp;                     *
&nbsp;                     * @param folder    The folder to write class files to.
&nbsp;                     * @param timestamp The timestamp to append.
&nbsp;                     */
<b class="nc">&nbsp;                    protected Enabled(String folder, long timestamp) {</b>
<b class="nc">&nbsp;                        this.folder = folder;</b>
<b class="nc">&nbsp;                        this.timestamp = timestamp;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void dump(TypeDescription instrumentedType, boolean original, byte[] binaryRepresentation) {
&nbsp;                        try {
<b class="nc">&nbsp;                            doPrivileged(new ClassDumpAction(folder, instrumentedType, original, timestamp, binaryRepresentation));</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            exception.printStackTrace();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 10:47</div>
</div>
</body>
</html>
