


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodDelegation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: MethodDelegation (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodDelegation</td>
<td class="coverageStat">
  <span class="percent">
    41.9%
  </span>
  <span class="absValue">
    (13/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.8%
  </span>
  <span class="absValue">
    (21/39)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodDelegation$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$Compiled</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$Compiled$ForConstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$Compiled$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$Compiled$ForMethodReturn</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$Compiled$ForStaticCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$ForConstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$ForField$WithInstance</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$ForField$WithLookup</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$ForMethodReturn</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$ImplementationDelegate$ForStaticMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDelegation$WithCustomProperties</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (22/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.4%
  </span>
  <span class="absValue">
    (37/46)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    73.5%
  </span>
  <span class="absValue">
    (72/98)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.8%
  </span>
  <span class="absValue">
    (175/204)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.implementation.bind.MethodDelegationBinder;
&nbsp;import net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * This implementation delegates a method call to another method which can either be {@code static} by providing
&nbsp; * a reference to a {@link java.lang.Class} or an instance method when another object is provided. The potential
&nbsp; * targets of the method delegation can further be filtered by applying a filter. The method delegation can be
&nbsp; * customized by invoking the {@code MethodDelegation}&#39;s several builder methods.
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * &lt;b&gt;Without any customization, the method delegation will work as follows:&lt;/b&gt;
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * &lt;span style=&quot;text-decoration: underline&quot;&gt;Binding an instrumented method to a given delegate method&lt;/span&gt;
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * A method will be bound parameter by parameter. Considering a method {@code Foo#bar} being bound to a method
&nbsp; * {@code Qux#baz}, the method delegation will be decided on basis of the following annotations:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Argument}:
&nbsp; * This annotation will bind the {@code n}-th parameter of {@code Foo#bar} to that parameter of {@code Qux#baz}that
&nbsp; * is annotated with this annotation where {@code n} is the obligatory argument of the {@code @Argument} annotation.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.AllArguments}:
&nbsp; * This annotation will assign a collection of all parameters of {@code Foo#bar} to that parameter of {@code Qux#baz}
&nbsp; * that is annotated with {@code AllArguments}.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.This}: A parameter
&nbsp; * of {@code Qux#baz} that is annotated with {@code This} will be assigned the instance that is instrumented for
&nbsp; * a non-static method.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Super}: A parameter that is annotated with
&nbsp; * this annotation is assigned a proxy that allows calling an instrumented type&#39;s super methods.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Default}: A parameter that is annotated with
&nbsp; * this annotation is assigned a proxy that allows calling an instrumented type&#39;s directly implemented interfaces&#39;
&nbsp; * default methods.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.SuperCall}: A parameter
&nbsp; * of {@code Qux#baz} that is annotated with {@code SuperCall} will be assigned an instance of a type implementing both
&nbsp; * {@link java.lang.Runnable} and {@link java.util.concurrent.Callable} which will invoke the instrumented method on the
&nbsp; * invocation of either interface&#39;s method. The call is made using the original arguments of the method invocation.
&nbsp; * The return value is only emitted for the {@link java.util.concurrent.Callable#call()} method which additionally
&nbsp; * requires to catch any unchecked exceptions that might be thrown by the original method&#39;s implementation. If a
&nbsp; * source method is abstract, using this annotation excludes the method with this parameter annotation from being bound
&nbsp; * to this source method.
&nbsp; * &lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.DefaultCall}:
&nbsp; * This annotation is similar to the {@link net.bytebuddy.implementation.bind.annotation.SuperCall}
&nbsp; * annotation but it invokes a default method that is compatible to this method. If a source method does not represent
&nbsp; * a default method, using this annotation excludes the method with this parameter annotation from being bound to this
&nbsp; * source method. For using method handles, the {@link net.bytebuddy.implementation.bind.annotation.SuperCallHandle}
&nbsp; * and {@link net.bytebuddy.implementation.bind.annotation.DefaultCallHandle} annotations can be used.&lt;/li&gt;
&nbsp; * &lt;li&gt;The {@link net.bytebuddy.implementation.bind.annotation.SuperMethod} or
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.DefaultMethod} annotations can be used on any parameter type
&nbsp; * that is assignable from the {@link java.lang.reflect.Method} type. the parameter is bound a method instance that
&nbsp; * allows for the reflective invocation of a super or default method. Note that this method is not equal to the intercepted
&nbsp; * method but represents a synthetic accessor method. Using this annotation also causes this accessor to be {@code public}
&nbsp; * which allows its outside invocation without any access checks by a security manager. For using method handles, the
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.SuperCallHandle} and
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.DefaultCallHandle} annotations can be used.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Origin}: A parameter of
&nbsp; * {@code Qux#baz} that is annotated with {@code Origin} is assigned a reference to either a {@link java.lang.reflect.Method},
&nbsp; * a {@link java.lang.reflect.Constructor}, a {@code java.lang.reflect.Executable} or a {@link java.lang.Class} instance.
&nbsp; * A {@code Method}-typed, {@code Constructor} or {@code Executable} parameter is assigned a reference to the original
&nbsp; * method that is instrumented. A {@code Class}-typed parameter is assigned the type of the caller. Furthermore, {@code MethodType}
&nbsp; * and {@code MethodHandle} parameters are also supported. When using the annotation on a {@link java.lang.String} type,
&nbsp; * the intercepted method&#39;s {@code toString} value is injected. The same holds for a parameter of type {@code int} that receives
&nbsp; * the modifiers of the instrumented method.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.StubValue}: Assigns the (boxed) default value of the
&nbsp; * intercepted method&#39;s return type to the parameter. If the return type is {@code void}, {@code null} is assigned.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Empty}: Assigns the parameter type&#39;s
&nbsp; * default value, i.e. {@code null} for a reference type or zero for primitive types. This is an opportunity to
&nbsp; * ignore a parameter.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Pipe}: A parameter that is annotated
&nbsp; * with this annotation is assigned a proxy for forwarding the source method invocation to another instance of the
&nbsp; * same type as the declaring type of the intercepted method. &lt;b&gt;This annotation needs to be installed and explicitly
&nbsp; * registered before it can be used.&lt;/b&gt; See the {@link net.bytebuddy.implementation.bind.annotation.Pipe}
&nbsp; * annotation&#39;s documentation for further information on how this can be done.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.Morph}: The morph annotation is similar to
&nbsp; * the {@link net.bytebuddy.implementation.bind.annotation.SuperCall} annotation but allows to
&nbsp; * explicitly define and therewith alter the arguments that are handed to the super method. &lt;b&gt;This annotation needs
&nbsp; * to be installed and explicitly registered before it can be used.&lt;/b&gt; See the documentation to the annotation for
&nbsp; * further information.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.FieldValue}: Allows to access a field&#39;s value at the time
&nbsp; * of the method invocation. The field&#39;s value is directly assigned to the annotated parameter.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.FieldProxy}: Allows to access fields via getter
&nbsp; * and setter proxies. &lt;b&gt;This annotation needs to be installed and explicitly registered before it can be used.&lt;/b&gt;
&nbsp; * Note that any field access requires boxing such that a use of {@link net.bytebuddy.implementation.FieldAccessor} in
&nbsp; * combination with {@link net.bytebuddy.implementation.MethodDelegation#andThen(Implementation)} might be a more
&nbsp; * performant alternative for implementing field getters and setters.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * If a method is not annotated with any of the above methods, it will be treated as if it was annotated
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.Argument} using the next
&nbsp; * unbound parameter index of the source method as its parameter. This means that a method
&nbsp; * {@code Qux#baz(@Argument(2) Object p1, Object p2, @Argument(0) Object p3} would be treated as if {@code p2} was annotated
&nbsp; * with {@code @Argument(1)}.
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * In addition, the {@link net.bytebuddy.implementation.bind.annotation.RuntimeType}
&nbsp; * annotation can instruct a parameter to be bound by a
&nbsp; * {@link net.bytebuddy.implementation.bytecode.assign.Assigner} with considering the
&nbsp; * runtime type of the parameter.
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * &lt;span style=&quot;text-decoration: underline&quot;&gt;Selecting among different methods that can be used for binding a method
&nbsp; * of the instrumented type&lt;/span&gt;
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * When deciding between two methods {@code Foo#bar} and {@code Foo#qux} that could both be used to delegating a
&nbsp; * method call, the following consideration is applied in the given order:
&nbsp; * &lt;ol&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.annotation.BindingPriority}:
&nbsp; * A method that is annotated with this annotation is given a specific priority where the default priority is set
&nbsp; * to {@link net.bytebuddy.implementation.bind.annotation.BindingPriority#DEFAULT}
&nbsp; * for non-annotated method. A method with a higher priority is considered a better target for delegation.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.DeclaringTypeResolver}:
&nbsp; * If a target method is declared by a more specific type than another method, the method with the most specific
&nbsp; * type is bound.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.MethodNameEqualityResolver}:
&nbsp; * If a source method {@code Baz#qux} is the source method, it will rather be assigned to {@code Foo#qux} because
&nbsp; * of their equal names. Similar names and case-insensitive equality are not considered.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.ArgumentTypeResolver}:
&nbsp; * The most specific type resolver will consider all bindings that are using the
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.Argument}
&nbsp; * annotation for resolving a binding conflict. In this context, the resolution will equal the most-specific
&nbsp; * type resolution that is performed by the Java compiler. This means that a source method {@code Bar#baz(String)}
&nbsp; * will rather be bound to a method {@code Foo#bar(String)} than {@code Foo#qux(Object)} because the {@code String}
&nbsp; * type is more specific than the {@code Object} type. If two methods are equally adequate by their parameter types,
&nbsp; * then the method with the higher numbers of {@code @Argument} annotated parameters is considered as the better
&nbsp; * delegation target.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link net.bytebuddy.implementation.bind.ParameterLengthResolver}:
&nbsp; * If a target methods has a higher number of total parameters that were successfully bound, the method with
&nbsp; * the higher number will be considered as the better delegation target.&lt;/li&gt;
&nbsp; * &lt;/ol&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Additionally, if a method is annotated by
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.IgnoreForBinding},
&nbsp; * it is never considered as a target for a method delegation.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Important&lt;/b&gt;: For invoking a method on another instance, use the {@link MethodCall} implementation. A method delegation
&nbsp; * intends to bind a interceptor class and its resolution algorithm will not necessarily yield a delegation to the intercepted
&nbsp; * method.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @see MethodCall
&nbsp; * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFixedValue
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class MethodDelegation implements Implementation.Composable {
&nbsp;
&nbsp;    /**
&nbsp;     * The implementation delegate for this method delegation.
&nbsp;     */
&nbsp;    private final ImplementationDelegate implementationDelegate;
&nbsp;
&nbsp;    /**
&nbsp;     * A list of {@link net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder}s
&nbsp;     * to be used by this method delegation.
&nbsp;     */
&nbsp;    private final List&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders;
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.AmbiguityResolver}
&nbsp;     * to be used by this method delegation.
&nbsp;     */
&nbsp;    private final MethodDelegationBinder.AmbiguityResolver ambiguityResolver;
&nbsp;
&nbsp;    /**
&nbsp;     * The termination handler to apply.
&nbsp;     */
&nbsp;    private final TargetMethodAnnotationDrivenBinder.TerminationHandler terminationHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The binding resolver being used to select the relevant method binding.
&nbsp;     */
&nbsp;    private final MethodDelegationBinder.BindingResolver bindingResolver;
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link net.bytebuddy.implementation.bytecode.assign.Assigner} to be used by this method delegation.
&nbsp;     */
&nbsp;    private final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method delegation.
&nbsp;     *
&nbsp;     * @param implementationDelegate The implementation delegate to use by this method delegator.
&nbsp;     * @param parameterBinders       The parameter binders to use by this method delegator.
&nbsp;     * @param ambiguityResolver      The ambiguity resolver to use by this method delegator.
&nbsp;     * @param bindingResolver        The binding resolver being used to select the relevant method binding.
&nbsp;     */
&nbsp;    protected MethodDelegation(ImplementationDelegate implementationDelegate,
&nbsp;                               List&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
&nbsp;                               MethodDelegationBinder.AmbiguityResolver ambiguityResolver,
&nbsp;                               MethodDelegationBinder.BindingResolver bindingResolver) {
<b class="fc">&nbsp;        this(implementationDelegate,</b>
&nbsp;                parameterBinders,
&nbsp;                ambiguityResolver,
&nbsp;                MethodDelegationBinder.TerminationHandler.Default.RETURNING,
&nbsp;                bindingResolver,
&nbsp;                Assigner.DEFAULT);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method delegation.
&nbsp;     *
&nbsp;     * @param implementationDelegate The implementation delegate to use by this method delegator.
&nbsp;     * @param parameterBinders       The parameter binders to use by this method delegator.
&nbsp;     * @param ambiguityResolver      The ambiguity resolver to use by this method delegator.
&nbsp;     * @param terminationHandler     The termination handler to apply.
&nbsp;     * @param bindingResolver        The binding resolver being used to select the relevant method binding.
&nbsp;     * @param assigner               The assigner to be supplied by this method delegator.
&nbsp;     */
&nbsp;    private MethodDelegation(ImplementationDelegate implementationDelegate,
&nbsp;                             List&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
&nbsp;                             MethodDelegationBinder.AmbiguityResolver ambiguityResolver,
&nbsp;                             TargetMethodAnnotationDrivenBinder.TerminationHandler terminationHandler,
&nbsp;                             MethodDelegationBinder.BindingResolver bindingResolver,
<b class="fc">&nbsp;                             Assigner assigner) {</b>
<b class="fc">&nbsp;        this.implementationDelegate = implementationDelegate;</b>
<b class="fc">&nbsp;        this.parameterBinders = parameterBinders;</b>
<b class="fc">&nbsp;        this.terminationHandler = terminationHandler;</b>
<b class="fc">&nbsp;        this.ambiguityResolver = ambiguityResolver;</b>
<b class="fc">&nbsp;        this.bindingResolver = bindingResolver;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a {@code static} method that is declared by the supplied type. To be considered
&nbsp;     * a valid delegation target, the target method must be visible and accessible to the instrumented type. This is the case if
&nbsp;     * the target type is either public or in the same package as the instrumented type and if the target method is either public
&nbsp;     * or non-private and in the same package as the instrumented type. Private methods can only be used as a delegation target if
&nbsp;     * the interception is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param type The target type for the delegation.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return withDefaultConfiguration().to(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a {@code static} method that is declared by the supplied type. To be considered
&nbsp;     * a valid delegation target, the target method must be visible and accessible to the instrumented type. This is the case if
&nbsp;     * the target type is either public or in the same package as the instrumented type and if the target method is either public
&nbsp;     * or non-private and in the same package as the instrumented type. Private methods can only be used as a delegation target if
&nbsp;     * the interception is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param typeDescription The target type for the delegation.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(TypeDescription typeDescription) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(typeDescription);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target The target instance for the delegation.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target) {
<b class="fc">&nbsp;        return withDefaultConfiguration().to(target);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target              The target instance for the delegation.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target    The target instance for the delegation.
&nbsp;     * @param fieldName The name of the field that is holding the {@code target} instance.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, String fieldName) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, fieldName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target              The target instance for the delegation.
&nbsp;     * @param fieldName           The name of the field that is holding the {@code target} instance.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, String fieldName, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, fieldName, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target The target instance for the delegation.
&nbsp;     * @param type   The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, Type type) {
<b class="fc">&nbsp;        return withDefaultConfiguration().to(target, type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target              The target instance for the delegation.
&nbsp;     * @param type                The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, Type type, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, type, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target    The target instance for the delegation.
&nbsp;     * @param type      The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @param fieldName The name of the field that is holding the {@code target} instance.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, Type type, String fieldName) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, type, fieldName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target              The target instance for the delegation.
&nbsp;     * @param type                The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @param fieldName           The name of the field that is holding the {@code target} instance.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, Type type, String fieldName, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, type, fieldName, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target         The target instance for the delegation.
&nbsp;     * @param typeDefinition The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, TypeDefinition typeDefinition) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, typeDefinition);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target              The target instance for the delegation.
&nbsp;     * @param typeDefinition      The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, TypeDefinition typeDefinition, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, typeDefinition, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target         The target instance for the delegation.
&nbsp;     * @param typeDefinition The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @param fieldName      The name of the field that is holding the {@code target} instance.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, TypeDefinition typeDefinition, String fieldName) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, typeDefinition, fieldName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;     * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param target              The target instance for the delegation.
&nbsp;     * @param typeDefinition      The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;     * @param fieldName           The name of the field that is holding the {@code target} instance.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation to(Object target, TypeDefinition typeDefinition, String fieldName, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().to(target, typeDefinition, fieldName, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a constructor of the supplied type. To be considered a valid delegation target,
&nbsp;     * a constructor must be visible and accessible to the instrumented type. This is the case if the constructor&#39;s declaring type is
&nbsp;     * either public or in the same package as the instrumented type and if the constructor is either public or non-private and in
&nbsp;     * the same package as the instrumented type. Private constructors can only be used as a delegation target if the delegation is
&nbsp;     * targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param type The type to construct.
&nbsp;     * @return A delegation that redirects method calls to a constructor of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation toConstructor(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return withDefaultConfiguration().toConstructor(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a constructor of the supplied type. To be considered a valid delegation target,
&nbsp;     * a constructor must be visible and accessible to the instrumented type. This is the case if the constructor&#39;s declaring type is
&nbsp;     * either public or in the same package as the instrumented type and if the constructor is either public or non-private and in
&nbsp;     * the same package as the instrumented type. Private constructors can only be used as a delegation target if the delegation is
&nbsp;     * targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param typeDescription The type to construct.
&nbsp;     * @return A delegation that redirects method calls to a constructor of the supplied type.
&nbsp;     */
&nbsp;    public static MethodDelegation toConstructor(TypeDescription typeDescription) {
<b class="nc">&nbsp;        return withDefaultConfiguration().toConstructor(typeDescription);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;     * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;     * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param name The field&#39;s name.
&nbsp;     * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;     */
&nbsp;    public static MethodDelegation toField(String name) {
<b class="fc">&nbsp;        return withDefaultConfiguration().toField(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;     * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;     * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param name                The field&#39;s name.
&nbsp;     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;     * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;     */
&nbsp;    public static MethodDelegation toField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;        return withDefaultConfiguration().toField(name, fieldLocatorFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;     * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;     * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param name                The field&#39;s name.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;     */
&nbsp;    public static MethodDelegation toField(String name, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().toField(name, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;     * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;     * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;     * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;     * a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param name                The field&#39;s name.
&nbsp;     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;     */
&nbsp;    public static MethodDelegation toField(String name, FieldLocator.Factory fieldLocatorFactory, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().toField(name, fieldLocatorFactory, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a method on an instance that is returned by a parameterless method of the
&nbsp;     * given name. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if
&nbsp;     * the method is either public or non-private and in the same package as the instrumented type. Private methods can only
&nbsp;     * be used as a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param name The name of the method that returns the delegation target.
&nbsp;     * @return A delegation that redirects invocations to the return value of a method that is declared by the instrumented type.
&nbsp;     */
&nbsp;    public static MethodDelegation toMethodReturnOf(String name) {
<b class="fc">&nbsp;        return withDefaultConfiguration().toMethodReturnOf(name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delegates any intercepted method to invoke a method on an instance that is returned by a parameterless method of the
&nbsp;     * given name. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;     * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if
&nbsp;     * the method is either public or non-private and in the same package as the instrumented type. Private methods can only
&nbsp;     * be used as a delegation target if the delegation is targeting the instrumented type.
&nbsp;     *
&nbsp;     * @param name                The name of the method that returns the delegation target.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A delegation that redirects invocations to the return value of a method that is declared by the instrumented type.
&nbsp;     */
&nbsp;    public static MethodDelegation toMethodReturnOf(String name, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return withDefaultConfiguration().toMethodReturnOf(name, methodGraphCompiler);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a configuration builder for a method delegation that is pre-configured with the ambiguity resolvers defined by
&nbsp;     * {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.AmbiguityResolver#DEFAULT} and the parameter binders
&nbsp;     * defined by {@link net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder#DEFAULTS}.
&nbsp;     *
&nbsp;     * @return A method delegation configuration with pre-configuration.
&nbsp;     */
&nbsp;    public static WithCustomProperties withDefaultConfiguration() {
<b class="fc">&nbsp;        return new WithCustomProperties(MethodDelegationBinder.AmbiguityResolver.DEFAULT, TargetMethodAnnotationDrivenBinder.ParameterBinder.DEFAULTS);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a configuration builder for a method delegation that does not apply any pre-configured
&nbsp;     * {@link net.bytebuddy.implementation.bind.MethodDelegationBinder.AmbiguityResolver}s or
&nbsp;     * {@link net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder}s.
&nbsp;     *
&nbsp;     * @return A method delegation configuration without any pre-configuration.
&nbsp;     */
&nbsp;    public static WithCustomProperties withEmptyConfiguration() {
<b class="fc">&nbsp;        return new WithCustomProperties(MethodDelegationBinder.AmbiguityResolver.NoOp.INSTANCE, Collections.&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt;emptyList());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies an assigner to the method delegation that is used for assigning method return and parameter types.
&nbsp;     *
&nbsp;     * @param assigner The assigner to apply.
&nbsp;     * @return A method delegation implementation that makes use of the given designer.
&nbsp;     */
&nbsp;    public Implementation.Composable withAssigner(Assigner assigner) {
<b class="nc">&nbsp;        return new MethodDelegation(implementationDelegate,</b>
&nbsp;                parameterBinders,
&nbsp;                ambiguityResolver,
&nbsp;                terminationHandler,
&nbsp;                bindingResolver,
&nbsp;                assigner);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Implementation andThen(Implementation implementation) {
<b class="fc">&nbsp;        return new Compound(new MethodDelegation(implementationDelegate,</b>
&nbsp;                parameterBinders,
&nbsp;                ambiguityResolver,
&nbsp;                MethodDelegationBinder.TerminationHandler.Default.DROPPING,
&nbsp;                bindingResolver,
&nbsp;                assigner), implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;        return new Compound.Composable(new MethodDelegation(implementationDelegate,</b>
&nbsp;                parameterBinders,
&nbsp;                ambiguityResolver,
&nbsp;                MethodDelegationBinder.TerminationHandler.Default.DROPPING,
&nbsp;                bindingResolver,
&nbsp;                assigner), implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        return implementationDelegate.prepare(instrumentedType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        ImplementationDelegate.Compiled compiled = implementationDelegate.compile(implementationTarget.getInstrumentedType());</b>
<b class="fc">&nbsp;        return new Appender(implementationTarget,</b>
<b class="fc">&nbsp;                new MethodDelegationBinder.Processor(compiled.getRecords(), ambiguityResolver, bindingResolver),</b>
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                compiled);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation delegate is responsible for executing the actual method delegation and for resolving the target methods.
&nbsp;     */
&nbsp;    protected interface ImplementationDelegate extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;        /**
&nbsp;         * A name prefix for fields.
&nbsp;         */
&nbsp;        String FIELD_NAME_PREFIX = &quot;delegate&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles this implementation delegate.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return A compiled implementation delegate.
&nbsp;         */
&nbsp;        Compiled compile(TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * A compiled implementation delegate.
&nbsp;         */
&nbsp;        interface Compiled {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a stack manipulation that prepares the delegation invocation.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return A stack manipulation that is applied prior to loading arguments and executing the method call.
&nbsp;             */
&nbsp;            StackManipulation prepare(MethodDescription instrumentedMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an invoker to use for invoking the delegation target.
&nbsp;             *
&nbsp;             * @return The method invoker to use.
&nbsp;             */
&nbsp;            MethodDelegationBinder.MethodInvoker invoke();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a list of binding records to consider for delegation.
&nbsp;             *
&nbsp;             * @return A list of delegation binder records to consider.
&nbsp;             */
&nbsp;            List&lt;MethodDelegationBinder.Record&gt; getRecords();
&nbsp;
&nbsp;            /**
&nbsp;             * A compiled implementation delegate for invoking a static method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForStaticCall implements Compiled {
&nbsp;
&nbsp;                /**
&nbsp;                 * The list of records to consider.
&nbsp;                 */
&nbsp;                private final List&lt;MethodDelegationBinder.Record&gt; records;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compiled implementation delegate for a static method call.
&nbsp;                 *
&nbsp;                 * @param records The list of records to consider.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForStaticCall(List&lt;MethodDelegationBinder.Record&gt; records) {</b>
<b class="fc">&nbsp;                    this.records = records;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation prepare(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDelegationBinder.MethodInvoker invoke() {
<b class="fc">&nbsp;                    return MethodDelegationBinder.MethodInvoker.Simple.INSTANCE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;MethodDelegationBinder.Record&gt; getRecords() {
<b class="fc">&nbsp;                    return records;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compiled implementation delegate that invokes methods on a field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForField implements Compiled {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to delegate to.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The records to consider for delegation.
&nbsp;                 */
&nbsp;                private final List&lt;MethodDelegationBinder.Record&gt; records;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compiled implementation delegate for a field delegation.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The field to delegate to.
&nbsp;                 * @param records          The records to consider for delegation.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForField(FieldDescription fieldDescription, List&lt;MethodDelegationBinder.Record&gt; records) {</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                    this.records = records;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation prepare(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    if (instrumentedMethod.isStatic() &amp;&amp; !fieldDescription.isStatic()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot read &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                            : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDelegationBinder.MethodInvoker invoke() {
<b class="fc">&nbsp;                    return new MethodDelegationBinder.MethodInvoker.Virtual(fieldDescription.getType().asErasure());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;MethodDelegationBinder.Record&gt; getRecords() {
<b class="fc">&nbsp;                    return records;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compiled implementation delegate that invokes a method on an instance that is returned by another method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForMethodReturn implements Compiled {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method to call for result.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The records to consider for delegation.
&nbsp;                 */
&nbsp;                private final List&lt;MethodDelegationBinder.Record&gt; records;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compiled implementation delegate for a field delegation.
&nbsp;                 *
&nbsp;                 * @param methodDescription The method to call for result.
&nbsp;                 * @param records           The records to consider for delegation.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForMethodReturn(MethodDescription methodDescription, List&lt;MethodDelegationBinder.Record&gt; records) {</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    this.records = records;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation prepare(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    if (instrumentedMethod.isStatic() &amp;&amp; !methodDescription.isStatic()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + methodDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(methodDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                            : MethodVariableAccess.loadThis(), MethodInvocation.invoke(methodDescription));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDelegationBinder.MethodInvoker invoke() {
<b class="fc">&nbsp;                    return new MethodDelegationBinder.MethodInvoker.Virtual(methodDescription.getReturnType().asErasure());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;MethodDelegationBinder.Record&gt; getRecords() {
<b class="fc">&nbsp;                    return records;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compiled implementation delegate for a constructor delegation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForConstruction implements Compiled {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type to be constructed.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The records to consider for delegation.
&nbsp;                 */
&nbsp;                private final List&lt;MethodDelegationBinder.Record&gt; records;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compiled implementation delegate for a constructor delegation.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type to be constructed.
&nbsp;                 * @param records         The records to consider for delegation.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForConstruction(TypeDescription typeDescription, List&lt;MethodDelegationBinder.Record&gt; records) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                    this.records = records;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation prepare(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return new StackManipulation.Compound(TypeCreation.of(typeDescription), Duplication.SINGLE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDelegationBinder.MethodInvoker invoke() {
<b class="fc">&nbsp;                    return MethodDelegationBinder.MethodInvoker.Simple.INSTANCE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;MethodDelegationBinder.Record&gt; getRecords() {
<b class="fc">&nbsp;                    return records;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation delegate for a static method delegation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForStaticMethod implements ImplementationDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * The precompiled records.
&nbsp;             */
&nbsp;            private final List&lt;MethodDelegationBinder.Record&gt; records;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation delegate for a static method delegation.
&nbsp;             *
&nbsp;             * @param records The precompiled record.
&nbsp;             */
<b class="fc">&nbsp;            protected ForStaticMethod(List&lt;MethodDelegationBinder.Record&gt; records) {</b>
<b class="fc">&nbsp;                this.records = records;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Precompiles a static method delegation for a given list of methods.
&nbsp;             *
&nbsp;             * @param methods                The methods to consider.
&nbsp;             * @param methodDelegationBinder The method delegation binder to use.
&nbsp;             * @return An appropriate implementation delegate.
&nbsp;             */
&nbsp;            protected static ImplementationDelegate of(MethodList&lt;?&gt; methods, MethodDelegationBinder methodDelegationBinder) {
<b class="fc">&nbsp;                List&lt;MethodDelegationBinder.Record&gt; records = new ArrayList&lt;MethodDelegationBinder.Record&gt;(methods.size());</b>
<b class="fc">&nbsp;                for (MethodDescription methodDescription : methods) {</b>
<b class="fc">&nbsp;                    records.add(methodDelegationBinder.compile(methodDescription));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new ForStaticMethod(records);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ImplementationDelegate.Compiled compile(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new Compiled.ForStaticCall(records);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation delegate for invoking methods on a field that is declared by the instrumented type or a super type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class ForField implements ImplementationDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the field that is target of the delegation.
&nbsp;             */
&nbsp;            protected final String fieldName;
&nbsp;
&nbsp;            /**
&nbsp;             * The method graph compiler to use.
&nbsp;             */
&nbsp;            protected final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter binders to use.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders;
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to use for filtering methods.
&nbsp;             */
&nbsp;            protected final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation delegate for a field delegation.
&nbsp;             *
&nbsp;             * @param fieldName           The name of the field that is target of the delegation.
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param parameterBinders    The parameter binders to use.
&nbsp;             * @param matcher             The matcher to use for filtering methods.
&nbsp;             */
&nbsp;            protected ForField(String fieldName,
&nbsp;                               MethodGraph.Compiler methodGraphCompiler,
&nbsp;                               List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
<b class="fc">&nbsp;                               ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                this.fieldName = fieldName;</b>
<b class="fc">&nbsp;                this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;                this.parameterBinders = parameterBinders;</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                FieldDescription fieldDescription = resolve(instrumentedType);</b>
<b class="fc">&nbsp;                if (!fieldDescription.getType().asErasure().isVisibleTo(instrumentedType)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(fieldDescription + &quot; is not visible to &quot; + instrumentedType);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    MethodList&lt;?&gt; candidates = methodGraphCompiler.compile(fieldDescription.getType(), instrumentedType)</b>
<b class="fc">&nbsp;                            .listNodes()</b>
<b class="fc">&nbsp;                            .asMethodList()</b>
<b class="fc">&nbsp;                            .filter(matcher);</b>
<b class="fc">&nbsp;                    List&lt;MethodDelegationBinder.Record&gt; records = new ArrayList&lt;MethodDelegationBinder.Record&gt;(candidates.size());</b>
<b class="fc">&nbsp;                    MethodDelegationBinder methodDelegationBinder = TargetMethodAnnotationDrivenBinder.of(parameterBinders);</b>
<b class="fc">&nbsp;                    for (MethodDescription candidate : candidates) {</b>
<b class="fc">&nbsp;                        records.add(methodDelegationBinder.compile(candidate));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new Compiled.ForField(fieldDescription, records);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the field to which is delegated.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return The field that is the delegation target.
&nbsp;             */
&nbsp;            protected abstract FieldDescription resolve(TypeDescription instrumentedType);
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation target for a static field that is declared by the instrumented type and that is assigned an instance.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class WithInstance extends ForField {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target instance.
&nbsp;                 */
&nbsp;                private final Object target;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s type.
&nbsp;                 */
&nbsp;                private final TypeDescription.Generic fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new implementation delegate for invoking methods on a supplied instance.
&nbsp;                 *
&nbsp;                 * @param fieldName           The name of the field that is target of the delegation.
&nbsp;                 * @param methodGraphCompiler The method graph compiler to use.
&nbsp;                 * @param parameterBinders    The parameter binders to use.
&nbsp;                 * @param matcher             The matcher to use for filtering methods.
&nbsp;                 * @param target              The target instance.
&nbsp;                 * @param fieldType           The field&#39;s type.
&nbsp;                 */
&nbsp;                protected WithInstance(String fieldName,
&nbsp;                                       MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                       List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
&nbsp;                                       ElementMatcher&lt;? super MethodDescription&gt; matcher,
&nbsp;                                       Object target,
&nbsp;                                       TypeDescription.Generic fieldType) {
<b class="fc">&nbsp;                    super(fieldName, methodGraphCompiler, parameterBinders, matcher);</b>
<b class="fc">&nbsp;                    this.target = target;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(fieldName,</b>
&nbsp;                            Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC,
&nbsp;                            fieldType), target);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    if (!fieldType.asErasure().isVisibleTo(instrumentedType)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(fieldType + &quot; is not visible to &quot; + instrumentedType);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return instrumentedType.getDeclaredFields()</b>
<b class="fc">&nbsp;                                .filter(named(fieldName).and(fieldType(fieldType.asErasure())))</b>
<b class="fc">&nbsp;                                .getOnly();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation target for a field that is declared by the instrumented type or a super type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class WithLookup extends ForField {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field locator factory to use for locating the field to delegate to.
&nbsp;                 */
&nbsp;                private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new implementation delegate for a field that is declared by the instrumented type or any super type.
&nbsp;                 *
&nbsp;                 * @param fieldName           The name of the field that is target of the delegation.
&nbsp;                 * @param methodGraphCompiler The method graph compiler to use.
&nbsp;                 * @param parameterBinders    The parameter binders to use.
&nbsp;                 * @param matcher             The matcher to use for filtering methods.
&nbsp;                 * @param fieldLocatorFactory The field locator factory to use for locating the field to delegate to.
&nbsp;                 */
&nbsp;                protected WithLookup(String fieldName,
&nbsp;                                     MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                     List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
&nbsp;                                     ElementMatcher&lt;? super MethodDescription&gt; matcher,
&nbsp;                                     FieldLocator.Factory fieldLocatorFactory) {
<b class="fc">&nbsp;                    super(fieldName, methodGraphCompiler, parameterBinders, matcher);</b>
<b class="fc">&nbsp;                    this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(fieldName);</b>
<b class="fc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Could not locate &quot; + fieldName + &quot; on &quot; + instrumentedType);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return resolution.getField();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation delegate for invoking a delegation target on the another methods return value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodReturn implements ImplementationDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the method to invoke.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * The method graph compiler to use.
&nbsp;             */
&nbsp;            private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter binders to use.
&nbsp;             */
&nbsp;            private final List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders;
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to use for filtering methods.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation delegate for a method return value delegation.
&nbsp;             *
&nbsp;             * @param name                The name of the method to invoke.
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param parameterBinders    The parameter binders to use.
&nbsp;             * @param matcher             The matcher to use for filtering methods.
&nbsp;             */
&nbsp;            protected ForMethodReturn(String name,
&nbsp;                                      MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                      List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
<b class="fc">&nbsp;                                      ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                this.name = name;</b>
<b class="fc">&nbsp;                this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;                this.parameterBinders = parameterBinders;</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                MethodList&lt;?&gt; targets = new MethodList.Explicit&lt;MethodDescription&gt;(CompoundList.&lt;MethodDescription&gt;of(</b>
<b class="fc">&nbsp;                        instrumentedType.getDeclaredMethods().filter(isStatic().or(isPrivate())),</b>
<b class="fc">&nbsp;                        methodGraphCompiler.compile((TypeDefinition) instrumentedType).listNodes().asMethodList())</b>
<b class="fc">&nbsp;                ).filter(named(name).and(takesArguments(0)).and(not(returns(isPrimitive().or(isArray())))));</b>
<b class="fc">&nbsp;                if (targets.size() != 1) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; does not define method without arguments with name &quot; + name + &quot;: &quot; + targets);</b>
<b class="fc">&nbsp;                } else if (!targets.getOnly().getReturnType().asErasure().isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(targets.getOnly() + &quot; is not visible to &quot; + instrumentedType);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    MethodList&lt;?&gt; candidates = methodGraphCompiler.compile(targets.getOnly().getReturnType(), instrumentedType)</b>
<b class="fc">&nbsp;                            .listNodes()</b>
<b class="fc">&nbsp;                            .asMethodList()</b>
<b class="fc">&nbsp;                            .filter(matcher);</b>
<b class="fc">&nbsp;                    List&lt;MethodDelegationBinder.Record&gt; records = new ArrayList&lt;MethodDelegationBinder.Record&gt;(candidates.size());</b>
<b class="fc">&nbsp;                    MethodDelegationBinder methodDelegationBinder = TargetMethodAnnotationDrivenBinder.of(parameterBinders);</b>
<b class="fc">&nbsp;                    for (MethodDescription candidate : candidates) {</b>
<b class="fc">&nbsp;                        records.add(methodDelegationBinder.compile(candidate));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new Compiled.ForMethodReturn(targets.get(0), records);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation delegate for constructing an instance.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForConstruction implements ImplementationDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * The type being constructed.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The precompiled delegation records.
&nbsp;             */
&nbsp;            private final List&lt;MethodDelegationBinder.Record&gt; records;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an implementation delegate for constructing a new instance.
&nbsp;             *
&nbsp;             * @param typeDescription The type being constructed.
&nbsp;             * @param records         The precompiled delegation records.
&nbsp;             */
<b class="fc">&nbsp;            protected ForConstruction(TypeDescription typeDescription, List&lt;MethodDelegationBinder.Record&gt; records) {</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.records = records;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an implementation delegate for constructing a new instance.
&nbsp;             *
&nbsp;             * @param typeDescription        The type being constructed.
&nbsp;             * @param methods                The constructors to consider.
&nbsp;             * @param methodDelegationBinder The method delegation binder to use.
&nbsp;             * @return An appropriate implementation delegate.
&nbsp;             */
&nbsp;            protected static ImplementationDelegate of(TypeDescription typeDescription,
&nbsp;                                                       MethodList&lt;?&gt; methods,
&nbsp;                                                       MethodDelegationBinder methodDelegationBinder) {
<b class="fc">&nbsp;                List&lt;MethodDelegationBinder.Record&gt; records = new ArrayList&lt;MethodDelegationBinder.Record&gt;(methods.size());</b>
<b class="fc">&nbsp;                for (MethodDescription methodDescription : methods) {</b>
<b class="fc">&nbsp;                    records.add(methodDelegationBinder.compile(methodDescription));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new ForConstruction(typeDescription, records);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new Compiled.ForConstruction(typeDescription, records);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The appender for implementing a {@link net.bytebuddy.implementation.MethodDelegation}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation target of this implementation.
&nbsp;         */
&nbsp;        private final Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * The method delegation binder processor which is responsible for implementing the method delegation.
&nbsp;         */
&nbsp;        private final MethodDelegationBinder.Record processor;
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler for a method delegation binder.
&nbsp;         */
&nbsp;        private final MethodDelegationBinder.TerminationHandler terminationHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * The assigner to use.
&nbsp;         */
&nbsp;        private final Assigner assigner;
&nbsp;
&nbsp;        /**
&nbsp;         * The compiled implementation delegate.
&nbsp;         */
&nbsp;        private final ImplementationDelegate.Compiled compiled;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender for a method delegation.
&nbsp;         *
&nbsp;         * @param implementationTarget The implementation target of this implementation.
&nbsp;         * @param processor            The method delegation binder processor which is responsible for implementing the method delegation.
&nbsp;         * @param terminationHandler   A termination handler for a method delegation binder.
&nbsp;         * @param assigner             The assigner to use.
&nbsp;         * @param compiled             The compiled implementation delegate.
&nbsp;         */
&nbsp;        protected Appender(Target implementationTarget,
&nbsp;                           MethodDelegationBinder.Record processor,
&nbsp;                           MethodDelegationBinder.TerminationHandler terminationHandler,
&nbsp;                           Assigner assigner,
<b class="fc">&nbsp;                           ImplementationDelegate.Compiled compiled) {</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;            this.processor = processor;</b>
<b class="fc">&nbsp;            this.terminationHandler = terminationHandler;</b>
<b class="fc">&nbsp;            this.assigner = assigner;</b>
<b class="fc">&nbsp;            this.compiled = compiled;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                    compiled.prepare(instrumentedMethod),</b>
<b class="fc">&nbsp;                    processor.bind(implementationTarget, instrumentedMethod, terminationHandler, compiled.invoke(), assigner)</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;            return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link MethodDelegation} with custom configuration.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class WithCustomProperties {
&nbsp;
&nbsp;        /**
&nbsp;         * The ambiguity resolver to use.
&nbsp;         */
&nbsp;        private final MethodDelegationBinder.AmbiguityResolver ambiguityResolver;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter binders to use.
&nbsp;         */
&nbsp;        private final List&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders;
&nbsp;
&nbsp;        /**
&nbsp;         * The binding resolver being used to select the relevant method binding.
&nbsp;         */
&nbsp;        private final MethodDelegationBinder.BindingResolver bindingResolver;
&nbsp;
&nbsp;        /**
&nbsp;         * The matcher to use for filtering relevant methods.
&nbsp;         */
&nbsp;        private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method delegation with custom properties that does not filter any methods.
&nbsp;         *
&nbsp;         * @param ambiguityResolver The ambiguity resolver to use.
&nbsp;         * @param parameterBinders  The parameter binders to use.
&nbsp;         */
&nbsp;        protected WithCustomProperties(MethodDelegationBinder.AmbiguityResolver ambiguityResolver,
&nbsp;                                       List&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders) {
<b class="fc">&nbsp;            this(ambiguityResolver, parameterBinders, MethodDelegationBinder.BindingResolver.Default.INSTANCE, any());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method delegation with custom properties.
&nbsp;         *
&nbsp;         * @param ambiguityResolver The ambiguity resolver to use.
&nbsp;         * @param parameterBinders  The parameter binders to use.
&nbsp;         * @param bindingResolver   The binding resolver being used to select the relevant method binding.
&nbsp;         * @param matcher           The matcher to use for filtering relevant methods.
&nbsp;         */
&nbsp;        private WithCustomProperties(MethodDelegationBinder.AmbiguityResolver ambiguityResolver,
&nbsp;                                     List&lt;TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders,
&nbsp;                                     MethodDelegationBinder.BindingResolver bindingResolver,
<b class="fc">&nbsp;                                     ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;            this.ambiguityResolver = ambiguityResolver;</b>
<b class="fc">&nbsp;            this.parameterBinders = parameterBinders;</b>
<b class="fc">&nbsp;            this.bindingResolver = bindingResolver;</b>
<b class="fc">&nbsp;            this.matcher = matcher;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Configures this method delegation to use the supplied ambiguity resolvers when deciding which out of two ore
&nbsp;         * more legal delegation targets should be considered.
&nbsp;         *
&nbsp;         * @param ambiguityResolver The ambiguity resolvers to use in their application order.
&nbsp;         * @return A new delegation configuration which also applies the supplied ambiguity resolvers.
&nbsp;         */
&nbsp;        public WithCustomProperties withResolvers(MethodDelegationBinder.AmbiguityResolver... ambiguityResolver) {
<b class="fc">&nbsp;            return withResolvers(Arrays.asList(ambiguityResolver));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Configures this method delegation to use the supplied ambiguity resolvers when deciding which out of two ore
&nbsp;         * more legal delegation targets should be considered.
&nbsp;         *
&nbsp;         * @param ambiguityResolvers The ambiguity resolvers to use in their application order.
&nbsp;         * @return A new delegation configuration which also applies the supplied ambiguity resolvers.
&nbsp;         */
&nbsp;        public WithCustomProperties withResolvers(List&lt;? extends MethodDelegationBinder.AmbiguityResolver&gt; ambiguityResolvers) {
<b class="fc">&nbsp;            return new WithCustomProperties(new MethodDelegationBinder.AmbiguityResolver.Compound(CompoundList.of(this.ambiguityResolver,</b>
&nbsp;                    ambiguityResolvers)), parameterBinders, bindingResolver, matcher);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Configures this method delegation to use the supplied parameter binders when deciding what value to assign to
&nbsp;         * a parameter of a delegation target.
&nbsp;         *
&nbsp;         * @param parameterBinder The parameter binders to use.
&nbsp;         * @return A new delegation configuration which also applies the supplied parameter binders.
&nbsp;         */
&nbsp;        public WithCustomProperties withBinders(TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;... parameterBinder) {
<b class="fc">&nbsp;            return withBinders(Arrays.asList(parameterBinder));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Configures this method delegation to use the supplied parameter binders when deciding what value to assign to
&nbsp;         * a parameter of a delegation target.
&nbsp;         *
&nbsp;         * @param parameterBinders The parameter binders to use.
&nbsp;         * @return A new delegation configuration which also applies the supplied parameter binders.
&nbsp;         */
&nbsp;        public WithCustomProperties withBinders(List&lt;? extends TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;?&gt;&gt; parameterBinders) {
<b class="fc">&nbsp;            return new WithCustomProperties(ambiguityResolver, CompoundList.of(this.parameterBinders, parameterBinders), bindingResolver, matcher);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Configures a custom binding resolver which is responsible for choosing a method binding among multiple candidates. Configuring
&nbsp;         * a resolver overrides any previous configuration.
&nbsp;         *
&nbsp;         * @param bindingResolver The binding resolver being used to select the relevant method binding.
&nbsp;         * @return A new delegation configuration which applies the supplied binding resolver.
&nbsp;         */
&nbsp;        public WithCustomProperties withBindingResolver(MethodDelegationBinder.BindingResolver bindingResolver) {
<b class="nc">&nbsp;            return new WithCustomProperties(ambiguityResolver, parameterBinders, bindingResolver, matcher);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Configures this method delegation to only consider methods or constructors as a delegation target if they match the supplied matcher.
&nbsp;         *
&nbsp;         * @param matcher The matcher any delegation target needs to match in order to be considered a for delegation.
&nbsp;         * @return A new delegation configuration which only considers methods for delegation if they match the supplied matcher.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public WithCustomProperties filter(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;            return new WithCustomProperties(ambiguityResolver,</b>
&nbsp;                    parameterBinders,
&nbsp;                    bindingResolver,
&nbsp;                    new ElementMatcher.Junction.Conjunction&lt;MethodDescription&gt;(this.matcher, matcher));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a {@code static} method that is declared by the supplied type. To be considered
&nbsp;         * a valid delegation target, the target method must be visible and accessible to the instrumented type. This is the case if
&nbsp;         * the target type is either public or in the same package as the instrumented type and if the target method is either public
&nbsp;         * or non-private and in the same package as the instrumented type. Private methods can only be used as a delegation target if
&nbsp;         * the interception is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param type The target type for the delegation.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return to(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a {@code static} method that is declared by the supplied type. To be considered
&nbsp;         * a valid delegation target, the target method must be visible and accessible to the instrumented type. This is the case if
&nbsp;         * the target type is either public or in the same package as the instrumented type and if the target method is either public
&nbsp;         * or non-private and in the same package as the instrumented type. Private methods can only be used as a delegation target if
&nbsp;         * the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param typeDescription The target type for the delegation.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(TypeDescription typeDescription) {
<b class="fc">&nbsp;            if (typeDescription.isArray()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot delegate to array &quot; + typeDescription);</b>
<b class="fc">&nbsp;            } else if (typeDescription.isPrimitive()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot delegate to primitive &quot; + typeDescription);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new MethodDelegation(ImplementationDelegate.ForStaticMethod.of(typeDescription.getDeclaredMethods().filter(isStatic().and(matcher)),</b>
<b class="fc">&nbsp;                    TargetMethodAnnotationDrivenBinder.of(parameterBinders)), parameterBinders, ambiguityResolver, bindingResolver);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target The target instance for the delegation.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target) {
<b class="fc">&nbsp;            return to(target, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target              The target instance for the delegation.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            return to(target, target.getClass(), methodGraphCompiler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target    The target instance for the delegation.
&nbsp;         * @param fieldName The name of the field that is holding the {@code target} instance.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, String fieldName) {
<b class="nc">&nbsp;            return to(target, fieldName, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target              The target instance for the delegation.
&nbsp;         * @param fieldName           The name of the field that is holding the {@code target} instance.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, String fieldName, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;            return to(target, target.getClass(), fieldName, methodGraphCompiler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target The target instance for the delegation.
&nbsp;         * @param type   The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, Type type) {
<b class="fc">&nbsp;            return to(target, type, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target              The target instance for the delegation.
&nbsp;         * @param type                The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, Type type, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            return to(target,</b>
&nbsp;                    type,
<b class="fc">&nbsp;                    ImplementationDelegate.FIELD_NAME_PREFIX + &quot;$&quot; + RandomString.hashOf(target),</b>
&nbsp;                    methodGraphCompiler);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target    The target instance for the delegation.
&nbsp;         * @param type      The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @param fieldName The name of the field that is holding the {@code target} instance.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, Type type, String fieldName) {
<b class="nc">&nbsp;            return to(target, type, fieldName, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target              The target instance for the delegation.
&nbsp;         * @param type                The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @param fieldName           The name of the field that is holding the {@code target} instance.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, Type type, String fieldName, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            return to(target, TypeDefinition.Sort.describe(type), fieldName, methodGraphCompiler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target         The target instance for the delegation.
&nbsp;         * @param typeDefinition The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, TypeDefinition typeDefinition) {
<b class="nc">&nbsp;            return to(target, typeDefinition, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target              The target instance for the delegation.
&nbsp;         * @param typeDefinition      The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, TypeDefinition typeDefinition, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;            return to(target,</b>
&nbsp;                    typeDefinition,
<b class="nc">&nbsp;                    ImplementationDelegate.FIELD_NAME_PREFIX + &quot;$&quot; + RandomString.hashOf(target),</b>
&nbsp;                    methodGraphCompiler);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target         The target instance for the delegation.
&nbsp;         * @param typeDefinition The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @param fieldName      The name of the field that is holding the {@code target} instance.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, TypeDefinition typeDefinition, String fieldName) {
<b class="nc">&nbsp;            return to(target, typeDefinition, fieldName, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method that is declared by the supplied type&#39;s instance or any
&nbsp;         * of its super types. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param target              The target instance for the delegation.
&nbsp;         * @param typeDefinition      The most specific type of which {@code target} should be considered. Must be a super type of the target&#39;s actual type.
&nbsp;         * @param fieldName           The name of the field that is holding the {@code target} instance.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A method delegation that redirects method calls to a static method of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation to(Object target, TypeDefinition typeDefinition, String fieldName, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            if (!typeDefinition.asErasure().isInstance(target)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(target + &quot; is not an instance of &quot; + typeDefinition);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new MethodDelegation(new ImplementationDelegate.ForField.WithInstance(fieldName,</b>
&nbsp;                    methodGraphCompiler,
&nbsp;                    parameterBinders,
&nbsp;                    matcher,
&nbsp;                    target,
<b class="fc">&nbsp;                    typeDefinition.asGenericType()), parameterBinders, ambiguityResolver, bindingResolver);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a constructor of the supplied type. To be considered a valid delegation target,
&nbsp;         * a constructor must be visible and accessible to the instrumented type. This is the case if the constructor&#39;s declaring type is
&nbsp;         * either public or in the same package as the instrumented type and if the constructor is either public or non-private and in
&nbsp;         * the same package as the instrumented type. Private constructors can only be used as a delegation target if the delegation is
&nbsp;         * targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param type The type to construct.
&nbsp;         * @return A delegation that redirects method calls to a constructor of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation toConstructor(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return toConstructor(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a constructor of the supplied type. To be considered a valid delegation target,
&nbsp;         * a constructor must be visible and accessible to the instrumented type. This is the case if the constructor&#39;s declaring type is
&nbsp;         * either public or in the same package as the instrumented type and if the constructor is either public or non-private and in
&nbsp;         * the same package as the instrumented type. Private constructors can only be used as a delegation target if the delegation is
&nbsp;         * targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param typeDescription The type to construct.
&nbsp;         * @return A delegation that redirects method calls to a constructor of the supplied type.
&nbsp;         */
&nbsp;        public MethodDelegation toConstructor(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return new MethodDelegation(ImplementationDelegate.ForConstruction.of(typeDescription,</b>
<b class="fc">&nbsp;                    typeDescription.getDeclaredMethods().filter(isConstructor().and(matcher)),</b>
<b class="fc">&nbsp;                    TargetMethodAnnotationDrivenBinder.of(parameterBinders)), parameterBinders, ambiguityResolver, bindingResolver);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;         * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;         * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param name The field&#39;s name.
&nbsp;         * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;         */
&nbsp;        public MethodDelegation toField(String name) {
<b class="fc">&nbsp;            return toField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;         * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;         * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param name                The field&#39;s name.
&nbsp;         * @param fieldLocatorFactory The field locator factory to use.
&nbsp;         * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;         */
&nbsp;        public MethodDelegation toField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="fc">&nbsp;            return toField(name, fieldLocatorFactory, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;         * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;         * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param name                The field&#39;s name.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;         */
&nbsp;        public MethodDelegation toField(String name, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;            return toField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE, methodGraphCompiler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a non-{@code static} method on the instance of the supplied field. To be
&nbsp;         * considered a valid delegation target, a method must be visible and accessible to the instrumented type. This is the
&nbsp;         * case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if the method
&nbsp;         * is either public or non-private and in the same package as the instrumented type. Private methods can only be used as
&nbsp;         * a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param name                The field&#39;s name.
&nbsp;         * @param fieldLocatorFactory The field locator factory to use.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A delegation that redirects invocations to a method of the specified field&#39;s instance.
&nbsp;         */
&nbsp;        public MethodDelegation toField(String name, FieldLocator.Factory fieldLocatorFactory, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            return new MethodDelegation(new ImplementationDelegate.ForField.WithLookup(name,</b>
&nbsp;                    methodGraphCompiler,
&nbsp;                    parameterBinders,
&nbsp;                    matcher,
&nbsp;                    fieldLocatorFactory), parameterBinders, ambiguityResolver, bindingResolver);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a method on an instance that is returned by a parameterless method of the
&nbsp;         * given name. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if
&nbsp;         * the method is either public or non-private and in the same package as the instrumented type. Private methods can only
&nbsp;         * be used as a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param name The name of the method that returns the delegation target.
&nbsp;         * @return A delegation that redirects invocations to the return value of a method that is declared by the instrumented type.
&nbsp;         */
&nbsp;        public MethodDelegation toMethodReturnOf(String name) {
<b class="fc">&nbsp;            return toMethodReturnOf(name, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Delegates any intercepted method to invoke a method on an instance that is returned by a parameterless method of the
&nbsp;         * given name. To be considered a valid delegation target, a method must be visible and accessible to the instrumented type.
&nbsp;         * This is the case if the method&#39;s declaring type is either public or in the same package as the instrumented type and if
&nbsp;         * the method is either public or non-private and in the same package as the instrumented type. Private methods can only
&nbsp;         * be used as a delegation target if the delegation is targeting the instrumented type.
&nbsp;         *
&nbsp;         * @param name                The name of the method that returns the delegation target.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @return A delegation that redirects invocations to the return value of a method that is declared by the instrumented type.
&nbsp;         */
&nbsp;        public MethodDelegation toMethodReturnOf(String name, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            return new MethodDelegation(new ImplementationDelegate.ForMethodReturn(name,</b>
&nbsp;                    methodGraphCompiler,
&nbsp;                    parameterBinders,
&nbsp;                    matcher), parameterBinders, ambiguityResolver, bindingResolver);
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 16:00</div>
</div>
</body>
</html>
