


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodGraph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: MethodGraph (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">MethodGraph$Compiler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.1%
  </span>
  <span class="absValue">
    (41/45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJavaMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJavaMethod$Token</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJVMMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Harmonizer$ForJVMMethod$Token</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Detached</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Harmonized</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97%
  </span>
  <span class="absValue">
    (32/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (67/67)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Ambiguous</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.2%
  </span>
  <span class="absValue">
    (43/55)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Ambiguous$Node</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Initial</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (8/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$MockitoMock$594383175</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$MockitoMock$594383175$auxiliary$yfy8Y2FM</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$MockitoMock$594383175$auxiliary$YyY8qVok</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Entry$Resolved$Node</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Key$Store$Graph</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger$Directional</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger$MockitoMock$1781441735</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger$MockitoMock$1781441735$auxiliary$J9av1oio</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$Default$Merger$MockitoMock$1781441735$auxiliary$xJG99tv9</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$ForDeclaredMethods</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$MockitoMock$42941559</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$MockitoMock$42941559$auxiliary$AkojyDNS</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Compiler$MockitoMock$42941559$auxiliary$EOyweqTo</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Empty</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked$Delegation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked$MockitoMock$1266758063</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked$MockitoMock$1266758063$auxiliary$rYWimEP1</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Linked$MockitoMock$1266758063$auxiliary$VaMGnJkh</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$MockitoMock$679579131</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$MockitoMock$679579131$auxiliary$C2BBvot2</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$MockitoMock$679579131$auxiliary$XIv5TaoB</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$MockitoMock$77832331</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$MockitoMock$77832331$auxiliary$npKOX7hI</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$MockitoMock$77832331$auxiliary$osfmKdIc</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Node$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$0059rTd8</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$3mNX6L6L</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$4hWdo6Xk</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$7OLnD33w</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$A4Am7RAB</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$c01rRM6u</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$Cyzz9bH8</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$DHVQTNuH</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$DqfDObTk</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$eb1IBUG5</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$EnWwTy70</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$FqH3DcHI</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$GQ97Phfd</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$Hka5CH63</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$HUga5B9B</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$iCVSiEpV</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$JUma16EA</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$jyGNeh24</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$K09dcb99</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$M0I14hKE</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$nSaeh8fQ</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$NWxiqu78</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$PD6JkRGB</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$PYDeEL39</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$qHF9mX0S</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$QJgdEswk</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$rqTxiIa1</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$sfrVj5ji</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$sHdRCzWv</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$T6brv4x5</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$tQHkphES</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$whRfq37L</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$x7Ctfry6</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$xDW3zIwi</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$xlcAOwJr</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$XM4lnTOu</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$XoCJh3Vi</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$NodeList$MockitoMock$1309053449$auxiliary$yV332Dg6</td>
  </tr>
  <tr>
    <td class="name">MethodGraph$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    89.1%
  </span>
  <span class="absValue">
    (123/138)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.1%
  </span>
  <span class="absValue">
    (365/405)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.FilterableList;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A method graph represents a view on a set of methods as they are seen from a given type. Any method is represented as a node that represents
&nbsp; * a method, its bridge methods, its resolution state and information on if it was made visible by a visibility bridge.
&nbsp; */
&nbsp;public interface MethodGraph {
&nbsp;
&nbsp;    /**
&nbsp;     * Locates a node in this graph which represents the provided method token.
&nbsp;     *
&nbsp;     * @param token A method token that represents the method to be located.
&nbsp;     * @return The node representing the given token.
&nbsp;     */
&nbsp;    Node locate(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;    /**
&nbsp;     * Lists all nodes of this method graph.
&nbsp;     *
&nbsp;     * @return A list of all nodes of this method graph.
&nbsp;     */
&nbsp;    NodeList listNodes();
&nbsp;
&nbsp;    /**
&nbsp;     * A canonical implementation of an empty method graph.
&nbsp;     */
<b class="fc">&nbsp;    enum Empty implements MethodGraph.Linked, MethodGraph.Compiler {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Node locate(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;            return Node.Unresolved.INSTANCE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public NodeList listNodes() {
<b class="fc">&nbsp;            return new NodeList(Collections.&lt;Node&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodGraph getSuperClassGraph() {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodGraph getInterfaceGraph(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Linked compile(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public Linked compile(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A linked method graph represents a view that additionally exposes information of a given type&#39;s super type view and a
&nbsp;     * view on this graph&#39;s directly implemented interfaces.
&nbsp;     */
&nbsp;    interface Linked extends MethodGraph {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a graph representing the view on this represented type&#39;s super type.
&nbsp;         *
&nbsp;         * @return A graph representing the view on this represented type&#39;s super type.
&nbsp;         */
&nbsp;        MethodGraph getSuperClassGraph();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a graph representing the view on this represented type&#39;s directly implemented interface type.
&nbsp;         *
&nbsp;         * @param typeDescription The interface type for which a view is to be returned.
&nbsp;         * @return A graph representing the view on this represented type&#39;s directly implemented interface type.
&nbsp;         */
&nbsp;        MethodGraph getInterfaceGraph(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * A simple implementation of a linked method graph that exposes views by delegation to given method graphs.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Delegation implements Linked {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented type&#39;s method graph.
&nbsp;             */
&nbsp;            private final MethodGraph methodGraph;
&nbsp;
&nbsp;            /**
&nbsp;             * The super class&#39;s method graph.
&nbsp;             */
&nbsp;            private final MethodGraph superClassGraph;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of method graphs of the represented type&#39;s directly implemented interfaces to their graph representatives.
&nbsp;             */
&nbsp;            private final Map&lt;TypeDescription, MethodGraph&gt; interfaceGraphs;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new delegation method graph.
&nbsp;             *
&nbsp;             * @param methodGraph     The represented type&#39;s method graph.
&nbsp;             * @param superClassGraph The super class&#39;s method graph.
&nbsp;             * @param interfaceGraphs A mapping of method graphs of the represented type&#39;s directly implemented interfaces to their graph representatives.
&nbsp;             */
<b class="fc">&nbsp;            public Delegation(MethodGraph methodGraph, MethodGraph superClassGraph, Map&lt;TypeDescription, MethodGraph&gt; interfaceGraphs) {</b>
<b class="fc">&nbsp;                this.methodGraph = methodGraph;</b>
<b class="fc">&nbsp;                this.superClassGraph = superClassGraph;</b>
<b class="fc">&nbsp;                this.interfaceGraphs = interfaceGraphs;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodGraph getSuperClassGraph() {
<b class="fc">&nbsp;                return superClassGraph;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodGraph getInterfaceGraph(TypeDescription typeDescription) {
<b class="fc">&nbsp;                MethodGraph interfaceGraph = interfaceGraphs.get(typeDescription);</b>
<b class="fc">&nbsp;                return interfaceGraph == null</b>
<b class="fc">&nbsp;                        ? Empty.INSTANCE</b>
<b class="fc">&nbsp;                        : interfaceGraph;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Node locate(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                return methodGraph.locate(token);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public NodeList listNodes() {
<b class="fc">&nbsp;                return methodGraph.listNodes();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a node within a method graph.
&nbsp;     */
&nbsp;    interface Node {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the sort of this node.
&nbsp;         *
&nbsp;         * @return The sort of this node.
&nbsp;         */
&nbsp;        Sort getSort();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the method that is represented by this node.
&nbsp;         *
&nbsp;         * @return The method that is represented by this node.
&nbsp;         */
&nbsp;        MethodDescription getRepresentative();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a set of type tokens that this method represents. This set contains the actual method&#39;s type including the
&nbsp;         * types of all bridge methods.
&nbsp;         *
&nbsp;         * @return A set of type tokens that this method represents.
&nbsp;         */
&nbsp;        Set&lt;MethodDescription.TypeToken&gt; getMethodTypes();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the minimal method visibility of all methods that are represented by this node.
&nbsp;         *
&nbsp;         * @return The minimal method visibility of all methods that are represented by this node.
&nbsp;         */
&nbsp;        Visibility getVisibility();
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a {@link net.bytebuddy.dynamic.scaffold.MethodGraph.Node}&#39;s state.
&nbsp;         */
<b class="fc">&nbsp;        enum Sort {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a resolved node that was made visible by a visibility bridge.
&nbsp;             */
<b class="fc">&nbsp;            VISIBLE(true, true, true),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a resolved node that was not made visible by a visibility bridge.
&nbsp;             */
<b class="fc">&nbsp;            RESOLVED(true, true, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an ambiguous node, i.e. a node that might refer to several methods.
&nbsp;             */
<b class="fc">&nbsp;            AMBIGUOUS(true, false, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an unresolved node.
&nbsp;             */
<b class="fc">&nbsp;            UNRESOLVED(false, false, false);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this sort represents a resolved node.
&nbsp;             */
&nbsp;            private final boolean resolved;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this sort represents a non-ambiguous node.
&nbsp;             */
&nbsp;            private final boolean unique;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this sort represents a node that was made by a visibility bridge.
&nbsp;             */
&nbsp;            private final boolean madeVisible;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new sort.
&nbsp;             *
&nbsp;             * @param resolved    {@code true} if this sort represents a resolved node.
&nbsp;             * @param unique      {@code true} if this sort represents a non-ambiguous node.
&nbsp;             * @param madeVisible {@code true} if this sort represents a node that was made by a visibility bridge.
&nbsp;             */
<b class="fc">&nbsp;            Sort(boolean resolved, boolean unique, boolean madeVisible) {</b>
<b class="fc">&nbsp;                this.resolved = resolved;</b>
<b class="fc">&nbsp;                this.unique = unique;</b>
<b class="fc">&nbsp;                this.madeVisible = madeVisible;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Verifies if this sort represents a resolved node.
&nbsp;             *
&nbsp;             * @return {@code true} if this sort represents a resolved node.
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return resolved;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Verifies if this sort represents a non-ambiguous node.
&nbsp;             *
&nbsp;             * @return {@code true} if this sort represents a non-ambiguous node.
&nbsp;             */
&nbsp;            public boolean isUnique() {
<b class="fc">&nbsp;                return unique;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Verifies if this sort represents a node that was made visible by a visibility bridge.
&nbsp;             *
&nbsp;             * @return {@code true} if this sort represents a node that was made visible by a visibility bridge.
&nbsp;             */
&nbsp;            public boolean isMadeVisible() {
<b class="fc">&nbsp;                return madeVisible;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical implementation of an unresolved node.
&nbsp;         */
<b class="fc">&nbsp;        enum Unresolved implements Node {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.UNRESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription getRepresentative() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot resolve the method of an illegal node&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot resolve bridge method of an illegal node&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Visibility getVisibility() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot resolve visibility of an illegal node&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple implementation of a resolved node of a method without bridges.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements Node {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented method.
&nbsp;             */
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a simple node.
&nbsp;             *
&nbsp;             * @param methodDescription The represented method.
&nbsp;             */
<b class="fc">&nbsp;            public Simple(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription getRepresentative() {
<b class="fc">&nbsp;                return methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
<b class="fc">&nbsp;                return Collections.emptySet();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Visibility getVisibility() {
<b class="fc">&nbsp;                return methodDescription.getVisibility();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compiler to produce a {@link MethodGraph} from a given type.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;, justification = &quot;Safe initialization is implied.&quot;)
&nbsp;    interface Compiler {
&nbsp;
&nbsp;        /**
&nbsp;         * The default compiler for compiling Java methods.
&nbsp;         */
<b class="fc">&nbsp;        Compiler DEFAULT = MethodGraph.Compiler.Default.forJavaHierarchy();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles the given type into a method graph considering the type to be the viewpoint.
&nbsp;         *
&nbsp;         * @param typeDefinition The type to be compiled.
&nbsp;         * @return A linked method graph representing the given type.
&nbsp;         */
&nbsp;        MethodGraph.Linked compile(TypeDefinition typeDefinition);
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles the given type into a method graph considering the type to be the viewpoint.
&nbsp;         *
&nbsp;         * @param typeDescription The type to be compiled.
&nbsp;         * @return A linked method graph representing the given type.
&nbsp;         * @deprecated Use {@link MethodGraph.Compiler#compile(TypeDefinition)}.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        MethodGraph.Linked compile(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles the given type into a method graph.
&nbsp;         *
&nbsp;         * @param typeDefinition The type to be compiled.
&nbsp;         * @param viewPoint      The view point that determines the method&#39;s visibility.
&nbsp;         * @return A linked method graph representing the given type.
&nbsp;         */
&nbsp;        MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint);
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles the given type into a method graph.
&nbsp;         *
&nbsp;         * @param typeDefinition The type to be compiled.
&nbsp;         * @param viewPoint      The view point that determines the method&#39;s visibility.
&nbsp;         * @return A linked method graph representing the given type.
&nbsp;         * @deprecated Use {@link MethodGraph.Compiler#compile(TypeDefinition, TypeDescription)}.
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        MethodGraph.Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint);
&nbsp;
&nbsp;        /**
&nbsp;         * A flat compiler that simply returns the methods that are declared by the instrumented type.
&nbsp;         */
<b class="fc">&nbsp;        enum ForDeclaredMethods implements Compiler {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Linked compile(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return compile(typeDefinition, typeDefinition.asErasure());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDescription) {
<b class="nc">&nbsp;                return compile((TypeDefinition) typeDescription, typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
<b class="fc">&nbsp;                LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes = new LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt;();</b>
<b class="fc">&nbsp;                for (MethodDescription methodDescription : typeDefinition.getDeclaredMethods().filter(isVirtual().and(not(isBridge())).and(isVisibleTo(viewPoint)))) {</b>
<b class="fc">&nbsp;                    nodes.put(methodDescription.asSignatureToken(), new Node.Simple(methodDescription));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new Linked.Delegation(new MethodGraph.Simple(nodes), Empty.INSTANCE, Collections.&lt;TypeDescription, MethodGraph&gt;emptyMap());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
<b class="nc">&nbsp;                return compile((TypeDefinition) typeDefinition, viewPoint);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a method graph compiler.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase implements Compiler {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Linked compile(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return compile(typeDefinition, typeDefinition.asErasure());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDescription) {
<b class="nc">&nbsp;                return compile((TypeDefinition) typeDescription, typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @Deprecated
&nbsp;            public Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
<b class="nc">&nbsp;                return compile((TypeDefinition) typeDefinition, viewPoint);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of a method graph.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The type of the harmonizer token to be used for linking methods of different types.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Default&lt;T&gt; extends AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The harmonizer to be used.
&nbsp;             */
&nbsp;            private final Harmonizer&lt;T&gt; harmonizer;
&nbsp;
&nbsp;            /**
&nbsp;             * The merger to be used.
&nbsp;             */
&nbsp;            private final Merger merger;
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor to apply to all type descriptions before analyzing their methods or resolving super types.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher to filter methods from the graph.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default method graph compiler.
&nbsp;             *
&nbsp;             * @param harmonizer The harmonizer to be used.
&nbsp;             * @param merger     The merger to be used.
&nbsp;             * @param visitor    A visitor to apply to all type descriptions before analyzing their methods or resolving super types.
&nbsp;             */
&nbsp;            protected Default(Harmonizer&lt;T&gt; harmonizer, Merger merger, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;                this(harmonizer, merger, visitor, any());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default method graph compiler.
&nbsp;             *
&nbsp;             * @param harmonizer The harmonizer to be used.
&nbsp;             * @param merger     The merger to be used.
&nbsp;             * @param visitor    A visitor to apply to all type descriptions before analyzing their methods or resolving super types.
&nbsp;             * @param matcher    A matcher to filter methods from the graph.
&nbsp;             */
<b class="fc">&nbsp;            public Default(Harmonizer&lt;T&gt; harmonizer, Merger merger, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor, ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                this.harmonizer = harmonizer;</b>
<b class="fc">&nbsp;                this.merger = merger;</b>
<b class="fc">&nbsp;                this.visitor = visitor;</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default compiler using the given harmonizer and merger. All raw types are reified before analyzing their properties.
&nbsp;             *
&nbsp;             * @param harmonizer The harmonizer to be used for creating tokens that uniquely identify a method hierarchy.
&nbsp;             * @param merger     The merger to be used for identifying a method to represent an ambiguous method resolution.
&nbsp;             * @param &lt;S&gt;        The type of the harmonizer token.
&nbsp;             * @return A default compiler for the given harmonizer and merger.
&nbsp;             */
&nbsp;            public static &lt;S&gt; Compiler of(Harmonizer&lt;S&gt; harmonizer, Merger merger) {
<b class="fc">&nbsp;                return new Default&lt;S&gt;(harmonizer, merger, TypeDescription.Generic.Visitor.Reifying.INITIATING);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default compiler using the given harmonizer and merger. All raw types are reified before analyzing their properties.
&nbsp;             *
&nbsp;             * @param harmonizer The harmonizer to be used for creating tokens that uniquely identify a method hierarchy.
&nbsp;             * @param merger     The merger to be used for identifying a method to represent an ambiguous method resolution.
&nbsp;             * @param matcher    A matcher to filter methods from the graph.
&nbsp;             * @param &lt;S&gt;        The type of the harmonizer token.
&nbsp;             * @return A default compiler for the given harmonizer and merger.
&nbsp;             */
&nbsp;            public static &lt;S&gt; Compiler of(Harmonizer&lt;S&gt; harmonizer, Merger merger, ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="nc">&nbsp;                return new Default&lt;S&gt;(harmonizer, merger, TypeDescription.Generic.Visitor.Reifying.INITIATING, matcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default compiler using the given harmonizer and merger.
&nbsp;             *
&nbsp;             * @param harmonizer The harmonizer to be used for creating tokens that uniquely identify a method hierarchy.
&nbsp;             * @param merger     The merger to be used for identifying a method to represent an ambiguous method resolution.
&nbsp;             * @param visitor    A visitor to apply to all type descriptions before analyzing their methods or resolving super types.
&nbsp;             * @param &lt;S&gt;        The type of the harmonizer token.
&nbsp;             * @return A default compiler for the given harmonizer and merger.
&nbsp;             */
&nbsp;            public static &lt;S&gt; Compiler of(Harmonizer&lt;S&gt; harmonizer, Merger merger, TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="nc">&nbsp;                return new Default&lt;S&gt;(harmonizer, merger, visitor);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Creates a default compiler for a method hierarchy following the rules of the Java programming language. According
&nbsp;             * to these rules, two methods of the same name are only different if their parameter types represent different raw
&nbsp;             * types. The return type is not considered as a part of the signature.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Ambiguous methods are merged by considering the method that was discovered first.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @return A compiler for resolving a method hierarchy following the rules of the Java programming language.
&nbsp;             */
&nbsp;            public static Compiler forJavaHierarchy() {
<b class="fc">&nbsp;                return of(Harmonizer.ForJavaMethod.INSTANCE, Merger.Directional.LEFT);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Creates a default compiler for a method hierarchy following the rules of the Java virtual machine. According
&nbsp;             * to these rules, two methods of the same name are different if their parameter types and return types represent
&nbsp;             * different type erasures.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Ambiguous methods are merged by considering the method that was discovered first.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @return A compiler for resolving a method hierarchy following the rules of the Java programming language.
&nbsp;             */
&nbsp;            public static Compiler forJVMHierarchy() {
<b class="fc">&nbsp;                return of(Harmonizer.ForJVMMethod.INSTANCE, Merger.Directional.LEFT);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
<b class="fc">&nbsp;                Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots = new HashMap&lt;TypeDefinition, Key.Store&lt;T&gt;&gt;();</b>
<b class="fc">&nbsp;                Key.Store&lt;?&gt; rootStore = doAnalyze(typeDefinition, snapshots, isVirtual().and(isVisibleTo(viewPoint)).and(matcher));</b>
<b class="fc">&nbsp;                TypeDescription.Generic superClass = typeDefinition.getSuperClass();</b>
<b class="fc">&nbsp;                List&lt;TypeDescription.Generic&gt; interfaceTypes = typeDefinition.getInterfaces();</b>
<b class="fc">&nbsp;                Map&lt;TypeDescription, MethodGraph&gt; interfaceGraphs = new HashMap&lt;TypeDescription, MethodGraph&gt;();</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic interfaceType : interfaceTypes) {</b>
<b class="fc">&nbsp;                    Key.Store&lt;T&gt; store = snapshots.get(interfaceType);</b>
<b class="fc">&nbsp;                    if (store == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Failed to resolve interface type &quot; + interfaceType + &quot; from &quot; + snapshots.keySet());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    interfaceGraphs.put(interfaceType.asErasure(), store.asGraph(merger));</b>
<b class="fc">&nbsp;                }</b>
&nbsp;                Key.Store&lt;T&gt; store;
<b class="fc">&nbsp;                if (superClass == null) {</b>
<b class="fc">&nbsp;                    store = null;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    store = snapshots.get(superClass);</b>
<b class="fc">&nbsp;                    if (store == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Failed to resolve super class &quot; + superClass + &quot; from &quot; + snapshots.keySet());</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return new Linked.Delegation(rootStore.asGraph(merger),</b>
<b class="fc">&nbsp;                        store == null</b>
<b class="fc">&nbsp;                                ? Empty.INSTANCE</b>
<b class="fc">&nbsp;                                : store.asGraph(merger),</b>
&nbsp;                        interfaceGraphs);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Analyzes the given type description without checking if the end of the type hierarchy was reached.
&nbsp;             *
&nbsp;             * @param typeDefinition   The type to analyze.
&nbsp;             * @param key              The type in its original form before applying the visitor.
&nbsp;             * @param snapshots        A map containing snapshots of key stores for previously analyzed types.
&nbsp;             * @param relevanceMatcher A matcher for filtering methods that should be included in the graph.
&nbsp;             * @return A key store describing the provided type.
&nbsp;             */
&nbsp;            protected Key.Store&lt;T&gt; analyze(TypeDefinition typeDefinition,
&nbsp;                                           TypeDefinition key,
&nbsp;                                           Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots,
&nbsp;                                           ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher) {
<b class="fc">&nbsp;                Key.Store&lt;T&gt; store = snapshots.get(key);</b>
<b class="fc">&nbsp;                if (store == null) {</b>
<b class="fc">&nbsp;                    store = doAnalyze(typeDefinition, snapshots, relevanceMatcher);</b>
<b class="fc">&nbsp;                    snapshots.put(key, store);</b>
&nbsp;                }
<b class="fc">&nbsp;                return store;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Analyzes the given type description.
&nbsp;             *
&nbsp;             * @param typeDescription  The type to analyze.
&nbsp;             * @param snapshots        A map containing snapshots of key stores for previously analyzed types.
&nbsp;             * @param relevanceMatcher A matcher for filtering methods that should be included in the graph.
&nbsp;             * @return A key store describing the provided type.
&nbsp;             */
&nbsp;            protected Key.Store&lt;T&gt; analyzeNullable(@MaybeNull TypeDescription.Generic typeDescription,
&nbsp;                                                   Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots,
&nbsp;                                                   ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher) {
<b class="fc">&nbsp;                return typeDescription == null</b>
<b class="fc">&nbsp;                        ? new Key.Store&lt;T&gt;()</b>
<b class="fc">&nbsp;                        : analyze(typeDescription.accept(visitor), typeDescription, snapshots, relevanceMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Analyzes the given type description without checking if it is already presented in the key store.
&nbsp;             *
&nbsp;             * @param typeDefinition   The type to analyze.
&nbsp;             * @param snapshots        A map containing snapshots of key stores for previously analyzed types.
&nbsp;             * @param relevanceMatcher A matcher for filtering methods that should be included in the graph.
&nbsp;             * @return A key store describing the provided type.
&nbsp;             */
&nbsp;            protected Key.Store&lt;T&gt; doAnalyze(TypeDefinition typeDefinition,
&nbsp;                                             Map&lt;TypeDefinition, Key.Store&lt;T&gt;&gt; snapshots,
&nbsp;                                             ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher) {
<b class="fc">&nbsp;                Key.Store&lt;T&gt; store = analyzeNullable(typeDefinition.getSuperClass(), snapshots, relevanceMatcher);</b>
<b class="fc">&nbsp;                Key.Store&lt;T&gt; interfaceStore = new Key.Store&lt;T&gt;();</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic interfaceType : typeDefinition.getInterfaces()) {</b>
<b class="fc">&nbsp;                    interfaceStore = interfaceStore.combineWith(analyze(interfaceType.accept(visitor), interfaceType, snapshots, relevanceMatcher));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return store.inject(interfaceStore).registerTopLevel(typeDefinition.getDeclaredMethods().filter(relevanceMatcher), harmonizer);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A harmonizer is responsible for creating a token that identifies a method&#39;s relevant attributes for considering
&nbsp;             * two methods of being equal or not.
&nbsp;             *
&nbsp;             * @param &lt;S&gt; The type of the token that is created by the implementing harmonizer.
&nbsp;             */
&nbsp;            public interface Harmonizer&lt;S&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Harmonizes the given type token.
&nbsp;                 *
&nbsp;                 * @param typeToken The type token to harmonize.
&nbsp;                 * @return A token representing the given type token.
&nbsp;                 */
&nbsp;                S harmonize(MethodDescription.TypeToken typeToken);
&nbsp;
&nbsp;                /**
&nbsp;                 * A harmonizer for the Java programming language that identifies a method by its parameter types only.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForJavaMethod implements Harmonizer&lt;ForJavaMethod.Token&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Token harmonize(MethodDescription.TypeToken typeToken) {
<b class="fc">&nbsp;                        return new Token(typeToken);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token that identifies a Java method&#39;s type by its parameter types only.
&nbsp;                     */
&nbsp;                    protected static class Token {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type token.
&nbsp;                         */
&nbsp;                        private final MethodDescription.TypeToken typeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The hash code of this token which is precomputed for to improve performance.
&nbsp;                         */
&nbsp;                        private final int hashCode;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type token for a Java method.
&nbsp;                         *
&nbsp;                         * @param typeToken The represented type token.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Token(MethodDescription.TypeToken typeToken) {</b>
<b class="fc">&nbsp;                            this.typeToken = typeToken;</b>
<b class="fc">&nbsp;                            hashCode = typeToken.getParameterTypes().hashCode();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public int hashCode() {
<b class="fc">&nbsp;                            return hashCode;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                            return this == other || other instanceof Token &amp;&amp; typeToken.getParameterTypes().equals(((Token) other).typeToken.getParameterTypes());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public String toString() {
<b class="nc">&nbsp;                            return typeToken.getParameterTypes().toString();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A harmonizer for the Java virtual machine&#39;s method dispatching rules that identifies a method by its parameter types and return type.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForJVMMethod implements Harmonizer&lt;ForJVMMethod.Token&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Token harmonize(MethodDescription.TypeToken typeToken) {
<b class="fc">&nbsp;                        return new Token(typeToken);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token that identifies a Java method&#39;s type by its parameter types and return type.
&nbsp;                     */
&nbsp;                    protected static class Token {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type token.
&nbsp;                         */
&nbsp;                        private final MethodDescription.TypeToken typeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The hash code of this token which is precomputed for to improve performance.
&nbsp;                         */
&nbsp;                        private final int hashCode;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type token for a JVM method.
&nbsp;                         *
&nbsp;                         * @param typeToken The represented type token.
&nbsp;                         */
<b class="fc">&nbsp;                        public Token(MethodDescription.TypeToken typeToken) {</b>
<b class="fc">&nbsp;                            this.typeToken = typeToken;</b>
<b class="fc">&nbsp;                            hashCode = typeToken.getReturnType().hashCode() + 31 * typeToken.getParameterTypes().hashCode();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public int hashCode() {
<b class="fc">&nbsp;                            return hashCode;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                            if (this == other) {</b>
<b class="nc">&nbsp;                                return true;</b>
<b class="fc">&nbsp;                            } else if (!(other instanceof Token)) {</b>
<b class="nc">&nbsp;                                return false;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            Token token = (Token) other;</b>
<b class="fc">&nbsp;                            return typeToken.getReturnType().equals(token.typeToken.getReturnType())</b>
<b class="fc">&nbsp;                                    &amp;&amp; typeToken.getParameterTypes().equals(token.typeToken.getParameterTypes());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public String toString() {
<b class="nc">&nbsp;                            return typeToken.toString();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implementations are responsible for identifying a representative method for a {@link net.bytebuddy.dynamic.scaffold.MethodGraph.Node}
&nbsp;             * between several ambiguously resolved methods.
&nbsp;             */
&nbsp;            public interface Merger {
&nbsp;
&nbsp;                /**
&nbsp;                 * Merges two ambiguously resolved methods to yield a single representative.
&nbsp;                 *
&nbsp;                 * @param left  The left method description, i.e. the method that was discovered first or was previously merged.
&nbsp;                 * @param right The right method description, i.e. the method that was discovered last.
&nbsp;                 * @return A method description compatible to both method&#39;s types that is used as a representative.
&nbsp;                 */
&nbsp;                MethodDescription merge(MethodDescription left, MethodDescription right);
&nbsp;
&nbsp;                /**
&nbsp;                 * A directional merger that always returns either the left or right method description.
&nbsp;                 */
<b class="fc">&nbsp;                enum Directional implements Merger {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A merger that always returns the left method, i.e. the method that was discovered first or was previously merged.
&nbsp;                     */
<b class="fc">&nbsp;                    LEFT(true),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A merger that always returns the right method, i.e. the method that was discovered last.
&nbsp;                     */
<b class="fc">&nbsp;                    RIGHT(false);</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the left method should be returned when merging methods.
&nbsp;                     */
&nbsp;                    private final boolean left;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a directional merger.
&nbsp;                     *
&nbsp;                     * @param left {@code true} if the left method should be returned when merging methods.
&nbsp;                     */
<b class="fc">&nbsp;                    Directional(boolean left) {</b>
<b class="fc">&nbsp;                        this.left = left;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription merge(MethodDescription left, MethodDescription right) {
<b class="fc">&nbsp;                        return this.left</b>
<b class="fc">&nbsp;                                ? left</b>
<b class="fc">&nbsp;                                : right;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A key represents a collection of methods within a method graph to later yield a node representing a collection of methods,
&nbsp;             * i.e. a method representative including information on the required method bridges.
&nbsp;             *
&nbsp;             * @param &lt;S&gt; The type of the token used for deciding on method equality.
&nbsp;             */
&nbsp;            protected abstract static class Key&lt;S&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name of the method this key identifies.
&nbsp;                 */
&nbsp;                protected final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The number of method parameters of the method this key identifies.
&nbsp;                 */
&nbsp;                protected final int parameterCount;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new key.
&nbsp;                 *
&nbsp;                 * @param internalName   The internal name of the method this key identifies.
&nbsp;                 * @param parameterCount The number of method parameters of the method this key identifies.
&nbsp;                 */
<b class="fc">&nbsp;                protected Key(String internalName, int parameterCount) {</b>
<b class="fc">&nbsp;                    this.internalName = internalName;</b>
<b class="fc">&nbsp;                    this.parameterCount = parameterCount;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a set of all identifiers of this key.
&nbsp;                 *
&nbsp;                 * @return A set of all identifiers of this key.
&nbsp;                 */
&nbsp;                protected abstract Set&lt;S&gt; getIdentifiers();
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    return internalName.hashCode() + 31 * parameterCount;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                    if (this == other) {</b>
<b class="nc">&nbsp;                        return true;</b>
<b class="fc">&nbsp;                    } else if (!(other instanceof Key)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Key&lt;?&gt; key = (Key&lt;?&gt;) other;</b>
<b class="fc">&nbsp;                    return internalName.equals(key.internalName)</b>
&nbsp;                            &amp;&amp; parameterCount == key.parameterCount
<b class="fc">&nbsp;                            &amp;&amp; !Collections.disjoint(getIdentifiers(), key.getIdentifiers());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A harmonized key represents a key where equality is decided based on tokens that are returned by a
&nbsp;                 * {@link net.bytebuddy.dynamic.scaffold.MethodGraph.Compiler.Default.Harmonizer}.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; The type of the tokens yielded by a harmonizer.
&nbsp;                 */
&nbsp;                protected static class Harmonized&lt;V&gt; extends Key&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of identifiers to the type tokens they represent.
&nbsp;                     */
&nbsp;                    private final Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new harmonized key.
&nbsp;                     *
&nbsp;                     * @param internalName   The internal name of the method this key identifies.
&nbsp;                     * @param parameterCount The number of method parameters of the method this key identifies.
&nbsp;                     * @param identifiers    A mapping of identifiers to the type tokens they represent.
&nbsp;                     */
&nbsp;                    protected Harmonized(String internalName, int parameterCount, Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers) {
<b class="fc">&nbsp;                        super(internalName, parameterCount);</b>
<b class="fc">&nbsp;                        this.identifiers = identifiers;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new harmonized key for the given method description.
&nbsp;                     *
&nbsp;                     * @param methodDescription The method description to represent as a harmonized key.
&nbsp;                     * @param harmonizer        The harmonizer to use.
&nbsp;                     * @param &lt;Q&gt;               The type of the token yielded by a harmonizer.
&nbsp;                     * @return A harmonized key representing the provided method.
&nbsp;                     */
&nbsp;                    protected static &lt;Q&gt; Harmonized&lt;Q&gt; of(MethodDescription methodDescription, Harmonizer&lt;Q&gt; harmonizer) {
<b class="fc">&nbsp;                        MethodDescription.TypeToken typeToken = methodDescription.asTypeToken();</b>
<b class="fc">&nbsp;                        return new Harmonized&lt;Q&gt;(methodDescription.getInternalName(),</b>
<b class="fc">&nbsp;                                methodDescription.getParameters().size(),</b>
<b class="fc">&nbsp;                                Collections.singletonMap(harmonizer.harmonize(typeToken), Collections.&lt;MethodDescription.TypeToken&gt;emptySet()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a detached version of this key.
&nbsp;                     *
&nbsp;                     * @param typeToken The type token of the representative method.
&nbsp;                     * @return The detached version of this key.
&nbsp;                     */
&nbsp;                    protected Detached detach(MethodDescription.TypeToken typeToken) {
<b class="fc">&nbsp;                        Set&lt;MethodDescription.TypeToken&gt; identifiers = new HashSet&lt;MethodDescription.TypeToken&gt;();</b>
<b class="fc">&nbsp;                        for (Set&lt;MethodDescription.TypeToken&gt; typeTokens : this.identifiers.values()) {</b>
<b class="fc">&nbsp;                            identifiers.addAll(typeTokens);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        identifiers.add(typeToken);</b>
<b class="fc">&nbsp;                        return new Detached(internalName, parameterCount, identifiers);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Combines this key with the given key.
&nbsp;                     *
&nbsp;                     * @param key The key to be merged with this key.
&nbsp;                     * @return A harmonized key representing the merger of this key and the given key.
&nbsp;                     */
&nbsp;                    protected Harmonized&lt;V&gt; combineWith(Harmonized&lt;V&gt; key) {
<b class="fc">&nbsp;                        Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers = new HashMap&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt;(this.identifiers);</b>
<b class="fc">&nbsp;                        for (Map.Entry&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; entry : key.identifiers.entrySet()) {</b>
<b class="fc">&nbsp;                            Set&lt;MethodDescription.TypeToken&gt; typeTokens = identifiers.get(entry.getKey());</b>
<b class="fc">&nbsp;                            if (typeTokens == null) {</b>
<b class="nc">&nbsp;                                identifiers.put(entry.getKey(), entry.getValue());</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                typeTokens = new HashSet&lt;MethodDescription.TypeToken&gt;(typeTokens);</b>
<b class="fc">&nbsp;                                typeTokens.addAll(entry.getValue());</b>
<b class="fc">&nbsp;                                identifiers.put(entry.getKey(), typeTokens);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new Harmonized&lt;V&gt;(internalName, parameterCount, identifiers);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extends this key by the given method description.
&nbsp;                     *
&nbsp;                     * @param methodDescription The method to extend this key with.
&nbsp;                     * @param harmonizer        The harmonizer to use for determining method equality.
&nbsp;                     * @return The harmonized key representing the extension of this key with the provided method.
&nbsp;                     */
&nbsp;                    protected Harmonized&lt;V&gt; extend(MethodDescription.InDefinedShape methodDescription, Harmonizer&lt;V&gt; harmonizer) {
<b class="fc">&nbsp;                        Map&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt; identifiers = new HashMap&lt;V, Set&lt;MethodDescription.TypeToken&gt;&gt;(this.identifiers);</b>
<b class="fc">&nbsp;                        MethodDescription.TypeToken typeToken = methodDescription.asTypeToken();</b>
<b class="fc">&nbsp;                        V identifier = harmonizer.harmonize(typeToken);</b>
<b class="fc">&nbsp;                        Set&lt;MethodDescription.TypeToken&gt; typeTokens = identifiers.get(identifier);</b>
<b class="fc">&nbsp;                        if (typeTokens == null) {</b>
<b class="fc">&nbsp;                            identifiers.put(identifier, Collections.singleton(typeToken));</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            typeTokens = new HashSet&lt;MethodDescription.TypeToken&gt;(typeTokens);</b>
<b class="fc">&nbsp;                            typeTokens.add(typeToken);</b>
<b class="fc">&nbsp;                            identifiers.put(identifier, typeTokens);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Harmonized&lt;V&gt;(internalName, parameterCount, identifiers);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Set&lt;V&gt; getIdentifiers() {
<b class="fc">&nbsp;                        return identifiers.keySet();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A detached version of a key that identifies methods by their JVM signature, i.e. parameter types and return type.
&nbsp;                 */
&nbsp;                protected static class Detached extends Key&lt;MethodDescription.TypeToken&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type tokens represented by this key.
&nbsp;                     */
&nbsp;                    private final Set&lt;MethodDescription.TypeToken&gt; identifiers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new detached key.
&nbsp;                     *
&nbsp;                     * @param internalName   The internal name of the method this key identifies.
&nbsp;                     * @param parameterCount The number of method parameters of the method this key identifies.
&nbsp;                     * @param identifiers    The type tokens represented by this key.
&nbsp;                     */
&nbsp;                    protected Detached(String internalName, int parameterCount, Set&lt;MethodDescription.TypeToken&gt; identifiers) {
<b class="fc">&nbsp;                        super(internalName, parameterCount);</b>
<b class="fc">&nbsp;                        this.identifiers = identifiers;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new detached key of the given method token.
&nbsp;                     *
&nbsp;                     * @param token The method token to represent as a key.
&nbsp;                     * @return A detached key representing the given method token..
&nbsp;                     */
&nbsp;                    protected static Detached of(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                        return new Detached(token.getName(), token.getParameterTypes().size(), Collections.singleton(token.asTypeToken()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Set&lt;MethodDescription.TypeToken&gt; getIdentifiers() {
<b class="fc">&nbsp;                        return identifiers;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A store for collected methods that are identified by keys.
&nbsp;                 *
&nbsp;                 * @param &lt;V&gt; The type of the token used for deciding on method equality.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Store&lt;V&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of harmonized keys to their represented entry.
&nbsp;                     */
&nbsp;                    private final LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an empty store.
&nbsp;                     */
&nbsp;                    protected Store() {
<b class="fc">&nbsp;                        this(new LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt;());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new store representing the given entries.
&nbsp;                     *
&nbsp;                     * @param entries A mapping of harmonized keys to their represented entry.
&nbsp;                     */
<b class="fc">&nbsp;                    private Store(LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries) {</b>
<b class="fc">&nbsp;                        this.entries = entries;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Combines the two given stores.
&nbsp;                     *
&nbsp;                     * @param left  The left store to be combined.
&nbsp;                     * @param right The right store to be combined.
&nbsp;                     * @param &lt;W&gt;   The type of the harmonized key of both stores.
&nbsp;                     * @return An entry representing the combination of both stores.
&nbsp;                     */
&nbsp;                    private static &lt;W&gt; Entry&lt;W&gt; combine(Entry&lt;W&gt; left, Entry&lt;W&gt; right) {
<b class="fc">&nbsp;                        Set&lt;MethodDescription&gt; leftMethods = left.getCandidates(), rightMethods = right.getCandidates();</b>
<b class="fc">&nbsp;                        LinkedHashSet&lt;MethodDescription&gt; combined = new LinkedHashSet&lt;MethodDescription&gt;();</b>
<b class="fc">&nbsp;                        combined.addAll(leftMethods);</b>
<b class="fc">&nbsp;                        combined.addAll(rightMethods);</b>
<b class="fc">&nbsp;                        for (MethodDescription leftMethod : leftMethods) {</b>
<b class="fc">&nbsp;                            TypeDescription leftType = leftMethod.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                            for (MethodDescription rightMethod : rightMethods) {</b>
<b class="fc">&nbsp;                                TypeDescription rightType = rightMethod.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                                if (leftType.equals(rightType)) {</b>
<b class="fc">&nbsp;                                    break;</b>
<b class="fc">&nbsp;                                } else if (leftType.isAssignableTo(rightType)) {</b>
<b class="fc">&nbsp;                                    combined.remove(rightMethod);</b>
<b class="fc">&nbsp;                                    break;</b>
<b class="fc">&nbsp;                                } else if (leftType.isAssignableFrom(rightType)) {</b>
<b class="fc">&nbsp;                                    combined.remove(leftMethod);</b>
<b class="fc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        Key.Harmonized&lt;W&gt; key = left.getKey().combineWith(right.getKey());</b>
<b class="fc">&nbsp;                        Visibility visibility = left.getVisibility().expandTo(right.getVisibility());</b>
<b class="fc">&nbsp;                        return combined.size() == 1</b>
<b class="fc">&nbsp;                                ? new Entry.Resolved&lt;W&gt;(key, combined.iterator().next(), visibility, Entry.Resolved.NOT_MADE_VISIBLE)</b>
<b class="fc">&nbsp;                                : new Entry.Ambiguous&lt;W&gt;(key, combined, visibility);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Registers a new top level method within this store.
&nbsp;                     *
&nbsp;                     * @param methodDescriptions The methods to register.
&nbsp;                     * @param harmonizer         The harmonizer to use for determining method equality.
&nbsp;                     * @return A store with the given method registered as a top-level method.
&nbsp;                     */
&nbsp;                    protected Store&lt;V&gt; registerTopLevel(List&lt;? extends MethodDescription&gt; methodDescriptions, Harmonizer&lt;V&gt; harmonizer) {
<b class="fc">&nbsp;                        if (methodDescriptions.isEmpty()) {</b>
<b class="fc">&nbsp;                            return this;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries = new LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt;(this.entries);</b>
<b class="fc">&nbsp;                        for (MethodDescription methodDescription : methodDescriptions) {</b>
<b class="fc">&nbsp;                            Harmonized&lt;V&gt; key = Harmonized.of(methodDescription, harmonizer);</b>
<b class="fc">&nbsp;                            Entry&lt;V&gt; currentEntry = entries.remove(key), extendedEntry = (currentEntry == null</b>
<b class="fc">&nbsp;                                    ? new Entry.Initial&lt;V&gt;(key)</b>
<b class="fc">&nbsp;                                    : currentEntry).extendBy(methodDescription, harmonizer);</b>
<b class="fc">&nbsp;                            entries.put(extendedEntry.getKey(), extendedEntry);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new Store&lt;V&gt;(entries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Combines this store with the given store.
&nbsp;                     *
&nbsp;                     * @param store The store to combine with this store.
&nbsp;                     * @return A store representing a combination of this store and the given store.
&nbsp;                     */
&nbsp;                    protected Store&lt;V&gt; combineWith(Store&lt;V&gt; store) {
<b class="fc">&nbsp;                        if (entries.isEmpty()) {</b>
<b class="fc">&nbsp;                            return store;</b>
<b class="fc">&nbsp;                        } else if (store.entries.isEmpty()) {</b>
<b class="fc">&nbsp;                            return this;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries = new LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt;(this.entries);</b>
<b class="fc">&nbsp;                        for (Entry&lt;V&gt; entry : store.entries.values()) {</b>
<b class="fc">&nbsp;                            Entry&lt;V&gt; previousEntry = entries.remove(entry.getKey()), injectedEntry = previousEntry == null</b>
<b class="fc">&nbsp;                                    ? entry</b>
<b class="fc">&nbsp;                                    : combine(previousEntry, entry);</b>
<b class="fc">&nbsp;                            entries.put(injectedEntry.getKey(), injectedEntry);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new Store&lt;V&gt;(entries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Injects the given store into this store.
&nbsp;                     *
&nbsp;                     * @param store The key store to inject into this store.
&nbsp;                     * @return A store that represents this store with the given store injected.
&nbsp;                     */
&nbsp;                    protected Store&lt;V&gt; inject(Store&lt;V&gt; store) {
<b class="fc">&nbsp;                        if (entries.isEmpty()) {</b>
<b class="fc">&nbsp;                            return store;</b>
<b class="fc">&nbsp;                        } else if (store.entries.isEmpty()) {</b>
<b class="fc">&nbsp;                            return this;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt; entries = new LinkedHashMap&lt;Harmonized&lt;V&gt;, Entry&lt;V&gt;&gt;(this.entries);</b>
<b class="fc">&nbsp;                        for (Entry&lt;V&gt; entry : store.entries.values()) {</b>
<b class="fc">&nbsp;                            Entry&lt;V&gt; previous = entries.remove(entry.getKey()), injectedEntry = previous == null</b>
<b class="fc">&nbsp;                                    ? entry</b>
<b class="fc">&nbsp;                                    : previous.inject(entry);</b>
<b class="fc">&nbsp;                            entries.put(injectedEntry.getKey(), injectedEntry);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new Store&lt;V&gt;(entries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Transforms this store into a method graph by applying the given merger.
&nbsp;                     *
&nbsp;                     * @param merger The merger to apply for resolving the representative for ambiguous resolutions.
&nbsp;                     * @return The method graph that represents this key store.
&nbsp;                     */
&nbsp;                    protected MethodGraph asGraph(Merger merger) {
<b class="fc">&nbsp;                        LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt; entries = new LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt;();</b>
<b class="fc">&nbsp;                        for (Entry&lt;V&gt; entry : this.entries.values()) {</b>
<b class="fc">&nbsp;                            Node node = entry.asNode(merger);</b>
<b class="fc">&nbsp;                            entries.put(entry.getKey().detach(node.getRepresentative().asTypeToken()), node);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new Graph(entries);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An entry of a key store.
&nbsp;                     *
&nbsp;                     * @param &lt;W&gt; The type of the harmonized token used for determining method equality.
&nbsp;                     */
&nbsp;                    protected interface Entry&lt;W&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns the harmonized key of this entry.
&nbsp;                         *
&nbsp;                         * @return The harmonized key of this entry.
&nbsp;                         */
&nbsp;                        Harmonized&lt;W&gt; getKey();
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns all candidate methods represented by this entry.
&nbsp;                         *
&nbsp;                         * @return All candidate methods represented by this entry.
&nbsp;                         */
&nbsp;                        Set&lt;MethodDescription&gt; getCandidates();
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns the minimal visibility of this entry.
&nbsp;                         *
&nbsp;                         * @return The minimal visibility of this entry.
&nbsp;                         */
&nbsp;                        Visibility getVisibility();
&nbsp;
&nbsp;                        /**
&nbsp;                         * Extends this entry by the given method.
&nbsp;                         *
&nbsp;                         * @param methodDescription The method description to extend this entry with.
&nbsp;                         * @param harmonizer        The harmonizer to use for determining method equality.
&nbsp;                         * @return This key extended by the given method.
&nbsp;                         */
&nbsp;                        Entry&lt;W&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;W&gt; harmonizer);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Injects the given key into this entry.
&nbsp;                         *
&nbsp;                         * @param entry The entry to be combined.
&nbsp;                         * @return This entry extended with the given key.
&nbsp;                         */
&nbsp;                        Entry&lt;W&gt; inject(Entry&lt;W&gt; entry);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Transforms this entry into a node.
&nbsp;                         *
&nbsp;                         * @param merger The merger to use for determining the representative method of an ambiguous node.
&nbsp;                         * @return The resolved node.
&nbsp;                         */
&nbsp;                        Node asNode(Merger merger);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An entry in its initial state before registering any method as a representative.
&nbsp;                         *
&nbsp;                         * @param &lt;U&gt; The type of the harmonized key to determine method equality.
&nbsp;                         */
&nbsp;                        class Initial&lt;U&gt; implements Entry&lt;U&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The harmonized key this entry represents.
&nbsp;                             */
&nbsp;                            private final Harmonized&lt;U&gt; key;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new initial key.
&nbsp;                             *
&nbsp;                             * @param key The harmonized key this entry represents.
&nbsp;                             */
<b class="fc">&nbsp;                            protected Initial(Harmonized&lt;U&gt; key) {</b>
<b class="fc">&nbsp;                                this.key = key;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Harmonized&lt;U&gt; getKey() {
<b class="fc">&nbsp;                                throw new IllegalStateException(&quot;Cannot extract key from initial entry:&quot; + this);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Set&lt;MethodDescription&gt; getCandidates() {
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot extract method from initial entry:&quot; + this);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Visibility getVisibility() {
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot extract visibility from initial entry:&quot; + this);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Entry&lt;U&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;U&gt; harmonizer) {
<b class="fc">&nbsp;                                return new Resolved&lt;U&gt;(key.extend(methodDescription.asDefined(), harmonizer),</b>
&nbsp;                                        methodDescription,
<b class="fc">&nbsp;                                        methodDescription.getVisibility(),</b>
&nbsp;                                        Resolved.NOT_MADE_VISIBLE);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Entry&lt;U&gt; inject(Entry&lt;U&gt; entry) {
<b class="fc">&nbsp;                                throw new IllegalStateException(&quot;Cannot inject into initial entry without a registered method: &quot; + this);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Node asNode(Merger merger) {
<b class="fc">&nbsp;                                throw new IllegalStateException(&quot;Cannot transform initial entry without a registered method: &quot; + this);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public int hashCode() {
<b class="fc">&nbsp;                                return key.hashCode();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                                if (this == other) {</b>
<b class="nc">&nbsp;                                    return true;</b>
<b class="nc">&nbsp;                                } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                                    return false;</b>
&nbsp;                                }
<b class="nc">&nbsp;                                Initial&lt;?&gt; initial = (Initial&lt;?&gt;) other;</b>
<b class="nc">&nbsp;                                return key.equals(initial.key);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An entry representing a non-ambiguous node resolution.
&nbsp;                         *
&nbsp;                         * @param &lt;U&gt; The type of the harmonized key to determine method equality.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Resolved&lt;U&gt; implements Entry&lt;U&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Indicates that a type&#39;s methods are already globally visible, meaning that a bridge method is not added
&nbsp;                             * with the intend of creating a visibility bridge.
&nbsp;                             */
&nbsp;                            private static final int MADE_VISIBLE = Opcodes.ACC_PUBLIC | Opcodes.ACC_PROTECTED;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Indicates that the entry was not made visible.
&nbsp;                             */
&nbsp;                            private static final boolean NOT_MADE_VISIBLE = false;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The harmonized key this entry represents.
&nbsp;                             */
&nbsp;                            private final Harmonized&lt;U&gt; key;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The non-ambiguous, representative method of this entry.
&nbsp;                             */
&nbsp;                            private final MethodDescription methodDescription;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The minimal required visibility for this method.
&nbsp;                             */
&nbsp;                            private final Visibility visibility;
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@code true} if this entry&#39;s representative was made visible by a visibility bridge.
&nbsp;                             */
&nbsp;                            private final boolean madeVisible;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new resolved entry that is not made visible.
&nbsp;                             *
&nbsp;                             * @param key               The harmonized key this entry represents.
&nbsp;                             * @param methodDescription The non-ambiguous, representative method of this entry.
&nbsp;                             * @param visibility        The minimal required visibility for this method.
&nbsp;                             */
&nbsp;                            protected Resolved(Harmonized&lt;U&gt; key, MethodDescription methodDescription, Visibility visibility) {
<b class="fc">&nbsp;                                this(key, methodDescription, visibility, NOT_MADE_VISIBLE);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new resolved entry.
&nbsp;                             *
&nbsp;                             * @param key               The harmonized key this entry represents.
&nbsp;                             * @param methodDescription The non-ambiguous, representative method of this entry.
&nbsp;                             * @param visibility        The minimal required visibility for this method.
&nbsp;                             * @param madeVisible       {@code true} if this entry&#39;s representative was made visible by a visibility bridge.
&nbsp;                             */
<b class="fc">&nbsp;                            protected Resolved(Harmonized&lt;U&gt; key, MethodDescription methodDescription, Visibility visibility, boolean madeVisible) {</b>
<b class="fc">&nbsp;                                this.key = key;</b>
<b class="fc">&nbsp;                                this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                                this.visibility = visibility;</b>
<b class="fc">&nbsp;                                this.madeVisible = madeVisible;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an entry for an override where a method overrides another method within a super class.
&nbsp;                             *
&nbsp;                             * @param key        The merged key for both methods.
&nbsp;                             * @param override   The method declared by the extending type, potentially a bridge method.
&nbsp;                             * @param original   The method that is overridden by the extending type.
&nbsp;                             * @param visibility The minimal required visibility for this entry.
&nbsp;                             * @param &lt;V&gt;        The type of the harmonized key to determine method equality.
&nbsp;                             * @return An entry representing the merger of both methods.
&nbsp;                             */
&nbsp;                            private static &lt;V&gt; Entry&lt;V&gt; of(Harmonized&lt;V&gt; key, MethodDescription override, MethodDescription original, Visibility visibility) {
<b class="fc">&nbsp;                                visibility = visibility.expandTo(original.getVisibility()).expandTo(override.getVisibility());</b>
<b class="fc">&nbsp;                                return override.isBridge()</b>
<b class="fc">&nbsp;                                        ? new Resolved&lt;V&gt;(key, original, visibility, (original.getDeclaringType().getModifiers() &amp; MADE_VISIBLE) == 0)</b>
<b class="fc">&nbsp;                                        : new Resolved&lt;V&gt;(key, override, visibility, NOT_MADE_VISIBLE);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Harmonized&lt;U&gt; getKey() {
<b class="fc">&nbsp;                                return key;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Set&lt;MethodDescription&gt; getCandidates() {
<b class="fc">&nbsp;                                return Collections.singleton(methodDescription);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Visibility getVisibility() {
<b class="fc">&nbsp;                                return visibility;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Entry&lt;U&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;U&gt; harmonizer) {
<b class="fc">&nbsp;                                Harmonized&lt;U&gt; key = this.key.extend(methodDescription.asDefined(), harmonizer);</b>
<b class="fc">&nbsp;                                Visibility visibility = this.visibility.expandTo(methodDescription.getVisibility());</b>
<b class="fc">&nbsp;                                return methodDescription.getDeclaringType().equals(this.methodDescription.getDeclaringType())</b>
<b class="fc">&nbsp;                                        ? Ambiguous.of(key, methodDescription, this.methodDescription, visibility)</b>
<b class="fc">&nbsp;                                        : Resolved.of(key, methodDescription, this.methodDescription, visibility);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Entry&lt;U&gt; inject(Entry&lt;U&gt; entry) {
<b class="fc">&nbsp;                                if (methodDescription.getDeclaringType().isInterface()) {</b>
<b class="fc">&nbsp;                                    LinkedHashSet&lt;MethodDescription&gt; candidates = new LinkedHashSet&lt;MethodDescription&gt;();</b>
<b class="fc">&nbsp;                                    candidates.add(methodDescription);</b>
<b class="fc">&nbsp;                                    TypeDescription target = methodDescription.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                                    for (MethodDescription methodDescription : entry.getCandidates()) {</b>
<b class="fc">&nbsp;                                        if (methodDescription.getDeclaringType().asErasure().isAssignableTo(target)) {</b>
<b class="fc">&nbsp;                                            candidates.remove(this.methodDescription);</b>
<b class="fc">&nbsp;                                            candidates.add(methodDescription);</b>
<b class="fc">&nbsp;                                        } else if (!methodDescription.getDeclaringType().asErasure().isAssignableFrom(target)) {</b>
<b class="fc">&nbsp;                                            candidates.add(methodDescription);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    return candidates.size() == 1</b>
<b class="fc">&nbsp;                                            ? new Resolved&lt;U&gt;(key.combineWith(entry.getKey()), candidates.iterator().next(), visibility.expandTo(entry.getVisibility()), madeVisible)</b>
<b class="fc">&nbsp;                                            : new Ambiguous&lt;U&gt;(key.combineWith(entry.getKey()), candidates, visibility.expandTo(entry.getVisibility()));</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    return new Resolved&lt;U&gt;(key.combineWith(entry.getKey()), methodDescription, visibility.expandTo(entry.getVisibility()), madeVisible);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodGraph.Node asNode(Merger merger) {
<b class="fc">&nbsp;                                return new Node(key.detach(methodDescription.asTypeToken()), methodDescription, visibility, madeVisible);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A node implementation representing a non-ambiguous method.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Node implements MethodGraph.Node {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The detached key representing this node.
&nbsp;                                 */
&nbsp;                                private final Detached key;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The representative method of this node.
&nbsp;                                 */
&nbsp;                                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The node&#39;s minimal visibility.
&nbsp;                                 */
&nbsp;                                private final Visibility visibility;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@code true} if the represented method was made explicitly visible by a visibility bridge.
&nbsp;                                 */
&nbsp;                                private final boolean visible;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new node.
&nbsp;                                 *
&nbsp;                                 * @param key               The detached key representing this node.
&nbsp;                                 * @param methodDescription The representative method of this node.
&nbsp;                                 * @param visibility        The node&#39;s minimal visibility.
&nbsp;                                 * @param visible           {@code true} if the represented method was made explicitly visible by a visibility bridge.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Node(Detached key, MethodDescription methodDescription, Visibility visibility, boolean visible) {</b>
<b class="fc">&nbsp;                                    this.key = key;</b>
<b class="fc">&nbsp;                                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                                    this.visibility = visibility;</b>
<b class="fc">&nbsp;                                    this.visible = visible;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Sort getSort() {
<b class="fc">&nbsp;                                    return visible</b>
<b class="fc">&nbsp;                                            ? Sort.VISIBLE</b>
<b class="fc">&nbsp;                                            : Sort.RESOLVED;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public MethodDescription getRepresentative() {
<b class="fc">&nbsp;                                    return methodDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
<b class="fc">&nbsp;                                    return key.getIdentifiers();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Visibility getVisibility() {
<b class="fc">&nbsp;                                    return visibility;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An entry representing an ambiguous node resolution.
&nbsp;                         *
&nbsp;                         * @param &lt;U&gt; The type of the harmonized key to determine method equality.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Ambiguous&lt;U&gt; implements Entry&lt;U&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The harmonized key this entry represents.
&nbsp;                             */
&nbsp;                            private final Harmonized&lt;U&gt; key;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A set of ambiguous methods that this entry represents.
&nbsp;                             */
&nbsp;                            private final LinkedHashSet&lt;MethodDescription&gt; methodDescriptions;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The minimal required visibility for this method.
&nbsp;                             */
&nbsp;                            private final Visibility visibility;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new ambiguous entry.
&nbsp;                             *
&nbsp;                             * @param key                The harmonized key this entry represents.
&nbsp;                             * @param methodDescriptions A set of ambiguous methods that this entry represents.
&nbsp;                             * @param visibility         The minimal required visibility for this method.
&nbsp;                             */
<b class="fc">&nbsp;                            protected Ambiguous(Harmonized&lt;U&gt; key, LinkedHashSet&lt;MethodDescription&gt; methodDescriptions, Visibility visibility) {</b>
<b class="fc">&nbsp;                                this.key = key;</b>
<b class="fc">&nbsp;                                this.methodDescriptions = methodDescriptions;</b>
<b class="fc">&nbsp;                                this.visibility = visibility;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new ambiguous entry if both provided entries are not considered to be a bridge of one another.
&nbsp;                             *
&nbsp;                             * @param key        The key of the entry to be created.
&nbsp;                             * @param left       The left method to be considered.
&nbsp;                             * @param right      The right method to be considered.
&nbsp;                             * @param visibility The entry&#39;s minimal visibility.
&nbsp;                             * @param &lt;Q&gt;        The type of the token of the harmonized key to determine method equality.
&nbsp;                             * @return The entry representing both methods.
&nbsp;                             */
&nbsp;                            protected static &lt;Q&gt; Entry&lt;Q&gt; of(Harmonized&lt;Q&gt; key, MethodDescription left, MethodDescription right, Visibility visibility) {
<b class="fc">&nbsp;                                visibility = visibility.expandTo(left.getVisibility()).expandTo(right.getVisibility());</b>
<b class="fc">&nbsp;                                return left.isBridge() ^ right.isBridge()</b>
<b class="fc">&nbsp;                                        ? new Resolved&lt;Q&gt;(key, left.isBridge() ? right : left, visibility, Resolved.NOT_MADE_VISIBLE)</b>
<b class="fc">&nbsp;                                        : new Ambiguous&lt;Q&gt;(key, new LinkedHashSet&lt;MethodDescription&gt;(Arrays.asList(left, right)), visibility);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Harmonized&lt;U&gt; getKey() {
<b class="fc">&nbsp;                                return key;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Set&lt;MethodDescription&gt; getCandidates() {
<b class="fc">&nbsp;                                return methodDescriptions;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Visibility getVisibility() {
<b class="fc">&nbsp;                                return visibility;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Entry&lt;U&gt; extendBy(MethodDescription methodDescription, Harmonizer&lt;U&gt; harmonizer) {
<b class="fc">&nbsp;                                Harmonized&lt;U&gt; key = this.key.extend(methodDescription.asDefined(), harmonizer);</b>
<b class="fc">&nbsp;                                LinkedHashSet&lt;MethodDescription&gt; methodDescriptions = new LinkedHashSet&lt;MethodDescription&gt;();</b>
<b class="fc">&nbsp;                                TypeDescription declaringType = methodDescription.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                                boolean bridge = methodDescription.isBridge();</b>
<b class="fc">&nbsp;                                Visibility visibility = this.visibility;</b>
<b class="fc">&nbsp;                                for (MethodDescription extendedMethod : this.methodDescriptions) {</b>
<b class="fc">&nbsp;                                    if (extendedMethod.getDeclaringType().asErasure().equals(declaringType)) {</b>
<b class="nc">&nbsp;                                        if (extendedMethod.isBridge() ^ bridge) {</b>
<b class="nc">&nbsp;                                            methodDescriptions.add(bridge ? extendedMethod : methodDescription);</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            methodDescriptions.add(methodDescription);</b>
<b class="nc">&nbsp;                                            methodDescriptions.add(extendedMethod);</b>
&nbsp;                                        }
&nbsp;                                    }
<b class="fc">&nbsp;                                    visibility = visibility.expandTo(extendedMethod.getVisibility());</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                if (methodDescriptions.isEmpty()) {</b>
<b class="fc">&nbsp;                                    return new Resolved&lt;U&gt;(key, methodDescription, visibility, bridge);</b>
<b class="nc">&nbsp;                                } else if (methodDescriptions.size() == 1) {</b>
<b class="nc">&nbsp;                                    return new Resolved&lt;U&gt;(key, methodDescriptions.iterator().next(), visibility, Resolved.NOT_MADE_VISIBLE);</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    return new Ambiguous&lt;U&gt;(key, methodDescriptions, visibility);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Entry&lt;U&gt; inject(Entry&lt;U&gt; entry) {
<b class="fc">&nbsp;                                LinkedHashSet&lt;MethodDescription&gt; methodDescriptions = new LinkedHashSet&lt;MethodDescription&gt;();</b>
&nbsp;                                outer:
<b class="fc">&nbsp;                                for (MethodDescription methodDescription : this.methodDescriptions) {</b>
<b class="fc">&nbsp;                                    TypeDescription target = methodDescription.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                                    for (MethodDescription candidate : entry.getCandidates()) {</b>
<b class="fc">&nbsp;                                        TypeDescription typeDescription = candidate.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                                        if (!typeDescription.equals(target) &amp;&amp; typeDescription.isAssignableTo(target)) {</b>
<b class="fc">&nbsp;                                            continue outer;</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                    }</b>
<b class="nc">&nbsp;                                    methodDescriptions.add(methodDescription);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                                outer:
<b class="fc">&nbsp;                                for (MethodDescription candidate : entry.getCandidates()) {</b>
<b class="fc">&nbsp;                                    TypeDescription target = candidate.getDeclaringType().asErasure();</b>
<b class="fc">&nbsp;                                    for (MethodDescription methodDescription : this.methodDescriptions) {</b>
<b class="fc">&nbsp;                                        if (methodDescription.getDeclaringType().asErasure().isAssignableTo(target)) {</b>
<b class="nc">&nbsp;                                            continue outer;</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    methodDescriptions.add(candidate);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                return methodDescriptions.size() == 1</b>
<b class="fc">&nbsp;                                        ? new Resolved&lt;U&gt;(key.combineWith(entry.getKey()), methodDescriptions.iterator().next(), visibility.expandTo(entry.getVisibility()))</b>
<b class="nc">&nbsp;                                        : new Ambiguous&lt;U&gt;(key.combineWith(entry.getKey()), methodDescriptions, visibility.expandTo(entry.getVisibility()));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public MethodGraph.Node asNode(Merger merger) {
<b class="fc">&nbsp;                                Iterator&lt;MethodDescription&gt; iterator = methodDescriptions.iterator();</b>
<b class="fc">&nbsp;                                MethodDescription methodDescription = iterator.next();</b>
<b class="fc">&nbsp;                                while (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                                    methodDescription = merger.merge(methodDescription, iterator.next());</b>
&nbsp;                                }
<b class="fc">&nbsp;                                return new Node(key.detach(methodDescription.asTypeToken()), methodDescription, visibility);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A node implementation representing an ambiguous method resolution.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Node implements MethodGraph.Node {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The detached key representing this node.
&nbsp;                                 */
&nbsp;                                private final Detached key;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The representative method of this node.
&nbsp;                                 */
&nbsp;                                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The node&#39;s minimal visibility.
&nbsp;                                 */
&nbsp;                                private final Visibility visibility;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * @param key               The detached key representing this node.
&nbsp;                                 * @param methodDescription The representative method of this node.
&nbsp;                                 * @param visibility        The node&#39;s minimal visibility.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Node(Detached key, MethodDescription methodDescription, Visibility visibility) {</b>
<b class="fc">&nbsp;                                    this.key = key;</b>
<b class="fc">&nbsp;                                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                                    this.visibility = visibility;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Sort getSort() {
<b class="fc">&nbsp;                                    return Sort.AMBIGUOUS;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public MethodDescription getRepresentative() {
<b class="fc">&nbsp;                                    return methodDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Set&lt;MethodDescription.TypeToken&gt; getMethodTypes() {
<b class="fc">&nbsp;                                    return key.getIdentifiers();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Visibility getVisibility() {
<b class="fc">&nbsp;                                    return visibility;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A graph implementation based on a key store.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Graph implements MethodGraph {
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of a node&#39;s type tokens to the represented node.
&nbsp;                         */
&nbsp;                        private final LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt; entries;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new graph.
&nbsp;                         *
&nbsp;                         * @param entries A mapping of a node&#39;s type tokens to the represented node.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Graph(LinkedHashMap&lt;Key&lt;MethodDescription.TypeToken&gt;, Node&gt; entries) {</b>
<b class="fc">&nbsp;                            this.entries = entries;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Node locate(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                            Node node = entries.get(Detached.of(token));</b>
<b class="fc">&nbsp;                            return node == null</b>
<b class="fc">&nbsp;                                    ? Node.Unresolved.INSTANCE</b>
<b class="fc">&nbsp;                                    : node;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public NodeList listNodes() {
<b class="fc">&nbsp;                            return new NodeList(new ArrayList&lt;Node&gt;(entries.values()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of nodes.
&nbsp;     */
&nbsp;    class NodeList extends FilterableList.AbstractBase&lt;Node, NodeList&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented nodes.
&nbsp;         */
&nbsp;        private final List&lt;? extends Node&gt; nodes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a list of nodes.
&nbsp;         *
&nbsp;         * @param nodes The represented nodes.
&nbsp;         */
<b class="fc">&nbsp;        public NodeList(List&lt;? extends Node&gt; nodes) {</b>
<b class="fc">&nbsp;            this.nodes = nodes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Node get(int index) {
<b class="fc">&nbsp;            return nodes.get(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int size() {
<b class="fc">&nbsp;            return nodes.size();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected NodeList wrap(List&lt;Node&gt; values) {
<b class="fc">&nbsp;            return new NodeList(values);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Transforms this list of nodes into a list of the node&#39;s representatives.
&nbsp;         *
&nbsp;         * @return A list of these node&#39;s representatives.
&nbsp;         */
&nbsp;        public MethodList&lt;?&gt; asMethodList() {
<b class="fc">&nbsp;            List&lt;MethodDescription&gt; methodDescriptions = new ArrayList&lt;MethodDescription&gt;(size());</b>
<b class="fc">&nbsp;            for (Node node : nodes) {</b>
<b class="fc">&nbsp;                methodDescriptions.add(node.getRepresentative());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new MethodList.Explicit&lt;MethodDescription&gt;(methodDescriptions);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A simple implementation of a method graph.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Simple implements MethodGraph {
&nbsp;
&nbsp;        /**
&nbsp;         * The nodes represented by this method graph.
&nbsp;         */
&nbsp;        private final LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new simple method graph.
&nbsp;         *
&nbsp;         * @param nodes The nodes represented by this method graph.
&nbsp;         */
<b class="fc">&nbsp;        public Simple(LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes) {</b>
<b class="fc">&nbsp;            this.nodes = nodes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method graph that contains all of the provided methods as simple nodes.
&nbsp;         *
&nbsp;         * @param methodDescriptions A list of method descriptions to be represented as simple nodes.
&nbsp;         * @return A method graph that represents all of the provided methods as simple nodes.
&nbsp;         */
&nbsp;        public static MethodGraph of(List&lt;? extends MethodDescription&gt; methodDescriptions) {
<b class="fc">&nbsp;            LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt; nodes = new LinkedHashMap&lt;MethodDescription.SignatureToken, Node&gt;();</b>
<b class="fc">&nbsp;            for (MethodDescription methodDescription : methodDescriptions) {</b>
<b class="fc">&nbsp;                nodes.put(methodDescription.asSignatureToken(), new Node.Simple(methodDescription));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Simple(nodes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Node locate(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;            Node node = nodes.get(token);</b>
<b class="fc">&nbsp;            return node == null</b>
<b class="nc">&nbsp;                    ? Node.Unresolved.INSTANCE</b>
<b class="fc">&nbsp;                    : node;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public NodeList listNodes() {
<b class="fc">&nbsp;            return new NodeList(new ArrayList&lt;Node&gt;(nodes.values()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
