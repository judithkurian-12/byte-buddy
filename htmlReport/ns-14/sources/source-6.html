


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodRegistry</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.dynamic.scaffold</a>
</div>

<h1>Coverage Summary for Class: MethodRegistry (net.bytebuddy.dynamic.scaffold)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">MethodRegistry$Compiled</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (61/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Default$Compiled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Default$Compiled$Entry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Default$Entry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Default$Prepared</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Default$Prepared$Entry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$Compiled</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$Compiled$MockitoMock$2048575111</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$Compiled$MockitoMock$2048575111$auxiliary$FHwZREYq</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$Compiled$MockitoMock$2048575111$auxiliary$snBtsBC9</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$ForAbstractMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$ForAnnotationValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$ForImplementation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$ForImplementation$Compiled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$ForVisibilityBridge</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$ForVisibilityBridge$Compiled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$MockitoMock$417094304</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$MockitoMock$417094304$auxiliary$BSmZQGms</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Handler$MockitoMock$417094304$auxiliary$gPCCVWBV</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$MockitoMock$682293732</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$MockitoMock$682293732$auxiliary$SrPcOZDE</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$MockitoMock$682293732$auxiliary$yOdqhOME</td>
  </tr>
  <tr>
    <td class="name">MethodRegistry$Prepared</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (55/55)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (179/179)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.dynamic.scaffold;
&nbsp;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.Transformer;
&nbsp;import net.bytebuddy.dynamic.VisibilityBridgeStrategy;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.LatentMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A method registry is responsible for storing information on how a method is intercepted.
&nbsp; */
&nbsp;public interface MethodRegistry {
&nbsp;
&nbsp;    /**
&nbsp;     * Prepends the given method definition to this method registry, i.e. this configuration is applied first.
&nbsp;     *
&nbsp;     * @param methodMatcher            A matcher to identify any method that this definition concerns.
&nbsp;     * @param handler                  The handler to instrument any matched method.
&nbsp;     * @param attributeAppenderFactory A method attribute appender to apply to any matched method.
&nbsp;     * @param transformer              The method transformer to be applied to implemented methods.
&nbsp;     * @return An adapted version of this method registry.
&nbsp;     */
&nbsp;    MethodRegistry prepend(LatentMatcher&lt;? super MethodDescription&gt; methodMatcher,
&nbsp;                           Handler handler,
&nbsp;                           MethodAttributeAppender.Factory attributeAppenderFactory,
&nbsp;                           Transformer&lt;MethodDescription&gt; transformer);
&nbsp;
&nbsp;    /**
&nbsp;     * Appends the given method definition to this method registry, i.e. this configuration is applied last.
&nbsp;     *
&nbsp;     * @param methodMatcher            A matcher to identify all entries that are to be matched.
&nbsp;     * @param handler                  The handler to instrument any matched method.
&nbsp;     * @param attributeAppenderFactory A method attribute appender to apply to any matched method.
&nbsp;     * @param transformer              The method transformer to be applied to implemented methods.
&nbsp;     * @return An adapted version of this method registry.
&nbsp;     */
&nbsp;    MethodRegistry append(LatentMatcher&lt;? super MethodDescription&gt; methodMatcher,
&nbsp;                          Handler handler,
&nbsp;                          MethodAttributeAppender.Factory attributeAppenderFactory,
&nbsp;                          Transformer&lt;MethodDescription&gt; transformer);
&nbsp;
&nbsp;    /**
&nbsp;     * Prepares this method registry.
&nbsp;     *
&nbsp;     * @param instrumentedType         The instrumented type that should be created.
&nbsp;     * @param methodGraphCompiler      The method graph compiler to be used for analyzing the fully assembled instrumented type.
&nbsp;     * @param typeValidation           Determines if a type should be explicitly validated.
&nbsp;     * @param visibilityBridgeStrategy The visibility bridge strategy to apply.
&nbsp;     * @param ignoredMethods           A filter that only matches methods that should be instrumented.
&nbsp;     * @return A prepared version of this method registry.
&nbsp;     */
&nbsp;    Prepared prepare(InstrumentedType instrumentedType,
&nbsp;                     MethodGraph.Compiler methodGraphCompiler,
&nbsp;                     TypeValidation typeValidation,
&nbsp;                     VisibilityBridgeStrategy visibilityBridgeStrategy,
&nbsp;                     LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods);
&nbsp;
&nbsp;    /**
&nbsp;     * A handler for implementing a method.
&nbsp;     */
&nbsp;    interface Handler extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles this handler.
&nbsp;         *
&nbsp;         * @param implementationTarget The implementation target to compile this handler for.
&nbsp;         * @return A compiled handler.
&nbsp;         */
&nbsp;        Handler.Compiled compile(Implementation.Target implementationTarget);
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for defining an abstract or native method.
&nbsp;         */
<b class="fc">&nbsp;        enum ForAbstractMethod implements Handler, Compiled {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeWriter.MethodPool.Record assemble(MethodDescription methodDescription, MethodAttributeAppender attributeAppender, Visibility visibility) {
<b class="fc">&nbsp;                return new TypeWriter.MethodPool.Record.ForDefinedMethod.WithoutBody(methodDescription, attributeAppender, visibility);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for implementing a visibility bridge.
&nbsp;         */
<b class="fc">&nbsp;        enum ForVisibilityBridge implements Handler {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A visibility bridge handler must not apply any preparations&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                return new Compiled(implementationTarget.getInstrumentedType());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compiled handler for a visibility bridge handler.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Compiled implements Handler.Compiled {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compiled handler for a visibility bridge.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 */
<b class="fc">&nbsp;                protected Compiled(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeWriter.MethodPool.Record assemble(MethodDescription methodDescription, MethodAttributeAppender attributeAppender, Visibility visibility) {
<b class="fc">&nbsp;                    return TypeWriter.MethodPool.Record.ForDefinedMethod.OfVisibilityBridge.of(instrumentedType, methodDescription, attributeAppender);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compiled handler for implementing a method.
&nbsp;         */
&nbsp;        interface Compiled {
&nbsp;
&nbsp;            /**
&nbsp;             * Assembles this compiled entry with a method attribute appender.
&nbsp;             *
&nbsp;             * @param methodDescription The method description to apply with this handler.
&nbsp;             * @param attributeAppender The method attribute appender to apply together with this handler.
&nbsp;             * @param visibility        The represented method&#39;s minimum visibility.
&nbsp;             * @return A method pool entry representing this handler and the given attribute appender.
&nbsp;             */
&nbsp;            TypeWriter.MethodPool.Record assemble(MethodDescription methodDescription, MethodAttributeAppender attributeAppender, Visibility visibility);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for a method that is implemented as byte code.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForImplementation implements Handler {
&nbsp;
&nbsp;            /**
&nbsp;             * The implementation to apply.
&nbsp;             */
&nbsp;            private final Implementation implementation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new handler for implementing a method with byte code.
&nbsp;             *
&nbsp;             * @param implementation The implementation to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForImplementation(Implementation implementation) {</b>
<b class="fc">&nbsp;                this.implementation = implementation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return implementation.prepare(instrumentedType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                return new Compiled(implementation.appender(implementationTarget));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compiled handler for implementing a method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Compiled implements Handler.Compiled {
&nbsp;
&nbsp;                /**
&nbsp;                 * The byte code appender to apply.
&nbsp;                 */
&nbsp;                private final ByteCodeAppender byteCodeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compiled handler for a method implementation.
&nbsp;                 *
&nbsp;                 * @param byteCodeAppender The byte code appender to apply.
&nbsp;                 */
<b class="fc">&nbsp;                protected Compiled(ByteCodeAppender byteCodeAppender) {</b>
<b class="fc">&nbsp;                    this.byteCodeAppender = byteCodeAppender;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeWriter.MethodPool.Record assemble(MethodDescription methodDescription, MethodAttributeAppender attributeAppender, Visibility visibility) {
<b class="fc">&nbsp;                    return new TypeWriter.MethodPool.Record.ForDefinedMethod.WithBody(methodDescription, byteCodeAppender, attributeAppender, visibility);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for defining a default annotation value for a method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForAnnotationValue implements Handler, Compiled {
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation value to set as a default value.
&nbsp;             */
&nbsp;            private final AnnotationValue&lt;?, ?&gt; annotationValue;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a handler for defining a default annotation value for a method.
&nbsp;             *
&nbsp;             * @param annotationValue The annotation value to set as a default value.
&nbsp;             */
<b class="fc">&nbsp;            public ForAnnotationValue(AnnotationValue&lt;?, ?&gt; annotationValue) {</b>
<b class="fc">&nbsp;                this.annotationValue = annotationValue;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Compiled compile(Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeWriter.MethodPool.Record assemble(MethodDescription methodDescription, MethodAttributeAppender attributeAppender, Visibility visibility) {
<b class="fc">&nbsp;                return new TypeWriter.MethodPool.Record.ForDefinedMethod.WithAnnotationDefaultValue(methodDescription, annotationValue, attributeAppender);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method registry that fully prepared the instrumented type.
&nbsp;     */
&nbsp;    interface Prepared {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the fully prepared instrumented type.
&nbsp;         *
&nbsp;         * @return The fully prepared instrumented type.
&nbsp;         */
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the declared or virtually inherited methods of this type.
&nbsp;         *
&nbsp;         * @return The declared or virtually inherited methods of this type.
&nbsp;         */
&nbsp;        MethodList&lt;?&gt; getMethods();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a list of all methods that should be instrumented.
&nbsp;         *
&nbsp;         * @return A list of all methods that should be instrumented.
&nbsp;         */
&nbsp;        MethodList&lt;?&gt; getInstrumentedMethods();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the loaded type initializer of the instrumented type.
&nbsp;         *
&nbsp;         * @return The loaded type initializer of the instrumented type.
&nbsp;         */
&nbsp;        LoadedTypeInitializer getLoadedTypeInitializer();
&nbsp;
&nbsp;        /**
&nbsp;         * The type initializer of the instrumented type.
&nbsp;         *
&nbsp;         * @return The type initializer of the instrumented type.
&nbsp;         */
&nbsp;        TypeInitializer getTypeInitializer();
&nbsp;
&nbsp;        /**
&nbsp;         * Compiles this prepared method registry.
&nbsp;         *
&nbsp;         * @param implementationTargetFactory A factory for creating an implementation target.
&nbsp;         * @param classFileVersion            The type&#39;s class file version.
&nbsp;         * @return A factory for creating an implementation target.
&nbsp;         */
&nbsp;        Compiled compile(Implementation.Target.Factory implementationTargetFactory, ClassFileVersion classFileVersion);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compiled version of a method registry.
&nbsp;     */
&nbsp;    interface Compiled extends TypeWriter.MethodPool {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the instrumented type that is to be created.
&nbsp;         *
&nbsp;         * @return The instrumented type that is to be created.
&nbsp;         */
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the declared or virtually inherited methods of this type.
&nbsp;         *
&nbsp;         * @return The declared or virtually inherited methods of this type.
&nbsp;         */
&nbsp;        MethodList&lt;?&gt; getMethods();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a list of all methods that should be instrumented.
&nbsp;         *
&nbsp;         * @return A list of all methods that should be instrumented.
&nbsp;         */
&nbsp;        MethodList&lt;?&gt; getInstrumentedMethods();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the loaded type initializer of the instrumented type.
&nbsp;         *
&nbsp;         * @return The loaded type initializer of the instrumented type.
&nbsp;         */
&nbsp;        LoadedTypeInitializer getLoadedTypeInitializer();
&nbsp;
&nbsp;        /**
&nbsp;         * The type initializer of the instrumented type.
&nbsp;         *
&nbsp;         * @return The type initializer of the instrumented type.
&nbsp;         */
&nbsp;        TypeInitializer getTypeInitializer();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A default implementation of a method registry.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Default implements MethodRegistry {
&nbsp;
&nbsp;        /**
&nbsp;         * The list of currently registered entries in their application order.
&nbsp;         */
&nbsp;        private final List&lt;Entry&gt; entries;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default method registry without entries.
&nbsp;         */
<b class="fc">&nbsp;        public Default() {</b>
<b class="fc">&nbsp;            entries = Collections.emptyList();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default method registry.
&nbsp;         *
&nbsp;         * @param entries The currently registered entries.
&nbsp;         */
<b class="fc">&nbsp;        private Default(List&lt;Entry&gt; entries) {</b>
<b class="fc">&nbsp;            this.entries = entries;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodRegistry prepend(LatentMatcher&lt;? super MethodDescription&gt; matcher,
&nbsp;                                      Handler handler,
&nbsp;                                      MethodAttributeAppender.Factory attributeAppenderFactory,
&nbsp;                                      Transformer&lt;MethodDescription&gt; transformer) {
<b class="fc">&nbsp;            return new Default(CompoundList.of(new Entry(matcher, handler, attributeAppenderFactory, transformer), entries));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodRegistry append(LatentMatcher&lt;? super MethodDescription&gt; matcher,
&nbsp;                                     Handler handler,
&nbsp;                                     MethodAttributeAppender.Factory attributeAppenderFactory,
&nbsp;                                     Transformer&lt;MethodDescription&gt; transformer) {
<b class="fc">&nbsp;            return new Default(CompoundList.of(entries, new Entry(matcher, handler, attributeAppenderFactory, transformer)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodRegistry.Prepared prepare(InstrumentedType instrumentedType,
&nbsp;                                               MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                               TypeValidation typeValidation,
&nbsp;                                               VisibilityBridgeStrategy visibilityBridgeStrategy,
&nbsp;                                               LatentMatcher&lt;? super MethodDescription&gt; ignoredMethods) {
<b class="fc">&nbsp;            LinkedHashMap&lt;MethodDescription, Prepared.Entry&gt; implementations = new LinkedHashMap&lt;MethodDescription, Prepared.Entry&gt;();</b>
<b class="fc">&nbsp;            Set&lt;Handler&gt; handlers = new HashSet&lt;Handler&gt;();</b>
<b class="fc">&nbsp;            Set&lt;MethodDescription&gt; declaredMethods = new HashSet&lt;MethodDescription&gt;(instrumentedType.getDeclaredMethods());</b>
<b class="fc">&nbsp;            for (Entry entry : entries) {</b>
<b class="fc">&nbsp;                if (handlers.add(entry.getHandler())) {</b>
<b class="fc">&nbsp;                    InstrumentedType typeDescription = entry.getHandler().prepare(instrumentedType);</b>
<b class="fc">&nbsp;                    if (instrumentedType != typeDescription) { // Avoid unnecessary scanning for helper methods if instrumented type was not changed.</b>
<b class="fc">&nbsp;                        for (MethodDescription methodDescription : typeDescription.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                            if (!declaredMethods.contains(methodDescription)) {</b>
<b class="fc">&nbsp;                                implementations.put(methodDescription, entry.asSupplementaryEntry(methodDescription));</b>
<b class="fc">&nbsp;                                declaredMethods.add(methodDescription);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        instrumentedType = typeDescription;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            MethodGraph.Linked methodGraph = methodGraphCompiler.compile((TypeDefinition) instrumentedType);</b>
&nbsp;            // Casting required for Java 6 compiler.
<b class="fc">&nbsp;            ElementMatcher&lt;? super MethodDescription&gt; relevanceMatcher = (ElementMatcher&lt;? super MethodDescription&gt;) failSafe(not(anyOf(implementations.keySet()))</b>
<b class="fc">&nbsp;                    .and(returns(isVisibleTo(instrumentedType)))</b>
<b class="fc">&nbsp;                    .and(hasParameters(whereNone(hasType(not(isVisibleTo(instrumentedType))))))).and(ignoredMethods.resolve(instrumentedType));</b>
<b class="fc">&nbsp;            List&lt;MethodDescription&gt; methods = new ArrayList&lt;MethodDescription&gt;();</b>
<b class="fc">&nbsp;            for (MethodGraph.Node node : methodGraph.listNodes()) {</b>
<b class="fc">&nbsp;                MethodDescription methodDescription = node.getRepresentative();</b>
<b class="fc">&nbsp;                boolean visibilityBridge = instrumentedType.isPublic() &amp;&amp; !instrumentedType.isInterface();</b>
<b class="fc">&nbsp;                if (relevanceMatcher.matches(methodDescription)) {</b>
<b class="fc">&nbsp;                    for (Entry entry : entries) {</b>
<b class="fc">&nbsp;                        if (entry.resolve(instrumentedType).matches(methodDescription)) {</b>
<b class="fc">&nbsp;                            implementations.put(methodDescription, entry.asPreparedEntry(instrumentedType,</b>
&nbsp;                                    methodDescription,
<b class="fc">&nbsp;                                    node.getMethodTypes(),</b>
<b class="fc">&nbsp;                                    node.getVisibility()));</b>
<b class="fc">&nbsp;                            visibilityBridge = false;</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                if (visibilityBridge</b>
<b class="fc">&nbsp;                        &amp;&amp; !node.getSort().isMadeVisible()</b>
<b class="fc">&nbsp;                        &amp;&amp; methodDescription.isPublic()</b>
<b class="fc">&nbsp;                        &amp;&amp; !(methodDescription.isAbstract() || methodDescription.isFinal())</b>
<b class="fc">&nbsp;                        &amp;&amp; methodDescription.getDeclaringType().isPackagePrivate()</b>
<b class="fc">&nbsp;                        &amp;&amp; visibilityBridgeStrategy.generateVisibilityBridge(methodDescription)) {</b>
&nbsp;                    // Visibility bridges are required for public classes that inherit a public method from a package-private class.
<b class="fc">&nbsp;                    implementations.put(methodDescription, Prepared.Entry.forVisibilityBridge(methodDescription, node.getVisibility()));</b>
&nbsp;                }
<b class="fc">&nbsp;                methods.add(methodDescription);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            for (MethodDescription methodDescription : CompoundList.of(</b>
<b class="fc">&nbsp;                    instrumentedType.getDeclaredMethods().filter(not(isVirtual()).and(relevanceMatcher)),</b>
&nbsp;                    new MethodDescription.Latent.TypeInitializer(instrumentedType))) {
<b class="fc">&nbsp;                for (Entry entry : entries) {</b>
<b class="fc">&nbsp;                    if (entry.resolve(instrumentedType).matches(methodDescription)) {</b>
<b class="fc">&nbsp;                        implementations.put(methodDescription, entry.asPreparedEntry(instrumentedType, methodDescription, methodDescription.getVisibility()));</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                methods.add(methodDescription);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Prepared(implementations,</b>
<b class="fc">&nbsp;                    instrumentedType.getLoadedTypeInitializer(),</b>
<b class="fc">&nbsp;                    instrumentedType.getTypeInitializer(),</b>
<b class="fc">&nbsp;                    typeValidation.isEnabled()</b>
<b class="fc">&nbsp;                            ? instrumentedType.validated()</b>
<b class="fc">&nbsp;                            : instrumentedType,</b>
&nbsp;                    methodGraph,
&nbsp;                    new MethodList.Explicit&lt;MethodDescription&gt;(methods));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An entry of a default method registry.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Entry implements LatentMatcher&lt;MethodDescription&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The latent method matcher that this entry represents.
&nbsp;             */
&nbsp;            private final LatentMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The handler to apply to all matched entries.
&nbsp;             */
&nbsp;            private final Handler handler;
&nbsp;
&nbsp;            /**
&nbsp;             * A method attribute appender factory to apply to all entries.
&nbsp;             */
&nbsp;            private final MethodAttributeAppender.Factory attributeAppenderFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * The method transformer to be applied to implemented methods.
&nbsp;             */
&nbsp;            private final Transformer&lt;MethodDescription&gt; transformer;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new entry.
&nbsp;             *
&nbsp;             * @param matcher                  The latent method matcher that this entry represents.
&nbsp;             * @param handler                  The handler to apply to all matched entries.
&nbsp;             * @param attributeAppenderFactory A method attribute appender factory to apply to all entries.
&nbsp;             * @param transformer              The method transformer to be applied to implemented methods.
&nbsp;             */
&nbsp;            protected Entry(LatentMatcher&lt;? super MethodDescription&gt; matcher,
&nbsp;                            Handler handler,
&nbsp;                            MethodAttributeAppender.Factory attributeAppenderFactory,
<b class="fc">&nbsp;                            Transformer&lt;MethodDescription&gt; transformer) {</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.handler = handler;</b>
<b class="fc">&nbsp;                this.attributeAppenderFactory = attributeAppenderFactory;</b>
<b class="fc">&nbsp;                this.transformer = transformer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this entry into a prepared state.
&nbsp;             *
&nbsp;             * @param instrumentedType  The instrumented type.
&nbsp;             * @param methodDescription The non-transformed method to be implemented.
&nbsp;             * @param visibility        The represented method&#39;s minimum visibility.
&nbsp;             * @return A prepared version of this entry.
&nbsp;             */
&nbsp;            protected Prepared.Entry asPreparedEntry(TypeDescription instrumentedType, MethodDescription methodDescription, Visibility visibility) {
<b class="fc">&nbsp;                return asPreparedEntry(instrumentedType, methodDescription, Collections.&lt;MethodDescription.TypeToken&gt;emptySet(), visibility);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this entry into a prepared state.
&nbsp;             *
&nbsp;             * @param instrumentedType  The instrumented type.
&nbsp;             * @param methodDescription The non-transformed method to be implemented.
&nbsp;             * @param methodTypes       The method types this method represents.
&nbsp;             * @param visibility        The represented method&#39;s minimum visibility.
&nbsp;             * @return A prepared version of this entry.
&nbsp;             */
&nbsp;            protected Prepared.Entry asPreparedEntry(TypeDescription instrumentedType,
&nbsp;                                                     MethodDescription methodDescription,
&nbsp;                                                     Set&lt;MethodDescription.TypeToken&gt; methodTypes,
&nbsp;                                                     Visibility visibility) {
<b class="fc">&nbsp;                return new Prepared.Entry(handler,</b>
&nbsp;                        attributeAppenderFactory,
<b class="fc">&nbsp;                        transformer.transform(instrumentedType, methodDescription),</b>
&nbsp;                        methodTypes,
&nbsp;                        visibility,
&nbsp;                        false);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a prepared entry for a supplementary method.
&nbsp;             *
&nbsp;             * @param methodDescription The method to be implemented.
&nbsp;             * @return An entry for a supplementary entry that is defined by a method implementation instance.
&nbsp;             */
&nbsp;            protected Prepared.Entry asSupplementaryEntry(MethodDescription methodDescription) {
<b class="fc">&nbsp;                return new Prepared.Entry(handler,</b>
<b class="fc">&nbsp;                        MethodAttributeAppender.Explicit.of(methodDescription),</b>
&nbsp;                        methodDescription,
<b class="fc">&nbsp;                        Collections.&lt;MethodDescription.TypeToken&gt;emptySet(),</b>
<b class="fc">&nbsp;                        methodDescription.getVisibility(),</b>
&nbsp;                        false);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns this entry&#39;s handler.
&nbsp;             *
&nbsp;             * @return The handler of this entry.
&nbsp;             */
&nbsp;            protected Handler getHandler() {
<b class="fc">&nbsp;                return handler;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ElementMatcher&lt;? super MethodDescription&gt; resolve(TypeDescription typeDescription) {
<b class="fc">&nbsp;                return matcher.resolve(typeDescription);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A prepared version of a default method registry.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Prepared implements MethodRegistry.Prepared {
&nbsp;
&nbsp;            /**
&nbsp;             * A map of all method descriptions mapped to their handling entries.
&nbsp;             */
&nbsp;            private final LinkedHashMap&lt;MethodDescription, Entry&gt; implementations;
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded type initializer of the instrumented type.
&nbsp;             */
&nbsp;            private final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;            /**
&nbsp;             * The type initializer of the instrumented type.
&nbsp;             */
&nbsp;            private final TypeInitializer typeInitializer;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * A method graph describing the instrumented type.
&nbsp;             */
&nbsp;            private final MethodGraph.Linked methodGraph;
&nbsp;
&nbsp;            /**
&nbsp;             * The declared or virtually inherited methods of this type.
&nbsp;             */
&nbsp;            private final MethodList&lt;?&gt; methods;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a prepared version of a default method registry.
&nbsp;             *
&nbsp;             * @param implementations       A map of all method descriptions mapped to their handling entries.
&nbsp;             * @param loadedTypeInitializer The loaded type initializer of the instrumented type.
&nbsp;             * @param typeInitializer       The type initializer of the instrumented type.
&nbsp;             * @param instrumentedType      The instrumented type.
&nbsp;             * @param methodGraph           A method graph describing the instrumented type.
&nbsp;             * @param methods               The declared or virtually inherited methods of this type.
&nbsp;             */
&nbsp;            protected Prepared(LinkedHashMap&lt;MethodDescription, Entry&gt; implementations,
&nbsp;                               LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                               TypeInitializer typeInitializer,
&nbsp;                               TypeDescription instrumentedType,
&nbsp;                               MethodGraph.Linked methodGraph,
<b class="fc">&nbsp;                               MethodList&lt;?&gt; methods) {</b>
<b class="fc">&nbsp;                this.implementations = implementations;</b>
<b class="fc">&nbsp;                this.loadedTypeInitializer = loadedTypeInitializer;</b>
<b class="fc">&nbsp;                this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.methodGraph = methodGraph;</b>
<b class="fc">&nbsp;                this.methods = methods;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getInstrumentedType() {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public LoadedTypeInitializer getLoadedTypeInitializer() {
<b class="fc">&nbsp;                return loadedTypeInitializer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeInitializer getTypeInitializer() {
<b class="fc">&nbsp;                return typeInitializer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;?&gt; getMethods() {
<b class="fc">&nbsp;                return methods;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;?&gt; getInstrumentedMethods() {
<b class="fc">&nbsp;                return new MethodList.Explicit&lt;MethodDescription&gt;(new ArrayList&lt;MethodDescription&gt;(implementations.keySet())).filter(not(isTypeInitializer()));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodRegistry.Compiled compile(Implementation.Target.Factory implementationTargetFactory, ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;                Map&lt;Handler, Handler.Compiled&gt; compilationCache = new HashMap&lt;Handler, Handler.Compiled&gt;();</b>
<b class="fc">&nbsp;                Map&lt;MethodAttributeAppender.Factory, MethodAttributeAppender&gt; attributeAppenderCache = new HashMap&lt;MethodAttributeAppender.Factory, MethodAttributeAppender&gt;();</b>
<b class="fc">&nbsp;                LinkedHashMap&lt;MethodDescription, Compiled.Entry&gt; entries = new LinkedHashMap&lt;MethodDescription, Compiled.Entry&gt;();</b>
<b class="fc">&nbsp;                Implementation.Target implementationTarget = implementationTargetFactory.make(instrumentedType, methodGraph, classFileVersion);</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;MethodDescription, Entry&gt; entry : implementations.entrySet()) {</b>
<b class="fc">&nbsp;                    Handler.Compiled cachedHandler = compilationCache.get(entry.getValue().getHandler());</b>
<b class="fc">&nbsp;                    if (cachedHandler == null) {</b>
<b class="fc">&nbsp;                        cachedHandler = entry.getValue().getHandler().compile(implementationTarget);</b>
<b class="fc">&nbsp;                        compilationCache.put(entry.getValue().getHandler(), cachedHandler);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    MethodAttributeAppender cachedAttributeAppender = attributeAppenderCache.get(entry.getValue().getAppenderFactory());</b>
<b class="fc">&nbsp;                    if (cachedAttributeAppender == null) {</b>
<b class="fc">&nbsp;                        cachedAttributeAppender = entry.getValue().getAppenderFactory().make(instrumentedType);</b>
<b class="fc">&nbsp;                        attributeAppenderCache.put(entry.getValue().getAppenderFactory(), cachedAttributeAppender);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    entries.put(entry.getKey(), new Compiled.Entry(cachedHandler,</b>
&nbsp;                            cachedAttributeAppender,
<b class="fc">&nbsp;                            entry.getValue().getMethodDescription(),</b>
<b class="fc">&nbsp;                            entry.getValue().resolveBridgeTypes(),</b>
<b class="fc">&nbsp;                            entry.getValue().getVisibility(),</b>
<b class="fc">&nbsp;                            entry.getValue().isBridgeMethod()));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new Compiled(instrumentedType,</b>
&nbsp;                        loadedTypeInitializer,
&nbsp;                        typeInitializer,
&nbsp;                        methods,
&nbsp;                        entries,
<b class="fc">&nbsp;                        classFileVersion.isAtLeast(ClassFileVersion.JAVA_V5));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An entry of a prepared method registry.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Entry {
&nbsp;
&nbsp;                /**
&nbsp;                 * The handler for implementing methods.
&nbsp;                 */
&nbsp;                private final Handler handler;
&nbsp;
&nbsp;                /**
&nbsp;                 * A attribute appender factory for appending attributes for any implemented method.
&nbsp;                 */
&nbsp;                private final MethodAttributeAppender.Factory attributeAppenderFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method this entry represents.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method&#39;s type tokens.
&nbsp;                 */
&nbsp;                private final Set&lt;MethodDescription.TypeToken&gt; typeTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The minimum required visibility of this method.
&nbsp;                 */
&nbsp;                private final Visibility visibility;
&nbsp;
&nbsp;                /**
&nbsp;                 * Is {@code true} if this entry represents a bridge method.
&nbsp;                 */
&nbsp;                private final boolean bridgeMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new prepared entry.
&nbsp;                 *
&nbsp;                 * @param handler                  The handler for implementing methods.
&nbsp;                 * @param attributeAppenderFactory A attribute appender factory for appending attributes for any implemented method.
&nbsp;                 * @param methodDescription        The method this entry represents.
&nbsp;                 * @param typeTokens               A set of bridges representing the bridge methods of this method.
&nbsp;                 * @param visibility               The minimum required visibility of this method.
&nbsp;                 * @param bridgeMethod             {@code true} if this entry represents a bridge method.
&nbsp;                 */
&nbsp;                protected Entry(Handler handler,
&nbsp;                                MethodAttributeAppender.Factory attributeAppenderFactory,
&nbsp;                                MethodDescription methodDescription,
&nbsp;                                Set&lt;MethodDescription.TypeToken&gt; typeTokens,
&nbsp;                                Visibility visibility,
<b class="fc">&nbsp;                                boolean bridgeMethod) {</b>
<b class="fc">&nbsp;                    this.handler = handler;</b>
<b class="fc">&nbsp;                    this.attributeAppenderFactory = attributeAppenderFactory;</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    this.typeTokens = typeTokens;</b>
<b class="fc">&nbsp;                    this.visibility = visibility;</b>
<b class="fc">&nbsp;                    this.bridgeMethod = bridgeMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an entry for a visibility bridge.
&nbsp;                 *
&nbsp;                 * @param bridgeTarget The bridge method&#39;s target.
&nbsp;                 * @param visibility   The represented method&#39;s minimum visibility.
&nbsp;                 * @return An entry representing a visibility bridge.
&nbsp;                 */
&nbsp;                protected static Entry forVisibilityBridge(MethodDescription bridgeTarget, Visibility visibility) {
<b class="fc">&nbsp;                    return new Entry(Handler.ForVisibilityBridge.INSTANCE,</b>
<b class="fc">&nbsp;                            MethodAttributeAppender.Explicit.of(bridgeTarget),</b>
&nbsp;                            bridgeTarget,
<b class="fc">&nbsp;                            Collections.&lt;MethodDescription.TypeToken&gt;emptySet(),</b>
&nbsp;                            visibility,
&nbsp;                            true);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns this entry&#39;s handler.
&nbsp;                 *
&nbsp;                 * @return The entry&#39;s handler.
&nbsp;                 */
&nbsp;                protected Handler getHandler() {
<b class="fc">&nbsp;                    return handler;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns this entry&#39;s attribute appender factory.
&nbsp;                 *
&nbsp;                 * @return This entry&#39;s attribute appender factory.
&nbsp;                 */
&nbsp;                protected MethodAttributeAppender.Factory getAppenderFactory() {
<b class="fc">&nbsp;                    return attributeAppenderFactory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the method description this entry represents.
&nbsp;                 *
&nbsp;                 * @return The method description this entry represents.
&nbsp;                 */
&nbsp;                protected MethodDescription getMethodDescription() {
<b class="fc">&nbsp;                    return methodDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the type tokens of all bridge methods that are required to be implemented for this entry.
&nbsp;                 *
&nbsp;                 * @return A set of type tokens representing the bridge methods required for implementing this type.
&nbsp;                 */
&nbsp;                protected Set&lt;MethodDescription.TypeToken&gt; resolveBridgeTypes() {
<b class="fc">&nbsp;                    HashSet&lt;MethodDescription.TypeToken&gt; typeTokens = new HashSet&lt;MethodDescription.TypeToken&gt;(this.typeTokens);</b>
<b class="fc">&nbsp;                    typeTokens.remove(methodDescription.asTypeToken());</b>
<b class="fc">&nbsp;                    return typeTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the represented method&#39;s minimum visibility.
&nbsp;                 *
&nbsp;                 * @return The represented method&#39;s minimum visibility.
&nbsp;                 */
&nbsp;                protected Visibility getVisibility() {
<b class="fc">&nbsp;                    return visibility;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if this entry represents a bridge method.
&nbsp;                 *
&nbsp;                 * @return {@code true} if this entry represents a bridge method.
&nbsp;                 */
&nbsp;                protected boolean isBridgeMethod() {
<b class="fc">&nbsp;                    return bridgeMethod;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compiled version of a default method registry.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Compiled implements MethodRegistry.Compiled {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded type initializer of the instrumented type.
&nbsp;             */
&nbsp;            private final LoadedTypeInitializer loadedTypeInitializer;
&nbsp;
&nbsp;            /**
&nbsp;             * The type initializer of the instrumented type.
&nbsp;             */
&nbsp;            private final TypeInitializer typeInitializer;
&nbsp;
&nbsp;            /**
&nbsp;             * The declared or virtually inherited methods of this type.
&nbsp;             */
&nbsp;            private final MethodList&lt;?&gt; methods;
&nbsp;
&nbsp;            /**
&nbsp;             * A map of all method descriptions mapped to their handling entries.
&nbsp;             */
&nbsp;            private final LinkedHashMap&lt;MethodDescription, Entry&gt; implementations;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the created type supports bridge methods.
&nbsp;             */
&nbsp;            private final boolean supportsBridges;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compiled version of a default method registry.
&nbsp;             *
&nbsp;             * @param instrumentedType      The instrumented type.
&nbsp;             * @param loadedTypeInitializer The loaded type initializer of the instrumented type.
&nbsp;             * @param typeInitializer       The type initializer of the instrumented type.
&nbsp;             * @param methods               The declared or virtually inherited methods of this type.
&nbsp;             * @param implementations       A map of all method descriptions mapped to their handling entries.
&nbsp;             * @param supportsBridges       {@code true} if the created type supports bridge methods.
&nbsp;             */
&nbsp;            protected Compiled(TypeDescription instrumentedType,
&nbsp;                               LoadedTypeInitializer loadedTypeInitializer,
&nbsp;                               TypeInitializer typeInitializer,
&nbsp;                               MethodList&lt;?&gt; methods,
&nbsp;                               LinkedHashMap&lt;MethodDescription, Entry&gt; implementations,
<b class="fc">&nbsp;                               boolean supportsBridges) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.loadedTypeInitializer = loadedTypeInitializer;</b>
<b class="fc">&nbsp;                this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;                this.methods = methods;</b>
<b class="fc">&nbsp;                this.implementations = implementations;</b>
<b class="fc">&nbsp;                this.supportsBridges = supportsBridges;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getInstrumentedType() {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public LoadedTypeInitializer getLoadedTypeInitializer() {
<b class="fc">&nbsp;                return loadedTypeInitializer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeInitializer getTypeInitializer() {
<b class="fc">&nbsp;                return typeInitializer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;?&gt; getMethods() {
<b class="fc">&nbsp;                return methods;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;?&gt; getInstrumentedMethods() {
<b class="fc">&nbsp;                return new MethodList.Explicit&lt;MethodDescription&gt;(new ArrayList&lt;MethodDescription&gt;(implementations.keySet())).filter(not(isTypeInitializer()));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Record target(MethodDescription methodDescription) {
<b class="fc">&nbsp;                Entry entry = implementations.get(methodDescription);</b>
<b class="fc">&nbsp;                return entry == null</b>
<b class="fc">&nbsp;                        ? new Record.ForNonImplementedMethod(methodDescription)</b>
<b class="fc">&nbsp;                        : entry.bind(instrumentedType, supportsBridges);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An entry of a compiled method registry.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Entry {
&nbsp;
&nbsp;                /**
&nbsp;                 * The handler to be used for implementing a method.
&nbsp;                 */
&nbsp;                private final Handler.Compiled handler;
&nbsp;
&nbsp;                /**
&nbsp;                 * The attribute appender of a compiled method.
&nbsp;                 */
&nbsp;                private final MethodAttributeAppender attributeAppender;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method to be implemented including potential transformations.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type tokens representing all bridge methods for the method.
&nbsp;                 */
&nbsp;                private final Set&lt;MethodDescription.TypeToken&gt; bridgeTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented method&#39;s minimum visibility.
&nbsp;                 */
&nbsp;                private final Visibility visibility;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this entry represents a bridge method.
&nbsp;                 */
&nbsp;                private final boolean bridgeMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new entry for a compiled method registry.
&nbsp;                 *
&nbsp;                 * @param handler           The handler to be used for implementing a method.
&nbsp;                 * @param attributeAppender The attribute appender of a compiled method.
&nbsp;                 * @param methodDescription The method to be implemented including potential transformations.
&nbsp;                 * @param bridgeTypes       The type tokens representing all bridge methods for the method.
&nbsp;                 * @param visibility        The represented method&#39;s minimum visibility.
&nbsp;                 * @param bridgeMethod      {@code true} if this entry represents a bridge method.
&nbsp;                 */
&nbsp;                protected Entry(Handler.Compiled handler,
&nbsp;                                MethodAttributeAppender attributeAppender,
&nbsp;                                MethodDescription methodDescription,
&nbsp;                                Set&lt;MethodDescription.TypeToken&gt; bridgeTypes,
&nbsp;                                Visibility visibility,
<b class="fc">&nbsp;                                boolean bridgeMethod) {</b>
<b class="fc">&nbsp;                    this.handler = handler;</b>
<b class="fc">&nbsp;                    this.attributeAppender = attributeAppender;</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    this.bridgeTypes = bridgeTypes;</b>
<b class="fc">&nbsp;                    this.visibility = visibility;</b>
<b class="fc">&nbsp;                    this.bridgeMethod = bridgeMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this entry into a method record.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type to bind.
&nbsp;                 * @param supportsBridges  {@code true} if the record should support bridge methods.
&nbsp;                 * @return A record representing this entry&#39;s properties.
&nbsp;                 */
&nbsp;                protected Record bind(TypeDescription instrumentedType, boolean supportsBridges) {
<b class="fc">&nbsp;                    if (bridgeMethod &amp;&amp; !supportsBridges) {</b>
<b class="fc">&nbsp;                        return new Record.ForNonImplementedMethod(methodDescription);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Record record = handler.assemble(methodDescription, attributeAppender, visibility);</b>
<b class="fc">&nbsp;                    return supportsBridges</b>
<b class="fc">&nbsp;                            ? TypeWriter.MethodPool.Record.AccessBridgeWrapper.of(record, instrumentedType, methodDescription, bridgeTypes, attributeAppender)</b>
<b class="fc">&nbsp;                            : record;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
