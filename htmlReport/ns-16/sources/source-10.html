


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ToStringMethod</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: ToStringMethod (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ToStringMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ToStringMethod$1</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$Appender</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$PrefixResolver</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$PrefixResolver$Default</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$PrefixResolver$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$PrefixResolver$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$PrefixResolver$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$PrefixResolver$ForFixedValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/60)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$10</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$11</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$12</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$13</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$14</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$15</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$16</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$17</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$18</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$19</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$2</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$3</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$4</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$5</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$6</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$7</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$8</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ToStringMethod$ValueConsumer$9</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/67)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/211)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.TextConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * An implementation of {@link Object#toString()} that concatenates the {@link String} representation of all fields that are declared by a class.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;public class ToStringMethod implements Implementation {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link StringBuilder#StringBuilder(String)} constructor.
&nbsp;     */
<b class="nc">&nbsp;    private static final MethodDescription.InDefinedShape STRING_BUILDER_CONSTRUCTOR = TypeDescription.ForLoadedType.of(StringBuilder.class)</b>
<b class="nc">&nbsp;            .getDeclaredMethods()</b>
<b class="nc">&nbsp;            .filter(isConstructor().and(ElementMatchers.takesArguments(String.class)))</b>
<b class="nc">&nbsp;            .getOnly();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link StringBuilder#toString()} method.
&nbsp;     */
<b class="nc">&nbsp;    private static final MethodDescription.InDefinedShape TO_STRING = TypeDescription.ForLoadedType.of(StringBuilder.class)</b>
<b class="nc">&nbsp;            .getDeclaredMethods()</b>
<b class="nc">&nbsp;            .filter(isToString())</b>
<b class="nc">&nbsp;            .getOnly();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A resolver for the prefix of a {@link String} representation.
&nbsp;     */
&nbsp;    private final PrefixResolver prefixResolver;
&nbsp;
&nbsp;    /**
&nbsp;     * A token that is added between the prefix and the first field value.
&nbsp;     */
&nbsp;    private final String start;
&nbsp;
&nbsp;    /**
&nbsp;     * A token that is added after the last field value.
&nbsp;     */
&nbsp;    private final String end;
&nbsp;
&nbsp;    /**
&nbsp;     * A token that is added between two field values.
&nbsp;     */
&nbsp;    private final String separator;
&nbsp;
&nbsp;    /**
&nbsp;     * A token that is added between a field&#39;s name and its value.
&nbsp;     */
&nbsp;    private final String definer;
&nbsp;
&nbsp;    /**
&nbsp;     * A filter that determines what fields to ignore.
&nbsp;     */
&nbsp;    private final ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; ignored;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@code toString} implementation.
&nbsp;     *
&nbsp;     * @param prefixResolver A resolver for the prefix of a {@link String} representation.
&nbsp;     */
&nbsp;    protected ToStringMethod(PrefixResolver prefixResolver) {
<b class="nc">&nbsp;        this(prefixResolver, &quot;{&quot;, &quot;}&quot;, &quot;, &quot;, &quot;=&quot;, none());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new {@code toString} implementation.
&nbsp;     *
&nbsp;     * @param prefixResolver A resolver for the prefix of a {@link String} representation.
&nbsp;     * @param start          A token that is added between the prefix and the first field value.
&nbsp;     * @param end            A token that is added after the last field value.
&nbsp;     * @param separator      A token that is added between two field values.
&nbsp;     * @param definer        A token that is added between a field&#39;s name and its value.
&nbsp;     * @param ignored        A filter that determines what fields to ignore.
&nbsp;     */
&nbsp;    private ToStringMethod(PrefixResolver prefixResolver,
&nbsp;                           String start,
&nbsp;                           String end,
&nbsp;                           String separator,
&nbsp;                           String definer,
<b class="nc">&nbsp;                           ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; ignored) {</b>
<b class="nc">&nbsp;        this.prefixResolver = prefixResolver;</b>
<b class="nc">&nbsp;        this.start = start;</b>
<b class="nc">&nbsp;        this.end = end;</b>
<b class="nc">&nbsp;        this.separator = separator;</b>
<b class="nc">&nbsp;        this.definer = definer;</b>
<b class="nc">&nbsp;        this.ignored = ignored;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Object#toString()} implementation that is prefixed by the fully qualified class name of the instrumented type.
&nbsp;     *
&nbsp;     * @return A {@link Object#toString()} implementation that is prefixed by the fully qualified class name of the instrumented type.
&nbsp;     */
&nbsp;    public static ToStringMethod prefixedByFullyQualifiedClassName() {
<b class="nc">&nbsp;        return prefixedBy(PrefixResolver.Default.FULLY_QUALIFIED_CLASS_NAME);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Object#toString()} implementation that is prefixed by the canonical class name of the instrumented type.
&nbsp;     *
&nbsp;     * @return A {@link Object#toString()} implementation that is prefixed by the canonical class name of the instrumented type.
&nbsp;     */
&nbsp;    public static ToStringMethod prefixedByCanonicalClassName() {
<b class="nc">&nbsp;        return prefixedBy(PrefixResolver.Default.CANONICAL_CLASS_NAME);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Object#toString()} implementation that is prefixed by the simple class name of the instrumented type.
&nbsp;     *
&nbsp;     * @return A {@link Object#toString()} implementation that is prefixed by the simple class name of the instrumented type.
&nbsp;     */
&nbsp;    public static ToStringMethod prefixedBySimpleClassName() {
<b class="nc">&nbsp;        return prefixedBy(PrefixResolver.Default.SIMPLE_CLASS_NAME);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Object#toString()} implementation that is prefixed by the supplied string.
&nbsp;     *
&nbsp;     * @param prefix The prefix to use.
&nbsp;     * @return A {@link Object#toString()} implementation that is prefixed by the supplied string.
&nbsp;     */
&nbsp;    public static ToStringMethod prefixedBy(String prefix) {
<b class="nc">&nbsp;        if (prefix == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Prefix cannot be null&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return prefixedBy(new PrefixResolver.ForFixedValue(prefix));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link Object#toString()} implementation that is prefixed by the string that is supplied by the given prefix resolver.
&nbsp;     *
&nbsp;     * @param prefixResolver The prefix resolver to use.
&nbsp;     * @return A {@link Object#toString()} implementation that is prefixed by the string that is supplied by the given prefix resolver.
&nbsp;     */
&nbsp;    public static ToStringMethod prefixedBy(PrefixResolver prefixResolver) {
<b class="nc">&nbsp;        return new ToStringMethod(prefixResolver);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this toString method implementation that ignores the specified fields additionally to any
&nbsp;     * previously specified fields.
&nbsp;     *
&nbsp;     * @param ignored A matcher to specify any fields that should be ignored.
&nbsp;     * @return A new version of this toString method implementation that also ignores any fields matched by the provided matcher.
&nbsp;     */
&nbsp;    public ToStringMethod withIgnoredFields(ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; ignored) {
<b class="nc">&nbsp;        return new ToStringMethod(prefixResolver, start, end, separator, definer, this.ignored.&lt;FieldDescription.InDefinedShape&gt;or(ignored));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Changes the tokens used for the {@link Object#toString()} implementation.
&nbsp;     *
&nbsp;     * @param start     A token that is added between the prefix and the first field value.
&nbsp;     * @param end       A token that is added after the last field value.
&nbsp;     * @param separator A token that is added between two field values.
&nbsp;     * @param definer   A token that is added between two field values.
&nbsp;     * @return A new instance of this implementation that uses the supplied tokens.
&nbsp;     */
&nbsp;    public Implementation withTokens(String start, String end, String separator, String definer) {
<b class="nc">&nbsp;        if (start == null || end == null || separator == null || definer == null) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Token values cannot be null&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new ToStringMethod(prefixResolver, start, end, separator, definer, ignored);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;        return instrumentedType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Appender appender(Target implementationTarget) {
<b class="nc">&nbsp;        if (implementationTarget.getInstrumentedType().isInterface()) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot implement meaningful toString method for &quot; + implementationTarget.getInstrumentedType());</b>
&nbsp;        }
<b class="nc">&nbsp;        String prefix = prefixResolver.resolve(implementationTarget.getInstrumentedType());</b>
<b class="nc">&nbsp;        if (prefix == null) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Prefix for toString method cannot be null&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new Appender(prefix,</b>
&nbsp;                start,
&nbsp;                end,
&nbsp;                separator,
&nbsp;                definer,
<b class="nc">&nbsp;                implementationTarget.getInstrumentedType().getDeclaredFields().filter(not(isStatic().or(ignored))));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An appender to implement {@link ToStringMethod}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The prefix to use.
&nbsp;         */
&nbsp;        private final String prefix;
&nbsp;
&nbsp;        /**
&nbsp;         * A token that is added between the prefix and the first field value.
&nbsp;         */
&nbsp;        private final String start;
&nbsp;
&nbsp;        /**
&nbsp;         * A token that is added after the last field value.
&nbsp;         */
&nbsp;        private final String end;
&nbsp;
&nbsp;        /**
&nbsp;         * A token that is added between two field values.
&nbsp;         */
&nbsp;        private final String separator;
&nbsp;
&nbsp;        /**
&nbsp;         * A token that is added between a field&#39;s name and its value.
&nbsp;         */
&nbsp;        private final String definer;
&nbsp;
&nbsp;        /**
&nbsp;         * The list of fields to include in the {@link Object#toString()} implementation.
&nbsp;         */
&nbsp;        private final List&lt;? extends FieldDescription.InDefinedShape&gt; fieldDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender.
&nbsp;         *
&nbsp;         * @param prefix            The prefix to use.
&nbsp;         * @param start             A token that is added between the prefix and the first field value.
&nbsp;         * @param end               A token that is added after the last field value.
&nbsp;         * @param separator         A token that is added between two field values.
&nbsp;         * @param definer           A token that is added between a field&#39;s name and its value.
&nbsp;         * @param fieldDescriptions The list of fields to include in the {@link Object#toString()} implementation.
&nbsp;         */
&nbsp;        protected Appender(String prefix,
&nbsp;                           String start,
&nbsp;                           String end,
&nbsp;                           String separator,
&nbsp;                           String definer,
<b class="nc">&nbsp;                           List&lt;? extends FieldDescription.InDefinedShape&gt; fieldDescriptions) {</b>
<b class="nc">&nbsp;            this.prefix = prefix;</b>
<b class="nc">&nbsp;            this.start = start;</b>
<b class="nc">&nbsp;            this.end = end;</b>
<b class="nc">&nbsp;            this.separator = separator;</b>
<b class="nc">&nbsp;            this.definer = definer;</b>
<b class="nc">&nbsp;            this.fieldDescriptions = fieldDescriptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;            if (instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;toString method must not be static: &quot; + instrumentedMethod);</b>
<b class="nc">&nbsp;            } else if (!instrumentedMethod.getReturnType().asErasure().isAssignableFrom(String.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;toString method does not return String-compatible type: &quot; + instrumentedMethod);</b>
&nbsp;            }
<b class="nc">&nbsp;            List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(Math.max(0, fieldDescriptions.size() * 7 - 2) + 10);</b>
<b class="nc">&nbsp;            stackManipulations.add(TypeCreation.of(TypeDescription.ForLoadedType.of(StringBuilder.class)));</b>
<b class="nc">&nbsp;            stackManipulations.add(Duplication.SINGLE);</b>
<b class="nc">&nbsp;            stackManipulations.add(new TextConstant(prefix));</b>
<b class="nc">&nbsp;            stackManipulations.add(MethodInvocation.invoke(STRING_BUILDER_CONSTRUCTOR));</b>
<b class="nc">&nbsp;            stackManipulations.add(new TextConstant(start));</b>
<b class="nc">&nbsp;            stackManipulations.add(ValueConsumer.STRING);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (FieldDescription.InDefinedShape fieldDescription : fieldDescriptions) {</b>
<b class="nc">&nbsp;                if (first) {</b>
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stackManipulations.add(new TextConstant(separator));</b>
<b class="nc">&nbsp;                    stackManipulations.add(ValueConsumer.STRING);</b>
&nbsp;                }
<b class="nc">&nbsp;                stackManipulations.add(new TextConstant(fieldDescription.getName() + definer));</b>
<b class="nc">&nbsp;                stackManipulations.add(ValueConsumer.STRING);</b>
<b class="nc">&nbsp;                stackManipulations.add(MethodVariableAccess.loadThis());</b>
<b class="nc">&nbsp;                stackManipulations.add(FieldAccess.forField(fieldDescription).read());</b>
<b class="nc">&nbsp;                stackManipulations.add(ValueConsumer.of(fieldDescription.getType().asErasure()));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            stackManipulations.add(new TextConstant(end));</b>
<b class="nc">&nbsp;            stackManipulations.add(ValueConsumer.STRING);</b>
<b class="nc">&nbsp;            stackManipulations.add(MethodInvocation.invoke(TO_STRING));</b>
<b class="nc">&nbsp;            stackManipulations.add(MethodReturn.REFERENCE);</b>
<b class="nc">&nbsp;            return new Size(new StackManipulation.Compound(stackManipulations).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A prefix resolver is responsible for providing a value that is prepended to a {@link Object#toString()} implementation.
&nbsp;     */
&nbsp;    public interface PrefixResolver {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the prefixed value.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return The value to be prefixed.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        String resolve(TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * Default implementations for a prefix resolver.
&nbsp;         */
<b class="nc">&nbsp;        enum Default implements PrefixResolver {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A prefix resolver for the instrumented type&#39;s fully qualified class name.
&nbsp;             */
<b class="nc">&nbsp;            FULLY_QUALIFIED_CLASS_NAME {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public String resolve(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType.getName();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A prefix resolver for the instrumented type&#39;s fully qualified class name.
&nbsp;             */
<b class="nc">&nbsp;            CANONICAL_CLASS_NAME {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                @MaybeNull
&nbsp;                public String resolve(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType.getCanonicalName();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A prefix resolver for the instrumented type&#39;s simple class name.
&nbsp;             */
<b class="nc">&nbsp;            SIMPLE_CLASS_NAME {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public String resolve(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType.getSimpleName();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A prefix resolver that returns a fixed value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForFixedValue implements PrefixResolver {
&nbsp;
&nbsp;            /**
&nbsp;             * The prefix to prepend.
&nbsp;             */
&nbsp;            private final String prefix;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new prefix resolver that returns a fixed value.
&nbsp;             *
&nbsp;             * @param prefix The prefix to prepend.
&nbsp;             */
<b class="nc">&nbsp;            protected ForFixedValue(String prefix) {</b>
<b class="nc">&nbsp;                this.prefix = prefix;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String resolve(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                return prefix;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A value consumer that is responsible for adding a field value to the string creating {@link StringBuilder}.
&nbsp;     */
<b class="nc">&nbsp;    protected enum ValueConsumer implements StackManipulation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code boolean} value.
&nbsp;         */
<b class="nc">&nbsp;        BOOLEAN {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Z)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code char} value.
&nbsp;         */
<b class="nc">&nbsp;        CHARACTER {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(C)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for an {@code int} value.
&nbsp;         */
<b class="nc">&nbsp;        INTEGER {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(I)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code long} value.
&nbsp;         */
<b class="nc">&nbsp;        LONG {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(J)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code float} value.
&nbsp;         */
<b class="nc">&nbsp;        FLOAT {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(F)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code double} value.
&nbsp;         */
<b class="nc">&nbsp;        DOUBLE {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(D)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@link String} value.
&nbsp;         */
<b class="nc">&nbsp;        STRING {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@link CharSequence} value.
&nbsp;         */
<b class="nc">&nbsp;        CHARACTER_SEQUENCE {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/CharSequence;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a reference type.
&nbsp;         */
<b class="nc">&nbsp;        OBJECT {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/Object;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code boolean} array type.
&nbsp;         */
<b class="nc">&nbsp;        BOOLEAN_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([Z)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code byte} array type.
&nbsp;         */
<b class="nc">&nbsp;        BYTE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([B)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code short} array type.
&nbsp;         */
<b class="nc">&nbsp;        SHORT_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([S)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code char} array type.
&nbsp;         */
<b class="nc">&nbsp;        CHARACTER_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([C)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for an {@code int} array type.
&nbsp;         */
<b class="nc">&nbsp;        INTEGER_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([I)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code long} array type.
&nbsp;         */
<b class="nc">&nbsp;        LONG_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([J)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code float} array type.
&nbsp;         */
<b class="nc">&nbsp;        FLOAT_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([F)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a {@code double} array type.
&nbsp;         */
<b class="nc">&nbsp;        DOUBLE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([D)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a reference array type.
&nbsp;         */
<b class="nc">&nbsp;        REFERENCE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;toString&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A value consumer for a nested array type.
&nbsp;         */
<b class="nc">&nbsp;        NESTED_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;deepToString&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/String;&quot;, false);</b>
<b class="nc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/StringBuilder&quot;, &quot;append&quot;, &quot;(Ljava/lang/String;)Ljava/lang/StringBuilder;&quot;, false);</b>
<b class="nc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves an appropriate value resolver for a given type.
&nbsp;         *
&nbsp;         * @param typeDescription The type for which to resolve a value resolver.
&nbsp;         * @return An appropriate stack manipulation.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        protected static StackManipulation of(TypeDescription typeDescription) {
<b class="nc">&nbsp;            if (typeDescription.represents(boolean.class)) {</b>
<b class="nc">&nbsp;                return BOOLEAN;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(char.class)) {</b>
<b class="nc">&nbsp;                return CHARACTER;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(byte.class)</b>
<b class="nc">&nbsp;                    || typeDescription.represents(short.class)</b>
<b class="nc">&nbsp;                    || typeDescription.represents(int.class)) {</b>
<b class="nc">&nbsp;                return INTEGER;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(long.class)) {</b>
<b class="nc">&nbsp;                return LONG;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(float.class)) {</b>
<b class="nc">&nbsp;                return FLOAT;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(double.class)) {</b>
<b class="nc">&nbsp;                return DOUBLE;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(String.class)) {</b>
<b class="nc">&nbsp;                return STRING;</b>
<b class="nc">&nbsp;            } else if (typeDescription.isAssignableTo(CharSequence.class)) {</b>
<b class="nc">&nbsp;                return CHARACTER_SEQUENCE;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(boolean[].class)) {</b>
<b class="nc">&nbsp;                return BOOLEAN_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(byte[].class)) {</b>
<b class="nc">&nbsp;                return BYTE_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(short[].class)) {</b>
<b class="nc">&nbsp;                return SHORT_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(char[].class)) {</b>
<b class="nc">&nbsp;                return CHARACTER_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(int[].class)) {</b>
<b class="nc">&nbsp;                return INTEGER_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(long[].class)) {</b>
<b class="nc">&nbsp;                return LONG_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(float[].class)) {</b>
<b class="nc">&nbsp;                return FLOAT_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.represents(double[].class)) {</b>
<b class="nc">&nbsp;                return DOUBLE_ARRAY;</b>
<b class="nc">&nbsp;            } else if (typeDescription.isArray()) {</b>
<b class="nc">&nbsp;                return typeDescription.getComponentType().isArray()</b>
<b class="nc">&nbsp;                        ? NESTED_ARRAY</b>
<b class="nc">&nbsp;                        : REFERENCE_ARRAY;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return OBJECT;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isValid() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 10:47</div>
</div>
</body>
</html>
