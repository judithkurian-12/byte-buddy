


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Pipe</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.bind.annotation</a>
</div>

<h1>Coverage Summary for Class: Pipe (net.bytebuddy.implementation.bind.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Pipe$1</td>
  </tr>
  <tr>
    <td class="name">Pipe$Binder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.7%
  </span>
  <span class="absValue">
    (29/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Pipe$Binder$RedirectionProxy</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.9%
  </span>
  <span class="absValue">
    (34/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Pipe$Binder$RedirectionProxy$ConstructorCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Pipe$Binder$RedirectionProxy$ConstructorCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Pipe$Binder$RedirectionProxy$MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Pipe$Binder$RedirectionProxy$MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Pipe$MockitoMock$1160964533</td>
  </tr>
  <tr>
    <td class="name">Pipe$MockitoMock$1160964533$auxiliary$1Lfr2KWb</td>
  </tr>
  <tr>
    <td class="name">Pipe$MockitoMock$1160964533$auxiliary$FdNj9Gb4</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.3%
  </span>
  <span class="absValue">
    (26/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.5%
  </span>
  <span class="absValue">
    (109/113)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.bind.annotation;
&nbsp;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodAccessorFactory;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bind.MethodDelegationBinder;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * A target method parameter that is annotated with this annotation allows to forward an intercepted method
&nbsp; * invocation to another instance. The instance to which a method call is forwarded must be of the most specific
&nbsp; * type that declares the intercepted method on the intercepted type.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Unfortunately, before Java 8, the Java Class Library does not define any interface type which takes a single
&nbsp; * {@link java.lang.Object} type and returns another {@link java.lang.Object} type. For this reason, a
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.Pipe.Binder} needs to be installed explicitly
&nbsp; * and registered on a {@link net.bytebuddy.implementation.MethodDelegation}. The installed type is allowed to be an
&nbsp; * interface without any super types that declares a single method which maps an {@link java.lang.Object} type to
&nbsp; * a another {@link java.lang.Object} type as a result value. It is however not prohibited to use generics in the
&nbsp; * process.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @see net.bytebuddy.implementation.MethodDelegation
&nbsp; * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
&nbsp; */
&nbsp;@Documented
&nbsp;@Retention(RetentionPolicy.RUNTIME)
&nbsp;@Target(ElementType.PARAMETER)
&nbsp;public @interface Pipe {
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the generated proxy should be {@link java.io.Serializable}.
&nbsp;     *
&nbsp;     * @return {@code true} if the generated proxy should be {@link java.io.Serializable}.
&nbsp;     */
&nbsp;    boolean serializableProxy() default false;
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder.ParameterBinder}
&nbsp;     * for binding the {@link net.bytebuddy.implementation.bind.annotation.Pipe} annotation.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;Pipe&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the {@link Pipe#serializableProxy()} method.
&nbsp;         */
<b class="fc">&nbsp;        private static final MethodDescription.InDefinedShape SERIALIZABLE_PROXY = TypeDescription.ForLoadedType.of(Pipe.class)</b>
<b class="fc">&nbsp;                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                .filter(named(&quot;serializableProxy&quot;))</b>
<b class="fc">&nbsp;                .getOnly();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The method which implements the behavior of forwarding a method invocation. This method needs to define
&nbsp;         * a single non-static method with an {@link java.lang.Object} to {@link java.lang.Object} mapping.
&nbsp;         */
&nbsp;        private final MethodDescription forwardingMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new binder. This constructor is not doing any validation of the forwarding method and its
&nbsp;         * declaring type. Such validation is normally performed by the
&nbsp;         * {@link net.bytebuddy.implementation.bind.annotation.Pipe.Binder#install(Class)}
&nbsp;         * method.
&nbsp;         *
&nbsp;         * @param forwardingMethod The method which implements the behavior of forwarding a method invocation. This
&nbsp;         *                         method needs to define a single non-static method with an {@link java.lang.Object}
&nbsp;         *                         to {@link java.lang.Object} mapping.
&nbsp;         */
<b class="fc">&nbsp;        protected Binder(MethodDescription forwardingMethod) {</b>
<b class="fc">&nbsp;            this.forwardingMethod = forwardingMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Installs a given type for use on a {@link net.bytebuddy.implementation.bind.annotation.Pipe}
&nbsp;         * annotation. The given type must be an interface without any super interfaces and a single method which
&nbsp;         * maps an {@link java.lang.Object} type to another {@link java.lang.Object} type. The use of generics is
&nbsp;         * permitted.
&nbsp;         *
&nbsp;         * @param type The type to install.
&nbsp;         * @return A binder for the {@link net.bytebuddy.implementation.bind.annotation.Pipe}
&nbsp;         * annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;Pipe&gt; install(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return install(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Installs a given type for use on a {@link net.bytebuddy.implementation.bind.annotation.Pipe}
&nbsp;         * annotation. The given type must be an interface without any super interfaces and a single method which
&nbsp;         * maps an {@link java.lang.Object} type to another {@link java.lang.Object} type. The use of generics is
&nbsp;         * permitted.
&nbsp;         *
&nbsp;         * @param typeDescription The type to install.
&nbsp;         * @return A binder for the {@link net.bytebuddy.implementation.bind.annotation.Pipe}
&nbsp;         * annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;Pipe&gt; install(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return new Binder(onlyMethod(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Locates the only method of a type that is compatible to being overridden for invoking the proxy.
&nbsp;         *
&nbsp;         * @param typeDescription The type that is being installed.
&nbsp;         * @return Its only method after validation.
&nbsp;         */
&nbsp;        private static MethodDescription onlyMethod(TypeDescription typeDescription) {
<b class="fc">&nbsp;            if (!typeDescription.isInterface()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not an interface&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.getInterfaces().isEmpty()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must not extend other interfaces&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.isPublic()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is mot public&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;?&gt; methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());</b>
<b class="fc">&nbsp;            if (methodCandidates.size() != 1) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must declare exactly one abstract method&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodDescription methodDescription = methodCandidates.getOnly();</b>
<b class="fc">&nbsp;            if (!methodDescription.getReturnType().asErasure().represents(Object.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(methodDescription + &quot; does not return an Object-type&quot;);</b>
<b class="fc">&nbsp;            } else if (methodDescription.getParameters().size() != 1 || !methodDescription.getParameters().getOnly().getType().asErasure().represents(Object.class)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(methodDescription + &quot; does not take a single Object-typed argument&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return methodDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Class&lt;Pipe&gt; getHandledType() {
<b class="fc">&nbsp;            return Pipe.class;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDelegationBinder.ParameterBinding&lt;?&gt; bind(AnnotationDescription.Loadable&lt;Pipe&gt; annotation,
&nbsp;                                                               MethodDescription source,
&nbsp;                                                               ParameterDescription target,
&nbsp;                                                               Implementation.Target implementationTarget,
&nbsp;                                                               Assigner assigner,
&nbsp;                                                               Assigner.Typing typing) {
<b class="fc">&nbsp;            if (!target.getType().asErasure().equals(forwardingMethod.getDeclaringType())) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Illegal use of @Pipe for &quot; + target + &quot; which was installed for &quot; + forwardingMethod.getDeclaringType());</b>
<b class="fc">&nbsp;            } else if (source.isStatic()) {</b>
<b class="fc">&nbsp;                return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;</b>
&nbsp;            }
<b class="fc">&nbsp;            return new MethodDelegationBinder.ParameterBinding.Anonymous(new RedirectionProxy(forwardingMethod.getDeclaringType().asErasure(),</b>
&nbsp;                    source,
&nbsp;                    assigner,
<b class="fc">&nbsp;                    annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An auxiliary type for performing the redirection of a method invocation as requested by the
&nbsp;         * {@link net.bytebuddy.implementation.bind.annotation.Pipe} annotation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class RedirectionProxy extends StackManipulation.AbstractBase implements AuxiliaryType {
&nbsp;
&nbsp;            /**
&nbsp;             * The prefix for naming fields to store method arguments.
&nbsp;             */
&nbsp;            private static final String FIELD_NAME_PREFIX = &quot;argument&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The type that declares the method for forwarding a method invocation.
&nbsp;             */
&nbsp;            private final TypeDescription forwardingType;
&nbsp;
&nbsp;            /**
&nbsp;             * The method that is to be forwarded.
&nbsp;             */
&nbsp;            private final MethodDescription sourceMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if the generated proxy should be {@link java.io.Serializable}.
&nbsp;             */
&nbsp;            private final boolean serializableProxy;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new redirection.
&nbsp;             *
&nbsp;             * @param forwardingType    The type that declares the method for forwarding a method invocation.
&nbsp;             * @param sourceMethod      The method that is to be forwarded.
&nbsp;             * @param assigner          The assigner to use.
&nbsp;             * @param serializableProxy Determines if the generated proxy should be {@link java.io.Serializable}.
&nbsp;             */
&nbsp;            protected RedirectionProxy(TypeDescription forwardingType,
&nbsp;                                       MethodDescription sourceMethod,
&nbsp;                                       Assigner assigner,
<b class="fc">&nbsp;                                       boolean serializableProxy) {</b>
<b class="fc">&nbsp;                this.forwardingType = forwardingType;</b>
<b class="fc">&nbsp;                this.sourceMethod = sourceMethod;</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.serializableProxy = serializableProxy;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts all parameters of a method to fields.
&nbsp;             *
&nbsp;             * @param methodDescription The method to extract the parameters from.
&nbsp;             * @return A linked hash map of field names to the types of these fields representing all parameters of the
&nbsp;             * given method.
&nbsp;             */
&nbsp;            private static LinkedHashMap&lt;String, TypeDescription&gt; extractFields(MethodDescription methodDescription) {
<b class="fc">&nbsp;                TypeList parameterTypes = methodDescription.getParameters().asTypeList().asErasures();</b>
<b class="fc">&nbsp;                LinkedHashMap&lt;String, TypeDescription&gt; typeDescriptions = new LinkedHashMap&lt;String, TypeDescription&gt;();</b>
<b class="fc">&nbsp;                int currentIndex = 0;</b>
<b class="fc">&nbsp;                for (TypeDescription parameterType : parameterTypes) {</b>
<b class="fc">&nbsp;                    typeDescriptions.put(fieldName(currentIndex++), parameterType);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return typeDescriptions;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new field name.
&nbsp;             *
&nbsp;             * @param index The index of the field.
&nbsp;             * @return The field name that corresponds to the index.
&nbsp;             */
&nbsp;            private static String fieldName(int index) {
<b class="fc">&nbsp;                return FIELD_NAME_PREFIX + index;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSuffix() {
<b class="nc">&nbsp;                return RandomString.hashOf(forwardingType.hashCode())</b>
<b class="nc">&nbsp;                        + RandomString.hashOf(sourceMethod.hashCode())</b>
<b class="nc">&nbsp;                        + (serializableProxy ? &quot;S&quot; : &quot;0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType make(String auxiliaryTypeName,
&nbsp;                                    ClassFileVersion classFileVersion,
&nbsp;                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                LinkedHashMap&lt;String, TypeDescription&gt; parameterFields = extractFields(sourceMethod);</b>
<b class="fc">&nbsp;                DynamicType.Builder&lt;?&gt; builder = new ByteBuddy(classFileVersion)</b>
<b class="fc">&nbsp;                        .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                        .subclass(forwardingType, ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="fc">&nbsp;                        .name(auxiliaryTypeName)</b>
<b class="fc">&nbsp;                        .modifiers(DEFAULT_TYPE_MODIFIER)</b>
<b class="fc">&nbsp;                        .implement(serializableProxy ? new Class&lt;?&gt;[]{Serializable.class} : new Class&lt;?&gt;[0])</b>
<b class="fc">&nbsp;                        .method(ElementMatchers.&lt;MethodDescription&gt;isAbstract().and(isDeclaredBy(forwardingType)))</b>
<b class="fc">&nbsp;                        .intercept(new MethodCall(sourceMethod, assigner))</b>
<b class="fc">&nbsp;                        .defineConstructor().withParameters(parameterFields.values())</b>
<b class="fc">&nbsp;                        .intercept(ConstructorCall.INSTANCE);</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;String, TypeDescription&gt; field : parameterFields.entrySet()) {</b>
<b class="fc">&nbsp;                    builder = builder.defineField(field.getKey(), field.getValue(), Visibility.PRIVATE);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return builder.make();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;                TypeDescription forwardingType = implementationContext.register(this);</b>
<b class="fc">&nbsp;                return new Compound(</b>
<b class="fc">&nbsp;                        TypeCreation.of(forwardingType),</b>
&nbsp;                        Duplication.SINGLE,
<b class="fc">&nbsp;                        MethodVariableAccess.allArgumentsOf(sourceMethod),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(forwardingType.getDeclaredMethods().filter(isConstructor()).getOnly())</b>
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The implementation to implement a {@link RedirectionProxy}&#39;s constructor.
&nbsp;             */
<b class="fc">&nbsp;            protected enum ConstructorCall implements Implementation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference of the {@link Object} type default constructor.
&nbsp;                 */
&nbsp;                private final transient MethodDescription.InDefinedShape objectTypeDefaultConstructor;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates the constructor call singleton.
&nbsp;                 */
&nbsp;                ConstructorCall() {
&nbsp;                    objectTypeDefaultConstructor = TypeDescription.ForLoadedType.of(Object.class).getDeclaredMethods().filter(isConstructor()).getOnly();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                    return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The appender for implementing the {@link RedirectionProxy.ConstructorCall}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                private static class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type being created.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender.
&nbsp;                     *
&nbsp;                     * @param instrumentedType The instrumented type that is being created.
&nbsp;                     */
<b class="fc">&nbsp;                    private Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        FieldList&lt;?&gt; fieldList = instrumentedType.getDeclaredFields();</b>
<b class="fc">&nbsp;                        StackManipulation[] fieldLoading = new StackManipulation[fieldList.size()];</b>
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        for (FieldDescription fieldDescription : fieldList) {</b>
<b class="fc">&nbsp;                            fieldLoading[index] = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.load(instrumentedMethod.getParameters().get(index)),</b>
<b class="fc">&nbsp;                                    FieldAccess.forField(fieldDescription).write()</b>
&nbsp;                            );
<b class="fc">&nbsp;                            index++;</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                MethodInvocation.invoke(ConstructorCall.INSTANCE.objectTypeDefaultConstructor),</b>
&nbsp;                                new StackManipulation.Compound(fieldLoading),
&nbsp;                                MethodReturn.VOID
<b class="fc">&nbsp;                        ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                        return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The implementation to implement a {@link RedirectionProxy}&#39;s forwarding method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class MethodCall implements Implementation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The method that is invoked by the implemented method.
&nbsp;                 */
&nbsp;                private final MethodDescription redirectedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The assigner to be used for invoking the forwarded method.
&nbsp;                 */
&nbsp;                private final Assigner assigner;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new method call implementation.
&nbsp;                 *
&nbsp;                 * @param redirectedMethod The method that is invoked by the implemented method.
&nbsp;                 * @param assigner         The assigner to be used for invoking the forwarded method.
&nbsp;                 */
<b class="fc">&nbsp;                private MethodCall(MethodDescription redirectedMethod, Assigner assigner) {</b>
<b class="fc">&nbsp;                    this.redirectedMethod = redirectedMethod;</b>
<b class="fc">&nbsp;                    this.assigner = assigner;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                    if (!redirectedMethod.isAccessibleTo(implementationTarget.getInstrumentedType())) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + redirectedMethod + &quot; from outside of class via @Pipe proxy&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The appender for implementing the {@link RedirectionProxy.MethodCall}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                private class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type that is implemented.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender.
&nbsp;                     *
&nbsp;                     * @param instrumentedType The instrumented type to be implemented.
&nbsp;                     */
<b class="fc">&nbsp;                    private Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor,
&nbsp;                                      Context implementationContext,
&nbsp;                                      MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        FieldList&lt;?&gt; fieldList = instrumentedType.getDeclaredFields();</b>
<b class="fc">&nbsp;                        StackManipulation[] fieldLoading = new StackManipulation[fieldList.size()];</b>
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        for (FieldDescription fieldDescription : fieldList) {</b>
<b class="fc">&nbsp;                            fieldLoading[index++] = new StackManipulation.Compound(MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                                assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), redirectedMethod.getDeclaringType().asGenericType(), Assigner.Typing.DYNAMIC),</b>
&nbsp;                                new StackManipulation.Compound(fieldLoading),
<b class="fc">&nbsp;                                MethodInvocation.invoke(redirectedMethod),</b>
<b class="fc">&nbsp;                                assigner.assign(redirectedMethod.getReturnType(), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),</b>
&nbsp;                                MethodReturn.REFERENCE
<b class="fc">&nbsp;                        ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                        return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 15:48</div>
</div>
</body>
</html>
