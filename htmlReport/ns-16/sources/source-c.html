


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodCall</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: MethodCall (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    19%
  </span>
  <span class="absValue">
    (8/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    23.5%
  </span>
  <span class="absValue">
    (23/98)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodCall$1</td>
  </tr>
  <tr>
    <td class="name">MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (30/32)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ArgumentProvider</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForField$ArgumentProvider</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForField$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForInstance</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForInstance$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForInstrumentedType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForInstrumentedType$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodCall</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodCall$ArgumentProvider</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodCall$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameter$OfInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameterArray</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameterArray$ForInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameterArrayElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameterArrayElement$OfInvokedMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForMethodParameterArrayElement$OfParameter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForNullConstant</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForThisReference</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$ArgumentLoader$ForThisReference$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$FieldSetting</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$FieldSetting$Appender</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForContextualInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForContextualInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForDefaultMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForDefaultMethodInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForSuperMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForSuperMethodInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForVirtualInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForVirtualInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodInvoker$ForVirtualInvocation$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$ForElementMatcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$ForElementMatcher$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$ForExplicitMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$MethodLocator$ForInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForConstructingInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForConstructingInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForField$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForField$Location</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForField$Location$ForExplicitField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForField$Location$ForImplicitField</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodCall</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodCall$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodCall$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForMethodParameter$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForSelfOrStaticInvocation$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$ForValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$Resolved</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TargetHandler$Simple</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$FieldSetting</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$FieldSetting$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$FieldSetting$Implicit</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple$2</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$TerminationHandler$Simple$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCall$WithoutSpecifiedTarget</td>
<td class="coverageStat">
  <span class="percent">
    15.4%
  </span>
  <span class="absValue">
    (2/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (4/18)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    18.3%
  </span>
  <span class="absValue">
    (46/251)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.9%
  </span>
  <span class="absValue">
    (110/615)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.implementation.bytecode.*;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.*;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.Callable;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * This {@link Implementation} allows the invocation of a specified method while
&nbsp; * providing explicit arguments to this method.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class MethodCall implements Implementation.Composable {
&nbsp;
&nbsp;    /**
&nbsp;     * The method locator to use.
&nbsp;     */
&nbsp;    protected final MethodLocator.Factory methodLocator;
&nbsp;
&nbsp;    /**
&nbsp;     * The target handler to use.
&nbsp;     */
&nbsp;    protected final TargetHandler.Factory targetHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The argument loader to load arguments onto the operand stack in their application order.
&nbsp;     */
&nbsp;    protected final List&lt;ArgumentLoader.Factory&gt; argumentLoaders;
&nbsp;
&nbsp;    /**
&nbsp;     * The method invoker to use.
&nbsp;     */
&nbsp;    protected final MethodInvoker.Factory methodInvoker;
&nbsp;
&nbsp;    /**
&nbsp;     * The termination handler to use.
&nbsp;     */
&nbsp;    protected final TerminationHandler.Factory terminationHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to use.
&nbsp;     */
&nbsp;    protected final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method call implementation.
&nbsp;     *
&nbsp;     * @param methodLocator      The method locator to use.
&nbsp;     * @param targetHandler      The target handler to use.
&nbsp;     * @param argumentLoaders    The argument loader to load arguments onto the operand stack in their application order.
&nbsp;     * @param methodInvoker      The method invoker to use.
&nbsp;     * @param terminationHandler The termination handler to use.
&nbsp;     * @param assigner           The assigner to use.
&nbsp;     * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected MethodCall(MethodLocator.Factory methodLocator,
&nbsp;                         TargetHandler.Factory targetHandler,
&nbsp;                         List&lt;ArgumentLoader.Factory&gt; argumentLoaders,
&nbsp;                         MethodInvoker.Factory methodInvoker,
&nbsp;                         TerminationHandler.Factory terminationHandler,
&nbsp;                         Assigner assigner,
<b class="fc">&nbsp;                         Assigner.Typing typing) {</b>
<b class="fc">&nbsp;        this.methodLocator = methodLocator;</b>
<b class="fc">&nbsp;        this.targetHandler = targetHandler;</b>
<b class="fc">&nbsp;        this.argumentLoaders = argumentLoaders;</b>
<b class="fc">&nbsp;        this.methodInvoker = methodInvoker;</b>
<b class="fc">&nbsp;        this.terminationHandler = terminationHandler;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.typing = typing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given method. Without further specification, the method is invoked without any arguments on
&nbsp;     * the instance of the instrumented class or statically, if the given method is {@code static}.
&nbsp;     *
&nbsp;     * @param method The method to invoke.
&nbsp;     * @return A method call implementation that invokes the given method without providing any arguments.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(Method method) {
<b class="fc">&nbsp;        return invoke(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Invokes the given constructor on the instance of the instrumented type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: A constructor invocation can only be applied within another constructor to invoke the super constructor or an auxiliary
&nbsp;     * constructor. To construct a new instance, use {@link MethodCall#construct(Constructor)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param constructor The constructor to invoke.
&nbsp;     * @return A method call implementation that invokes the given constructor without providing any arguments.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;        return invoke(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Invokes the given method. If the method description describes a constructor, it is automatically invoked as
&nbsp;     * a special method invocation on the instance of the instrumented type. The same is true for {@code private}
&nbsp;     * methods. Finally, {@code static} methods are invoked statically.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: A constructor invocation can only be applied within another constructor to invoke the super constructor or an auxiliary
&nbsp;     * constructor. To construct a new instance, use {@link MethodCall#construct(MethodDescription)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param methodDescription The method to invoke.
&nbsp;     * @return A method call implementation that invokes the given method without providing any arguments.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(MethodDescription methodDescription) {
<b class="fc">&nbsp;        return invoke(new MethodLocator.ForExplicitMethod(methodDescription));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes a unique virtual method or constructor of the instrumented type that is matched by the specified matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to identify the method to invoke.
&nbsp;     * @return A method call for the uniquely identified method.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    public static WithoutSpecifiedTarget invoke(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="nc">&nbsp;        return invoke(matcher, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes a unique virtual method or constructor of the instrumented type that is matched by the specified matcher.
&nbsp;     *
&nbsp;     * @param matcher             The matcher to identify the method to invoke.
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A method call for the uniquely identified method.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invoke(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return invoke(new MethodLocator.ForElementMatcher.Factory(matcher, methodGraphCompiler));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes a method using the provided method locator.
&nbsp;     *
&nbsp;     * @param methodLocator The method locator to apply for locating the method to invoke given the instrumented
&nbsp;     *                      method.
&nbsp;     * @return A method call implementation that uses the provided method locator for resolving the method
&nbsp;     * to be invoked.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    public static WithoutSpecifiedTarget invoke(MethodLocator.Factory methodLocator) {
<b class="fc">&nbsp;        return new WithoutSpecifiedTarget(methodLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the instrumented method recursively. Invoking this method on the same instance causes a {@link StackOverflowError} due to
&nbsp;     * infinite recursion.
&nbsp;     *
&nbsp;     * @return A method call that invokes the method being instrumented.
&nbsp;     */
&nbsp;    public static WithoutSpecifiedTarget invokeSelf() {
<b class="nc">&nbsp;        return new WithoutSpecifiedTarget(MethodLocator.ForInstrumentedMethod.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the instrumented method as a super method call on the instance itself. This is a shortcut for {@code invokeSelf().onSuper()}.
&nbsp;     *
&nbsp;     * @return A method call that invokes the method being instrumented as a super method call.
&nbsp;     */
&nbsp;    public static MethodCall invokeSuper() {
<b class="nc">&nbsp;        return invokeSelf().onSuper();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements a method by invoking the provided {@link Callable}. The return value of the provided object is casted to the implemented method&#39;s
&nbsp;     * return type, if necessary.
&nbsp;     *
&nbsp;     * @param callable The callable to invoke when a method is intercepted.
&nbsp;     * @return A composable method implementation that invokes the given callable.
&nbsp;     */
&nbsp;    public static Composable call(Callable&lt;?&gt; callable) {
&nbsp;        try {
<b class="nc">&nbsp;            return invoke(Callable.class.getMethod(&quot;call&quot;)).on(callable, Callable.class).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC);</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Could not locate Callable::call method&quot;, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements a method by invoking the provided {@link Runnable}. If the instrumented method returns a value, {@code null} is returned.
&nbsp;     *
&nbsp;     * @param runnable The runnable to invoke when a method is intercepted.
&nbsp;     * @return A composable method implementation that invokes the given runnable.
&nbsp;     */
&nbsp;    public static Composable run(Runnable runnable) {
&nbsp;        try {
<b class="nc">&nbsp;            return invoke(Runnable.class.getMethod(&quot;run&quot;)).on(runnable, Runnable.class).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC);</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Could not locate Runnable::run method&quot;, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given constructor in order to create an instance.
&nbsp;     *
&nbsp;     * @param constructor The constructor to invoke.
&nbsp;     * @return A method call that invokes the given constructor without providing any arguments.
&nbsp;     */
&nbsp;    public static MethodCall construct(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;        return construct(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Invokes the given constructor in order to create an instance.
&nbsp;     *
&nbsp;     * @param methodDescription A description of the constructor to invoke.
&nbsp;     * @return A method call that invokes the given constructor without providing any arguments.
&nbsp;     */
&nbsp;    public static MethodCall construct(MethodDescription methodDescription) {
<b class="nc">&nbsp;        if (!methodDescription.isConstructor()) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Not a constructor: &quot; + methodDescription);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new MethodCall(new MethodLocator.ForExplicitMethod(methodDescription),</b>
&nbsp;                TargetHandler.ForConstructingInvocation.Factory.INSTANCE,
<b class="nc">&nbsp;                Collections.&lt;ArgumentLoader.Factory&gt;emptyList(),</b>
&nbsp;                MethodInvoker.ForContextualInvocation.Factory.INSTANCE,
&nbsp;                TerminationHandler.Simple.RETURNING,
&nbsp;                Assigner.DEFAULT,
&nbsp;                Assigner.Typing.STATIC);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a number of arguments to be handed to the method that is being invoked by this implementation. Any
&nbsp;     * wrapper type instances for primitive values, instances of {@link java.lang.String}, method handles, types,
&nbsp;     * method types as well as instances of {@link TypeDescription} or {@link JavaConstant} or {@code null} are loaded
&nbsp;     * directly onto the operand stack. This might corrupt referential identity for these values. Any other values
&nbsp;     * are stored within a {@code static} field that is added to the instrumented type.
&nbsp;     *
&nbsp;     * @param argument The arguments to provide to the method that is being called in their order.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(Object... argument) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(argument.length);</b>
<b class="nc">&nbsp;        for (Object anArgument : argument) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(ArgumentLoader.ForStackManipulation.of(anArgument));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given types to be provided as arguments to the invoked method where the represented types
&nbsp;     * are stored in the generated class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param typeDescription The type descriptions to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(TypeDescription... typeDescription) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(typeDescription.length);</b>
<b class="nc">&nbsp;        for (TypeDescription aTypeDescription : typeDescription) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(ClassConstant.of(aTypeDescription), Class.class));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given enumeration values to be provided as arguments to the invoked method where the values
&nbsp;     * are read from the enumeration class on demand.
&nbsp;     *
&nbsp;     * @param enumerationDescription The enumeration descriptions to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(EnumerationDescription... enumerationDescription) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(enumerationDescription.length);</b>
<b class="nc">&nbsp;        for (EnumerationDescription anEnumerationDescription : enumerationDescription) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(FieldAccess.forEnumeration(anEnumerationDescription), anEnumerationDescription.getEnumerationType()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given Java instances to be provided as arguments to the invoked method where the given
&nbsp;     * instances are stored in the generated class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param constant The constants to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(ConstantValue... constant) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(constant.length);</b>
<b class="nc">&nbsp;        for (ConstantValue aConstant : constant) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForStackManipulation(aConstant.toStackManipulation(), aConstant.getTypeDescription()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given Java instances to be provided as arguments to the invoked method where the given
&nbsp;     * instances are stored in the generated class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param constant The constants to provide as arguments.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(JavaConstant... constant) {
<b class="nc">&nbsp;        return with((ConstantValue[]) constant);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a number of arguments to be handed to the method that is being invoked by this implementation. Any
&nbsp;     * value is stored within a field in order to preserve referential identity. As an exception, the {@code null}
&nbsp;     * value is not stored within a field.
&nbsp;     *
&nbsp;     * @param argument The arguments to provide to the method that is being called in their order.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withReference(Object... argument) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(argument.length);</b>
<b class="nc">&nbsp;        for (Object anArgument : argument) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(anArgument == null</b>
<b class="nc">&nbsp;                    ? ArgumentLoader.ForNullConstant.INSTANCE</b>
<b class="nc">&nbsp;                    : new ArgumentLoader.ForInstance.Factory(anArgument));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a number of arguments of the instrumented method by their parameter indices to be handed
&nbsp;     * to the invoked method as an argument.
&nbsp;     *
&nbsp;     * @param index The parameter indices of the instrumented method to be handed to the invoked method as an
&nbsp;     *              argument in their order. The indices are zero-based.
&nbsp;     * @return A method call that hands the provided arguments to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withArgument(int... index) {
<b class="fc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(index.length);</b>
<b class="fc">&nbsp;        for (int anIndex : index) {</b>
<b class="fc">&nbsp;            if (anIndex &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Negative index: &quot; + anIndex);</b>
&nbsp;            }
<b class="fc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForMethodParameter.Factory(anIndex));</b>
&nbsp;        }
<b class="fc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds all arguments of the instrumented method as arguments to the invoked method to this method call.
&nbsp;     *
&nbsp;     * @return A method call that hands all arguments of the instrumented method to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withAllArguments() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForMethodParameter.OfInstrumentedMethod.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an array containing all arguments of the instrumented method to this method call.
&nbsp;     *
&nbsp;     * @return A method call that adds an array containing all arguments of the instrumented method to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArray() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForMethodParameterArray.ForInstrumentedMethod.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a method call where the parameter with {@code index} is expected to be an array and where each element of the array
&nbsp;     * is expected to represent an argument for the method being invoked.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This is typically used in combination with dynamic type assignments which is activated via
&nbsp;     * {@link MethodCall#withAssigner(Assigner, Assigner.Typing)} using a {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @return A method call that loads {@code size} elements from the array handed to the instrumented method as argument {@code index}.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArrayElements(int index) {
<b class="nc">&nbsp;        if (index &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(new ArgumentLoader.ForMethodParameterArrayElement.OfInvokedMethod(index));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a method call where the parameter with {@code index} is expected to be an array and where {@code size} elements are loaded
&nbsp;     * from the array as arguments for the invoked method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This is typically used in combination with dynamic type assignments which is activated via
&nbsp;     * {@link MethodCall#withAssigner(Assigner, Assigner.Typing)} using a {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param size  The amount of elements to load from the array.
&nbsp;     * @return A method call that loads {@code size} elements from the array handed to the instrumented method as argument {@code index}.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArrayElements(int index, int size) {
<b class="nc">&nbsp;        return withArgumentArrayElements(index, 0, size);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a method call where the parameter with {@code index} is expected to be an array and where {@code size} elements are loaded
&nbsp;     * from the array as arguments for the invoked method. The first element is loaded from index {@code start}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This is typically used in combination with dynamic type assignments which is activated via
&nbsp;     * {@link MethodCall#withAssigner(Assigner, Assigner.Typing)} using a {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param start The first array index to consider.
&nbsp;     * @param size  The amount of elements to load from the array with increasing index from {@code start}.
&nbsp;     * @return A method call that loads {@code size} elements from the array handed to the instrumented method as argument {@code index}.
&nbsp;     */
&nbsp;    public MethodCall withArgumentArrayElements(int index, int start, int size) {
<b class="nc">&nbsp;        if (index &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);</b>
<b class="nc">&nbsp;        } else if (start &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;An array index cannot be negative: &quot; + start);</b>
<b class="nc">&nbsp;        } else if (size == 0) {</b>
<b class="nc">&nbsp;            return this;</b>
<b class="nc">&nbsp;        } else if (size &lt; 0) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Size cannot be negative: &quot; + size);</b>
&nbsp;        }
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(size);</b>
<b class="nc">&nbsp;        for (int position = 0; position &lt; size; position++) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForMethodParameterArrayElement.OfParameter(index, start + position));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Assigns the {@code this} reference to the next parameter.
&nbsp;     *
&nbsp;     * @return This method call where the next parameter is a assigned a reference to the {@code this} reference
&nbsp;     * of the instance of the intercepted method.
&nbsp;     */
&nbsp;    public MethodCall withThis() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForThisReference.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Assigns the {@link java.lang.Class} value of the instrumented type.
&nbsp;     *
&nbsp;     * @return This method call where the next parameter is a assigned a reference to the {@link java.lang.Class}
&nbsp;     * value of the instrumented type.
&nbsp;     */
&nbsp;    public MethodCall withOwnType() {
<b class="nc">&nbsp;        return with(ArgumentLoader.ForInstrumentedType.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call which fetches a value from a list of existing fields.
&nbsp;     *
&nbsp;     * @param name The names of the fields.
&nbsp;     * @return A method call which assigns the next parameters to the values of the given fields.
&nbsp;     */
&nbsp;    public MethodCall withField(String... name) {
<b class="nc">&nbsp;        return withField(FieldLocator.ForClassHierarchy.Factory.INSTANCE, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call which fetches a value from a list of existing fields.
&nbsp;     *
&nbsp;     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;     * @param name                The names of the fields.
&nbsp;     * @return A method call which assigns the next parameters to the values of the given fields.
&nbsp;     */
&nbsp;    public MethodCall withField(FieldLocator.Factory fieldLocatorFactory, String... name) {
<b class="nc">&nbsp;        List&lt;ArgumentLoader.Factory&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader.Factory&gt;(name.length);</b>
<b class="nc">&nbsp;        for (String aName : name) {</b>
<b class="nc">&nbsp;            argumentLoaders.add(new ArgumentLoader.ForField.Factory(aName, fieldLocatorFactory));</b>
&nbsp;        }
<b class="nc">&nbsp;        return with(argumentLoaders);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call which fetches a value from a method call.
&nbsp;     *
&nbsp;     * @param methodCall The method call to use.
&nbsp;     * @return A method call which assigns the parameter to the result of the given method call.
&nbsp;     */
&nbsp;    public MethodCall withMethodCall(MethodCall methodCall) {
<b class="nc">&nbsp;        return with(new ArgumentLoader.ForMethodCall.Factory(methodCall));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a stack manipulation as an assignment to the next parameter.
&nbsp;     *
&nbsp;     * @param stackManipulation The stack manipulation loading the value.
&nbsp;     * @param type              The type of the argument being loaded.
&nbsp;     * @return A method call that adds the stack manipulation as the next argument to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(StackManipulation stackManipulation, Type type) {
<b class="nc">&nbsp;        return with(stackManipulation, TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a stack manipulation as an assignment to the next parameter.
&nbsp;     *
&nbsp;     * @param stackManipulation The stack manipulation loading the value.
&nbsp;     * @param typeDefinition    The type of the argument being loaded.
&nbsp;     * @return A method call that adds the stack manipulation as the next argument to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(StackManipulation stackManipulation, TypeDefinition typeDefinition) {
<b class="nc">&nbsp;        return with(new ArgumentLoader.ForStackManipulation(stackManipulation, typeDefinition));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call that resolves arguments by the supplied argument loader factories.
&nbsp;     *
&nbsp;     * @param argumentLoader The argument loaders to apply to the subsequent arguments of the
&nbsp;     * @return A method call that adds the arguments of the supplied argument loaders to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(ArgumentLoader.Factory... argumentLoader) {
<b class="nc">&nbsp;        return with(Arrays.asList(argumentLoader));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a method call that resolves arguments by the supplied argument loader factories.
&nbsp;     *
&nbsp;     * @param argumentLoaders The argument loaders to apply to the subsequent arguments of the
&nbsp;     * @return A method call that adds the arguments of the supplied argument loaders to the invoked method.
&nbsp;     */
&nbsp;    public MethodCall with(List&lt;? extends ArgumentLoader.Factory&gt; argumentLoaders) {
<b class="fc">&nbsp;        return new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
<b class="fc">&nbsp;                CompoundList.of(this.argumentLoaders, argumentLoaders),</b>
&nbsp;                methodInvoker,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the result of the method call as a value of the specified field. If the instrumented method does not
&nbsp;     * return {@code void}, this instrumentation must be chained with another instrumentation.
&nbsp;     *
&nbsp;     * @param field The field to set.
&nbsp;     * @return A new instance of this method call that sets the resulting value as the specified field&#39;s value.
&nbsp;     */
&nbsp;    public FieldSetting setsField(Field field) {
<b class="nc">&nbsp;        return setsField(new FieldDescription.ForLoadedField(field));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the result of the method call as a value of the specified field. If the instrumented method does not
&nbsp;     * return {@code void}, this instrumentation must be chained with another instrumentation.
&nbsp;     *
&nbsp;     * @param fieldDescription The field to set.
&nbsp;     * @return A new instance of this method call that sets the resulting value as the specified field&#39;s value.
&nbsp;     */
&nbsp;    public FieldSetting setsField(FieldDescription fieldDescription) {
<b class="nc">&nbsp;        return new FieldSetting(new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                new TerminationHandler.FieldSetting.Explicit(fieldDescription),
&nbsp;                assigner,
&nbsp;                typing));
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the result of the method call as a value of the specified field. If the instrumented method does not
&nbsp;     * return {@code void}, this instrumentation must be chained with another instrumentation.
&nbsp;     *
&nbsp;     * @param matcher A matcher that locates a field in the instrumented type&#39;s hierarchy.
&nbsp;     * @return A new instance of this method call that sets the resulting value as the specified field&#39;s value.
&nbsp;     */
&nbsp;    public FieldSetting setsField(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="nc">&nbsp;        return new FieldSetting(new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                new TerminationHandler.FieldSetting.Implicit(matcher),
&nbsp;                assigner,
&nbsp;                typing));
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines an assigner to be used for assigning values to the parameters of the invoked method. This assigner
&nbsp;     * is also used for assigning the invoked method&#39;s return value to the return type of the instrumented method,
&nbsp;     * if this method is not chained with
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall#andThen(Implementation)} such
&nbsp;     * that a return value of this method call is discarded.
&nbsp;     *
&nbsp;     * @param assigner The assigner to use.
&nbsp;     * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     * @return This method call using the provided assigner.
&nbsp;     */
&nbsp;    public Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;        return new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                terminationHandler,
&nbsp;                assigner,
&nbsp;                typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;        return new Implementation.Compound(new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                TerminationHandler.Simple.DROPPING,
&nbsp;                assigner,
&nbsp;                typing), implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;        return new Implementation.Compound.Composable(new MethodCall(methodLocator,</b>
&nbsp;                targetHandler,
&nbsp;                argumentLoaders,
&nbsp;                methodInvoker,
&nbsp;                TerminationHandler.Simple.DROPPING,
&nbsp;                assigner,
&nbsp;                typing), implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        for (InstrumentedType.Prepareable prepareable : argumentLoaders) {</b>
<b class="fc">&nbsp;            instrumentedType = prepareable.prepare(instrumentedType);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return targetHandler.prepare(instrumentedType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        return new Appender(implementationTarget, terminationHandler.make(implementationTarget.getInstrumentedType()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method locator is responsible for identifying the method that is to be invoked
&nbsp;     * by a {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    public interface MethodLocator {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the method to be invoked.
&nbsp;         *
&nbsp;         * @param targetType         The type the method is called on.
&nbsp;         * @param instrumentedMethod The method being instrumented.
&nbsp;         * @return The method to invoke.
&nbsp;         */
&nbsp;        MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a method locator.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a method locator for a given instrumented type.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return A suitable method locator.
&nbsp;             */
&nbsp;            MethodLocator make(TypeDescription instrumentedType);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method locator that simply returns the intercepted method.
&nbsp;         */
<b class="nc">&nbsp;        enum ForInstrumentedMethod implements MethodLocator, Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodLocator make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return instrumentedMethod;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a given method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForExplicitMethod implements MethodLocator, Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The method to be invoked.
&nbsp;             */
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method locator for a given method.
&nbsp;             *
&nbsp;             * @param methodDescription The method to be invoked.
&nbsp;             */
<b class="fc">&nbsp;            protected ForExplicitMethod(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodLocator make(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return methodDescription;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method locator that identifies a unique virtual method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForElementMatcher implements MethodLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to use.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The method graph compiler to use.
&nbsp;             */
&nbsp;            private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method locator for an element matcher.
&nbsp;             *
&nbsp;             * @param instrumentedType    The instrumented type.
&nbsp;             * @param matcher             The matcher to use.
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             */
<b class="nc">&nbsp;            protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                this.matcher = matcher;</b>
<b class="nc">&nbsp;                this.methodGraphCompiler = methodGraphCompiler;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription resolve(TypeDescription targetType, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                TypeDescription.Generic superClass = instrumentedType.getSuperClass();</b>
<b class="nc">&nbsp;                List&lt;MethodDescription&gt; candidates = CompoundList.&lt;MethodDescription&gt;of(</b>
<b class="nc">&nbsp;                        superClass == null</b>
<b class="nc">&nbsp;                                ? Collections.&lt;MethodDescription&gt;emptyList()</b>
<b class="nc">&nbsp;                                : superClass.getDeclaredMethods().filter(isConstructor().and(matcher)),</b>
<b class="nc">&nbsp;                        instrumentedType.getDeclaredMethods().filter(not(ElementMatchers.isVirtual()).and(matcher)),</b>
<b class="nc">&nbsp;                        methodGraphCompiler.compile((TypeDefinition) targetType, instrumentedType).listNodes().asMethodList().filter(matcher));</b>
<b class="nc">&nbsp;                if (candidates.size() == 1) {</b>
<b class="nc">&nbsp;                    return candidates.get(0);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; does not define exactly one virtual method or constructor for &quot; + matcher</b>
<b class="nc">&nbsp;                            + &quot; but contained &quot; + candidates.size()</b>
&nbsp;                            + &quot; candidates: &quot; + candidates);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a method locator that uses a matcher on the instrumented type&#39;s available methods for identifing a target method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Factory implements MethodLocator.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method graph compiler to use.
&nbsp;                 */
&nbsp;                private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for a method locator that identifies a method using a matcher.
&nbsp;                 *
&nbsp;                 * @param matcher             The matcher to use.
&nbsp;                 * @param methodGraphCompiler The method graph compiler to use.
&nbsp;                 */
<b class="nc">&nbsp;                public Factory(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {</b>
<b class="nc">&nbsp;                    this.matcher = matcher;</b>
<b class="nc">&nbsp;                    this.methodGraphCompiler = methodGraphCompiler;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodLocator make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    return new ForElementMatcher(instrumentedType, matcher, methodGraphCompiler);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An argument loader is responsible for loading an argument for an invoked method
&nbsp;     * onto the operand stack.
&nbsp;     */
&nbsp;    public interface ArgumentLoader {
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the argument that is represented by this instance onto the operand stack.
&nbsp;         *
&nbsp;         * @param target   The target parameter.
&nbsp;         * @param assigner The assigner to be used.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return The stack manipulation that loads the represented argument onto the stack.
&nbsp;         */
&nbsp;        StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing);
&nbsp;
&nbsp;        /**
&nbsp;         * An argument provider is responsible for providing an argument loader for each argument to supply to a method.
&nbsp;         */
&nbsp;        interface ArgumentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves this provider to an argument loader for each provided argument.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param invokedMethod      The invoked method.
&nbsp;             * @return A list of provided argument loaders.
&nbsp;             */
&nbsp;            List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory that produces {@link ArgumentLoader}s for a given instrumented method.
&nbsp;         */
&nbsp;        interface Factory extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument provider for the supplied implementation target.
&nbsp;             *
&nbsp;             * @param implementationTarget The implementation target to use.
&nbsp;             * @return An appropriate argument provider.
&nbsp;             */
&nbsp;            ArgumentProvider make(Implementation.Target implementationTarget);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument loader that loads the {@code null} value onto the operand stack.
&nbsp;         */
<b class="nc">&nbsp;        enum ForNullConstant implements ArgumentLoader, ArgumentProvider, Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                if (target.getType().isPrimitive()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign null to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return NullConstant.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * An argument loader that assigns the {@code this} reference to a parameter.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForThisReference implements ArgumentLoader, ArgumentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that supplies the {@code this} instance as an argument.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            public ForThisReference(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                if (instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(instrumentedMethod + &quot; is static and cannot supply an invoker instance&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                        assigner.assign(instrumentedType.asGenericType(), target.getType(), typing));</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedType + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loader that supplies the {@code this} value as an argument.
&nbsp;             */
<b class="nc">&nbsp;            public enum Factory implements ArgumentLoader.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForThisReference(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the instrumented type onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForInstrumentedType implements ArgumentLoader, ArgumentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for supporting the instrumented type as a type constant as an argument.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            public ForInstrumentedType(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        ClassConstant.of(instrumentedType),</b>
<b class="nc">&nbsp;                        assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Class.class), target.getType(), typing));</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign Class value to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loader that supplies the instrumented type as an argument.
&nbsp;             */
<b class="nc">&nbsp;            public enum Factory implements ArgumentLoader.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForInstrumentedType(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a parameter of the instrumented method onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameter implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of the parameter to be loaded onto the operand stack.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for a parameter of the instrumented method.
&nbsp;             *
&nbsp;             * @param index              The index of the parameter to be loaded onto the operand stack.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            public ForMethodParameter(int index, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                this.index = index;</b>
<b class="fc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);</b>
<b class="fc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        MethodVariableAccess.load(parameterDescription),</b>
<b class="fc">&nbsp;                        assigner.assign(parameterDescription.getType(), target.getType(), typing));</b>
<b class="fc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + target + &quot; for &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for argument loaders that supplies all arguments of the instrumented method as arguments.
&nbsp;             */
<b class="nc">&nbsp;            protected enum OfInstrumentedMethod implements ArgumentLoader.Factory, ArgumentProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                    List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader&gt;(instrumentedMethod.getParameters().size());</b>
<b class="nc">&nbsp;                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="nc">&nbsp;                        argumentLoaders.add(new ForMethodParameter(parameterDescription.getIndex(), instrumentedMethod));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return argumentLoaders;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loader that supplies a method parameter as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Factory implements ArgumentLoader.Factory, ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the parameter to be loaded onto the operand stack.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an argument loader that supplies a method parameter as an argument.
&nbsp;                 *
&nbsp;                 * @param index The index of the parameter to supply.
&nbsp;                 */
<b class="fc">&nbsp;                public Factory(int index) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="fc">&nbsp;                    if (index &gt;= instrumentedMethod.getParameters().size()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not have a parameter with index &quot; + index +</b>
<b class="nc">&nbsp;                                &quot;, &quot; + instrumentedMethod.getParameters().size() + &quot; defined&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodParameter(index, instrumentedMethod));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads an array containing all arguments of a method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameterArray implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The parameters to load.
&nbsp;             */
&nbsp;            private final ParameterList&lt;?&gt; parameters;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads the supplied parameters onto the operand stack.
&nbsp;             *
&nbsp;             * @param parameters The parameters to load.
&nbsp;             */
<b class="nc">&nbsp;            public ForMethodParameterArray(ParameterList&lt;?&gt; parameters) {</b>
<b class="nc">&nbsp;                this.parameters = parameters;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
&nbsp;                TypeDescription.Generic componentType;
<b class="nc">&nbsp;                if (target.getType().represents(Object.class)) {</b>
<b class="nc">&nbsp;                    componentType = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
<b class="nc">&nbsp;                } else if (target.getType().isArray()) {</b>
<b class="nc">&nbsp;                    componentType = target.getType().getComponentType();</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set method parameter array for non-array type: &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(parameters.size());</b>
<b class="nc">&nbsp;                for (ParameterDescription parameter : parameters) {</b>
<b class="nc">&nbsp;                    StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                            MethodVariableAccess.load(parameter),</b>
<b class="nc">&nbsp;                            assigner.assign(parameter.getType(), componentType, typing)</b>
&nbsp;                    );
<b class="nc">&nbsp;                    if (stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                        stackManipulations.add(stackManipulation);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + parameter + &quot; to &quot; + componentType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return new StackManipulation.Compound(ArrayFactory.forType(componentType).withValues(stackManipulations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory that creates an arguments loader that loads all parameters of the instrumented method contained in an array.
&nbsp;             */
<b class="nc">&nbsp;            public enum ForInstrumentedMethod implements Factory, ArgumentProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodParameterArray(instrumentedMethod.getParameters()));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument loader that loads an element of a parameter of an array type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameterArrayElement implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter to load the array from.
&nbsp;             */
&nbsp;            private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The array index to load.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for a parameter of the instrumented method where an array element is assigned to the invoked method.
&nbsp;             *
&nbsp;             * @param parameterDescription The parameter from which to load an array element.
&nbsp;             * @param index                The array index to load.
&nbsp;             */
<b class="nc">&nbsp;            public ForMethodParameterArrayElement(ParameterDescription parameterDescription, int index) {</b>
<b class="nc">&nbsp;                this.parameterDescription = parameterDescription;</b>
<b class="nc">&nbsp;                this.index = index;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        MethodVariableAccess.load(parameterDescription),</b>
<b class="nc">&nbsp;                        IntegerConstant.forValue(index),</b>
<b class="nc">&nbsp;                        ArrayAccess.of(parameterDescription.getType().getComponentType()).load(),</b>
<b class="nc">&nbsp;                        assigner.assign(parameterDescription.getType().getComponentType(), target.getType(), typing)</b>
&nbsp;                );
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription.getType().getComponentType() + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader for an array element that of a specific parameter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfParameter implements ArgumentLoader.Factory, ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The array index to load.
&nbsp;                 */
&nbsp;                private final int arrayIndex;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an argument loader that loads a given parameter&#39;s array value.
&nbsp;                 *
&nbsp;                 * @param index      The index of the parameter.
&nbsp;                 * @param arrayIndex The array index to load.
&nbsp;                 */
<b class="nc">&nbsp;                public OfParameter(int index, int arrayIndex) {</b>
<b class="nc">&nbsp;                    this.index = index;</b>
<b class="nc">&nbsp;                    this.arrayIndex = arrayIndex;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                    if (instrumentedMethod.getParameters().size() &lt;= index) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not declare a parameter with index &quot; + index +</b>
<b class="nc">&nbsp;                                &quot;, &quot; + instrumentedMethod.getParameters().size() + &quot; defined&quot;);</b>
<b class="nc">&nbsp;                    } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access an item from non-array parameter &quot; + instrumentedMethod.getParameters().get(index) +</b>
&nbsp;                                &quot; at index &quot; + index);
&nbsp;                    }
<b class="nc">&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(index), arrayIndex));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument loader factory that loads an array element from a parameter for each argument of the invoked method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfInvokedMethod implements ArgumentLoader.Factory, ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an argument loader factory for an invoked method.
&nbsp;                 *
&nbsp;                 * @param index The parameter index.
&nbsp;                 */
<b class="nc">&nbsp;                public OfInvokedMethod(int index) {</b>
<b class="nc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                    if (instrumentedMethod.getParameters().size() &lt;= index) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not declare a parameter with index &quot; + index +</b>
<b class="nc">&nbsp;                                &quot;, &quot; + instrumentedMethod.getParameters().size() + &quot; defined&quot;);</b>
<b class="nc">&nbsp;                    } else if (!instrumentedMethod.getParameters().get(index).getType().isArray()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access an item from non-array parameter &quot; + instrumentedMethod.getParameters().get(index) +</b>
&nbsp;                                &quot; at index &quot; + index);
&nbsp;                    }
<b class="nc">&nbsp;                    List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader&gt;(invokedMethod.getParameters().size());</b>
<b class="nc">&nbsp;                    for (int index = 0; index &lt; invokedMethod.getParameters().size(); index++) {</b>
<b class="nc">&nbsp;                        argumentLoaders.add(new ForMethodParameterArrayElement(instrumentedMethod.getParameters().get(this.index), index));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return argumentLoaders;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a value onto the operand stack that is stored in a static field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForInstance implements ArgumentLoader, ArgumentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The description of the field.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that supplies the value of a static field as an argument.
&nbsp;             *
&nbsp;             * @param fieldDescription The description of the field.
&nbsp;             */
<b class="nc">&nbsp;            public ForInstance(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                this.fieldDescription = fieldDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        FieldAccess.forField(fieldDescription).read(),</b>
<b class="nc">&nbsp;                        assigner.assign(fieldDescription.getType(), target.getType(), typing));</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription.getType() + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory that supplies the value of a static field as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name prefix of the field to store the argument.
&nbsp;                 */
&nbsp;                private static final String FIELD_PREFIX = &quot;methodCall&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The value to be stored in the field.
&nbsp;                 */
&nbsp;                private final Object value;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory that loads the value of a static field as an argument.
&nbsp;                 *
&nbsp;                 * @param value The value to supply as an argument.
&nbsp;                 */
<b class="nc">&nbsp;                public Factory(Object value) {</b>
<b class="nc">&nbsp;                    this.value = value;</b>
<b class="nc">&nbsp;                    name = FIELD_PREFIX + &quot;$&quot; + RandomString.hashOf(value);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name,</b>
&nbsp;                            Opcodes.ACC_SYNTHETIC | Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
<b class="nc">&nbsp;                            TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass())), value);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForInstance(implementationTarget.getInstrumentedType().getDeclaredFields().filter(named(name)).getOnly());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the value of an existing field onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForField implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The field containing the loaded value.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new argument loader for loading an existing field.
&nbsp;             *
&nbsp;             * @param fieldDescription   The field containing the loaded value.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             */
<b class="nc">&nbsp;            public ForField(FieldDescription fieldDescription, MethodDescription instrumentedMethod) {</b>
<b class="nc">&nbsp;                this.fieldDescription = fieldDescription;</b>
<b class="nc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="nc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                                ? StackManipulation.Trivial.INSTANCE</b>
<b class="nc">&nbsp;                                : MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                        FieldAccess.forField(fieldDescription).read(),</b>
<b class="nc">&nbsp;                        assigner.assign(fieldDescription.getType(), target.getType(), typing)</b>
&nbsp;                );
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a field access.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class ArgumentProvider implements ArgumentLoader.ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field being accessed.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a field access.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The field being accessed.
&nbsp;                 */
<b class="nc">&nbsp;                protected ArgumentProvider(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForField(fieldDescription, instrumentedMethod));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loaded that loads the value of an existing field as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field locator to use.
&nbsp;                 */
&nbsp;                private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument loader for an existing field.
&nbsp;                 *
&nbsp;                 * @param name                The name of the field.
&nbsp;                 * @param fieldLocatorFactory The field locator to use.
&nbsp;                 */
<b class="nc">&nbsp;                public Factory(String name, FieldLocator.Factory fieldLocatorFactory) {</b>
<b class="nc">&nbsp;                    this.name = name;</b>
<b class="nc">&nbsp;                    this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentLoader.ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    FieldLocator.Resolution resolution = fieldLocatorFactory.make(implementationTarget.getInstrumentedType()).locate(name);</b>
<b class="nc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not locate field &#39;&quot; + name + &quot;&#39; on &quot; + implementationTarget.getInstrumentedType());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new ArgumentProvider(resolution.getField());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the return value of a method call onto the operand stack.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodCall implements ArgumentLoader {
&nbsp;
&nbsp;            /**
&nbsp;             * The method call&#39;s appender.
&nbsp;             */
&nbsp;            private final Appender appender;
&nbsp;
&nbsp;            /**
&nbsp;             * The invoked method.
&nbsp;             */
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * The resolved target handler to use.
&nbsp;             */
&nbsp;            private final TargetHandler.Resolved targetHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new argument loader for loading a method call&#39;s return value.
&nbsp;             *
&nbsp;             * @param appender           The method call&#39;s appender.
&nbsp;             * @param methodDescription  The invoked method.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param targetHandler      The resolved target handler to use.
&nbsp;             */
<b class="nc">&nbsp;            public ForMethodCall(Appender appender, MethodDescription methodDescription, MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {</b>
<b class="nc">&nbsp;                this.appender = appender;</b>
<b class="nc">&nbsp;                this.methodDescription = methodDescription;</b>
<b class="nc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
<b class="nc">&nbsp;                this.targetHandler = targetHandler;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        appender.toStackManipulation(instrumentedMethod, methodDescription, targetHandler),</b>
<b class="nc">&nbsp;                        assigner.assign(methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                                ? methodDescription.getDeclaringType().asGenericType()</b>
<b class="nc">&nbsp;                                : methodDescription.getReturnType(), target.getType(), typing)</b>
&nbsp;                );
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign return type of &quot; + methodDescription + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An argument provider for a method call.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class ArgumentProvider implements ArgumentLoader.ArgumentProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method call&#39;s appender.
&nbsp;                 */
&nbsp;                private final Appender appender;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument provider for a method call.
&nbsp;                 *
&nbsp;                 * @param appender The method call&#39;s appender.
&nbsp;                 */
<b class="nc">&nbsp;                protected ArgumentProvider(Appender appender) {</b>
<b class="nc">&nbsp;                    this.appender = appender;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                    TargetHandler.Resolved targetHandler = appender.targetHandler.resolve(instrumentedMethod);</b>
<b class="nc">&nbsp;                    return Collections.&lt;ArgumentLoader&gt;singletonList(new ForMethodCall(appender,</b>
<b class="nc">&nbsp;                            appender.toInvokedMethod(instrumentedMethod, targetHandler),</b>
&nbsp;                            instrumentedMethod,
&nbsp;                            targetHandler));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an argument loaded that loads the return value of a method call as an argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements ArgumentLoader.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method call to use.
&nbsp;                 */
&nbsp;                private final MethodCall methodCall;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument loader for an existing method call.
&nbsp;                 *
&nbsp;                 * @param methodCall The method call to use.
&nbsp;                 */
<b class="nc">&nbsp;                public Factory(MethodCall methodCall) {</b>
<b class="nc">&nbsp;                    this.methodCall = methodCall;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return methodCall.prepare(instrumentedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ArgumentLoader.ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ArgumentProvider(methodCall.new Appender(implementationTarget, TerminationHandler.Simple.IGNORING));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads a stack manipulation resulting in a specific type as an argument.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForStackManipulation implements ArgumentLoader, ArgumentProvider, Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to load.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the resulting value.
&nbsp;             */
&nbsp;            private final TypeDefinition typeDefinition;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads a stack manipulation as an argument.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation to load.
&nbsp;             * @param type              The type of the resulting value.
&nbsp;             */
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, Type type) {
<b class="nc">&nbsp;                this(stackManipulation, TypeDescription.Generic.Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads a stack manipulation as an argument.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation to load.
&nbsp;             * @param typeDefinition    The type of the resulting value.
&nbsp;             */
<b class="nc">&nbsp;            public ForStackManipulation(StackManipulation stackManipulation, TypeDefinition typeDefinition) {</b>
<b class="nc">&nbsp;                this.stackManipulation = stackManipulation;</b>
<b class="nc">&nbsp;                this.typeDefinition = typeDefinition;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument loader that loads the supplied value as a constant. If the value cannot be represented
&nbsp;             * in the constant pool, a field is created to store the value.
&nbsp;             *
&nbsp;             * @param value The value to load as an argument or {@code null}.
&nbsp;             * @return An appropriate argument loader.
&nbsp;             */
&nbsp;            public static ArgumentLoader.Factory of(@MaybeNull Object value) {
<b class="nc">&nbsp;                if (value == null) {</b>
<b class="nc">&nbsp;                    return ForNullConstant.INSTANCE;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    ConstantValue constant = ConstantValue.Simple.wrapOrNull(value);</b>
<b class="nc">&nbsp;                    return constant == null</b>
<b class="nc">&nbsp;                            ? new ForInstance.Factory(value)</b>
<b class="nc">&nbsp;                            : new ForStackManipulation(constant.toStackManipulation(), constant.getTypeDescription());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ArgumentProvider make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;ArgumentLoader&gt; resolve(MethodDescription instrumentedMethod, MethodDescription invokedMethod) {
<b class="nc">&nbsp;                return Collections.&lt;ArgumentLoader&gt;singletonList(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(ParameterDescription target, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation assignment = assigner.assign(typeDefinition.asGenericType(), target.getType(), typing);</b>
<b class="nc">&nbsp;                if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + typeDefinition);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new StackManipulation.Compound(stackManipulation, assignment);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A target handler is responsible for invoking a method for a
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    protected interface TargetHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this target handler.
&nbsp;         *
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return The resolved target handler.
&nbsp;         */
&nbsp;        Resolved resolve(MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * A resolved target handler.
&nbsp;         */
&nbsp;        interface Resolved {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the target&#39;s type description.
&nbsp;             *
&nbsp;             * @return The target&#39;s type description.
&nbsp;             */
&nbsp;            TypeDescription getTypeDescription();
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a stack manipulation to represent this resolved target handler.
&nbsp;             *
&nbsp;             * @param invokedMethod The invoked method.
&nbsp;             * @param assigner      The assigner to use.
&nbsp;             * @param typing        The typing to apply.
&nbsp;             * @return A stack manipulation that implements this target handler.
&nbsp;             */
&nbsp;            StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a target handler.
&nbsp;         */
&nbsp;        interface Factory extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a target handler for a given implementation target.
&nbsp;             *
&nbsp;             * @param implementationTarget The implementation target to use.
&nbsp;             * @return The target handler to use.
&nbsp;             */
&nbsp;            TargetHandler make(Implementation.Target implementationTarget);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple target handler that applies a given stack manipulation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements TargetHandler, Factory, Resolved {
&nbsp;
&nbsp;            /**
&nbsp;             * The type resolved by the stack manipulation.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation that loads a target for the method call.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a simple target handler.
&nbsp;             *
&nbsp;             * @param typeDescription   The type resolved by the stack manipulation.
&nbsp;             * @param stackManipulation The stack manipulation that loads a target for the method call.
&nbsp;             */
<b class="nc">&nbsp;            protected Simple(TypeDescription typeDescription, StackManipulation stackManipulation) {</b>
<b class="nc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="nc">&nbsp;                this.stackManipulation = stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TargetHandler make(Target implementationTarget) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that invokes a method either on the instance of the instrumented
&nbsp;         * type or as a static method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForSelfOrStaticInvocation implements TargetHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for a static or self-declared invocation.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            protected ForSelfOrStaticInvocation(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TargetHandler.Resolved resolve(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return new Resolved(instrumentedType, instrumentedMethod);</b>
&nbsp;            }
&nbsp;
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved target handler for a static or self-declared invocation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Resolved implements TargetHandler.Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented method.
&nbsp;                 */
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a resolved target handler for a static or self-declared invocation.
&nbsp;                 *
&nbsp;                 * @param instrumentedType   The instrumented type.
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 */
&nbsp;                protected Resolved(TypeDescription instrumentedType,
<b class="nc">&nbsp;                                   MethodDescription instrumentedMethod) {</b>
<b class="nc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="nc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    if (instrumentedMethod.isStatic() &amp;&amp; !invokedMethod.isStatic() &amp;&amp; !invokedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; from &quot; + instrumentedMethod);</b>
<b class="nc">&nbsp;                    } else if (invokedMethod.isConstructor() &amp;&amp; (!instrumentedMethod.isConstructor()</b>
<b class="nc">&nbsp;                            || !instrumentedType.equals(invokedMethod.getDeclaringType().asErasure())</b>
<b class="nc">&nbsp;                            &amp;&amp; (instrumentedType.getSuperClass() == null</b>
<b class="nc">&nbsp;                            || !instrumentedType.getSuperClass().asErasure().equals(invokedMethod.getDeclaringType().asErasure())))) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; from &quot; + instrumentedMethod + &quot; in &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                            invokedMethod.isStatic()</b>
<b class="nc">&nbsp;                                    ? StackManipulation.Trivial.INSTANCE</b>
<b class="nc">&nbsp;                                    : MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                            invokedMethod.isConstructor()</b>
<b class="nc">&nbsp;                                    ? Duplication.SINGLE</b>
<b class="nc">&nbsp;                                    : StackManipulation.Trivial.INSTANCE</b>
&nbsp;                    );
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for invoking a static method or a self-declared method.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements TargetHandler.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForSelfOrStaticInvocation(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method in order to construct a new instance.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForConstructingInvocation implements TargetHandler, Resolved {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handle constructor invocation.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            protected ForConstructingInvocation(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                return new StackManipulation.Compound(TypeCreation.of(invokedMethod.getDeclaringType().asErasure()), Duplication.SINGLE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target handler factory for a constructor invocation.
&nbsp;             */
<b class="nc">&nbsp;            enum Factory implements TargetHandler.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForConstructingInvocation(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that invokes a method on an instance that is stored in a static field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForValue implements TargetHandler, Resolved {
&nbsp;
&nbsp;            /**
&nbsp;             * A description of the field that contains the value.
&nbsp;             */
&nbsp;            private final FieldDescription.InDefinedShape fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for a field value.
&nbsp;             *
&nbsp;             * @param fieldDescription A description of the field that contains the value.
&nbsp;             */
<b class="nc">&nbsp;            protected ForValue(FieldDescription.InDefinedShape fieldDescription) {</b>
<b class="nc">&nbsp;                this.fieldDescription = fieldDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                return fieldDescription.getType().asErasure();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = assigner.assign(fieldDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + fieldDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                        FieldAccess.forField(fieldDescription).read(),</b>
&nbsp;                        stackManipulation
&nbsp;                );
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a target handler that loads a specific value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements TargetHandler.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name prefix of the field to store the instance.
&nbsp;                 */
&nbsp;                private static final String FIELD_PREFIX = &quot;invocationTarget&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The target on which the method is to be invoked.
&nbsp;                 */
&nbsp;                private final Object target;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the field.
&nbsp;                 */
&nbsp;                private final TypeDescription.Generic fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field to store the target.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target handler for a static field.
&nbsp;                 *
&nbsp;                 * @param target    The target on which the method is to be invoked.
&nbsp;                 * @param fieldType The type of the field.
&nbsp;                 */
<b class="nc">&nbsp;                protected Factory(Object target, TypeDescription.Generic fieldType) {</b>
<b class="nc">&nbsp;                    this.target = target;</b>
<b class="nc">&nbsp;                    this.fieldType = fieldType;</b>
<b class="nc">&nbsp;                    name = FIELD_PREFIX + &quot;$&quot; + RandomString.hashOf(target);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name,</b>
&nbsp;                            Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC,
&nbsp;                            fieldType), target);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForValue(implementationTarget.getInstrumentedType().getDeclaredFields().filter(named(name)).getOnly());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a target handler that stores the instance to invoke a method on in an instance field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForField implements TargetHandler, Resolved {
&nbsp;
&nbsp;            /**
&nbsp;             * A description of the field that is the target.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for a field description.
&nbsp;             *
&nbsp;             * @param fieldDescription A description of the field that is the target.
&nbsp;             */
<b class="nc">&nbsp;            protected ForField(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                this.fieldDescription = fieldDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolved resolve(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                return fieldDescription.getType().asErasure();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                if (!invokedMethod.isMethod()</b>
<b class="nc">&nbsp;                        || !invokedMethod.isVirtual()</b>
<b class="nc">&nbsp;                        || !invokedMethod.isVisibleTo(fieldDescription.getType().asErasure())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + fieldDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                StackManipulation stackManipulation = assigner.assign(fieldDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + fieldDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new StackManipulation.Compound(invokedMethod.isStatic() || fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                        ? StackManipulation.Trivial.INSTANCE</b>
<b class="nc">&nbsp;                        : MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                        FieldAccess.forField(fieldDescription).read(), stackManipulation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A location of a field.
&nbsp;             */
&nbsp;            protected interface Location {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the field to invoke the method upon.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @return The field to invoke the method upon.
&nbsp;                 */
&nbsp;                FieldDescription resolve(TypeDescription instrumentedType);
&nbsp;
&nbsp;                /**
&nbsp;                 * An implicit field location.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForImplicitField implements Location {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the field.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field locator factory to use.
&nbsp;                     */
&nbsp;                    private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an implicit field location.
&nbsp;                     *
&nbsp;                     * @param name                The name of the field.
&nbsp;                     * @param fieldLocatorFactory The field locator factory to use.
&nbsp;                     */
<b class="nc">&nbsp;                    protected ForImplicitField(String name, FieldLocator.Factory fieldLocatorFactory) {</b>
<b class="nc">&nbsp;                        this.name = name;</b>
<b class="nc">&nbsp;                        this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDescription resolve(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                        FieldLocator.Resolution resolution = fieldLocatorFactory.make(instrumentedType).locate(name);</b>
<b class="nc">&nbsp;                        if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Could not locate field name &quot; + name + &quot; on &quot; + instrumentedType);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return resolution.getField();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An explicit field location.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForExplicitField implements Location {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field to resolve.
&nbsp;                     */
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an explicit field location.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field to resolve.
&nbsp;                     */
<b class="nc">&nbsp;                    protected ForExplicitField(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                        this.fieldDescription = fieldDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDescription resolve(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                        return fieldDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a field access.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements TargetHandler.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s location.
&nbsp;                 */
&nbsp;                private final Location location;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target handler factory for a field location.
&nbsp;                 *
&nbsp;                 * @param location The field&#39;s location.
&nbsp;                 */
<b class="nc">&nbsp;                protected Factory(Location location) {</b>
<b class="nc">&nbsp;                    this.location = location;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    FieldDescription fieldDescription = location.resolve(implementationTarget.getInstrumentedType());</b>
<b class="nc">&nbsp;                    if (!fieldDescription.isStatic() &amp;&amp; !implementationTarget.getInstrumentedType().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + implementationTarget.getInstrumentedType());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new ForField(fieldDescription);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that loads the parameter of the given index as the target object.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodParameter implements TargetHandler, Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of the instrumented method&#39;s parameter that is the target of the method invocation.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for the instrumented method&#39;s argument.
&nbsp;             *
&nbsp;             * @param index The index of the instrumented method&#39;s parameter that is the target of the method invocation.
&nbsp;             */
<b class="fc">&nbsp;            protected ForMethodParameter(int index) {</b>
<b class="fc">&nbsp;                this.index = index;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TargetHandler make(Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TargetHandler.Resolved resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (index &gt;= instrumentedMethod.getParameters().size()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(instrumentedMethod + &quot; does not have a parameter with index &quot; + index);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Resolved(instrumentedMethod.getParameters().get(index));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved target handler for a method parameter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Resolved implements TargetHandler.Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter that is the target of the method call.
&nbsp;                 */
&nbsp;                private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resolved target handler for a parameter.
&nbsp;                 *
&nbsp;                 * @param parameterDescription The parameter that is the target of the method call.
&nbsp;                 */
<b class="fc">&nbsp;                protected Resolved(ParameterDescription parameterDescription) {</b>
<b class="fc">&nbsp;                    this.parameterDescription = parameterDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getTypeDescription() {
<b class="fc">&nbsp;                    return parameterDescription.getType().asErasure();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    StackManipulation stackManipulation = assigner.assign(parameterDescription.getType(), invokedMethod.getDeclaringType().asGenericType(), typing);</b>
<b class="fc">&nbsp;                    if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + parameterDescription.getType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), stackManipulation);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target handler that executes the method and uses it&#39;s return value as the target object.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodCall implements TargetHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The appender that is the target of the using method call.
&nbsp;             */
&nbsp;            private final Appender appender;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new target handler for another method call.
&nbsp;             *
&nbsp;             * @param appender The appender that is the target of the using method call.
&nbsp;             */
<b class="nc">&nbsp;            protected ForMethodCall(Appender appender) {</b>
<b class="nc">&nbsp;                this.appender = appender;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TargetHandler.Resolved resolve(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                TargetHandler.Resolved targetHandler = appender.targetHandler.resolve(instrumentedMethod);</b>
<b class="nc">&nbsp;                return new Resolved(appender, appender.toInvokedMethod(instrumentedMethod, targetHandler), instrumentedMethod,</b>
&nbsp;                        targetHandler);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved target handler for a method call.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Resolved implements TargetHandler.Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * The appender to use.
&nbsp;                 */
&nbsp;                private final Appender appender;
&nbsp;
&nbsp;                /**
&nbsp;                 * The invoked method.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented method.
&nbsp;                 */
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The target handler to use.
&nbsp;                 */
&nbsp;                private final TargetHandler.Resolved targetHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a resolved target handler for a method call.
&nbsp;                 *
&nbsp;                 * @param appender           The appender to use.
&nbsp;                 * @param methodDescription  The invoked method.
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param targetHandler      The target handler to use.
&nbsp;                 */
<b class="nc">&nbsp;                protected Resolved(Appender appender, MethodDescription methodDescription, MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {</b>
<b class="nc">&nbsp;                    this.appender = appender;</b>
<b class="nc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="nc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
<b class="nc">&nbsp;                    this.targetHandler = targetHandler;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;                    return methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                            ? methodDescription.getDeclaringType().asErasure()</b>
<b class="nc">&nbsp;                            : methodDescription.getReturnType().asErasure();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    StackManipulation stackManipulation = assigner.assign(methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                            ? methodDescription.getDeclaringType().asGenericType()</b>
<b class="nc">&nbsp;                            : methodDescription.getReturnType(), invokedMethod.getDeclaringType().asGenericType(), typing);</b>
<b class="nc">&nbsp;                    if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + (methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                                ? methodDescription.getDeclaringType()</b>
<b class="nc">&nbsp;                                : methodDescription.getReturnType()));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new StackManipulation.Compound(appender.toStackManipulation(instrumentedMethod,</b>
&nbsp;                            methodDescription,
&nbsp;                            targetHandler), stackManipulation);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a factory for invoking a method on the return type of another method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements TargetHandler.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method call to invoke.
&nbsp;                 */
&nbsp;                private final MethodCall methodCall;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for invoking another method call as a method target.
&nbsp;                 *
&nbsp;                 * @param methodCall The method call to invoke.
&nbsp;                 */
<b class="nc">&nbsp;                public Factory(MethodCall methodCall) {</b>
<b class="nc">&nbsp;                    this.methodCall = methodCall;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return methodCall.prepare(instrumentedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TargetHandler make(Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                    return new ForMethodCall(methodCall.new Appender(implementationTarget, TerminationHandler.Simple.IGNORING));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method invoker is responsible for creating a method invocation that is to be applied by a
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    protected interface MethodInvoker {
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the method.
&nbsp;         *
&nbsp;         * @param invokedMethod        The method to be invoked.
&nbsp;         * @param implementationTarget The implementation target of the instrumented instance.
&nbsp;         * @return A stack manipulation that represents the method invocation.
&nbsp;         */
&nbsp;        StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a method invoker.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a method invoker.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return The method invoker to use.
&nbsp;             */
&nbsp;            MethodInvoker make(TypeDescription instrumentedType);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a contextual invocation of the provided method, i.e. a static invocation for static methods,
&nbsp;         * a special invocation for constructors and private methods and a virtual invocation for any other method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForContextualInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method invoker for a contextual invocation.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            protected ForContextualInvocation(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                if (invokedMethod.isVirtual() &amp;&amp; !invokedMethod.isInvokableOn(instrumentedType)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + instrumentedType);</b>
&nbsp;                }
<b class="nc">&nbsp;                return invokedMethod.isVirtual()</b>
<b class="nc">&nbsp;                        ? MethodInvocation.invoke(invokedMethod).virtual(instrumentedType)</b>
<b class="nc">&nbsp;                        : MethodInvocation.invoke(invokedMethod);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a contextual method invoker.
&nbsp;             */
<b class="fc">&nbsp;            enum Factory implements MethodInvoker.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    return new ForContextualInvocation(instrumentedType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a virtual invocation on a given type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForVirtualInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The type description to virtually invoke the method upon.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method invoking for a virtual method invocation.
&nbsp;             *
&nbsp;             * @param typeDescription The type description to virtually invoke the method upon.
&nbsp;             */
<b class="nc">&nbsp;            protected ForVirtualInvocation(TypeDescription typeDescription) {</b>
<b class="nc">&nbsp;                this.typeDescription = typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                if (!invokedMethod.isInvokableOn(typeDescription)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + typeDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                return MethodInvocation.invoke(invokedMethod).virtual(typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method invoker for a virtual method that uses an implicit target type.
&nbsp;             */
<b class="fc">&nbsp;            protected enum WithImplicitType implements MethodInvoker, MethodInvoker.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
<b class="fc">&nbsp;                    if (!invokedMethod.isAccessibleTo(implementationTarget.getInstrumentedType()) || !invokedMethod.isVirtual()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; virtually&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return MethodInvocation.invoke(invokedMethod);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method invoker factory for a virtual method invocation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements MethodInvoker.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type on which the virtual method is invoked.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new method invoker factory for a virtual method call.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type on which the virtual method is invoked.
&nbsp;                 */
<b class="nc">&nbsp;                protected Factory(TypeDescription typeDescription) {</b>
<b class="nc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    if (!typeDescription.asErasure().isAccessibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(typeDescription + &quot; is not accessible to &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new ForVirtualInvocation(typeDescription);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a super method invocation of the provided method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForSuperMethodInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a method invoker for a super method invocation.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            protected ForSuperMethodInvocation(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                if (!invokedMethod.isInvokableOn(implementationTarget.getOriginType().asErasure())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as super method of &quot; + instrumentedType);</b>
&nbsp;                }
<b class="nc">&nbsp;                StackManipulation stackManipulation = implementationTarget</b>
<b class="nc">&nbsp;                        .invokeDominant(invokedMethod.asSignatureToken())</b>
<b class="nc">&nbsp;                        .withCheckedCompatibilityTo(invokedMethod.asTypeToken());</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as a super method&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method invoker factory for a super method invocation.
&nbsp;             */
<b class="nc">&nbsp;            enum Factory implements MethodInvoker.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    if (instrumentedType.getSuperClass() == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke super method for &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new ForSuperMethodInvocation(instrumentedType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method as a Java 8 default method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForDefaultMethodInvocation implements MethodInvoker {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method invoker for a default method invocation.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="nc">&nbsp;            protected ForDefaultMethodInvocation(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, Implementation.Target implementationTarget) {
<b class="nc">&nbsp;                if (!invokedMethod.isInvokableOn(instrumentedType)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; as default method of &quot; + instrumentedType);</b>
&nbsp;                }
<b class="nc">&nbsp;                StackManipulation stackManipulation = implementationTarget</b>
<b class="nc">&nbsp;                        .invokeDefault(invokedMethod.asSignatureToken(), invokedMethod.getDeclaringType().asErasure())</b>
<b class="nc">&nbsp;                        .withCheckedCompatibilityTo(invokedMethod.asTypeToken());</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + invokedMethod + &quot; on &quot; + instrumentedType);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a method invoker for a default method invocation.
&nbsp;             */
<b class="nc">&nbsp;            enum Factory implements MethodInvoker.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodInvoker make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    return new ForDefaultMethodInvocation(instrumentedType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A termination handler is responsible to handle the return value of a method that is invoked via a
&nbsp;     * {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    protected interface TerminationHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a preparing stack manipulation to apply prior to the method call.
&nbsp;         *
&nbsp;         * @return The stack manipulation to apply prior to the method call.
&nbsp;         */
&nbsp;        StackManipulation prepare();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation that handles the method return.
&nbsp;         *
&nbsp;         * @param invokedMethod      The method that was invoked by the method call.
&nbsp;         * @param instrumentedMethod The method being intercepted.
&nbsp;         * @param assigner           The assigner to be used.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return A stack manipulation that handles the method return.
&nbsp;         */
&nbsp;        StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a termination handler.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a termination handler for a given instrumented type.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return A termination handler to apply for the instrumented type.
&nbsp;             */
&nbsp;            TerminationHandler make(TypeDescription instrumentedType);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Simple termination handler implementations.
&nbsp;         */
<b class="fc">&nbsp;        enum Simple implements TerminationHandler, Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A termination handler that returns the invoked method&#39;s return value.
&nbsp;             */
<b class="fc">&nbsp;            RETURNING {</b>
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                    StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor()</b>
<b class="nc">&nbsp;                            ? invokedMethod.getDeclaringType().asGenericType()</b>
<b class="fc">&nbsp;                            : invokedMethod.getReturnType(), instrumentedMethod.getReturnType(), typing);</b>
<b class="fc">&nbsp;                    if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot return &quot; + invokedMethod.getReturnType() + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(stackManipulation, MethodReturn.of(instrumentedMethod.getReturnType()));</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A termination handler that drops the invoked method&#39;s return value.
&nbsp;             */
<b class="fc">&nbsp;            DROPPING {</b>
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return Removal.of(invokedMethod.isConstructor()</b>
<b class="nc">&nbsp;                            ? invokedMethod.getDeclaringType()</b>
<b class="nc">&nbsp;                            : invokedMethod.getReturnType());</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A termination handler that does not apply any change.
&nbsp;             */
<b class="fc">&nbsp;            IGNORING {</b>
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                    return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TerminationHandler make(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation prepare() {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler that sets a field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class FieldSetting implements TerminationHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The field to set.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new field-setting termination handler.
&nbsp;             *
&nbsp;             * @param fieldDescription The field to set.
&nbsp;             */
<b class="nc">&nbsp;            protected FieldSetting(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                this.fieldDescription = fieldDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation prepare() {
<b class="nc">&nbsp;                return fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                        ? StackManipulation.Trivial.INSTANCE</b>
<b class="nc">&nbsp;                        : MethodVariableAccess.loadThis();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation(MethodDescription invokedMethod, MethodDescription instrumentedMethod, Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;                StackManipulation stackManipulation = assigner.assign(invokedMethod.isConstructor()</b>
<b class="nc">&nbsp;                        ? invokedMethod.getDeclaringType().asGenericType()</b>
<b class="nc">&nbsp;                        : invokedMethod.getReturnType(), fieldDescription.getType(), typing);</b>
<b class="nc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign result of &quot; + invokedMethod + &quot; to &quot; + fieldDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new StackManipulation.Compound(stackManipulation, FieldAccess.forField(fieldDescription).write());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a field-setting termination handler that locates a given field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Explicit implements TerminationHandler.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher being used for locating a field.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for a field-setting termination handler.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The field to set.
&nbsp;                 */
<b class="nc">&nbsp;                protected Explicit(FieldDescription fieldDescription) {</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                public TerminationHandler make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    if (!fieldDescription.isStatic() &amp;&amp; !instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot set &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
<b class="nc">&nbsp;                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new FieldSetting(fieldDescription);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a field-setting termination handler that uses a matcher to locate the target field on the insturmented type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Implicit implements TerminationHandler.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher being used for locating a field.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for a field-setting termination handler.
&nbsp;                 *
&nbsp;                 * @param matcher The matcher being used for locating a field.
&nbsp;                 */
<b class="nc">&nbsp;                protected Implicit(ElementMatcher&lt;? super FieldDescription&gt; matcher) {</b>
<b class="nc">&nbsp;                    this.matcher = matcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TerminationHandler make(TypeDescription instrumentedType) {
<b class="nc">&nbsp;                    TypeDefinition current = instrumentedType;</b>
&nbsp;                    do {
<b class="nc">&nbsp;                        FieldList&lt;?&gt; candidates = current.getDeclaredFields().filter(isVisibleTo(instrumentedType).and(matcher));</b>
<b class="nc">&nbsp;                        if (candidates.size() == 1) {</b>
<b class="nc">&nbsp;                            return new FieldSetting(candidates.getOnly());</b>
<b class="nc">&nbsp;                        } else if (candidates.size() == 2) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(matcher + &quot; is ambiguous and resolved: &quot; + candidates);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        current = current.getSuperClass();</b>
<b class="nc">&nbsp;                    } while (current != null);</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(matcher + &quot; does not locate any accessible fields for &quot; + instrumentedType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a {@link net.bytebuddy.implementation.MethodCall} that invokes a method without specifying
&nbsp;     * an invocation method. Some methods can for example be invoked both virtually or as a super method invocation.
&nbsp;     * Similarly, interface methods can be invoked virtually or as an explicit invocation of a default method. If
&nbsp;     * no explicit invocation type is set, a method is always invoked virtually unless the method
&nbsp;     * represents a static methods or a constructor.
&nbsp;     */
&nbsp;    public static class WithoutSpecifiedTarget extends MethodCall {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method call without a specified target.
&nbsp;         *
&nbsp;         * @param methodLocator The method locator to use.
&nbsp;         */
&nbsp;        protected WithoutSpecifiedTarget(MethodLocator.Factory methodLocator) {
<b class="fc">&nbsp;            super(methodLocator,</b>
&nbsp;                    TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE,
<b class="fc">&nbsp;                    Collections.&lt;ArgumentLoader.Factory&gt;emptyList(),</b>
&nbsp;                    MethodInvoker.ForContextualInvocation.Factory.INSTANCE,
&nbsp;                    TerminationHandler.Simple.RETURNING,
&nbsp;                    Assigner.DEFAULT,
&nbsp;                    Assigner.Typing.STATIC);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on the given instance.
&nbsp;         *
&nbsp;         * @param target The object on which the method is to be invoked upon.
&nbsp;         * @return A method call that invokes the provided method on the given object.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public MethodCall on(Object target) {
<b class="nc">&nbsp;            return on(target, (Class) target.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on the given instance.
&nbsp;         *
&nbsp;         * @param target The object on which the method is to be invoked upon.
&nbsp;         * @param type   The object&#39;s type.
&nbsp;         * @param &lt;T&gt;    The type of the object.
&nbsp;         * @return A method call that invokes the provided method on the given object.
&nbsp;         */
&nbsp;        public &lt;T&gt; MethodCall on(T target, Class&lt;? super T&gt; type) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
<b class="nc">&nbsp;                    new TargetHandler.ForValue.Factory(target, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(type)),</b>
&nbsp;                    argumentLoaders,
<b class="nc">&nbsp;                    new MethodInvoker.ForVirtualInvocation.Factory(TypeDescription.ForLoadedType.of(type)),</b>
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on an instance that is loaded by the provided stack manipulation.
&nbsp;         *
&nbsp;         * @param stackManipulation The stack manipulation that loads the instance that the method is invoked upon.
&nbsp;         * @param type              The type of the loaded instance.
&nbsp;         * @return A method call that invokes the provided method on the value of the provided stack manipulation.
&nbsp;         */
&nbsp;        public MethodCall on(StackManipulation stackManipulation, Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return on(stackManipulation, TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on an instance that is loaded by the provided stack manipulation.
&nbsp;         *
&nbsp;         * @param stackManipulation The stack manipulation that loads the instance that the method is invoked upon.
&nbsp;         * @param typeDescription   The type of the loaded instance.
&nbsp;         * @return A method call that invokes the provided method on the value of the provided stack manipulation.
&nbsp;         */
&nbsp;        public MethodCall on(StackManipulation stackManipulation, TypeDescription typeDescription) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.Simple(typeDescription, stackManipulation),
&nbsp;                    argumentLoaders,
&nbsp;                    new MethodInvoker.ForVirtualInvocation.Factory(typeDescription),
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the specified method on the instrumented method&#39;s argument of the given index.
&nbsp;         *
&nbsp;         * @param index The index of the method&#39;s argument on which the specified method should be invoked.
&nbsp;         * @return A method call that invokes the provided method on the given method argument.
&nbsp;         */
&nbsp;        public MethodCall onArgument(int index) {
<b class="fc">&nbsp;            if (index &lt; 0) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;An argument index cannot be negative: &quot; + index);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.ForMethodParameter(index),
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the object stored in the specified field.
&nbsp;         *
&nbsp;         * @param name The name of the field.
&nbsp;         * @return A method call that invokes the given method on an instance that is read from a field.
&nbsp;         */
&nbsp;        public MethodCall onField(String name) {
<b class="nc">&nbsp;            return onField(name, FieldLocator.ForClassHierarchy.Factory.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the object stored in the specified field.
&nbsp;         *
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param fieldLocatorFactory The field locator factory to use for locating the field.
&nbsp;         * @return A method call that invokes the given method on an instance that is read from a field.
&nbsp;         */
&nbsp;        public MethodCall onField(String name, FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.ForField.Factory(new TargetHandler.ForField.Location.ForImplicitField(name, fieldLocatorFactory)),
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the object stored in the specified field.
&nbsp;         *
&nbsp;         * @param field The field on which to invoke the method upon.
&nbsp;         * @return A method call that invokes the given method on an instance that is read from a field.
&nbsp;         */
&nbsp;        public MethodCall onField(Field field) {
<b class="nc">&nbsp;            return onField(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the object stored in the specified field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field on which to invoke the method upon.
&nbsp;         * @return A method call that invokes the given method on an instance that is read from a field.
&nbsp;         */
&nbsp;        public MethodCall onField(FieldDescription fieldDescription) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.ForField.Factory(new TargetHandler.ForField.Location.ForExplicitField(fieldDescription)),
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a method on the method call&#39;s return value.
&nbsp;         *
&nbsp;         * @param methodCall The method call that return&#39;s value is to be used in this method call
&nbsp;         * @return A method call that invokes the given method on an instance that is returned from a method call.
&nbsp;         */
&nbsp;        public MethodCall onMethodCall(MethodCall methodCall) {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    new TargetHandler.ForMethodCall.Factory(methodCall),
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForVirtualInvocation.WithImplicitType.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the given method by a super method invocation on the instance of the instrumented type.
&nbsp;         * Note that the super method is resolved depending on the type of implementation when this method is called.
&nbsp;         * In case that a subclass is created, the super type is invoked. If a type is rebased, the rebased method
&nbsp;         * is invoked if such a method exists.
&nbsp;         *
&nbsp;         * @return A method call where the given method is invoked as a super method invocation.
&nbsp;         */
&nbsp;        public MethodCall onSuper() {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE,
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForSuperMethodInvocation.Factory.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the given method by a Java 8 default method invocation on the instance of the instrumented type.
&nbsp;         *
&nbsp;         * @return A method call where the given method is invoked as a super method invocation.
&nbsp;         */
&nbsp;        public MethodCall onDefault() {
<b class="nc">&nbsp;            return new MethodCall(methodLocator,</b>
&nbsp;                    TargetHandler.ForSelfOrStaticInvocation.Factory.INSTANCE,
&nbsp;                    argumentLoaders,
&nbsp;                    MethodInvoker.ForDefaultMethodInvocation.Factory.INSTANCE,
&nbsp;                    terminationHandler,
&nbsp;                    assigner,
&nbsp;                    typing);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link MethodCall} that sets the call&#39;s result as the value of a field.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class FieldSetting implements Composable {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method call.
&nbsp;         */
&nbsp;        private final MethodCall methodCall;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new field setting method call.
&nbsp;         *
&nbsp;         * @param methodCall The represented method call.
&nbsp;         */
<b class="nc">&nbsp;        protected FieldSetting(MethodCall methodCall) {</b>
<b class="nc">&nbsp;            this.methodCall = methodCall;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines an assigner to be used for assigning values to the parameters of the invoked method. This assigner
&nbsp;         * is also used for assigning the invoked method&#39;s return value to the field being set.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return This field-setting method call using the provided assigner.
&nbsp;         */
&nbsp;        public Composable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new FieldSetting((MethodCall) methodCall.withAssigner(assigner, typing));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;            return methodCall.prepare(instrumentedType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="nc">&nbsp;            return new ByteCodeAppender.Compound(methodCall.appender(implementationTarget), Appender.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;            return new Compound(methodCall, implementation);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;            return new Compound.Composable(methodCall, implementation);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A byte code appender to implement a field-setting method call.
&nbsp;         */
<b class="nc">&nbsp;        protected enum Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Instrumented method &quot; + instrumentedMethod + &quot; does not return void for field setting method call&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new Size(MethodReturn.VOID.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The appender being used to implement a {@link net.bytebuddy.implementation.MethodCall}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="nc">&nbsp;    protected class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation target.
&nbsp;         */
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * The method locator to use.
&nbsp;         */
&nbsp;        private final MethodLocator methodLocator;
&nbsp;
&nbsp;        /**
&nbsp;         * The argument providers to use.
&nbsp;         */
&nbsp;        private final List&lt;ArgumentLoader.ArgumentProvider&gt; argumentProviders;
&nbsp;
&nbsp;        /**
&nbsp;         * The method invoker to use.
&nbsp;         */
&nbsp;        private final MethodInvoker methodInvoker;
&nbsp;
&nbsp;        /**
&nbsp;         * The target handler to use.
&nbsp;         */
&nbsp;        private final TargetHandler targetHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * The termination handler to use.
&nbsp;         */
&nbsp;        private final TerminationHandler terminationHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender.
&nbsp;         *
&nbsp;         * @param implementationTarget The implementation target.
&nbsp;         * @param terminationHandler   The termination handler to use.
&nbsp;         */
<b class="fc">&nbsp;        protected Appender(Target implementationTarget, TerminationHandler terminationHandler) {</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;            methodLocator = MethodCall.this.methodLocator.make(implementationTarget.getInstrumentedType());</b>
<b class="fc">&nbsp;            argumentProviders = new ArrayList&lt;ArgumentLoader.ArgumentProvider&gt;(argumentLoaders.size());</b>
<b class="fc">&nbsp;            for (ArgumentLoader.Factory factory : argumentLoaders) {</b>
<b class="fc">&nbsp;                argumentProviders.add(factory.make(implementationTarget));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            methodInvoker = MethodCall.this.methodInvoker.make(implementationTarget.getInstrumentedType());</b>
<b class="fc">&nbsp;            targetHandler = MethodCall.this.targetHandler.make(implementationTarget);</b>
<b class="fc">&nbsp;            this.terminationHandler = terminationHandler;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            TargetHandler.Resolved targetHandler = this.targetHandler.resolve(instrumentedMethod);</b>
<b class="fc">&nbsp;            return new Size(new StackManipulation.Compound(terminationHandler.prepare(), toStackManipulation(instrumentedMethod,</b>
<b class="fc">&nbsp;                    toInvokedMethod(instrumentedMethod, targetHandler),</b>
<b class="fc">&nbsp;                    targetHandler)).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this appender to the method being invoked.
&nbsp;         *
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param targetHandler      The resolved target handler to base the stack manipulation upon.
&nbsp;         * @return The invoked method.
&nbsp;         */
&nbsp;        protected MethodDescription toInvokedMethod(MethodDescription instrumentedMethod, TargetHandler.Resolved targetHandler) {
<b class="fc">&nbsp;            return methodLocator.resolve(targetHandler.getTypeDescription(), instrumentedMethod);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this appender to a stack manipulation.
&nbsp;         *
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param invokedMethod      The invoked method.
&nbsp;         * @param targetHandler      The resolved target handler to base the stack manipulation upon.
&nbsp;         * @return A stack manipulation that represents this method call.
&nbsp;         */
&nbsp;        protected StackManipulation toStackManipulation(MethodDescription instrumentedMethod, MethodDescription invokedMethod, TargetHandler.Resolved targetHandler) {
<b class="fc">&nbsp;            List&lt;ArgumentLoader&gt; argumentLoaders = new ArrayList&lt;ArgumentLoader&gt;();</b>
<b class="fc">&nbsp;            for (ArgumentLoader.ArgumentProvider argumentProvider : argumentProviders) {</b>
<b class="fc">&nbsp;                argumentLoaders.addAll(argumentProvider.resolve(instrumentedMethod, invokedMethod));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            ParameterList&lt;?&gt; parameters = invokedMethod.getParameters();</b>
<b class="fc">&nbsp;            if (parameters.size() != argumentLoaders.size()) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(invokedMethod + &quot; does not accept &quot; + argumentLoaders.size() + &quot; arguments&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            Iterator&lt;? extends ParameterDescription&gt; parameterIterator = parameters.iterator();</b>
<b class="fc">&nbsp;            List&lt;StackManipulation&gt; argumentInstructions = new ArrayList&lt;StackManipulation&gt;(argumentLoaders.size());</b>
<b class="fc">&nbsp;            for (ArgumentLoader argumentLoader : argumentLoaders) {</b>
<b class="fc">&nbsp;                argumentInstructions.add(argumentLoader.toStackManipulation(parameterIterator.next(), assigner, typing));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                    targetHandler.toStackManipulation(invokedMethod, assigner, typing),</b>
&nbsp;                    new StackManipulation.Compound(argumentInstructions),
<b class="fc">&nbsp;                    methodInvoker.toStackManipulation(invokedMethod, implementationTarget),</b>
<b class="fc">&nbsp;                    terminationHandler.toStackManipulation(invokedMethod, instrumentedMethod, assigner, typing)</b>
&nbsp;            );
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 10:47</div>
</div>
</body>
</html>
