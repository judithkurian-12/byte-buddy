


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > EqualsMethod</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: EqualsMethod (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">EqualsMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (35/35)
  </span>
</td>
</tr>
  <tr>
    <td class="name">EqualsMethod$1</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$CompoundComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ConditionalReturn</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$NaturalOrderComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$NullValueGuard</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$NullValueGuard$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$NullValueGuard$UsingJump</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$NullValueGuard$UsingJump$AfterInstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$NullValueGuard$UsingJump$BeforeInstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$SuperClassCheck</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$SuperClassCheck$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$SuperClassCheck$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypeCompatibilityCheck</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypeCompatibilityCheck$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypeCompatibilityCheck$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypePropertyComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypePropertyComparator$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypePropertyComparator$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypePropertyComparator$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$TypePropertyComparator$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.9%
  </span>
  <span class="absValue">
    (47/48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$11</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$12</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$13</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">EqualsMethod$ValueComparator$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    99%
  </span>
  <span class="absValue">
    (101/102)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    99.3%
  </span>
  <span class="absValue">
    (281/283)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.InstanceCheck;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import org.objectweb.asm.Label;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * An implementation of {@link Object#equals(Object)} that takes a class&#39;s declared fields into consideration. Equality is resolved by comparing two
&nbsp; * instances of the same or a compatible class field by field where reference fields must either both be {@code null} or where the field value of
&nbsp; * the instance upon which the method is invoked returns {@code true} upon calling the value&#39;s {@code equals} method. For arrays, the corresponding
&nbsp; * utilities of {@link java.util.Arrays} are used.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public class EqualsMethod implements Implementation {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link Object#equals(Object)} method.
&nbsp;     */
<b class="fc">&nbsp;    private static final MethodDescription.InDefinedShape EQUALS = TypeDescription.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;            .getDeclaredMethods()</b>
<b class="fc">&nbsp;            .filter(isEquals())</b>
<b class="fc">&nbsp;            .getOnly();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The baseline equality to check.
&nbsp;     */
&nbsp;    private final SuperClassCheck superClassCheck;
&nbsp;
&nbsp;    /**
&nbsp;     * The instance type compatibility check.
&nbsp;     */
&nbsp;    private final TypeCompatibilityCheck typeCompatibilityCheck;
&nbsp;
&nbsp;    /**
&nbsp;     * A matcher to filter fields that should not be used for a equality resolution.
&nbsp;     */
&nbsp;    private final ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; ignored;
&nbsp;
&nbsp;    /**
&nbsp;     * A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;     */
&nbsp;    private final ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; nonNullable;
&nbsp;
&nbsp;    /**
&nbsp;     * The comparator to apply for ordering fields.
&nbsp;     */
&nbsp;    private final Comparator&lt;? super FieldDescription.InDefinedShape&gt; comparator;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new equals method implementation.
&nbsp;     *
&nbsp;     * @param superClassCheck The baseline equality to check.
&nbsp;     */
&nbsp;    protected EqualsMethod(SuperClassCheck superClassCheck) {
<b class="fc">&nbsp;        this(superClassCheck, TypeCompatibilityCheck.EXACT, none(), none(), NaturalOrderComparator.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new equals method implementation.
&nbsp;     *
&nbsp;     * @param superClassCheck        The baseline equality to check.
&nbsp;     * @param typeCompatibilityCheck The instance type compatibility check.
&nbsp;     * @param ignored                A matcher to filter fields that should not be used for a equality resolution.
&nbsp;     * @param nonNullable            A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;     * @param comparator             The comparator to apply for ordering fields.
&nbsp;     */
&nbsp;    private EqualsMethod(SuperClassCheck superClassCheck,
&nbsp;                         TypeCompatibilityCheck typeCompatibilityCheck,
&nbsp;                         ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; ignored,
&nbsp;                         ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; nonNullable,
<b class="fc">&nbsp;                         Comparator&lt;? super FieldDescription.InDefinedShape&gt; comparator) {</b>
<b class="fc">&nbsp;        this.superClassCheck = superClassCheck;</b>
<b class="fc">&nbsp;        this.typeCompatibilityCheck = typeCompatibilityCheck;</b>
<b class="fc">&nbsp;        this.ignored = ignored;</b>
<b class="fc">&nbsp;        this.nonNullable = nonNullable;</b>
<b class="fc">&nbsp;        this.comparator = comparator;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an equals implementation that invokes the super class&#39;s {@link Object#equals(Object)} method first.
&nbsp;     *
&nbsp;     * @return An equals implementation that invokes the super class&#39;s {@link Object#equals(Object)} method first.
&nbsp;     */
&nbsp;    public static EqualsMethod requiringSuperClassEquality() {
<b class="fc">&nbsp;        return new EqualsMethod(SuperClassCheck.ENABLED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an equals method implementation that does not invoke the super class&#39;s {@link Object#equals(Object)} method.
&nbsp;     *
&nbsp;     * @return An equals method implementation that does not invoke the super class&#39;s {@link Object#equals(Object)} method.
&nbsp;     */
&nbsp;    public static EqualsMethod isolated() {
<b class="fc">&nbsp;        return new EqualsMethod(SuperClassCheck.DISABLED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method implementation that ignores the specified fields additionally to any
&nbsp;     * previously specified fields.
&nbsp;     *
&nbsp;     * @param ignored A matcher to specify any fields that should be ignored.
&nbsp;     * @return A new version of this equals method implementation that also ignores any fields matched by the provided matcher.
&nbsp;     */
&nbsp;    public EqualsMethod withIgnoredFields(ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; ignored) {
<b class="fc">&nbsp;        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, this.ignored.&lt;FieldDescription.InDefinedShape&gt;or(ignored), nonNullable, comparator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method implementation that does not apply a {@code null} value check for the specified fields
&nbsp;     * if they have a reference type additionally to any previously specified fields.
&nbsp;     *
&nbsp;     * @param nonNullable A matcher to specify any fields that should not be guarded against {@code null} values.
&nbsp;     * @return A new version of this equals method implementation that also does not apply {@code null} value checks to any fields matched by
&nbsp;     * the provided matcher.
&nbsp;     */
&nbsp;    public EqualsMethod withNonNullableFields(ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; nonNullable) {
<b class="fc">&nbsp;        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, ignored, this.nonNullable.&lt;FieldDescription.InDefinedShape&gt;or(nonNullable), comparator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method that compares fields with primitive types prior to fields with non-primitive types.
&nbsp;     *
&nbsp;     * @return A new version of this equals method that compares primitive-typed fields before fields with non-primitive-typed fields.
&nbsp;     */
&nbsp;    public EqualsMethod withPrimitiveTypedFieldsFirst() {
<b class="fc">&nbsp;        return withFieldOrder(TypePropertyComparator.FOR_PRIMITIVE_TYPES);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method that compares fields with enumeration types prior to fields with non-enumeration types.
&nbsp;     *
&nbsp;     * @return A new version of this equals method that compares enumeration-typed fields before fields with non-enumeration-typed fields.
&nbsp;     */
&nbsp;    public EqualsMethod withEnumerationTypedFieldsFirst() {
<b class="fc">&nbsp;        return withFieldOrder(TypePropertyComparator.FOR_ENUMERATION_TYPES);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method that compares fields with primitive wrapper types prior to fields with non-primitive wrapper types.
&nbsp;     *
&nbsp;     * @return A new version of this equals method that compares primitive wrapper-typed fields before fields with non-primitive wrapper-typed fields.
&nbsp;     */
&nbsp;    public EqualsMethod withPrimitiveWrapperTypedFieldsFirst() {
<b class="fc">&nbsp;        return withFieldOrder(TypePropertyComparator.FOR_PRIMITIVE_WRAPPER_TYPES);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method that compares fields with {@link String} types prior to fields with non-{@link String} types.
&nbsp;     *
&nbsp;     * @return A new version of this equals method that compares {@link String}-typed fields before fields with non-{@link String}-typed fields.
&nbsp;     */
&nbsp;    public EqualsMethod withStringTypedFieldsFirst() {
<b class="fc">&nbsp;        return withFieldOrder(TypePropertyComparator.FOR_STRING_TYPES);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies the supplied comparator to determine an order for fields for being compared. Fields with the lowest sort order are compared
&nbsp;     * first. Any previously defined comparators are applied prior to the supplied comparator.
&nbsp;     *
&nbsp;     * @param comparator The comparator to apply.
&nbsp;     * @return A new version of this equals method that sorts fields in their application order using the supplied comparator.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;    public EqualsMethod withFieldOrder(Comparator&lt;? super FieldDescription.InDefinedShape&gt; comparator) {
<b class="fc">&nbsp;        return new EqualsMethod(superClassCheck, typeCompatibilityCheck, ignored, nonNullable, new CompoundComparator(this.comparator, comparator));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this equals method implementation that permits subclasses of the instrumented type to be equal to instances
&nbsp;     * of the instrumented type instead of requiring an exact match.
&nbsp;     *
&nbsp;     * @return A new version of this equals method implementation that permits subclasses of the instrumented type to be equal to instances
&nbsp;     * of the instrumented type instead of requiring an exact match.
&nbsp;     */
&nbsp;    public Implementation withSubclassEquality() {
<b class="fc">&nbsp;        return new EqualsMethod(superClassCheck, TypeCompatibilityCheck.SUBCLASS, ignored, nonNullable, comparator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        return instrumentedType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        if (implementationTarget.getInstrumentedType().isInterface()) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot implement meaningful equals method for &quot; + implementationTarget.getInstrumentedType());</b>
&nbsp;        }
<b class="fc">&nbsp;        List&lt;FieldDescription.InDefinedShape&gt; fields = new ArrayList&lt;FieldDescription.InDefinedShape&gt;(implementationTarget.getInstrumentedType()</b>
<b class="fc">&nbsp;                .getDeclaredFields()</b>
<b class="fc">&nbsp;                .filter(not(isStatic().or(ignored))));</b>
<b class="fc">&nbsp;        Collections.sort(fields, comparator);</b>
<b class="fc">&nbsp;        return new Appender(implementationTarget.getInstrumentedType(), new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                superClassCheck.resolve(implementationTarget.getInstrumentedType()),</b>
<b class="fc">&nbsp;                MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                ConditionalReturn.onIdentity().returningTrue(),</b>
<b class="fc">&nbsp;                typeCompatibilityCheck.resolve(implementationTarget.getInstrumentedType())</b>
&nbsp;        ), fields, nonNullable);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the equality contract against the super class.
&nbsp;     */
<b class="fc">&nbsp;    protected enum SuperClassCheck {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Does not perform any super class check.
&nbsp;         */
<b class="fc">&nbsp;        DISABLED {</b>
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the super class&#39;s {@link Object#equals(Object)} method.
&nbsp;         */
<b class="fc">&nbsp;        ENABLED {</b>
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                TypeDefinition superClass = instrumentedType.getSuperClass();</b>
<b class="fc">&nbsp;                if (superClass == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; does not declare a super class&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                        MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(EQUALS).special(superClass.asErasure()),</b>
<b class="fc">&nbsp;                        ConditionalReturn.onZeroInteger());</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a stack manipulation for the required super class check.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return A stack manipulation that implements the specified check.
&nbsp;         */
&nbsp;        protected abstract StackManipulation resolve(TypeDescription instrumentedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the overall type of the provided argument.
&nbsp;     */
<b class="fc">&nbsp;    protected enum TypeCompatibilityCheck {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Requires an exact type match.
&nbsp;         */
<b class="fc">&nbsp;        EXACT {</b>
&nbsp;            @Override
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                        ConditionalReturn.onNullValue(),</b>
<b class="fc">&nbsp;                        MethodVariableAccess.REFERENCE.loadFrom(0),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(GET_CLASS),</b>
<b class="fc">&nbsp;                        MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(GET_CLASS),</b>
<b class="fc">&nbsp;                        ConditionalReturn.onNonIdentity()</b>
&nbsp;                );
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Requires a subtype relationship.
&nbsp;         */
<b class="fc">&nbsp;        SUBCLASS {</b>
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                        InstanceCheck.of(instrumentedType),</b>
<b class="fc">&nbsp;                        ConditionalReturn.onZeroInteger()</b>
&nbsp;                );
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Object#getClass()} method.
&nbsp;         */
<b class="fc">&nbsp;        protected static final MethodDescription.InDefinedShape GET_CLASS = TypeDescription.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                .filter(named(&quot;getClass&quot;))</b>
<b class="fc">&nbsp;                .getOnly();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a stack manipulation for the required type compatibility check.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return A stack manipulation that implements the specified check.
&nbsp;         */
&nbsp;        protected abstract StackManipulation resolve(TypeDescription instrumentedType);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Guards a field value against a potential {@code null} value.
&nbsp;     */
&nbsp;    protected interface NullValueGuard {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation to apply before computing equality.
&nbsp;         *
&nbsp;         * @return A stack manipulation to apply before computing equality.
&nbsp;         */
&nbsp;        StackManipulation before();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation to apply after computing equality.
&nbsp;         *
&nbsp;         * @return A stack manipulation to apply after computing equality.
&nbsp;         */
&nbsp;        StackManipulation after();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the required padding for the local variable array to apply this guard.
&nbsp;         *
&nbsp;         * @return The required padding for the local variable array to apply this guard.
&nbsp;         */
&nbsp;        int getRequiredVariablePadding();
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational null value guard.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements NullValueGuard {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation before() {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation after() {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getRequiredVariablePadding() {
<b class="fc">&nbsp;                return StackSize.ZERO.getSize();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A null value guard that expects a reference type and that skips the comparison if both values are {@code null} but returns if
&nbsp;         * the invoked instance&#39;s field value is {@code null} but not the compared instance&#39;s value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        class UsingJump implements NullValueGuard {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * The label to jump to if the first value is {@code null} whereas the second value is not {@code null}.
&nbsp;             */
&nbsp;            private final Label firstValueNull;
&nbsp;
&nbsp;            /**
&nbsp;             * The label to jump to if the second value is {@code null}.
&nbsp;             */
&nbsp;            private final Label secondValueNull;
&nbsp;
&nbsp;            /**
&nbsp;             * A label indicating the end of the null-guarding block.
&nbsp;             */
&nbsp;            private final Label endOfBlock;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new null value guard using a jump instruction for {@code null} values.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            protected UsingJump(MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                firstValueNull = new Label();</b>
<b class="fc">&nbsp;                secondValueNull = new Label();</b>
<b class="fc">&nbsp;                endOfBlock = new Label();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation before() {
<b class="fc">&nbsp;                return new UsingJump.BeforeInstruction();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation after() {
<b class="fc">&nbsp;                return new UsingJump.AfterInstruction();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getRequiredVariablePadding() {
<b class="fc">&nbsp;                return 2;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to apply before the equality computation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;            protected class BeforeInstruction extends StackManipulation.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, instrumentedMethod.getStackSize());</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, instrumentedMethod.getStackSize() + 1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, instrumentedMethod.getStackSize() + 1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, instrumentedMethod.getStackSize());</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, secondValueNull);</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, firstValueNull);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, instrumentedMethod.getStackSize() + 1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, instrumentedMethod.getStackSize());</b>
<b class="fc">&nbsp;                    return Size.ZERO;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to apply after the equality computation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;            protected class AfterInstruction extends StackManipulation.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.GOTO, endOfBlock);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(secondValueNull);</b>
<b class="fc">&nbsp;                    implementationContext.getFrameGeneration().same1(methodVisitor,</b>
<b class="fc">&nbsp;                            TypeDescription.ForLoadedType.of(Object.class),</b>
<b class="fc">&nbsp;                            Arrays.asList(implementationContext.getInstrumentedType(), TypeDescription.ForLoadedType.of(Object.class)));</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, endOfBlock);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(firstValueNull);</b>
<b class="fc">&nbsp;                    implementationContext.getFrameGeneration().same(methodVisitor,</b>
<b class="fc">&nbsp;                            Arrays.asList(implementationContext.getInstrumentedType(), TypeDescription.ForLoadedType.of(Object.class)));</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.IRETURN);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(endOfBlock);</b>
<b class="fc">&nbsp;                    implementationContext.getFrameGeneration().same(methodVisitor,</b>
<b class="fc">&nbsp;                            Arrays.asList(implementationContext.getInstrumentedType(), TypeDescription.ForLoadedType.of(Object.class)));</b>
<b class="fc">&nbsp;                    return Size.ZERO;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A value comparator is responsible to compare to values of a given type.
&nbsp;     */
<b class="fc">&nbsp;    protected enum ValueComparator implements StackManipulation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code long} value.
&nbsp;         */
<b class="fc">&nbsp;        LONG {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.LCMP);</b>
<b class="fc">&nbsp;                return new Size(-2, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code float} value.
&nbsp;         */
<b class="fc">&nbsp;        FLOAT {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/Float&quot;, &quot;compare&quot;, &quot;(FF)I&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code double} value.
&nbsp;         */
<b class="fc">&nbsp;        DOUBLE {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/Double&quot;, &quot;compare&quot;, &quot;(DD)I&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-2, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code boolean[]} value.
&nbsp;         */
<b class="fc">&nbsp;        BOOLEAN_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([Z[Z)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code byte[]} value.
&nbsp;         */
<b class="fc">&nbsp;        BYTE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([B[B)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code short[]} value.
&nbsp;         */
<b class="fc">&nbsp;        SHORT_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([S[S)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code char[]} value.
&nbsp;         */
<b class="fc">&nbsp;        CHARACTER_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([C[C)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for an {@code int[]} value.
&nbsp;         */
<b class="fc">&nbsp;        INTEGER_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([I[I)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code long[]} value.
&nbsp;         */
<b class="fc">&nbsp;        LONG_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([J[J)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A comparator for a {@code float[]} value.
&nbsp;         */
<b class="fc">&nbsp;        FLOAT_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([F[F)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code double[]} value.
&nbsp;         */
<b class="fc">&nbsp;        DOUBLE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([D[D)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a reference array value.
&nbsp;         */
<b class="fc">&nbsp;        REFERENCE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;equals&quot;, &quot;([Ljava/lang/Object;[Ljava/lang/Object;)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a nested reference array value.
&nbsp;         */
<b class="fc">&nbsp;        NESTED_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;deepEquals&quot;, &quot;([Ljava/lang/Object;[Ljava/lang/Object;)Z&quot;, false);</b>
<b class="fc">&nbsp;                return new Size(-1, 0);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a type definition to a equality comparison.
&nbsp;         *
&nbsp;         * @param typeDefinition The type definition to resolve.
&nbsp;         * @return The stack manipulation to apply.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public static StackManipulation of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            if (typeDefinition.represents(boolean.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(byte.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(short.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(char.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(int.class)) {</b>
<b class="fc">&nbsp;                return ConditionalReturn.onNonEqualInteger();</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(long.class)) {</b>
<b class="fc">&nbsp;                return new Compound(LONG, ConditionalReturn.onNonZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(float.class)) {</b>
<b class="fc">&nbsp;                return new Compound(FLOAT, ConditionalReturn.onNonZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(double.class)) {</b>
<b class="fc">&nbsp;                return new Compound(DOUBLE, ConditionalReturn.onNonZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(boolean[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(BOOLEAN_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(byte[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(BYTE_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(short[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(SHORT_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(char[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(CHARACTER_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(int[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(INTEGER_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(long[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(LONG_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(float[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(FLOAT_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(double[].class)) {</b>
<b class="fc">&nbsp;                return new Compound(DOUBLE_ARRAY, ConditionalReturn.onZeroInteger());</b>
<b class="fc">&nbsp;            } else if (typeDefinition.isArray()) {</b>
<b class="fc">&nbsp;                return new Compound(typeDefinition.getComponentType().isArray()</b>
<b class="fc">&nbsp;                        ? NESTED_ARRAY</b>
<b class="fc">&nbsp;                        : REFERENCE_ARRAY, ConditionalReturn.onZeroInteger());</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return new Compound(MethodInvocation.invoke(EQUALS).virtual(typeDefinition.asErasure()), ConditionalReturn.onZeroInteger());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isValid() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A byte code appender to implement the {@link EqualsMethod}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type.
&nbsp;         */
&nbsp;        private final TypeDescription instrumentedType;
&nbsp;
&nbsp;        /**
&nbsp;         * The baseline stack manipulation.
&nbsp;         */
&nbsp;        private final StackManipulation baseline;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of fields to use for the comparison.
&nbsp;         */
&nbsp;        private final List&lt;FieldDescription.InDefinedShape&gt; fieldDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;         */
&nbsp;        private final ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; nonNullable;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender.
&nbsp;         *
&nbsp;         * @param instrumentedType  The instrumented type.
&nbsp;         * @param baseline          The baseline stack manipulation.
&nbsp;         * @param fieldDescriptions A list of fields to use for the comparison.
&nbsp;         * @param nonNullable       A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;         */
&nbsp;        protected Appender(TypeDescription instrumentedType,
&nbsp;                           StackManipulation baseline,
&nbsp;                           List&lt;FieldDescription.InDefinedShape&gt; fieldDescriptions,
<b class="fc">&nbsp;                           ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; nonNullable) {</b>
<b class="fc">&nbsp;            this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;            this.baseline = baseline;</b>
<b class="fc">&nbsp;            this.fieldDescriptions = fieldDescriptions;</b>
<b class="fc">&nbsp;            this.nonNullable = nonNullable;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            if (instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Hash code method must not be static: &quot; + instrumentedMethod);</b>
<b class="fc">&nbsp;            } else if (instrumentedMethod.getParameters().size() != 1 || instrumentedMethod.getParameters().getOnly().getType().isPrimitive()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException();</b>
<b class="fc">&nbsp;            } else if (!instrumentedMethod.getReturnType().represents(boolean.class)) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Hash code method does not return primitive boolean: &quot; + instrumentedMethod);</b>
&nbsp;            }
<b class="fc">&nbsp;            List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(3 + fieldDescriptions.size() * 8);</b>
<b class="fc">&nbsp;            stackManipulations.add(baseline);</b>
<b class="fc">&nbsp;            int padding = 0;</b>
<b class="fc">&nbsp;            for (FieldDescription.InDefinedShape fieldDescription : fieldDescriptions) {</b>
<b class="fc">&nbsp;                stackManipulations.add(MethodVariableAccess.loadThis());</b>
<b class="fc">&nbsp;                stackManipulations.add(FieldAccess.forField(fieldDescription).read());</b>
<b class="fc">&nbsp;                stackManipulations.add(MethodVariableAccess.REFERENCE.loadFrom(1));</b>
<b class="fc">&nbsp;                stackManipulations.add(TypeCasting.to(instrumentedType));</b>
<b class="fc">&nbsp;                stackManipulations.add(FieldAccess.forField(fieldDescription).read());</b>
<b class="fc">&nbsp;                NullValueGuard nullValueGuard = fieldDescription.getType().isPrimitive() || fieldDescription.getType().isArray() || nonNullable.matches(fieldDescription)</b>
<b class="fc">&nbsp;                        ? NullValueGuard.NoOp.INSTANCE</b>
<b class="fc">&nbsp;                        : new NullValueGuard.UsingJump(instrumentedMethod);</b>
<b class="fc">&nbsp;                stackManipulations.add(nullValueGuard.before());</b>
<b class="fc">&nbsp;                stackManipulations.add(ValueComparator.of(fieldDescription.getType()));</b>
<b class="fc">&nbsp;                stackManipulations.add(nullValueGuard.after());</b>
<b class="fc">&nbsp;                padding = Math.max(padding, nullValueGuard.getRequiredVariablePadding());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            stackManipulations.add(IntegerConstant.forValue(true));</b>
<b class="fc">&nbsp;            stackManipulations.add(MethodReturn.INTEGER);</b>
<b class="fc">&nbsp;            return new Size(new StackManipulation.Compound(stackManipulations).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize() + padding);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A conditional return aborts the equality computation if a given condition was reached.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ConditionalReturn extends StackManipulation.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * An empty array.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object[] EMPTY = new Object[0];</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The conditional jump instruction upon which the return is not triggered.
&nbsp;         */
&nbsp;        private final int jumpCondition;
&nbsp;
&nbsp;        /**
&nbsp;         * The opcode for the value being returned.
&nbsp;         */
&nbsp;        private final int value;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a conditional return for a value of {@code false}.
&nbsp;         *
&nbsp;         * @param jumpCondition The opcode upon which the return is not triggered.
&nbsp;         */
&nbsp;        protected ConditionalReturn(int jumpCondition) {
<b class="fc">&nbsp;            this(jumpCondition, Opcodes.ICONST_0);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a conditional return.
&nbsp;         *
&nbsp;         * @param jumpCondition The opcode upon which the return is not triggered.
&nbsp;         * @param value         The opcode for the value being returned.
&nbsp;         */
<b class="fc">&nbsp;        private ConditionalReturn(int jumpCondition, int value) {</b>
<b class="fc">&nbsp;            this.jumpCondition = jumpCondition;</b>
<b class="fc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a conditional return that returns on an {@code int} value of {@code 0}.
&nbsp;         *
&nbsp;         * @return A conditional return that returns on an {@code int} value of {@code 0}.
&nbsp;         */
&nbsp;        protected static ConditionalReturn onZeroInteger() {
<b class="fc">&nbsp;            return new ConditionalReturn(Opcodes.IFNE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a conditional return that returns on an {@code int} value of not {@code 0}.
&nbsp;         *
&nbsp;         * @return A conditional return that returns on an {@code int} value of not {@code 0}.
&nbsp;         */
&nbsp;        protected static ConditionalReturn onNonZeroInteger() {
<b class="fc">&nbsp;            return new ConditionalReturn(Opcodes.IFEQ);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a conditional return that returns on a reference value of {@code null}.
&nbsp;         *
&nbsp;         * @return A conditional return that returns on a reference value of {@code null}.
&nbsp;         */
&nbsp;        protected static ConditionalReturn onNullValue() {
<b class="fc">&nbsp;            return new ConditionalReturn(Opcodes.IFNONNULL);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a conditional return that returns if two reference values are not identical.
&nbsp;         *
&nbsp;         * @return A conditional return that returns if two reference values are not identical.
&nbsp;         */
&nbsp;        protected static ConditionalReturn onNonIdentity() {
<b class="fc">&nbsp;            return new ConditionalReturn(Opcodes.IF_ACMPEQ);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a conditional return that returns if two reference values are identical.
&nbsp;         *
&nbsp;         * @return A conditional return that returns if two reference values are identical.
&nbsp;         */
&nbsp;        protected static ConditionalReturn onIdentity() {
<b class="fc">&nbsp;            return new ConditionalReturn(Opcodes.IF_ACMPNE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a conditional return that returns if two {@code int} values are not equal.
&nbsp;         *
&nbsp;         * @return A conditional return that returns if two {@code int} values are not equal.
&nbsp;         */
&nbsp;        protected static ConditionalReturn onNonEqualInteger() {
<b class="fc">&nbsp;            return new ConditionalReturn(Opcodes.IF_ICMPEQ);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a new stack manipulation that returns {@code true} for the given condition.
&nbsp;         *
&nbsp;         * @return A new stack manipulation that returns {@code true} for the given condition.
&nbsp;         */
&nbsp;        protected StackManipulation returningTrue() {
<b class="fc">&nbsp;            return new ConditionalReturn(jumpCondition, Opcodes.ICONST_1);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;            Label label = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(jumpCondition, label);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(value);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.IRETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(label);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(implementationContext.getInstrumentedType(), TypeDescription.ForLoadedType.of(Object.class)));</b>
<b class="fc">&nbsp;            return new Size(-1, 1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A comparator that retains the natural order.
&nbsp;     */
<b class="fc">&nbsp;    protected enum NaturalOrderComparator implements Comparator&lt;FieldDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int compare(FieldDescription.InDefinedShape left, FieldDescription.InDefinedShape right) {
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A comparator that sorts fields by a type property.
&nbsp;     */
<b class="fc">&nbsp;    protected enum TypePropertyComparator implements Comparator&lt;FieldDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Weights primitive types before non-primitive types.
&nbsp;         */
<b class="fc">&nbsp;        FOR_PRIMITIVE_TYPES {</b>
&nbsp;            @Override
&nbsp;            protected boolean resolve(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return typeDefinition.isPrimitive();</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Weights enumeration types before non-enumeration types.
&nbsp;         */
<b class="fc">&nbsp;        FOR_ENUMERATION_TYPES {</b>
&nbsp;            @Override
&nbsp;            protected boolean resolve(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return typeDefinition.isEnum();</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Weights {@link String} types first.
&nbsp;         */
<b class="fc">&nbsp;        FOR_STRING_TYPES {</b>
&nbsp;            @Override
&nbsp;            protected boolean resolve(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return typeDefinition.represents(String.class);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Weights primitive wrapper types first.
&nbsp;         */
<b class="fc">&nbsp;        FOR_PRIMITIVE_WRAPPER_TYPES {</b>
&nbsp;            @Override
&nbsp;            protected boolean resolve(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return typeDefinition.asErasure().isPrimitiveWrapper();</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int compare(FieldDescription.InDefinedShape left, FieldDescription.InDefinedShape right) {
<b class="fc">&nbsp;            if (resolve(left.getType()) &amp;&amp; !resolve(right.getType())) {</b>
<b class="fc">&nbsp;                return -1;</b>
<b class="fc">&nbsp;            } else if (!resolve(left.getType()) &amp;&amp; resolve(right.getType())) {</b>
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a type property.
&nbsp;         *
&nbsp;         * @param typeDefinition The type to resolve the property for.
&nbsp;         * @return {@code true} if the type property is resolved.
&nbsp;         */
&nbsp;        protected abstract boolean resolve(TypeDefinition typeDefinition);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compound comparator that compares the values of multiple fields.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    @SuppressFBWarnings(value = &quot;SE_COMPARATOR_SHOULD_BE_SERIALIZABLE&quot;, justification = &quot;Not used within a serializable instance&quot;)
&nbsp;    protected static class CompoundComparator implements Comparator&lt;FieldDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * All comparators to be applied in the application order.
&nbsp;         */
&nbsp;        private final List&lt;Comparator&lt;? super FieldDescription.InDefinedShape&gt;&gt; comparators;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a compound comparator.
&nbsp;         *
&nbsp;         * @param comparator All comparators to be applied in the application order.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;        protected CompoundComparator(Comparator&lt;? super FieldDescription.InDefinedShape&gt;... comparator) {
<b class="fc">&nbsp;            this(Arrays.asList(comparator));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a compound comparator.
&nbsp;         *
&nbsp;         * @param comparators All comparators to be applied in the application order.
&nbsp;         */
<b class="fc">&nbsp;        protected CompoundComparator(List&lt;? extends Comparator&lt;? super FieldDescription.InDefinedShape&gt;&gt; comparators) {</b>
<b class="fc">&nbsp;            this.comparators = new ArrayList&lt;Comparator&lt;? super FieldDescription.InDefinedShape&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Comparator&lt;? super FieldDescription.InDefinedShape&gt; comparator : comparators) {</b>
<b class="fc">&nbsp;                if (comparator instanceof CompoundComparator) {</b>
<b class="fc">&nbsp;                    this.comparators.addAll(((CompoundComparator) comparator).comparators);</b>
<b class="fc">&nbsp;                } else if (!(comparator instanceof NaturalOrderComparator)) {</b>
<b class="fc">&nbsp;                    this.comparators.add(comparator);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int compare(FieldDescription.InDefinedShape left, FieldDescription.InDefinedShape right) {
<b class="fc">&nbsp;            for (Comparator&lt;? super FieldDescription.InDefinedShape&gt; comparator : comparators) {</b>
<b class="fc">&nbsp;                int comparison = comparator.compare(left, right);</b>
<b class="fc">&nbsp;                if (comparison != 0) {</b>
<b class="fc">&nbsp;                    return comparison;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return 0;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
