


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FieldAccessor</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: FieldAccessor (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FieldAccessor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FieldAccessor$1</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$AssignerConfigurable</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Absolute</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Prepared</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Relative</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldLocation$Relative$Prepared</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor$ForBeanProperty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor$ForBeanProperty$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor$ForBeanProperty$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$FieldNameExtractor$ForFixedValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForImplicitProperty</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (18/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (24/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForImplicitProperty$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.5%
  </span>
  <span class="absValue">
    (23/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.9%
  </span>
  <span class="absValue">
    (15/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$OfConstantValue</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$OfDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$OfFieldValue</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (12/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$OfParameterValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$OfReferenceValue</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (10/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$TerminationHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$TerminationHandler$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$ForSetter$TerminationHandler$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$OwnerTypeLocatable</td>
  </tr>
  <tr>
    <td class="name">FieldAccessor$PropertyConfigurable</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    84.8%
  </span>
  <span class="absValue">
    (78/92)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.4%
  </span>
  <span class="absValue">
    (174/199)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DefaultValue;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.ConstantValue;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * Defines a method to access a given field by following the Java bean conventions for getters and setters:
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Getter: A method named {@code getFoo()} will be instrumented to read and return the value of a field {@code foo}
&nbsp; * or another field if one was specified explicitly. If a property is of type {@link java.lang.Boolean} or
&nbsp; * {@code boolean}, the name {@code isFoo()} is also permitted.&lt;/li&gt;
&nbsp; * &lt;li&gt;Setter: A method named {@code setFoo(value)} will be instrumented to write the given argument {@code value}
&nbsp; * to a field {@code foo} or to another field if one was specified explicitly.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Field accessors always implement a getter if a non-{@code void} value is returned from a method and attempt to define a setter
&nbsp; * otherwise. If a field accessor is not explicitly defined as a setter via {@link PropertyConfigurable}, an instrumented
&nbsp; * method must define exactly one parameter. Using the latter API, an explicit parameter index can be defined and a return
&nbsp; * value can be specified explicitly when {@code void} is not returned.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public abstract class FieldAccessor implements Implementation {
&nbsp;
&nbsp;    /**
&nbsp;     * The field&#39;s location.
&nbsp;     */
&nbsp;    protected final FieldLocation fieldLocation;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to use.
&nbsp;     */
&nbsp;    protected final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new field accessor.
&nbsp;     *
&nbsp;     * @param fieldLocation The field&#39;s location.
&nbsp;     * @param assigner      The assigner to use.
&nbsp;     * @param typing        Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
<b class="fc">&nbsp;    protected FieldAccessor(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;        this.fieldLocation = fieldLocation;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.typing = typing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where any access is targeted to a field named {@code name}.
&nbsp;     *
&nbsp;     * @param name The name of the field to be accessed.
&nbsp;     * @return A field accessor for a field of a given name.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable ofField(String name) {
<b class="fc">&nbsp;        return of(new FieldNameExtractor.ForFixedValue(name));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where any access is targeted to a field that matches the methods
&nbsp;     * name with the Java specification for bean properties, i.e. a method {@code getFoo} or {@code setFoo(value)}
&nbsp;     * will either read or write a field named {@code foo}.
&nbsp;     *
&nbsp;     * @return A field accessor that follows the Java naming conventions for bean properties.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable ofBeanProperty() {
<b class="fc">&nbsp;        return of(FieldNameExtractor.ForBeanProperty.INSTANCE, FieldNameExtractor.ForBeanProperty.CAPITALIZED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a custom strategy for determining the field that is accessed by this field accessor.
&nbsp;     *
&nbsp;     * @param fieldNameExtractor The field name extractor to use.
&nbsp;     * @return A field accessor using the given field name extractor.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable of(FieldNameExtractor fieldNameExtractor) {
<b class="fc">&nbsp;        return of(Collections.singletonList(fieldNameExtractor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a custom strategy for determining the field that is accessed by this field accessor.
&nbsp;     *
&nbsp;     * @param fieldNameExtractor The field name extractors to use in their application order.
&nbsp;     * @return A field accessor using the given field name extractor.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable of(FieldNameExtractor... fieldNameExtractor) {
<b class="fc">&nbsp;        return of(Arrays.asList(fieldNameExtractor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a custom strategy for determining the field that is accessed by this field accessor.
&nbsp;     *
&nbsp;     * @param fieldNameExtractors The field name extractors to use in their application order.
&nbsp;     * @return A field accessor using the given field name extractor.
&nbsp;     */
&nbsp;    public static OwnerTypeLocatable of(List&lt;? extends FieldNameExtractor&gt; fieldNameExtractors) {
<b class="fc">&nbsp;        return new ForImplicitProperty(new FieldLocation.Relative(fieldNameExtractors));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where the specified field is accessed. The field must be within the hierarchy of the instrumented type.
&nbsp;     *
&nbsp;     * @param field The field being accessed.
&nbsp;     * @return A field accessor for the given field.
&nbsp;     */
&nbsp;    public static AssignerConfigurable of(Field field) {
<b class="fc">&nbsp;        return of(new FieldDescription.ForLoadedField(field));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a field accessor where the specified field is accessed. The field must be within the hierarchy of the instrumented type.
&nbsp;     *
&nbsp;     * @param fieldDescription The field being accessed.
&nbsp;     * @return A field accessor for the given field.
&nbsp;     */
&nbsp;    public static AssignerConfigurable of(FieldDescription fieldDescription) {
<b class="fc">&nbsp;        return new ForImplicitProperty(new FieldLocation.Absolute(fieldDescription));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field location represents an identified field description which depends on the instrumented type and method.
&nbsp;     */
&nbsp;    protected interface FieldLocation {
&nbsp;
&nbsp;        /**
&nbsp;         * Specifies a field locator factory to use.
&nbsp;         *
&nbsp;         * @param fieldLocatorFactory The field locator factory to use.
&nbsp;         * @return An appropriate field location.
&nbsp;         */
&nbsp;        FieldLocation with(FieldLocator.Factory fieldLocatorFactory);
&nbsp;
&nbsp;        /**
&nbsp;         * A prepared field location.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return A prepared field location.
&nbsp;         */
&nbsp;        Prepared prepare(TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * A prepared field location.
&nbsp;         */
&nbsp;        interface Prepared {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the field description to use.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return The resolved field description.
&nbsp;             */
&nbsp;            FieldDescription resolve(MethodDescription instrumentedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An absolute field description representing a previously resolved field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Absolute implements FieldLocation, Prepared {
&nbsp;
&nbsp;            /**
&nbsp;             * The field description.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an absolute field location.
&nbsp;             *
&nbsp;             * @param fieldDescription The field description.
&nbsp;             */
<b class="fc">&nbsp;            protected Absolute(FieldDescription fieldDescription) {</b>
<b class="fc">&nbsp;                this.fieldDescription = fieldDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot specify a field locator factory for an absolute field location&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;            public Prepared prepare(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; !instrumentedType.isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(fieldDescription + &quot; is not declared by &quot; + instrumentedType);</b>
<b class="fc">&nbsp;                } else if (!fieldDescription.isAccessibleTo(instrumentedType)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
&nbsp;                }
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDescription resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return fieldDescription;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A relative field location where a field is located dynamically.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Relative implements FieldLocation {
&nbsp;
&nbsp;            /**
&nbsp;             * The field name extractors to use in their application order.
&nbsp;             */
&nbsp;            private final List&lt;? extends FieldNameExtractor&gt; fieldNameExtractors;
&nbsp;
&nbsp;            /**
&nbsp;             * The field locator factory to use.
&nbsp;             */
&nbsp;            private final FieldLocator.Factory fieldLocatorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new relative field location.
&nbsp;             *
&nbsp;             * @param fieldNameExtractors The field name extractors to use in their application order.
&nbsp;             */
&nbsp;            protected Relative(List&lt;? extends FieldNameExtractor&gt; fieldNameExtractors) {
<b class="fc">&nbsp;                this(fieldNameExtractors, FieldLocator.ForClassHierarchy.Factory.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new relative field location.
&nbsp;             *
&nbsp;             * @param fieldNameExtractors  The field name extractors to use in their application order.
&nbsp;             * @param fieldLocatorFactory The field locator factory to use.
&nbsp;             */
<b class="fc">&nbsp;            private Relative(List&lt;? extends FieldNameExtractor&gt; fieldNameExtractors, FieldLocator.Factory fieldLocatorFactory) {</b>
<b class="fc">&nbsp;                this.fieldNameExtractors = fieldNameExtractors;</b>
<b class="fc">&nbsp;                this.fieldLocatorFactory = fieldLocatorFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldLocation with(FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;                return new Relative(fieldNameExtractors, fieldLocatorFactory);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldLocation.Prepared prepare(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new Prepared(fieldNameExtractors, fieldLocatorFactory.make(instrumentedType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A prepared version of a field location.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Prepared implements FieldLocation.Prepared {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field name extractor to use in their application order.
&nbsp;                 */
&nbsp;                private final List&lt;? extends FieldNameExtractor&gt; fieldNameExtractors;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field locator factory to use.
&nbsp;                 */
&nbsp;                private final FieldLocator fieldLocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new relative field location.
&nbsp;                 *
&nbsp;                 * @param fieldNameExtractors The field name extractors to use in their application order.
&nbsp;                 * @param fieldLocator        The field locator to use.
&nbsp;                 */
<b class="fc">&nbsp;                protected Prepared(List&lt;? extends FieldNameExtractor&gt; fieldNameExtractors, FieldLocator fieldLocator) {</b>
<b class="fc">&nbsp;                    this.fieldNameExtractors = fieldNameExtractors;</b>
<b class="fc">&nbsp;                    this.fieldLocator = fieldLocator;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDescription resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = FieldLocator.Resolution.Illegal.INSTANCE;</b>
<b class="fc">&nbsp;                    Iterator&lt;? extends FieldNameExtractor&gt; iterator = fieldNameExtractors.iterator();</b>
<b class="fc">&nbsp;                    while (iterator.hasNext() &amp;&amp; !resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        resolution = fieldLocator.locate(iterator.next().resolve(instrumentedMethod));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve field for &quot; + instrumentedMethod + &quot; using &quot; + fieldLocator);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return resolution.getField();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field name extractor is responsible for determining a field name to a method that is implemented
&nbsp;     * to access this method.
&nbsp;     */
&nbsp;    public interface FieldNameExtractor {
&nbsp;
&nbsp;        /**
&nbsp;         * Extracts a field name to be accessed by a getter or setter method.
&nbsp;         *
&nbsp;         * @param methodDescription The method for which a field name is to be determined.
&nbsp;         * @return The name of the field to be accessed by this method.
&nbsp;         */
&nbsp;        String resolve(MethodDescription methodDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link net.bytebuddy.implementation.FieldAccessor.FieldNameExtractor} that determines a field name
&nbsp;         * according to the rules of Java bean naming conventions.
&nbsp;         */
<b class="fc">&nbsp;        enum ForBeanProperty implements FieldNameExtractor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A resolver that resolves a standard bean property name.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE {</b>
&nbsp;                @Override
&nbsp;                protected char resolve(char character) {
<b class="fc">&nbsp;                    return Character.toLowerCase(character);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A resolver that resolves a field name with a capital letter.
&nbsp;             */
<b class="fc">&nbsp;            CAPITALIZED {</b>
&nbsp;                @Override
&nbsp;                protected char resolve(char character) {
<b class="fc">&nbsp;                    return Character.toUpperCase(character);</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                String name = methodDescription.getInternalName();</b>
&nbsp;                int crop;
<b class="fc">&nbsp;                if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {</b>
<b class="fc">&nbsp;                    crop = 3;</b>
<b class="fc">&nbsp;                } else if (name.startsWith(&quot;is&quot;)) {</b>
<b class="fc">&nbsp;                    crop = 2;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(methodDescription + &quot; does not follow Java bean naming conventions&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                name = name.substring(crop);</b>
<b class="fc">&nbsp;                if (name.length() == 0) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(methodDescription + &quot; does not specify a bean name&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return resolve(name.charAt(0)) + name.substring(1);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the first character of the bean property.
&nbsp;             *
&nbsp;             * @param character The first character.
&nbsp;             * @return The resolved first character.
&nbsp;             */
&nbsp;            protected abstract char resolve(char character);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A field name extractor that returns a fixed value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForFixedValue implements FieldNameExtractor {
&nbsp;
&nbsp;            /**
&nbsp;             * The name to return.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new field name extractor for a fixed value.
&nbsp;             *
&nbsp;             * @param name The name to return.
&nbsp;             */
<b class="fc">&nbsp;            protected ForFixedValue(String name) {</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String resolve(MethodDescription methodDescription) {
<b class="fc">&nbsp;                return name;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that allows to define the access to be a field write of a given argument.
&nbsp;     */
&nbsp;    public interface PropertyConfigurable extends Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of the specified parameter for the field being described.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param index The index of the parameter for which to set the field&#39;s value.
&nbsp;         * @return An instrumentation that sets the parameter&#39;s value to the described field.
&nbsp;         */
&nbsp;        Composable setsArgumentAt(int index);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of the described field&#39;s default value, i.e. {@code null} or a primitive type&#39;s
&nbsp;         * representation of {@code 0}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return An instrumentation that sets the field&#39;s default value.
&nbsp;         */
&nbsp;        Composable setsDefaultValue();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a given value for the described field. If the value is a constant value, it will be
&nbsp;         * defined as a constant assignment, otherwise it is defined as a reference value that is stored in a static
&nbsp;         * field of the instrumented type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param value The value to set.
&nbsp;         * @return An instrumentation that sets the field&#39;s value as specified.
&nbsp;         */
&nbsp;        Composable setsValue(Object value);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a given class constant value for the described field.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typeDescription The type to set to the described field.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the given class constant.
&nbsp;         */
&nbsp;        Composable setsValue(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a given constant value for the described field.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param constant The constant to set as a value.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the given constant.
&nbsp;         */
&nbsp;        Composable setsValue(ConstantValue constant);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a given constant value for the described field.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param constant The constant to set as a value.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the given constant.
&nbsp;         */
&nbsp;        Composable setsValue(JavaConstant constant);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a value that is represented by a stack manipulation.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param stackManipulation A stack manipulation to load the field&#39;s value.
&nbsp;         * @param type              The field value&#39;s type.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the given value.
&nbsp;         */
&nbsp;        Composable setsValue(StackManipulation stackManipulation, Type type);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a value that is represented by a stack manipulation.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param stackManipulation A stack manipulation to load the field&#39;s value.
&nbsp;         * @param typeDescription   The field value&#39;s type.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the given value.
&nbsp;         */
&nbsp;        Composable setsValue(StackManipulation stackManipulation, TypeDescription.Generic typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a given value for the described field. The value is kept as a referenced that is stored
&nbsp;         * in a static field of the instrumented type. The field name is chosen based on the value&#39;s hash code.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param value The value to set.
&nbsp;         * @return An instrumentation that sets the field&#39;s value as specified.
&nbsp;         */
&nbsp;        Composable setsReference(Object value);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a given value for the described field. The value is kept as a referenced that is stored
&nbsp;         * in a static field of the instrumented type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param value The value to set.
&nbsp;         * @param name  The name of the field.
&nbsp;         * @return An instrumentation that sets the field&#39;s value as specified.
&nbsp;         */
&nbsp;        Composable setsReference(Object value, String name);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a value that sets another field&#39;s value.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param field The field that holds the value to be set.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the specified field&#39;s value.
&nbsp;         */
&nbsp;        Composable setsFieldValueOf(Field field);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a value that sets another field&#39;s value.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param fieldDescription The field that holds the value to be set.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the specified field&#39;s value.
&nbsp;         */
&nbsp;        Composable setsFieldValueOf(FieldDescription fieldDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a value that sets another field&#39;s value.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param fieldName The name of the field that is specified by the instrumented type.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the specified field&#39;s value.
&nbsp;         */
&nbsp;        Composable setsFieldValueOf(String fieldName);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Defines a setter of a value that sets another field&#39;s value.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If the instrumented method does not return {@code void}, a chained instrumentation must be supplied.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param fieldNameExtractor A field name extractor for the field that is specified by the instrumented type.
&nbsp;         * @return An instrumentation that sets the field&#39;s value to the specified field&#39;s value.
&nbsp;         */
&nbsp;        Composable setsFieldValueOf(FieldNameExtractor fieldNameExtractor);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that can be configured to use a given assigner and runtime type use configuration.
&nbsp;     */
&nbsp;    public interface AssignerConfigurable extends PropertyConfigurable {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a field accessor that is identical to this field accessor but uses the given assigner
&nbsp;         * and runtime type use configuration.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return This field accessor with the given assigner and runtime type use configuration.
&nbsp;         */
&nbsp;        PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor that can be configured to locate a field in a specific manner.
&nbsp;     */
&nbsp;    public interface OwnerTypeLocatable extends AssignerConfigurable {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines that a field should only be considered when it was defined in a given type.
&nbsp;         *
&nbsp;         * @param type The type to be considered.
&nbsp;         * @return This field accessor which will only considered fields that are defined in the given type.
&nbsp;         */
&nbsp;        AssignerConfigurable in(Class&lt;?&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * Determines that a field should only be considered when it was defined in a given type.
&nbsp;         *
&nbsp;         * @param typeDescription A description of the type to be considered.
&nbsp;         * @return This field accessor which will only considered fields that are defined in the given type.
&nbsp;         */
&nbsp;        AssignerConfigurable in(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * Determines that a field should only be considered when it was identified by a field locator that is
&nbsp;         * produced by the given factory.
&nbsp;         *
&nbsp;         * @param fieldLocatorFactory A factory that will produce a field locator that will be used to find locate
&nbsp;         *                            a field to be accessed.
&nbsp;         * @return This field accessor which will only considered fields that are defined in the given type.
&nbsp;         */
&nbsp;        AssignerConfigurable in(FieldLocator.Factory fieldLocatorFactory);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor for an implicit property where a getter or setter property is inferred from the signature.
&nbsp;     */
&nbsp;    protected static class ForImplicitProperty extends FieldAccessor implements OwnerTypeLocatable {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a field accessor for an implicit property.
&nbsp;         *
&nbsp;         * @param fieldLocation The field&#39;s location.
&nbsp;         */
&nbsp;        protected ForImplicitProperty(FieldLocation fieldLocation) {
<b class="fc">&nbsp;            this(fieldLocation, Assigner.DEFAULT, Assigner.Typing.STATIC);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a field accessor for an implicit property.
&nbsp;         *
&nbsp;         * @param fieldLocation The field&#39;s location.
&nbsp;         * @param assigner      The assigner to use.
&nbsp;         * @param typing        The typing to use.
&nbsp;         */
&nbsp;        private ForImplicitProperty(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;            super(fieldLocation, assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(fieldLocation.prepare(implementationTarget.getInstrumentedType()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsArgumentAt(int index) {
<b class="fc">&nbsp;            if (index &lt; 0) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;A parameter index cannot be negative: &quot; + index);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new ForSetter.OfParameterValue(fieldLocation,</b>
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    ForSetter.TerminationHandler.RETURNING,
&nbsp;                    index);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsDefaultValue() {
<b class="fc">&nbsp;            return new ForSetter.OfDefaultValue(fieldLocation, assigner, typing, ForSetter.TerminationHandler.RETURNING);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsValue(@MaybeNull Object value) {
<b class="fc">&nbsp;            if (value == null) {</b>
<b class="nc">&nbsp;                return setsDefaultValue();</b>
&nbsp;            }
<b class="fc">&nbsp;            ConstantValue constant = ConstantValue.Simple.wrapOrNull(value);</b>
<b class="fc">&nbsp;            return constant == null</b>
<b class="nc">&nbsp;                    ? setsReference(value)</b>
<b class="fc">&nbsp;                    : setsValue(constant.toStackManipulation(), constant.getTypeDescription().asGenericType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsValue(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return setsValue(ClassConstant.of(typeDescription), Class.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsValue(ConstantValue constant) {
<b class="fc">&nbsp;            return setsValue(constant.toStackManipulation(), constant.getTypeDescription().asGenericType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsValue(JavaConstant constant) {
<b class="fc">&nbsp;            return setsValue((ConstantValue) constant);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsValue(StackManipulation stackManipulation, Type type) {
<b class="fc">&nbsp;            return setsValue(stackManipulation, TypeDescription.Generic.Sort.describe(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsValue(StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {
<b class="fc">&nbsp;            return new ForSetter.OfConstantValue(fieldLocation,</b>
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    ForSetter.TerminationHandler.RETURNING,
&nbsp;                    typeDescription,
&nbsp;                    stackManipulation);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsReference(Object value) {
<b class="fc">&nbsp;            return setsReference(value, ForSetter.OfReferenceValue.PREFIX + &quot;$&quot; + RandomString.hashOf(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsReference(Object value, String name) {
<b class="fc">&nbsp;            return new ForSetter.OfReferenceValue(fieldLocation,</b>
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    ForSetter.TerminationHandler.RETURNING,
&nbsp;                    value,
&nbsp;                    name);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsFieldValueOf(Field field) {
<b class="fc">&nbsp;            return setsFieldValueOf(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsFieldValueOf(FieldDescription fieldDescription) {
<b class="fc">&nbsp;            return new ForSetter.OfFieldValue(fieldLocation,</b>
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    ForSetter.TerminationHandler.RETURNING,
&nbsp;                    new FieldLocation.Absolute(fieldDescription));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsFieldValueOf(String fieldName) {
<b class="fc">&nbsp;            return setsFieldValueOf(new FieldNameExtractor.ForFixedValue(fieldName));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Composable setsFieldValueOf(FieldNameExtractor fieldNameExtractor) {
<b class="fc">&nbsp;            return new ForSetter.OfFieldValue(fieldLocation,</b>
&nbsp;                    assigner,
&nbsp;                    typing,
&nbsp;                    ForSetter.TerminationHandler.RETURNING,
<b class="fc">&nbsp;                    new FieldLocation.Relative(Collections.singletonList(fieldNameExtractor)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public PropertyConfigurable withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new ForImplicitProperty(fieldLocation, assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AssignerConfigurable in(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return in(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AssignerConfigurable in(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return in(new FieldLocator.ForExactType.Factory(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AssignerConfigurable in(FieldLocator.Factory fieldLocatorFactory) {
<b class="nc">&nbsp;            return new ForImplicitProperty(fieldLocation.with(fieldLocatorFactory), assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An byte code appender for an field accessor implementation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The field&#39;s location.
&nbsp;             */
&nbsp;            private final FieldLocation.Prepared fieldLocation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for a field accessor implementation.
&nbsp;             *
&nbsp;             * @param fieldLocation The field&#39;s location.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(FieldLocation.Prepared fieldLocation) {</b>
<b class="fc">&nbsp;                this.fieldLocation = fieldLocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (!instrumentedMethod.isMethod()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(instrumentedMethod + &quot; does not describe a field getter or setter&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                FieldDescription fieldDescription = fieldLocation.resolve(instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set instance field &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                StackManipulation implementation, initialization = fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                        ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                        : MethodVariableAccess.loadThis();</b>
<b class="fc">&nbsp;                if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                    implementation = new StackManipulation.Compound(</b>
&nbsp;                            initialization,
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).read(),</b>
<b class="fc">&nbsp;                            assigner.assign(fieldDescription.getType(), instrumentedMethod.getReturnType(), typing),</b>
<b class="fc">&nbsp;                            MethodReturn.of(instrumentedMethod.getReturnType())</b>
&nbsp;                    );
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(void.class) &amp;&amp; instrumentedMethod.getParameters().size() == 1) {</b>
<b class="fc">&nbsp;                    if (fieldDescription.isFinal() &amp;&amp; instrumentedMethod.isMethod()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot set final field &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    implementation = new StackManipulation.Compound(</b>
&nbsp;                            initialization,
<b class="fc">&nbsp;                            MethodVariableAccess.load(instrumentedMethod.getParameters().get(0)),</b>
<b class="fc">&nbsp;                            assigner.assign(instrumentedMethod.getParameters().get(0).getType(), fieldDescription.getType(), typing),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).write(),</b>
&nbsp;                            MethodReturn.VOID
&nbsp;                    );
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Method &quot; + instrumentedMethod + &quot; is no bean accessor&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!implementation.isValid()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set or get value of &quot; + instrumentedMethod + &quot; using &quot; + fieldDescription);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Size(implementation.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field accessor for a field setter.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the value that is initialized per instrumented type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    protected abstract static class ForSetter&lt;T&gt; extends FieldAccessor implements Implementation.Composable {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The termination handler to apply.
&nbsp;         */
&nbsp;        private final TerminationHandler terminationHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new field accessor for a setter instrumentation.
&nbsp;         *
&nbsp;         * @param fieldLocation      The field&#39;s location.
&nbsp;         * @param assigner           The assigner to use.
&nbsp;         * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @param terminationHandler The termination handler to apply.
&nbsp;         */
&nbsp;        protected ForSetter(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler) {
<b class="fc">&nbsp;            super(fieldLocation, assigner, typing);</b>
<b class="fc">&nbsp;            this.terminationHandler = terminationHandler;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType(),</b>
<b class="fc">&nbsp;                    initialize(implementationTarget.getInstrumentedType()),</b>
<b class="fc">&nbsp;                    fieldLocation.prepare(implementationTarget.getInstrumentedType()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Initializes a value to be used during method instrumentation.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return The initialized value.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected abstract T initialize(TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the stack manipulation to load the value being set.
&nbsp;         *
&nbsp;         * @param initialized        The method that was initialized for the instrumented type.
&nbsp;         * @param fieldDescription   The field to set the value for.
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return The stack manipulation to apply.
&nbsp;         */
&nbsp;        protected abstract StackManipulation resolve(@MaybeNull T initialized,
&nbsp;                                                     FieldDescription fieldDescription,
&nbsp;                                                     TypeDescription instrumentedType,
&nbsp;                                                     MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * A termination handler is responsible for handling a field accessor&#39;s return.
&nbsp;         */
<b class="fc">&nbsp;        protected enum TerminationHandler {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code void} or throws an exception if this is not the return type of the instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            RETURNING {</b>
&nbsp;                @Override
&nbsp;                protected StackManipulation resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot implement setter with return value for &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return MethodReturn.VOID;</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Does not return from the method at all.
&nbsp;             */
<b class="fc">&nbsp;            NON_OPERATIONAL {</b>
&nbsp;                @Override
&nbsp;                protected StackManipulation resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the return instruction.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return An appropriate stack manipulation.
&nbsp;             */
&nbsp;            protected abstract StackManipulation resolve(MethodDescription instrumentedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A setter instrumentation for a parameter value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class OfParameterValue extends ForSetter&lt;Void&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter&#39;s index.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new setter instrumentation for a parameter value.
&nbsp;             *
&nbsp;             * @param fieldLocation      The field&#39;s location.
&nbsp;             * @param assigner           The assigner to use.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param terminationHandler The termination handler to apply.
&nbsp;             * @param index              The parameter&#39;s index.
&nbsp;             */
&nbsp;            protected OfParameterValue(FieldLocation fieldLocation,
&nbsp;                                       Assigner assigner,
&nbsp;                                       Assigner.Typing typing,
&nbsp;                                       TerminationHandler terminationHandler,
&nbsp;                                       int index) {
<b class="fc">&nbsp;                super(fieldLocation, assigner, typing, terminationHandler);</b>
<b class="fc">&nbsp;                this.index = index;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @AlwaysNull
&nbsp;            protected Void initialize(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            protected StackManipulation resolve(@MaybeNull Void unused,
&nbsp;                                                FieldDescription fieldDescription,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (instrumentedMethod.getParameters().size() &lt;= index) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(instrumentedMethod + &quot; does not define a parameter with index &quot; + index);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.load(instrumentedMethod.getParameters().get(index)),</b>
<b class="fc">&nbsp;                            assigner.assign(instrumentedMethod.getParameters().get(index).getType(), fieldDescription.getType(), typing)</b>
&nbsp;                    );
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation andThen(Implementation implementation) {
<b class="fc">&nbsp;                return new Compound(new OfParameterValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        index), implementation);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Composable andThen(Composable implementation) {
<b class="fc">&nbsp;                return new Compound.Composable(new OfParameterValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        index), implementation);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A setter instrumentation that sets a {@code null} or a primitive type&#39;s default value.
&nbsp;         */
&nbsp;        protected static class OfDefaultValue extends ForSetter&lt;Void&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an intrumentation that sets a field&#39;s default value.
&nbsp;             *
&nbsp;             * @param fieldLocation      The field&#39;s location.
&nbsp;             * @param assigner           The assigner to use.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param terminationHandler The termination handler to apply.
&nbsp;             */
&nbsp;            protected OfDefaultValue(FieldLocation fieldLocation, Assigner assigner, Assigner.Typing typing, TerminationHandler terminationHandler) {
<b class="fc">&nbsp;                super(fieldLocation, assigner, typing, terminationHandler);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @AlwaysNull
&nbsp;            protected Void initialize(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            protected StackManipulation resolve(@MaybeNull Void initialized,
&nbsp;                                                FieldDescription fieldDescription,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return DefaultValue.of(fieldDescription.getType());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;                return new Compound(new OfDefaultValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL), implementation);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;                return new Compound.Composable(new OfDefaultValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL), implementation);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An instrumentation that sets a constant value to a field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class OfConstantValue extends ForSetter&lt;Void&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The value&#39;s type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * A stack manipulation to load the constant value.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a setter instrumentation for setting a constant value.
&nbsp;             *
&nbsp;             * @param fieldLocation      The field&#39;s location.
&nbsp;             * @param assigner           The assigner to use.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param terminationHandler The termination handler to apply.
&nbsp;             * @param typeDescription    The value&#39;s type.
&nbsp;             * @param stackManipulation  A stack manipulation to load the constant value.
&nbsp;             */
&nbsp;            protected OfConstantValue(FieldLocation fieldLocation,
&nbsp;                                      Assigner assigner,
&nbsp;                                      Assigner.Typing typing,
&nbsp;                                      TerminationHandler terminationHandler,
&nbsp;                                      TypeDescription.Generic typeDescription,
&nbsp;                                      StackManipulation stackManipulation) {
<b class="fc">&nbsp;                super(fieldLocation, assigner, typing, terminationHandler);</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @AlwaysNull
&nbsp;            protected Void initialize(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            protected StackManipulation resolve(@MaybeNull Void unused,
&nbsp;                                                FieldDescription fieldDescription,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return new StackManipulation.Compound(stackManipulation, assigner.assign(typeDescription, fieldDescription.getType(), typing));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;                return new Compound(new OfConstantValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        typeDescription,
&nbsp;                        stackManipulation), implementation);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;                return new Compound.Composable(new OfConstantValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        typeDescription,
&nbsp;                        stackManipulation), implementation);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An instrumentation that sets a field to a reference value that is stored in a static field of the instrumented type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class OfReferenceValue extends ForSetter&lt;FieldDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The prefix used for implicitly named cached fields.
&nbsp;             */
&nbsp;            protected static final String PREFIX = &quot;fixedFieldValue&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The value to store.
&nbsp;             */
&nbsp;            private final Object value;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the field to store the reference in.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a setter instrumentation for setting a value stored in a static field of the instrumented type.
&nbsp;             *
&nbsp;             * @param fieldLocation      The field&#39;s location.
&nbsp;             * @param assigner           The assigner to use.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param terminationHandler The termination handler to apply.
&nbsp;             * @param value              The value to store.
&nbsp;             * @param name               The name of the field to store the reference in.
&nbsp;             */
&nbsp;            protected OfReferenceValue(FieldLocation fieldLocation,
&nbsp;                                       Assigner assigner,
&nbsp;                                       Assigner.Typing typing,
&nbsp;                                       TerminationHandler terminationHandler,
&nbsp;                                       Object value,
&nbsp;                                       String name) {
<b class="fc">&nbsp;                super(fieldLocation, assigner, typing, terminationHandler);</b>
<b class="fc">&nbsp;                this.value = value;</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name,</b>
&nbsp;                        Opcodes.ACC_SYNTHETIC | Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                        TypeDescription.ForLoadedType.of(value.getClass()).asGenericType()), value);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            protected FieldDescription.InDefinedShape initialize(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType.getDeclaredFields().filter(named(name)).getOnly();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Expects its own initialized value as argument&quot;)
&nbsp;            protected StackManipulation resolve(@MaybeNull FieldDescription.InDefinedShape target,
&nbsp;                                                FieldDescription fieldDescription,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (fieldDescription.isFinal() &amp;&amp; instrumentedMethod.isMethod()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot set final field &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        FieldAccess.forField(target).read(),</b>
<b class="fc">&nbsp;                        assigner.assign(TypeDescription.ForLoadedType.of(value.getClass()).asGenericType(), fieldDescription.getType(), typing)</b>
&nbsp;                );
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;                return new Compound(new OfReferenceValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        value,
&nbsp;                        name), implementation);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;                return new Compound.Composable(new OfReferenceValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        value,
&nbsp;                        name), implementation);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A setter that reads a value of another field and sets this value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class OfFieldValue extends ForSetter&lt;FieldLocation.Prepared&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The target field locator.
&nbsp;             */
&nbsp;            private final FieldLocation target;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a setter that sets another field value.
&nbsp;             *
&nbsp;             * @param fieldLocation      The field&#39;s location.
&nbsp;             * @param assigner           The assigner to use.
&nbsp;             * @param typing             Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;             * @param terminationHandler The termination handler to apply.
&nbsp;             * @param target             The target field locator.
&nbsp;             */
&nbsp;            protected OfFieldValue(FieldLocation fieldLocation,
&nbsp;                                   Assigner assigner,
&nbsp;                                   Assigner.Typing typing,
&nbsp;                                   TerminationHandler terminationHandler,
&nbsp;                                   FieldLocation target) {
<b class="fc">&nbsp;                super(fieldLocation, assigner, typing, terminationHandler);</b>
<b class="fc">&nbsp;                this.target = target;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            protected FieldLocation.Prepared initialize(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return target.prepare(instrumentedType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE&quot;, justification = &quot;Expects its own initialized value as argument&quot;)
&nbsp;            protected StackManipulation resolve(@MaybeNull FieldLocation.Prepared target,
&nbsp;                                                FieldDescription fieldDescription,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                FieldDescription resolved = target.resolve(instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!resolved.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set instance field &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        resolved.isStatic()</b>
<b class="fc">&nbsp;                                ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                : MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                        FieldAccess.forField(resolved).read(),</b>
<b class="fc">&nbsp;                        assigner.assign(resolved.getType(), fieldDescription.getType(), typing)</b>
&nbsp;                );
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation andThen(Implementation implementation) {
<b class="nc">&nbsp;                return new Compound(new OfFieldValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        target), implementation);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Composable andThen(Composable implementation) {
<b class="nc">&nbsp;                return new Compound.Composable(new OfFieldValue(fieldLocation,</b>
&nbsp;                        assigner,
&nbsp;                        typing,
&nbsp;                        TerminationHandler.NON_OPERATIONAL,
&nbsp;                        target), implementation);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An appender to implement a field setter.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The initialized value which might be {@code null}.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;            private final T initialized;
&nbsp;
&nbsp;            /**
&nbsp;             * The set field&#39;s prepared location.
&nbsp;             */
&nbsp;            private final FieldLocation.Prepared fieldLocation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender for a field setter.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param initialized      The initialized value which might be {@code null}.
&nbsp;             * @param fieldLocation    The set field&#39;s prepared location.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(TypeDescription instrumentedType, @MaybeNull T initialized, FieldLocation.Prepared fieldLocation) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.initialized = initialized;</b>
<b class="fc">&nbsp;                this.fieldLocation = fieldLocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                FieldDescription fieldDescription = fieldLocation.resolve(instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set instance field &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
<b class="fc">&nbsp;                } else if (fieldDescription.isFinal() &amp;&amp; instrumentedMethod.isMethod()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set final field &quot; + fieldDescription + &quot; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                StackManipulation stackManipulation = resolve(initialized, fieldDescription, instrumentedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!stackManipulation.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Set value cannot be assigned to &quot; + fieldDescription);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Size(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        instrumentedMethod.isStatic()</b>
<b class="nc">&nbsp;                                ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                : MethodVariableAccess.loadThis(),</b>
&nbsp;                        stackManipulation,
<b class="fc">&nbsp;                        FieldAccess.forField(fieldDescription).write(),</b>
<b class="fc">&nbsp;                        terminationHandler.resolve(instrumentedMethod)</b>
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
