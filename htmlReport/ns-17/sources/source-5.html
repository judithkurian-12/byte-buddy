


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FixedValue</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: FixedValue (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FixedValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FixedValue$1</td>
  </tr>
  <tr>
    <td class="name">FixedValue$AssignerConfigurable</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForArgument</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForConstantValue</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForNullValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForOriginType</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForOriginType$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForThisValue</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForThisValue$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForValue</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FixedValue$ForValue$StaticFieldByteCodeAppender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88.7%
  </span>
  <span class="absValue">
    (47/53)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.6%
  </span>
  <span class="absValue">
    (88/94)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.ConstantValue;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * This implementation returns a fixed value for a method. Other than the {@link net.bytebuddy.implementation.StubMethod}
&nbsp; * implementation, this implementation allows to determine a specific value which must be assignable to the returning value
&nbsp; * of any instrumented method. Otherwise, an exception will be thrown.
&nbsp; *
&nbsp; * @see FieldAccessor
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public abstract class FixedValue implements Implementation {
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner that is used for assigning the fixed value to a method&#39;s return type.
&nbsp;     */
&nbsp;    protected final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
&nbsp;    protected final Assigner.Typing typing;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new fixed value implementation.
&nbsp;     *
&nbsp;     * @param assigner The assigner to use for assigning the fixed value to the return type of the instrumented value.
&nbsp;     * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;     */
<b class="fc">&nbsp;    protected FixedValue(Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.typing = typing;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Returns a fixed value from any intercepted method. The fixed value is stored in the constant pool if this is possible.
&nbsp;     * Specifically, an argument that is a {@link JavaConstant}, {@link TypeDescription}, primitive, {@link String} or
&nbsp;     * {@link Class} value is stored in the constant pool.  Since Java 7, {@code MethodHandle} as well as {@code MethodType}
&nbsp;     * references are also supported. Alternatively, the fixed value is stored in a static field.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When a value is stored in the class&#39;s constant pool, its identity is lost. If an object&#39;s identity is important, the
&nbsp;     * {@link FixedValue#reference(Object)} method should be used instead.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: When supplying a method handle or a method type, all types that are implied must be visible to the instrumented
&nbsp;     * type or an {@link IllegalAccessException} will be thrown at runtime.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param value The fixed value to return from the method.
&nbsp;     * @return An implementation for the given {@code value}.
&nbsp;     * @see #value(JavaConstant)
&nbsp;     * @see #value(TypeDescription)
&nbsp;     * @see #nullValue()
&nbsp;     */
&nbsp;    public static AssignerConfigurable value(Object value) {
<b class="fc">&nbsp;        ConstantValue constant = ConstantValue.Simple.wrapOrNull(value);</b>
<b class="fc">&nbsp;        return constant == null</b>
<b class="fc">&nbsp;                ? reference(value)</b>
<b class="fc">&nbsp;                : new ForConstantValue(constant.toStackManipulation(), constant.getTypeDescription());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Other than {@link net.bytebuddy.implementation.FixedValue#value(Object)}, this function
&nbsp;     * will create a fixed value implementation that will always defined a field in the instrumented class. As a result,
&nbsp;     * object identity will be preserved between the given {@code value} and the value that is returned by
&nbsp;     * instrumented methods. The field name can be explicitly determined. The field name is generated from the fixed value&#39;s
&nbsp;     * hash code.
&nbsp;     *
&nbsp;     * @param value The fixed value to be returned by methods that are instrumented by this implementation.
&nbsp;     * @return An implementation for the given {@code value}.
&nbsp;     */
&nbsp;    public static AssignerConfigurable reference(Object value) {
<b class="fc">&nbsp;        return reference(value, ForValue.PREFIX + &quot;$&quot; + RandomString.hashOf(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Other than {@link net.bytebuddy.implementation.FixedValue#value(Object)}, this function
&nbsp;     * will create a fixed value implementation that will always defined a field in the instrumented class. As a result,
&nbsp;     * object identity will be preserved between the given {@code value} and the value that is returned by
&nbsp;     * instrumented methods. The field name can be explicitly determined.
&nbsp;     *
&nbsp;     * @param value The fixed value to be returned by methods that are instrumented by this implementation.
&nbsp;     * @param name  The name of the field for storing the fixed value.
&nbsp;     * @return An implementation for the given {@code value}.
&nbsp;     */
&nbsp;    public static AssignerConfigurable reference(Object value, String name) {
<b class="fc">&nbsp;        return new ForValue(value, name);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the given type in form of a loaded type. The value is loaded from the written class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param type The type to return from the method.
&nbsp;     * @return An implementation for the given {@code value}.
&nbsp;     */
&nbsp;    public static AssignerConfigurable value(TypeDescription type) {
<b class="fc">&nbsp;        return new ForConstantValue(ClassConstant.of(type), TypeDescription.ForLoadedType.of(Class.class));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the loaded version of the given {@link JavaConstant}. The value is loaded from the written class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param constant The type to return from the method.
&nbsp;     * @return An implementation for the given {@code value}.
&nbsp;     */
&nbsp;    public static AssignerConfigurable value(ConstantValue constant) {
<b class="fc">&nbsp;        return new ForConstantValue(constant.toStackManipulation(), constant.getTypeDescription());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the loaded version of the given {@link JavaConstant}. The value is loaded from the written class&#39;s constant pool.
&nbsp;     *
&nbsp;     * @param constant The type to return from the method.
&nbsp;     * @return An implementation for the given {@code value}.
&nbsp;     */
&nbsp;    public static AssignerConfigurable value(JavaConstant constant) {
<b class="fc">&nbsp;        return value((ConstantValue) constant);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the argument at the specified index.
&nbsp;     *
&nbsp;     * @param index The index of the argument to return.
&nbsp;     * @return An implementation of a method that returns the argument at the specified index.
&nbsp;     */
&nbsp;    public static AssignerConfigurable argument(int index) {
<b class="fc">&nbsp;        if (index &lt; 0) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Argument index cannot be negative: &quot; + index);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new ForArgument(index);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code this} from an instrumented method.
&nbsp;     *
&nbsp;     * @return An implementation that returns {@code this} from a method.
&nbsp;     */
&nbsp;    public static AssignerConfigurable self() {
<b class="fc">&nbsp;        return new ForThisValue();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a {@code null} value from an instrumented method.
&nbsp;     *
&nbsp;     * @return An implementation that returns {@code null} from a method.
&nbsp;     */
&nbsp;    public static Implementation nullValue() {
<b class="fc">&nbsp;        return ForNullValue.INSTANCE;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the origin type from an instrumented method.
&nbsp;     *
&nbsp;     * @return An implementation that returns the origin type of the current instrumented type.
&nbsp;     */
&nbsp;    public static AssignerConfigurable originType() {
<b class="fc">&nbsp;        return new ForOriginType();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Blueprint method that for applying the actual implementation.
&nbsp;     *
&nbsp;     * @param methodVisitor         The method visitor to which the implementation is applied to.
&nbsp;     * @param implementationContext The implementation context for the given implementation.
&nbsp;     * @param instrumentedMethod    The instrumented method that is target of the implementation.
&nbsp;     * @param typeDescription       A description of the type of the fixed value that is loaded by the
&nbsp;     *                              {@code valueLoadingInstruction}.
&nbsp;     * @param stackManipulation     A stack manipulation that represents the loading of the fixed value onto the
&nbsp;     *                              operand stack.
&nbsp;     * @return A representation of the stack and variable array sized that are required for this implementation.
&nbsp;     */
&nbsp;    protected ByteCodeAppender.Size apply(MethodVisitor methodVisitor,
&nbsp;                                          Context implementationContext,
&nbsp;                                          MethodDescription instrumentedMethod,
&nbsp;                                          TypeDescription.Generic typeDescription,
&nbsp;                                          StackManipulation stackManipulation) {
<b class="fc">&nbsp;        StackManipulation assignment = assigner.assign(typeDescription, instrumentedMethod.getReturnType(), typing);</b>
<b class="fc">&nbsp;        if (!assignment.isValid()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Cannot return value of type &quot; + typeDescription + &quot; for &quot; + instrumentedMethod);</b>
&nbsp;        }
<b class="fc">&nbsp;        StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
&nbsp;                stackManipulation,
&nbsp;                assignment,
<b class="fc">&nbsp;                MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="fc">&nbsp;        ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;        return new ByteCodeAppender.Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a fixed value implementation that is using a default assigner for attempting to assign
&nbsp;     * the fixed value to the return type of the instrumented method.
&nbsp;     */
&nbsp;    public interface AssignerConfigurable extends Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * Defines an explicit assigner to this fixed value implementation.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use for assigning the fixed value to the return type of the
&nbsp;         *                 instrumented value.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @return A fixed value implementation that makes use of the given assigner.
&nbsp;         */
&nbsp;        Implementation withAssigner(Assigner assigner, Assigner.Typing typing);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fixed value of {@code null}.
&nbsp;     */
<b class="fc">&nbsp;    protected enum ForNullValue implements Implementation, ByteCodeAppender {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            if (instrumentedMethod.getReturnType().isPrimitive()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot return null from &quot; + instrumentedMethod);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new ByteCodeAppender.Simple(</b>
&nbsp;                    NullConstant.INSTANCE,
&nbsp;                    MethodReturn.REFERENCE
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fixed value that appends the origin type of the instrumented type.
&nbsp;     */
&nbsp;    protected static class ForOriginType extends FixedValue implements AssignerConfigurable {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new fixed value appender for the origin type.
&nbsp;         */
&nbsp;        protected ForOriginType() {
<b class="fc">&nbsp;            this(Assigner.DEFAULT, Assigner.Typing.STATIC);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new fixed value appender for the origin type.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use for assigning the fixed value to the return type of the instrumented value.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        private ForOriginType(Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;            super(assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new ForOriginType(assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getOriginType().asErasure());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An appender for writing the origin type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription originType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender.
&nbsp;             *
&nbsp;             * @param originType The instrumented type.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(TypeDescription originType) {</b>
<b class="fc">&nbsp;                this.originType = originType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return ForOriginType.this.apply(methodVisitor,</b>
&nbsp;                        implementationContext,
&nbsp;                        instrumentedMethod,
<b class="fc">&nbsp;                        TypeDescription.ForLoadedType.of(Class.class).asGenericType(),</b>
<b class="fc">&nbsp;                        ClassConstant.of(originType));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fixed value of {@code this}.
&nbsp;     */
&nbsp;    protected static class ForThisValue extends FixedValue implements AssignerConfigurable {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an implementation that returns the instance of the instrumented type.
&nbsp;         */
&nbsp;        protected ForThisValue() {
<b class="fc">&nbsp;            super(Assigner.DEFAULT, Assigner.Typing.STATIC);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an implementation that returns the instance of the instrumented type.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use for assigning the fixed value to the return type of the instrumented value.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        private ForThisValue(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            super(assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new ForThisValue(assigner, typing);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A byte code appender for returning {@code this}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for returning {@code this}.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (instrumentedMethod.isStatic() || !instrumentedType.isAssignableTo(instrumentedMethod.getReturnType().asErasure())) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot return &#39;this&#39; from &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new ByteCodeAppender.Simple(</b>
<b class="fc">&nbsp;                        MethodVariableAccess.loadThis(),</b>
&nbsp;                        MethodReturn.REFERENCE
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fixed value implementation that returns a method&#39;s argument.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ForArgument extends FixedValue implements AssignerConfigurable, ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The argument index.
&nbsp;         */
&nbsp;        private final int index;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new fixed value implementation that returns a method&#39;s argument.
&nbsp;         *
&nbsp;         * @param index The argument&#39;s index.
&nbsp;         */
&nbsp;        protected ForArgument(int index) {
<b class="fc">&nbsp;            this(Assigner.DEFAULT, Assigner.Typing.STATIC, index);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new fixed value implementation that returns a method&#39;s argument.
&nbsp;         *
&nbsp;         * @param assigner The assigner to use for assigning the fixed value to the return type of the
&nbsp;         *                 instrumented value.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         * @param index    The argument&#39;s index.
&nbsp;         */
&nbsp;        private ForArgument(Assigner assigner, Assigner.Typing typing, int index) {
<b class="fc">&nbsp;            super(assigner, typing);</b>
<b class="fc">&nbsp;            this.index = index;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            if (instrumentedMethod.getParameters().size() &lt;= index) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(instrumentedMethod + &quot; does not define a parameter with index &quot; + index);</b>
&nbsp;            }
<b class="fc">&nbsp;            ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);</b>
<b class="fc">&nbsp;            StackManipulation stackManipulation = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                    MethodVariableAccess.load(parameterDescription),</b>
<b class="fc">&nbsp;                    assigner.assign(parameterDescription.getType(), instrumentedMethod.getReturnType(), typing),</b>
<b class="fc">&nbsp;                    MethodReturn.of(instrumentedMethod.getReturnType())</b>
&nbsp;            );
<b class="fc">&nbsp;            if (!stackManipulation.isValid()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedMethod.getReturnType() + &quot; to &quot; + parameterDescription);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Size(stackManipulation.apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new ForArgument(assigner, typing, index);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fixed value implementation that represents its fixed value as a constant pool value or a byte code instruction.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ForConstantValue extends FixedValue implements AssignerConfigurable, ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The stack manipulation which is responsible for loading the fixed value onto the operand stack.
&nbsp;         */
&nbsp;        private final StackManipulation valueLoadInstruction;
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the fixed value.
&nbsp;         */
&nbsp;        private final TypeDescription loadedType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant pool fixed value implementation.
&nbsp;         *
&nbsp;         * @param valueLoadInstruction The instruction that is responsible for loading the constant pool value onto the
&nbsp;         *                             operand stack.
&nbsp;         * @param loadedType           A type description representing the loaded type.
&nbsp;         */
&nbsp;        protected ForConstantValue(StackManipulation valueLoadInstruction, Class&lt;?&gt; loadedType) {
<b class="nc">&nbsp;            this(valueLoadInstruction, TypeDescription.ForLoadedType.of(loadedType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant pool fixed value implementation.
&nbsp;         *
&nbsp;         * @param valueLoadInstruction The instruction that is responsible for loading the constant pool value onto the
&nbsp;         *                             operand stack.
&nbsp;         * @param loadedType           A type description representing the loaded type.
&nbsp;         */
&nbsp;        protected ForConstantValue(StackManipulation valueLoadInstruction, TypeDescription loadedType) {
<b class="fc">&nbsp;            this(Assigner.DEFAULT, Assigner.Typing.STATIC, valueLoadInstruction, loadedType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant pool fixed value implementation.
&nbsp;         *
&nbsp;         * @param valueLoadInstruction The instruction that is responsible for loading the constant pool value onto the
&nbsp;         *                             operand stack.
&nbsp;         * @param loadedType           A type description representing the loaded type.
&nbsp;         * @param assigner             The assigner to use for assigning the fixed value to the return type of the
&nbsp;         *                             instrumented value.
&nbsp;         * @param typing               Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        private ForConstantValue(Assigner assigner, Assigner.Typing typing, StackManipulation valueLoadInstruction, TypeDescription loadedType) {
<b class="fc">&nbsp;            super(assigner, typing);</b>
<b class="fc">&nbsp;            this.valueLoadInstruction = valueLoadInstruction;</b>
<b class="fc">&nbsp;            this.loadedType = loadedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;            return new ForConstantValue(assigner, typing, valueLoadInstruction, loadedType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            return apply(methodVisitor, implementationContext, instrumentedMethod, loadedType.asGenericType(), valueLoadInstruction);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fixed value implementation that represents its fixed value as a static field of the instrumented class.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    protected static class ForValue extends FixedValue implements AssignerConfigurable {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The prefix of the static field that is created for storing the fixed value.
&nbsp;         */
&nbsp;        private static final String PREFIX = &quot;value&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the field in which the fixed value is stored.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The value that is to be stored in the static field.
&nbsp;         */
&nbsp;        private final Object value;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new static field fixed value implementation.
&nbsp;         *
&nbsp;         * @param value The fixed value to be returned.
&nbsp;         * @param name  The name of the field for storing the fixed value.
&nbsp;         */
&nbsp;        protected ForValue(Object value, String name) {
<b class="fc">&nbsp;            this(Assigner.DEFAULT, Assigner.Typing.STATIC, value, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new static field fixed value implementation.
&nbsp;         *
&nbsp;         * @param value    The fixed value to be returned.
&nbsp;         * @param name     The name of the field for storing the fixed value.
&nbsp;         * @param assigner The assigner to use for assigning the fixed value to the return type of the
&nbsp;         *                 instrumented value.
&nbsp;         * @param typing   Indicates if dynamic type castings should be attempted for incompatible assignments.
&nbsp;         */
&nbsp;        private ForValue(Assigner assigner, Assigner.Typing typing, Object value, String name) {
<b class="fc">&nbsp;            super(assigner, typing);</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Implementation withAssigner(Assigner assigner, Assigner.Typing typing) {
<b class="nc">&nbsp;            return new ForValue(assigner, typing, value, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType.withAuxiliaryField(new FieldDescription.Token(name,</b>
&nbsp;                    Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC | Opcodes.ACC_VOLATILE | Opcodes.ACC_SYNTHETIC,
<b class="fc">&nbsp;                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass())), value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new StaticFieldByteCodeAppender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A byte code appender for returning the fixed value that was stored in a static field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        private class StaticFieldByteCodeAppender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation that loads the fixed value onto the operand stack.
&nbsp;             */
&nbsp;            private final StackManipulation fieldGetAccess;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for returning a value of a static field from an instrumented method.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type that is subject of the instrumentation.
&nbsp;             */
<b class="fc">&nbsp;            private StaticFieldByteCodeAppender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                fieldGetAccess = FieldAccess.forField(instrumentedType.getDeclaredFields().filter((named(name))).getOnly()).read();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return ForValue.this.apply(methodVisitor,</b>
&nbsp;                        implementationContext,
&nbsp;                        instrumentedMethod,
<b class="fc">&nbsp;                        TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(value.getClass()),</b>
&nbsp;                        fieldGetAccess);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
