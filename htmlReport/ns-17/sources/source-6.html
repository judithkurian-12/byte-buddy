


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > HashCodeMethod</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: HashCodeMethod (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HashCodeMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (29/29)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HashCodeMethod$1</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (28/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$NullValueGuard</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$NullValueGuard$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$NullValueGuard$UsingJump</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$NullValueGuard$UsingJump$AfterInstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$NullValueGuard$UsingJump$BeforeInstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$OffsetProvider</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$OffsetProvider$ForDynamicTypeHash</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$OffsetProvider$ForFixedValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$OffsetProvider$ForStaticTypeHash</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$OffsetProvider$ForSuperMethodCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.9%
  </span>
  <span class="absValue">
    (47/48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$10</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$11</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$12</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$13</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeMethod$ValueTransformer$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    98.6%
  </span>
  <span class="absValue">
    (69/70)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    99%
  </span>
  <span class="absValue">
    (192/194)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.implementation.bytecode.*;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import org.objectweb.asm.Label;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * An implementation of {@link Object#hashCode()} that takes a class&#39;s declared fields into consideration. A hash code is computed by transforming
&nbsp; * primitive field types to an {@code int} value and by summing those values up starting from a given offset after multiplying any previous value
&nbsp; * with a multiplier. Reference values are checked against {@code null} values unless specified otherwise.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public class HashCodeMethod implements Implementation {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The default offset which should be a prime number.
&nbsp;     */
&nbsp;    private static final int DEFAULT_OFFSET = 17;
&nbsp;
&nbsp;    /**
&nbsp;     * The default multiplier for each value before adding a field&#39;s hash code value which should be a prime number.
&nbsp;     */
&nbsp;    private static final int DEFAULT_MULTIPLIER = 31;
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link Object#hashCode()} method.
&nbsp;     */
<b class="fc">&nbsp;    private static final MethodDescription.InDefinedShape HASH_CODE = TypeDescription.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;            .getDeclaredMethods()</b>
<b class="fc">&nbsp;            .filter(isHashCode())</b>
<b class="fc">&nbsp;            .getOnly();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The {@link Object#getClass()} method.
&nbsp;     */
<b class="fc">&nbsp;    private static final MethodDescription.InDefinedShape GET_CLASS = TypeDescription.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;            .getDeclaredMethods()</b>
<b class="fc">&nbsp;            .filter(named(&quot;getClass&quot;).and(takesArguments(0)))</b>
<b class="fc">&nbsp;            .getOnly();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The hash code&#39;s offset provider.
&nbsp;     */
&nbsp;    private final OffsetProvider offsetProvider;
&nbsp;
&nbsp;    /**
&nbsp;     * A multiplier for each value before adding a field&#39;s hash code value.
&nbsp;     */
&nbsp;    private final int multiplier;
&nbsp;
&nbsp;    /**
&nbsp;     * A matcher to filter fields that should not be used for a hash codes computation.
&nbsp;     */
&nbsp;    private final ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; ignored;
&nbsp;
&nbsp;    /**
&nbsp;     * A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;     */
&nbsp;    private final ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; nonNullable;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new hash code method implementation.
&nbsp;     *
&nbsp;     * @param offsetProvider The hash code&#39;s offset provider.
&nbsp;     */
&nbsp;    protected HashCodeMethod(OffsetProvider offsetProvider) {
<b class="fc">&nbsp;        this(offsetProvider, DEFAULT_MULTIPLIER, none(), none());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new hash code method implementation.
&nbsp;     *
&nbsp;     * @param offsetProvider The hash code&#39;s offset provider.
&nbsp;     * @param multiplier     A multiplier for each value before adding a field&#39;s hash code value
&nbsp;     * @param ignored        A matcher to filter fields that should not be used for a hash codes computation.
&nbsp;     * @param nonNullable    A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;     */
&nbsp;    private HashCodeMethod(OffsetProvider offsetProvider,
&nbsp;                           int multiplier,
&nbsp;                           ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; ignored,
<b class="fc">&nbsp;                           ElementMatcher.Junction&lt;? super FieldDescription.InDefinedShape&gt; nonNullable) {</b>
<b class="fc">&nbsp;        this.offsetProvider = offsetProvider;</b>
<b class="fc">&nbsp;        this.multiplier = multiplier;</b>
<b class="fc">&nbsp;        this.ignored = ignored;</b>
<b class="fc">&nbsp;        this.nonNullable = nonNullable;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a hash code method implementation that bases the hash code on the instrumented type&#39;s super class&#39;s hash code value.
&nbsp;     *
&nbsp;     * @return A hash code method implementation that bases the hash code on the instrumented type&#39;s super class&#39;s hash code value.
&nbsp;     */
&nbsp;    public static HashCodeMethod usingSuperClassOffset() {
<b class="fc">&nbsp;        return new HashCodeMethod(OffsetProvider.ForSuperMethodCall.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a hash code method implementation that bases the hash code on the instrumented type&#39;s class constant&#39;s hash code..
&nbsp;     *
&nbsp;     * @param dynamic {@code true} if the type should be resolved from the instance and not be set as the declaring class.
&nbsp;     * @return A hash code method implementation that bases the hash code on the instrumented type&#39;s class constant&#39;s hash code.
&nbsp;     */
&nbsp;    public static HashCodeMethod usingTypeHashOffset(boolean dynamic) {
<b class="fc">&nbsp;        return new HashCodeMethod(dynamic ? OffsetProvider.ForDynamicTypeHash.INSTANCE : OffsetProvider.ForStaticTypeHash.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a hash code method implementation that bases the hash code on a fixed value.
&nbsp;     *
&nbsp;     * @return A hash code method implementation that bases the hash code on a fixed value.
&nbsp;     */
&nbsp;    public static HashCodeMethod usingDefaultOffset() {
<b class="fc">&nbsp;        return usingOffset(DEFAULT_OFFSET);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a hash code method implementation that bases the hash code on a fixed value.
&nbsp;     *
&nbsp;     * @param value The fixed value.
&nbsp;     * @return A hash code method implementation that bases the hash code on a fixed value.
&nbsp;     */
&nbsp;    public static HashCodeMethod usingOffset(int value) {
<b class="fc">&nbsp;        return new HashCodeMethod(new OffsetProvider.ForFixedValue(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this hash code method implementation that ignores the specified fields additionally to any
&nbsp;     * previously specified fields.
&nbsp;     *
&nbsp;     * @param ignored A matcher to specify any fields that should be ignored.
&nbsp;     * @return A new version of this hash code method implementation that also ignores any fields matched by the provided matcher.
&nbsp;     */
&nbsp;    public HashCodeMethod withIgnoredFields(ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; ignored) {
<b class="fc">&nbsp;        return new HashCodeMethod(offsetProvider, multiplier, this.ignored.&lt;FieldDescription.InDefinedShape&gt;or(ignored), nonNullable);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this hash code method implementation that does not apply a {@code null} value check for the specified fields
&nbsp;     * if they have a reference type additionally to any previously specified fields.
&nbsp;     *
&nbsp;     * @param nonNullable A matcher to specify any fields that should not be guarded against {@code null} values.
&nbsp;     * @return A new version of this hash code method implementation that also does not apply {@code null} value checks to any fields matched by
&nbsp;     * the provided matcher.
&nbsp;     */
&nbsp;    public HashCodeMethod withNonNullableFields(ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; nonNullable) {
<b class="fc">&nbsp;        return new HashCodeMethod(offsetProvider, multiplier, ignored, this.nonNullable.&lt;FieldDescription.InDefinedShape&gt;or(nonNullable));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a new version of this hash code method implementation that uses the given multiplier onto any given hash code before adding a
&nbsp;     * field&#39;s hash code.
&nbsp;     *
&nbsp;     * @param multiplier The multiplier to use for any hash code before adding any field&#39;s hash code.
&nbsp;     * @return A new version of this hash code method implementation that uses the given multiplier onto any given hash code before adding a
&nbsp;     * field&#39;s hash code.
&nbsp;     */
&nbsp;    public Implementation withMultiplier(int multiplier) {
<b class="fc">&nbsp;        if (multiplier == 0) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Hash code multiplier must not be zero&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new HashCodeMethod(offsetProvider, multiplier, ignored, nonNullable);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        return instrumentedType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        if (implementationTarget.getInstrumentedType().isInterface()) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot implement meaningful hash code method for &quot; + implementationTarget.getInstrumentedType());</b>
&nbsp;        }
<b class="fc">&nbsp;        return new Appender(offsetProvider.resolve(implementationTarget.getInstrumentedType()),</b>
&nbsp;                multiplier,
<b class="fc">&nbsp;                implementationTarget.getInstrumentedType().getDeclaredFields().filter(not(isStatic().or(ignored))),</b>
&nbsp;                nonNullable);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An offset provider is responsible for supplying the initial hash code.
&nbsp;     */
&nbsp;    protected interface OffsetProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this offset provider for a given instrumented type.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @return A stack manipulation that loads the initial hash code onto the operand stack.
&nbsp;         */
&nbsp;        StackManipulation resolve(TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * An offset provider that supplies a fixed value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForFixedValue implements OffsetProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The value to load onto the operand stack.
&nbsp;             */
&nbsp;            private final int value;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset provider for a fixed value.
&nbsp;             *
&nbsp;             * @param value The value to load onto the operand stack.
&nbsp;             */
<b class="fc">&nbsp;            protected ForFixedValue(int value) {</b>
<b class="fc">&nbsp;                this.value = value;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return IntegerConstant.forValue(value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset provider that invokes the super class&#39;s {@link Object#hashCode()} implementation.
&nbsp;         */
<b class="fc">&nbsp;        enum ForSuperMethodCall implements OffsetProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                TypeDefinition superClass = instrumentedType.getSuperClass();</b>
<b class="fc">&nbsp;                if (superClass == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; does not declare a super class&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(MethodVariableAccess.loadThis(), MethodInvocation.invoke(HASH_CODE).special(superClass.asErasure()));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset provider that uses the instrumented type&#39;s class constant&#39;s hash code.
&nbsp;         */
<b class="fc">&nbsp;        enum ForStaticTypeHash implements OffsetProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new StackManipulation.Compound(ClassConstant.of(instrumentedType), MethodInvocation.invoke(HASH_CODE).virtual(TypeDescription.ForLoadedType.of(Class.class)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset provider that uses the instance&#39;s class&#39;s hash code.
&nbsp;         */
<b class="fc">&nbsp;        enum ForDynamicTypeHash implements OffsetProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return new StackManipulation.Compound(MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(GET_CLASS).virtual(instrumentedType),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(HASH_CODE).virtual(TypeDescription.ForLoadedType.of(Class.class)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A guard against {@code null} values for fields with reference types.
&nbsp;     */
&nbsp;    protected interface NullValueGuard {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation to apply before computing a hash value.
&nbsp;         *
&nbsp;         * @return A stack manipulation to apply before computing a hash value.
&nbsp;         */
&nbsp;        StackManipulation before();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a stack manipulation to apply after computing a hash value.
&nbsp;         *
&nbsp;         * @return A stack manipulation to apply after computing a hash value.
&nbsp;         */
&nbsp;        StackManipulation after();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the required padding for the local variable array to apply this guard.
&nbsp;         *
&nbsp;         * @return The required padding for the local variable array to apply this guard.
&nbsp;         */
&nbsp;        int getRequiredVariablePadding();
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational null value guard.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements NullValueGuard {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation before() {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation after() {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getRequiredVariablePadding() {
<b class="fc">&nbsp;                return StackSize.ZERO.getSize();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A null value guard that expects a reference type and that uses a jump if a field value is {@code null}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        class UsingJump implements NullValueGuard {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * A label to indicate the target of a jump.
&nbsp;             */
&nbsp;            private final Label label;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new null value guard using a jump instruction for {@code null} values.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            protected UsingJump(MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                label = new Label();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation before() {
<b class="fc">&nbsp;                return new BeforeInstruction();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation after() {
<b class="fc">&nbsp;                return new AfterInstruction();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getRequiredVariablePadding() {
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to apply before the hash value computation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;            protected class BeforeInstruction extends StackManipulation.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, instrumentedMethod.getStackSize());</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, instrumentedMethod.getStackSize());</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFNULL, label);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, instrumentedMethod.getStackSize());</b>
<b class="fc">&nbsp;                    return Size.ZERO;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to apply after the hash value computation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;            protected class AfterInstruction extends StackManipulation.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    methodVisitor.visitLabel(label);</b>
<b class="fc">&nbsp;                    implementationContext.getFrameGeneration().same1(methodVisitor,</b>
<b class="fc">&nbsp;                            TypeDescription.ForLoadedType.of(int.class),</b>
<b class="fc">&nbsp;                            Arrays.asList(implementationContext.getInstrumentedType(), TypeDescription.ForLoadedType.of(Object.class)));</b>
<b class="fc">&nbsp;                    return Size.ZERO;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A value transformer that is responsible for resolving a field value to an {@code int} value.
&nbsp;     */
<b class="fc">&nbsp;    protected enum ValueTransformer implements StackManipulation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code long} value.
&nbsp;         */
<b class="fc">&nbsp;        LONG {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP2);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 32);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.LUSHR);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.LXOR);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.L2I);</b>
<b class="fc">&nbsp;                return new Size(-1, 3);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code float} value.
&nbsp;         */
<b class="fc">&nbsp;        FLOAT {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/Float&quot;, &quot;floatToIntBits&quot;, &quot;(F)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code double} value.
&nbsp;         */
<b class="fc">&nbsp;        DOUBLE {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/Double&quot;, &quot;doubleToLongBits&quot;, &quot;(D)J&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP2);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 32);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.LUSHR);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.LXOR);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.L2I);</b>
<b class="fc">&nbsp;                return new Size(-1, 3);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code boolean[]} value.
&nbsp;         */
<b class="fc">&nbsp;        BOOLEAN_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([Z)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code byte[]} value.
&nbsp;         */
<b class="fc">&nbsp;        BYTE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([B)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code short[]} value.
&nbsp;         */
<b class="fc">&nbsp;        SHORT_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([S)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code char[]} value.
&nbsp;         */
<b class="fc">&nbsp;        CHARACTER_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([C)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for an {@code int[]} value.
&nbsp;         */
<b class="fc">&nbsp;        INTEGER_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([I)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code long[]} value.
&nbsp;         */
<b class="fc">&nbsp;        LONG_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([J)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code float[]} value.
&nbsp;         */
<b class="fc">&nbsp;        FLOAT_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([F)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a {@code double[]} value.
&nbsp;         */
<b class="fc">&nbsp;        DOUBLE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([D)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a reference array value.
&nbsp;         */
<b class="fc">&nbsp;        REFERENCE_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;hashCode&quot;, &quot;([Ljava/lang/Object;)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a nested reference array value.
&nbsp;         */
<b class="fc">&nbsp;        NESTED_ARRAY {</b>
&nbsp;            /** {@inheritDoc} */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;deepHashCode&quot;, &quot;([Ljava/lang/Object;)I&quot;, false);</b>
<b class="fc">&nbsp;                return Size.ZERO;</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a type definition to a hash code.
&nbsp;         *
&nbsp;         * @param typeDefinition The type definition to resolve.
&nbsp;         * @return The stack manipulation to apply.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public static StackManipulation of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            if (typeDefinition.represents(boolean.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(byte.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(short.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(char.class)</b>
<b class="fc">&nbsp;                    || typeDefinition.represents(int.class)) {</b>
<b class="fc">&nbsp;                return Trivial.INSTANCE;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(long.class)) {</b>
<b class="fc">&nbsp;                return LONG;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(float.class)) {</b>
<b class="fc">&nbsp;                return FLOAT;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(double.class)) {</b>
<b class="fc">&nbsp;                return DOUBLE;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(boolean[].class)) {</b>
<b class="fc">&nbsp;                return BOOLEAN_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(byte[].class)) {</b>
<b class="fc">&nbsp;                return BYTE_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(short[].class)) {</b>
<b class="fc">&nbsp;                return SHORT_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(char[].class)) {</b>
<b class="fc">&nbsp;                return CHARACTER_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(int[].class)) {</b>
<b class="fc">&nbsp;                return INTEGER_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(long[].class)) {</b>
<b class="fc">&nbsp;                return LONG_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(float[].class)) {</b>
<b class="fc">&nbsp;                return FLOAT_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(double[].class)) {</b>
<b class="fc">&nbsp;                return DOUBLE_ARRAY;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.isArray()) {</b>
<b class="fc">&nbsp;                return typeDefinition.getComponentType().isArray()</b>
<b class="fc">&nbsp;                        ? NESTED_ARRAY</b>
<b class="fc">&nbsp;                        : REFERENCE_ARRAY;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return MethodInvocation.invoke(HASH_CODE).virtual(typeDefinition.asErasure());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isValid() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A byte code appender to implement a hash code method.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * Loads the initial hash code onto the operand stack.
&nbsp;         */
&nbsp;        private final StackManipulation initialValue;
&nbsp;
&nbsp;        /**
&nbsp;         * A multiplier for each value before adding a field&#39;s hash code value.
&nbsp;         */
&nbsp;        private final int multiplier;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of fields to include in the hash code computation.
&nbsp;         */
&nbsp;        private final List&lt;FieldDescription.InDefinedShape&gt; fieldDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;         */
&nbsp;        private final ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; nonNullable;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender for implementing a hash code method.
&nbsp;         *
&nbsp;         * @param initialValue      Loads the initial hash code onto the operand stack.
&nbsp;         * @param multiplier        A multiplier for each value before adding a field&#39;s hash code value.
&nbsp;         * @param fieldDescriptions A list of fields to include in the hash code computation.
&nbsp;         * @param nonNullable       A matcher to determine fields of a reference type that cannot be {@code null}.
&nbsp;         */
&nbsp;        protected Appender(StackManipulation initialValue,
&nbsp;                           int multiplier,
&nbsp;                           List&lt;FieldDescription.InDefinedShape&gt; fieldDescriptions,
<b class="fc">&nbsp;                           ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; nonNullable) {</b>
<b class="fc">&nbsp;            this.initialValue = initialValue;</b>
<b class="fc">&nbsp;            this.multiplier = multiplier;</b>
<b class="fc">&nbsp;            this.fieldDescriptions = fieldDescriptions;</b>
<b class="fc">&nbsp;            this.nonNullable = nonNullable;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            if (instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Hash code method must not be static: &quot; + instrumentedMethod);</b>
<b class="fc">&nbsp;            } else if (!instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Hash code method does not return primitive integer: &quot; + instrumentedMethod);</b>
&nbsp;            }
<b class="fc">&nbsp;            List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(2 + fieldDescriptions.size() * 8);</b>
<b class="fc">&nbsp;            stackManipulations.add(initialValue);</b>
<b class="fc">&nbsp;            int padding = 0;</b>
<b class="fc">&nbsp;            for (FieldDescription.InDefinedShape fieldDescription : fieldDescriptions) {</b>
<b class="fc">&nbsp;                stackManipulations.add(IntegerConstant.forValue(multiplier));</b>
<b class="fc">&nbsp;                stackManipulations.add(Multiplication.INTEGER);</b>
<b class="fc">&nbsp;                stackManipulations.add(MethodVariableAccess.loadThis());</b>
<b class="fc">&nbsp;                stackManipulations.add(FieldAccess.forField(fieldDescription).read());</b>
<b class="fc">&nbsp;                NullValueGuard nullValueGuard = fieldDescription.getType().isPrimitive() || fieldDescription.getType().isArray() || nonNullable.matches(fieldDescription)</b>
<b class="fc">&nbsp;                        ? NullValueGuard.NoOp.INSTANCE</b>
<b class="fc">&nbsp;                        : new NullValueGuard.UsingJump(instrumentedMethod);</b>
<b class="fc">&nbsp;                stackManipulations.add(nullValueGuard.before());</b>
<b class="fc">&nbsp;                stackManipulations.add(ValueTransformer.of(fieldDescription.getType()));</b>
<b class="fc">&nbsp;                stackManipulations.add(Addition.INTEGER);</b>
<b class="fc">&nbsp;                stackManipulations.add(nullValueGuard.after());</b>
<b class="fc">&nbsp;                padding = Math.max(padding, nullValueGuard.getRequiredVariablePadding());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            stackManipulations.add(MethodReturn.INTEGER);</b>
<b class="fc">&nbsp;            return new Size(new StackManipulation.Compound(stackManipulations).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize() + padding);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
