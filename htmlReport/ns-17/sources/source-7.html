


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Implementation</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation</a>
</div>

<h1>Coverage Summary for Class: Implementation (net.bytebuddy.implementation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Implementation$1</td>
  </tr>
  <tr>
    <td class="name">Implementation$Composable</td>
  </tr>
  <tr>
    <td class="name">Implementation$Composable$MockitoMock$1957223440</td>
  </tr>
  <tr>
    <td class="name">Implementation$Composable$MockitoMock$1957223440$auxiliary$HcMpJHWt</td>
  </tr>
  <tr>
    <td class="name">Implementation$Composable$MockitoMock$1957223440$auxiliary$J5AH4jxA</td>
  </tr>
  <tr>
    <td class="name">Implementation$Compound</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.4%
  </span>
  <span class="absValue">
    (19/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Compound$Composable</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.2%
  </span>
  <span class="absValue">
    (25/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (69/69)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AbstractPropertyAccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethod</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$AccessorMethodDelegation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$CacheValueField</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$DelegationRecord</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$Factory</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$Factory$WithFixedSuffix</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldCacheEntry</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (12/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldGetter</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldGetterDelegation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldSetter</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Default$FieldSetterDelegation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Disabled$Factory</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$ExtractableView$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$Factory</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.6%
  </span>
  <span class="absValue">
    (44/47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$FrameGeneration$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$MockitoMock$939309773</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$MockitoMock$939309773$auxiliary$CyLkBkB6</td>
  </tr>
  <tr>
    <td class="name">Implementation$Context$MockitoMock$939309773$auxiliary$LgOtSUw5</td>
  </tr>
  <tr>
    <td class="name">Implementation$MockitoMock$1192880215</td>
  </tr>
  <tr>
    <td class="name">Implementation$MockitoMock$1192880215$auxiliary$mlwKp18J</td>
  </tr>
  <tr>
    <td class="name">Implementation$MockitoMock$1192880215$auxiliary$zuJoynH5</td>
  </tr>
  <tr>
    <td class="name">Implementation$Simple</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Simple$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">Implementation$Simple$ForDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Simple$ForDispatcher$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$MockitoMock$1489799396</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$MockitoMock$1489799396$auxiliary$ew6Ihx1Y</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$MockitoMock$1489799396$auxiliary$vVSYbryC</td>
  </tr>
  <tr>
    <td class="name">Implementation$SpecialMethodInvocation$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$AbstractBase$DefaultMethodInvocation$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$Factory</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$Factory$MockitoMock$1762196933</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$Factory$MockitoMock$1762196933$auxiliary$5FeZlreK</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$Factory$MockitoMock$1762196933$auxiliary$AlFYpSFO</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$MockitoMock$872400137</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$MockitoMock$872400137$auxiliary$iEdLWzPM</td>
  </tr>
  <tr>
    <td class="name">Implementation$Target$MockitoMock$872400137$auxiliary$r07ZwkG6</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    91.3%
  </span>
  <span class="absValue">
    (157/172)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.3%
  </span>
  <span class="absValue">
    (386/423)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation;
&nbsp;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeInitializer;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.ClassVisitor;
&nbsp;import org.objectweb.asm.FieldVisitor;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * An implementation is responsible for implementing methods of a dynamically created type as byte code. An
&nbsp; * implementation is applied in two stages:
&nbsp; * &lt;ol&gt;
&nbsp; * &lt;li&gt;The implementation is able to prepare an instrumented type by adding fields and/or helper methods that are
&nbsp; * required for the methods implemented by this implementation. Furthermore,
&nbsp; * {@link LoadedTypeInitializer}s  and byte code for the type initializer can be registered for the instrumented
&nbsp; * type.&lt;/li&gt;
&nbsp; * &lt;li&gt;Any implementation is required to supply a byte code appender that is responsible for providing the byte code
&nbsp; * to the instrumented methods that were delegated to this implementation. This byte code appender is also
&nbsp; * be responsible for providing implementations for the methods added in step &lt;i&gt;1&lt;/i&gt;.&lt;/li&gt;
&nbsp; * &lt;/ol&gt;
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * An implementation should provide meaningful implementations of both {@link java.lang.Object#equals(Object)}
&nbsp; * and {@link Object#hashCode()} if it wants to avoid to be used twice within the creation of a dynamic type. For two
&nbsp; * equal implementations only one will be applied on the creation of a dynamic type.
&nbsp; */
&nbsp;public interface Implementation extends InstrumentedType.Prepareable {
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a byte code appender that determines the implementation of the instrumented type&#39;s methods.
&nbsp;     *
&nbsp;     * @param implementationTarget The target of the current implementation.
&nbsp;     * @return A byte code appender for implementing methods delegated to this implementation. This byte code appender
&nbsp;     * is also responsible for handling methods that were added by this implementation on the call to
&nbsp;     * {@link Implementation#prepare(InstrumentedType)}.
&nbsp;     */
&nbsp;    ByteCodeAppender appender(Target implementationTarget);
&nbsp;
&nbsp;    /**
&nbsp;     * Represents an implementation that can be chained together with another implementation.
&nbsp;     */
&nbsp;    interface Composable extends Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the supplied implementation to this implementation.
&nbsp;         *
&nbsp;         * @param implementation The subsequent implementation.
&nbsp;         * @return An implementation that combines this implementation with the provided one.
&nbsp;         */
&nbsp;        Implementation andThen(Implementation implementation);
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the supplied composable implementation to this implementation.
&nbsp;         *
&nbsp;         * @param implementation The subsequent composable implementation.
&nbsp;         * @return A composable implementation that combines this implementation with the provided one.
&nbsp;         */
&nbsp;        Composable andThen(Composable implementation);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a type-specific method invocation on the current instrumented type which is not legal from outside
&nbsp;     * the type such as a super method or default method invocation. Legal instances of special method invocations must
&nbsp;     * be equal to one another if they represent the same invocation target.
&nbsp;     */
&nbsp;    interface SpecialMethodInvocation extends StackManipulation {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the method that represents this special method invocation. This method can be different even for
&nbsp;         * equal special method invocations, dependent on the method that was used to request such an invocation by the
&nbsp;         * means of a {@link Implementation.Target}.
&nbsp;         *
&nbsp;         * @return The method description that describes this instances invocation target.
&nbsp;         */
&nbsp;        MethodDescription getMethodDescription();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the target type the represented method is invoked on.
&nbsp;         *
&nbsp;         * @return The type the represented method is invoked on.
&nbsp;         */
&nbsp;        TypeDescription getTypeDescription();
&nbsp;
&nbsp;        /**
&nbsp;         * Checks that this special method invocation is compatible with the supplied type representation.
&nbsp;         *
&nbsp;         * @param token The type token to check against.
&nbsp;         * @return This special method invocation or an illegal invocation if the method invocation is not applicable.
&nbsp;         */
&nbsp;        SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method handle representing this special method invocation.
&nbsp;         *
&nbsp;         * @return A method handle for this special method invocation.
&nbsp;         */
&nbsp;        JavaConstant.MethodHandle toMethodHandle();
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical implementation of an illegal {@link Implementation.SpecialMethodInvocation}.
&nbsp;         */
<b class="fc">&nbsp;        enum Illegal implements SpecialMethodInvocation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isValid() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot implement an undefined method&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription getMethodDescription() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getTypeDescription() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public JavaConstant.MethodHandle toMethodHandle() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;An illegal special method invocation must not be applied&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a valid special method invocation.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends StackManipulation.AbstractBase implements SpecialMethodInvocation {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return 31 * getMethodDescription().asSignatureToken().hashCode() + getTypeDescription().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof SpecialMethodInvocation)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = (SpecialMethodInvocation) other;</b>
<b class="fc">&nbsp;                return getMethodDescription().asSignatureToken().equals(specialMethodInvocation.getMethodDescription().asSignatureToken())</b>
<b class="fc">&nbsp;                        &amp;&amp; getTypeDescription().equals(specialMethodInvocation.getTypeDescription());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical implementation of a {@link SpecialMethodInvocation}.
&nbsp;         */
&nbsp;        class Simple extends SpecialMethodInvocation.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The method description that is represented by this legal special method invocation.
&nbsp;             */
&nbsp;            private final MethodDescription methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The type description that is represented by this legal special method invocation.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * A stack manipulation representing the method&#39;s invocation on the type description.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new legal special method invocation.
&nbsp;             *
&nbsp;             * @param methodDescription The method that represents the special method invocation.
&nbsp;             * @param typeDescription   The type on which the method should be invoked on by an {@code INVOKESPECIAL}
&nbsp;             *                          invocation.
&nbsp;             * @param stackManipulation The stack manipulation that represents this special method invocation.
&nbsp;             */
<b class="fc">&nbsp;            protected Simple(MethodDescription methodDescription, TypeDescription typeDescription, StackManipulation stackManipulation) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a special method invocation for a given invocation target.
&nbsp;             *
&nbsp;             * @param methodDescription The method that represents the special method invocation.
&nbsp;             * @param typeDescription   The type on which the method should be invoked on by an {@code INVOKESPECIAL}
&nbsp;             *                          invocation.
&nbsp;             * @return A special method invocation representing a legal invocation if the method can be invoked
&nbsp;             * specially on the target type or an illegal invocation if this is not possible.
&nbsp;             */
&nbsp;            public static SpecialMethodInvocation of(MethodDescription methodDescription, TypeDescription typeDescription) {
<b class="fc">&nbsp;                StackManipulation stackManipulation = MethodInvocation.invoke(methodDescription).special(typeDescription);</b>
<b class="fc">&nbsp;                return stackManipulation.isValid()</b>
<b class="fc">&nbsp;                        ? new SpecialMethodInvocation.Simple(methodDescription, typeDescription, stackManipulation)</b>
<b class="fc">&nbsp;                        : SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription getMethodDescription() {
<b class="fc">&nbsp;                return methodDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getTypeDescription() {
<b class="fc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                return stackManipulation.apply(methodVisitor, implementationContext);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SpecialMethodInvocation withCheckedCompatibilityTo(MethodDescription.TypeToken token) {
<b class="fc">&nbsp;                if (methodDescription.asTypeToken().equals(token)) {</b>
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public JavaConstant.MethodHandle toMethodHandle() {
<b class="fc">&nbsp;                return JavaConstant.MethodHandle.ofSpecial(methodDescription.asDefined(), typeDescription);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The target of an implementation. Implementation targets must be immutable and can be queried without altering
&nbsp;     * the implementation result. An implementation target provides information on the type that is to be created
&nbsp;     * where it is the implementation&#39;s responsibility to cache expensive computations, especially such computations
&nbsp;     * that require reflective look-up.
&nbsp;     */
&nbsp;    interface Target {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a description of the instrumented type.
&nbsp;         *
&nbsp;         * @return A description of the instrumented type.
&nbsp;         */
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        /**
&nbsp;         * Identifies the origin type of an implementation. The origin type describes the type that is subject to
&nbsp;         * any form of enhancement. If a subclass of a given type is generated, the base type of this subclass
&nbsp;         * describes the origin type. If a given type is redefined or rebased, the origin type is described by the
&nbsp;         * instrumented type itself.
&nbsp;         *
&nbsp;         * @return The origin type of this implementation.
&nbsp;         */
&nbsp;        TypeDefinition getOriginType();
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation for invoking the super method of the given method.
&nbsp;         *
&nbsp;         * @param token A token of the method that is to be invoked as a super method.
&nbsp;         * @return The corresponding special method invocation which might be illegal if the requested invocation is not legal.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeSuper(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation for invoking a default method with the given token. The default method call must
&nbsp;         * not be ambiguous or an illegal special method invocation is returned.
&nbsp;         *
&nbsp;         * @param token A token of the method that is to be invoked as a default method.
&nbsp;         * @return The corresponding default method invocation which might be illegal if the requested invocation is not legal or ambiguous.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation for invoking a default method.
&nbsp;         *
&nbsp;         * @param targetType The interface on which the default method is to be invoked.
&nbsp;         * @param token      A token that uniquely describes the method to invoke.
&nbsp;         * @return The corresponding special method invocation which might be illegal if the requested invocation is
&nbsp;         * not legal.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType);
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes a dominant method, i.e. if the method token can be invoked as a super method invocation, this invocation is considered dominant.
&nbsp;         * Alternatively, a method invocation is attempted on an interface type as a default method invocation only if this invocation is not ambiguous
&nbsp;         * for several interfaces.
&nbsp;         *
&nbsp;         * @param token The method token representing the method to be invoked.
&nbsp;         * @return A special method invocation for a method representing the method token.
&nbsp;         */
&nbsp;        SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating an {@link Implementation.Target}.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an implementation target.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param methodGraph      A method graph of the instrumented type.
&nbsp;             * @param classFileVersion The type&#39;s class file version.
&nbsp;             * @return An implementation target for the instrumented type.
&nbsp;             */
&nbsp;            Target make(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, ClassFileVersion classFileVersion);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation for an {@link Implementation.Target}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class AbstractBase implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type&#39;s method graph.
&nbsp;             */
&nbsp;            protected final MethodGraph.Linked methodGraph;
&nbsp;
&nbsp;            /**
&nbsp;             * The default method invocation mode to apply.
&nbsp;             */
&nbsp;            protected final DefaultMethodInvocation defaultMethodInvocation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation target.
&nbsp;             *
&nbsp;             * @param instrumentedType        The instrumented type.
&nbsp;             * @param methodGraph             The instrumented type&#39;s method graph.
&nbsp;             * @param defaultMethodInvocation The default method invocation mode to apply.
&nbsp;             */
<b class="fc">&nbsp;            protected AbstractBase(TypeDescription instrumentedType, MethodGraph.Linked methodGraph, DefaultMethodInvocation defaultMethodInvocation) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.methodGraph = methodGraph;</b>
<b class="fc">&nbsp;                this.defaultMethodInvocation = defaultMethodInvocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getInstrumentedType() {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = SpecialMethodInvocation.Illegal.INSTANCE;</b>
<b class="fc">&nbsp;                for (TypeDescription interfaceType : instrumentedType.getInterfaces().asErasures()) {</b>
<b class="fc">&nbsp;                    SpecialMethodInvocation invocation = invokeDefault(token, interfaceType).withCheckedCompatibilityTo(token.asTypeToken());</b>
<b class="fc">&nbsp;                    if (invocation.isValid()) {</b>
<b class="fc">&nbsp;                        if (specialMethodInvocation.isValid()) {</b>
<b class="fc">&nbsp;                            return SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            specialMethodInvocation = invocation;</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return specialMethodInvocation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SpecialMethodInvocation invokeDefault(MethodDescription.SignatureToken token, TypeDescription targetType) {
<b class="fc">&nbsp;                return defaultMethodInvocation.apply(methodGraph.getInterfaceGraph(targetType).locate(token), targetType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SpecialMethodInvocation invokeDominant(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = invokeSuper(token);</b>
<b class="fc">&nbsp;                return specialMethodInvocation.isValid()</b>
<b class="fc">&nbsp;                        ? specialMethodInvocation</b>
<b class="fc">&nbsp;                        : invokeDefault(token);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if default method invocations are possible.
&nbsp;             */
<b class="fc">&nbsp;            protected enum DefaultMethodInvocation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Permits default method invocations, if an interface declaring a default method is possible.
&nbsp;                 */
<b class="fc">&nbsp;                ENABLED {</b>
&nbsp;                    @Override
&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
<b class="fc">&nbsp;                        return node.getSort().isUnique()</b>
<b class="fc">&nbsp;                                ? SpecialMethodInvocation.Simple.of(node.getRepresentative(), targetType)</b>
<b class="fc">&nbsp;                                : SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Does not permit default method invocations.
&nbsp;                 */
<b class="fc">&nbsp;                DISABLED {</b>
&nbsp;                    @Override
&nbsp;                    protected SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType) {
<b class="fc">&nbsp;                        return SpecialMethodInvocation.Illegal.INSTANCE;</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a default method invocation depending on the class file version permitting such calls.
&nbsp;                 *
&nbsp;                 * @param classFileVersion The class file version to resolve for.
&nbsp;                 * @return A suitable default method invocation mode.
&nbsp;                 */
&nbsp;                public static DefaultMethodInvocation of(ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;                    return classFileVersion.isAtLeast(ClassFileVersion.JAVA_V8)</b>
<b class="fc">&nbsp;                            ? ENABLED</b>
<b class="fc">&nbsp;                            : DISABLED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a default method invocation for a given node.
&nbsp;                 *
&nbsp;                 * @param node       The node representing the default method call.
&nbsp;                 * @param targetType The target type defining the default method.
&nbsp;                 * @return A suitable special method invocation.
&nbsp;                 */
&nbsp;                protected abstract SpecialMethodInvocation apply(MethodGraph.Node node, TypeDescription targetType);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The context for an implementation application. An implementation context represents a mutable data structure
&nbsp;     * where any registration is irrevocable. Calling methods on an implementation context should be considered equally
&nbsp;     * sensitive as calling a {@link org.objectweb.asm.MethodVisitor}. As such, an implementation context and a
&nbsp;     * {@link org.objectweb.asm.MethodVisitor} are complementary for creating an new Java type.
&nbsp;     */
&nbsp;    interface Context extends MethodAccessorFactory {
&nbsp;
&nbsp;        /**
&nbsp;         * Registers an auxiliary type as required for the current implementation. Registering a type will cause the
&nbsp;         * creation of this type even if this type is not effectively used for the current implementation.
&nbsp;         *
&nbsp;         * @param auxiliaryType The auxiliary type that is required for the current implementation.
&nbsp;         * @return A description of the registered auxiliary type.
&nbsp;         */
&nbsp;        TypeDescription register(AuxiliaryType auxiliaryType);
&nbsp;
&nbsp;        /**
&nbsp;         * Caches a single value by storing it in form of a {@code private}, {@code final} and {@code static} field.
&nbsp;         * By caching values, expensive instance creations can be avoided and object identity can be preserved.
&nbsp;         * The field is initiated in a generated class&#39;s static initializer.
&nbsp;         *
&nbsp;         * @param fieldValue A stack manipulation for creating the value that is to be cached in a {@code static} field.
&nbsp;         *                   After executing the stack manipulation, exactly one value must be put onto the operand
&nbsp;         *                   stack which is assignable to the given {@code fieldType}.
&nbsp;         * @param fieldType  The type of the field for storing the cached value. This field&#39;s type determines the value
&nbsp;         *                   that is put onto the operand stack by this method&#39;s returned stack manipulation.
&nbsp;         * @return A description of a field that was defined on the instrumented type which contains the given value.
&nbsp;         */
&nbsp;        FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the instrumented type of the current implementation. The instrumented type is exposed with the intend of allowing optimal
&nbsp;         * byte code generation and not for implementing checks or changing the behavior of a {@link StackManipulation}.
&nbsp;         *
&nbsp;         * @return The instrumented type of the current implementation.
&nbsp;         */
&nbsp;        TypeDescription getInstrumentedType();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the class file version of the currently creatgetClassFileVersioned dynamic type.
&nbsp;         *
&nbsp;         * @return The class file version of the currently created dynamic type.
&nbsp;         */
&nbsp;        ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if the explicit generation of stack map frames is expected.
&nbsp;         *
&nbsp;         * @return {@code true} if the explicit generation of stack map frames is expected.
&nbsp;         */
&nbsp;        FrameGeneration getFrameGeneration();
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates the frame generation being applied.
&nbsp;         */
<b class="fc">&nbsp;        enum FrameGeneration {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that frames should be generated.
&nbsp;             */
<b class="fc">&nbsp;            GENERATE(true) {</b>
&nbsp;                @Override
&nbsp;                public void generate(MethodVisitor methodVisitor,
&nbsp;                                     int type,
&nbsp;                                     int stackCount,
&nbsp;                                     @MaybeNull Object[] stack,
&nbsp;                                     int changedLocalVariableCount,
&nbsp;                                     @MaybeNull Object[] changedLocalVariable,
&nbsp;                                     int fullLocalVariableCount,
&nbsp;                                     @MaybeNull Object[] fullLocalVariable) {
<b class="fc">&nbsp;                    methodVisitor.visitFrame(type, changedLocalVariableCount, changedLocalVariable, stackCount, stack);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that frames should be generated and expanded.
&nbsp;             */
<b class="fc">&nbsp;            EXPAND(true) {</b>
&nbsp;                @Override
&nbsp;                public void generate(MethodVisitor methodVisitor,
&nbsp;                                     int type,
&nbsp;                                     int stackCount,
&nbsp;                                     @MaybeNull Object[] stack,
&nbsp;                                     int changedLocalVariableCount,
&nbsp;                                     @MaybeNull Object[] changedLocalVariable,
&nbsp;                                     int fullLocalVariableCount,
&nbsp;                                     @MaybeNull Object[] fullLocalVariable) {
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_NEW, fullLocalVariableCount, fullLocalVariable, stackCount, stack);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that no frames should be generated.
&nbsp;             */
<b class="fc">&nbsp;            DISABLED(false) {</b>
&nbsp;                @Override
&nbsp;                public void generate(MethodVisitor methodVisitor,
&nbsp;                                     int type,
&nbsp;                                     int stackCount,
&nbsp;                                     @MaybeNull Object[] stack,
&nbsp;                                     int changedLocalVariableCount,
&nbsp;                                     @MaybeNull Object[] changedLocalVariable,
&nbsp;                                     int fullLocalVariableCount,
&nbsp;                                     @MaybeNull Object[] fullLocalVariable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * An empty array to reuse for empty frames.
&nbsp;             */
<b class="fc">&nbsp;            private static final Object[] EMPTY = new Object[0];</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if frames should be generated.
&nbsp;             */
&nbsp;            private final boolean active;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new frame generation type.
&nbsp;             *
&nbsp;             * @param active {@code true} if frames should be generated.
&nbsp;             */
<b class="fc">&nbsp;            FrameGeneration(boolean active) {</b>
<b class="fc">&nbsp;                this.active = active;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if frames should be generated.
&nbsp;             *
&nbsp;             * @return {@code true} if frames should be generated.
&nbsp;             */
&nbsp;            public boolean isActive() {
<b class="fc">&nbsp;                return active;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Inserts a {@link Opcodes#F_SAME} frame.
&nbsp;             *
&nbsp;             * @param methodVisitor  The method visitor to write to.
&nbsp;             * @param localVariables The local variables that are defined at this frame location.
&nbsp;             */
&nbsp;            public void same(MethodVisitor methodVisitor,
&nbsp;                             List&lt;? extends TypeDefinition&gt; localVariables) {
<b class="fc">&nbsp;                generate(methodVisitor,</b>
&nbsp;                        Opcodes.F_SAME,
&nbsp;                        EMPTY.length,
&nbsp;                        EMPTY,
&nbsp;                        EMPTY.length,
&nbsp;                        EMPTY,
<b class="fc">&nbsp;                        localVariables.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(localVariables));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Inserts a {@link Opcodes#F_SAME1} frame.
&nbsp;             *
&nbsp;             * @param methodVisitor  The method visitor to write to.
&nbsp;             * @param stackValue     The single stack value.
&nbsp;             * @param localVariables The local variables that are defined at this frame location.
&nbsp;             */
&nbsp;            public void same1(MethodVisitor methodVisitor,
&nbsp;                              TypeDefinition stackValue,
&nbsp;                              List&lt;? extends TypeDefinition&gt; localVariables) {
<b class="fc">&nbsp;                generate(methodVisitor,</b>
&nbsp;                        Opcodes.F_SAME1,
&nbsp;                        1,
<b class="fc">&nbsp;                        new Object[]{toStackMapFrame(stackValue)},</b>
&nbsp;                        EMPTY.length,
&nbsp;                        EMPTY,
<b class="fc">&nbsp;                        localVariables.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(localVariables));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Inserts a {@link Opcodes#F_APPEND} frame.
&nbsp;             *
&nbsp;             * @param methodVisitor  The method visitor to write to.
&nbsp;             * @param appended       The appended local variables.
&nbsp;             * @param localVariables The local variables that are defined at this frame location, excluding the ones appended.
&nbsp;             */
&nbsp;            public void append(MethodVisitor methodVisitor,
&nbsp;                               List&lt;? extends TypeDefinition&gt; appended,
&nbsp;                               List&lt;? extends TypeDefinition&gt; localVariables) {
<b class="fc">&nbsp;                generate(methodVisitor,</b>
&nbsp;                        Opcodes.F_APPEND,
&nbsp;                        EMPTY.length,
&nbsp;                        EMPTY,
<b class="fc">&nbsp;                        appended.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(appended),</b>
<b class="fc">&nbsp;                        localVariables.size() + appended.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(CompoundList.of(localVariables, appended)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Inserts a {@link Opcodes#F_CHOP} frame.
&nbsp;             *
&nbsp;             * @param methodVisitor  The method visitor to write to.
&nbsp;             * @param chopped        The number of chopped values.
&nbsp;             * @param localVariables The local variables that are defined at this frame location, excluding the chopped variables.
&nbsp;             */
&nbsp;            public void chop(MethodVisitor methodVisitor,
&nbsp;                             int chopped,
&nbsp;                             List&lt;? extends TypeDefinition&gt; localVariables) {
<b class="fc">&nbsp;                generate(methodVisitor,</b>
&nbsp;                        Opcodes.F_CHOP,
&nbsp;                        EMPTY.length,
&nbsp;                        EMPTY,
&nbsp;                        chopped,
&nbsp;                        EMPTY,
<b class="fc">&nbsp;                        localVariables.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(localVariables));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Inserts a {@link Opcodes#F_FULL} frame.
&nbsp;             *
&nbsp;             * @param methodVisitor  The method visitor to write to.
&nbsp;             * @param stackValues    The values on the operand stack.
&nbsp;             * @param localVariables The local variables that are defined at this frame location.
&nbsp;             */
&nbsp;            public void full(MethodVisitor methodVisitor,
&nbsp;                             List&lt;? extends TypeDefinition&gt; stackValues,
&nbsp;                             List&lt;? extends TypeDefinition&gt; localVariables) {
<b class="fc">&nbsp;                generate(methodVisitor,</b>
&nbsp;                        Opcodes.F_FULL,
<b class="fc">&nbsp;                        stackValues.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(stackValues),</b>
<b class="fc">&nbsp;                        localVariables.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(localVariables),</b>
<b class="fc">&nbsp;                        localVariables.size(),</b>
<b class="fc">&nbsp;                        toStackMapFrames(localVariables));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Writes frames to a {@link MethodVisitor}, if applicable.
&nbsp;             *
&nbsp;             * @param methodVisitor             The method visitor to use
&nbsp;             * @param type                      The frame type.
&nbsp;             * @param stackCount                The number of values on the operand stack.
&nbsp;             * @param stack                     The values on the operand stack up to {@code stackCount}, or {@code null}, if none.
&nbsp;             * @param changedLocalVariableCount The number of local variables that were changed.
&nbsp;             * @param changedLocalVariable      The values added to the local variable array up to {@code changedLocalVariableCount}
&nbsp;             *                                  or {@code null}, if none or not applicable.
&nbsp;             * @param fullLocalVariableCount    The number of local variables.
&nbsp;             * @param fullLocalVariable         The total number of local variables up to {@code fullLocalVariableCount} or
&nbsp;             *                                  {@code null}, if none.
&nbsp;             */
&nbsp;            protected abstract void generate(MethodVisitor methodVisitor,
&nbsp;                                             int type,
&nbsp;                                             int stackCount,
&nbsp;                                             @MaybeNull Object[] stack,
&nbsp;                                             int changedLocalVariableCount,
&nbsp;                                             @MaybeNull Object[] changedLocalVariable,
&nbsp;                                             int fullLocalVariableCount,
&nbsp;                                             @MaybeNull Object[] fullLocalVariable);
&nbsp;
&nbsp;            private static Object[] toStackMapFrames(List&lt;? extends TypeDefinition&gt; typeDefinitions) {
<b class="fc">&nbsp;                Object[] value = typeDefinitions.isEmpty() ? EMPTY : new Object[typeDefinitions.size()];</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; typeDefinitions.size(); index++) {</b>
<b class="fc">&nbsp;                    value[index] = toStackMapFrame(typeDefinitions.get(index));</b>
&nbsp;                }
<b class="fc">&nbsp;                return value;</b>
&nbsp;            }
&nbsp;
&nbsp;            private static Object toStackMapFrame(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                if (typeDefinition.represents(boolean.class)</b>
<b class="fc">&nbsp;                        || typeDefinition.represents(byte.class)</b>
<b class="fc">&nbsp;                        || typeDefinition.represents(short.class)</b>
<b class="fc">&nbsp;                        || typeDefinition.represents(char.class)</b>
<b class="fc">&nbsp;                        || typeDefinition.represents(int.class)) {</b>
<b class="fc">&nbsp;                    return Opcodes.INTEGER;</b>
<b class="fc">&nbsp;                } else if (typeDefinition.represents(long.class)) {</b>
<b class="nc">&nbsp;                    return Opcodes.LONG;</b>
<b class="fc">&nbsp;                } else if (typeDefinition.represents(float.class)) {</b>
<b class="nc">&nbsp;                    return Opcodes.FLOAT;</b>
<b class="fc">&nbsp;                } else if (typeDefinition.represents(double.class)) {</b>
<b class="nc">&nbsp;                    return Opcodes.DOUBLE;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return typeDefinition.asErasure().getInternalName();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an extractable view of an {@link Implementation.Context} which
&nbsp;         * allows the retrieval of any registered auxiliary type.
&nbsp;         */
&nbsp;        interface ExtractableView extends Context {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if this implementation context permits the registration of any implicit type initializers.
&nbsp;             *
&nbsp;             * @return {@code true} if this implementation context permits the registration of any implicit type initializers.
&nbsp;             */
&nbsp;            boolean isEnabled();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns any {@link net.bytebuddy.implementation.auxiliary.AuxiliaryType} that was registered
&nbsp;             * with this {@link Implementation.Context}.
&nbsp;             *
&nbsp;             * @return A list of all manifested registered auxiliary types.
&nbsp;             */
&nbsp;            List&lt;DynamicType&gt; getAuxiliaryTypes();
&nbsp;
&nbsp;            /**
&nbsp;             * Writes any information that was registered with an {@link Implementation.Context}
&nbsp;             * to the provided class visitor. This contains any fields for value caching, any accessor method and it
&nbsp;             * writes the type initializer. The type initializer must therefore never be written manually.
&nbsp;             *
&nbsp;             * @param drain                        The drain to write the type initializer to.
&nbsp;             * @param classVisitor                 The class visitor to which the extractable view is to be written.
&nbsp;             * @param annotationValueFilterFactory The annotation value filter factory to apply when writing annotation.
&nbsp;             */
&nbsp;            void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of an extractable view of an implementation context.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class AbstractBase implements ExtractableView {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file version of the dynamic type.
&nbsp;                 */
&nbsp;                protected final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines the frame generation to be applied.
&nbsp;                 */
&nbsp;                protected final FrameGeneration frameGeneration;
&nbsp;
&nbsp;                /**
&nbsp;                 * Create a new extractable view.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param classFileVersion The class file version of the dynamic type.
&nbsp;                 * @param frameGeneration  Determines the frame generation to be applied.
&nbsp;                 */
<b class="fc">&nbsp;                protected AbstractBase(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FrameGeneration frameGeneration) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.classFileVersion = classFileVersion;</b>
<b class="fc">&nbsp;                    this.frameGeneration = frameGeneration;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getInstrumentedType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ClassFileVersion getClassFileVersion() {
<b class="fc">&nbsp;                    return classFileVersion;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FrameGeneration getFrameGeneration() {
<b class="fc">&nbsp;                    return frameGeneration;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a new implementation context.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType            The description of the type that is currently subject of creation.
&nbsp;             * @param auxiliaryTypeNamingStrategy The naming strategy for naming an auxiliary type.
&nbsp;             * @param typeInitializer             The type initializer of the created instrumented type.
&nbsp;             * @param classFileVersion            The class file version of the created class.
&nbsp;             * @param auxiliaryClassFileVersion   The class file version of any auxiliary classes.
&nbsp;             * @return An implementation context in its extractable view.
&nbsp;             * @deprecated Use {@link Implementation.Context.Factory#make(TypeDescription, AuxiliaryType.NamingStrategy, TypeInitializer, ClassFileVersion, ClassFileVersion, Implementation.Context.FrameGeneration)}.
&nbsp;             */
&nbsp;            @Deprecated
&nbsp;            ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                 AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                 TypeInitializer typeInitializer,
&nbsp;                                 ClassFileVersion classFileVersion,
&nbsp;                                 ClassFileVersion auxiliaryClassFileVersion);
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType            The description of the type that is currently subject of creation.
&nbsp;             * @param auxiliaryTypeNamingStrategy The naming strategy for naming an auxiliary type.
&nbsp;             * @param typeInitializer             The type initializer of the created instrumented type.
&nbsp;             * @param classFileVersion            The class file version of the created class.
&nbsp;             * @param auxiliaryClassFileVersion   The class file version of any auxiliary classes.
&nbsp;             * @param frameGeneration             Indicates the frame generation being applied.
&nbsp;             * @return An implementation context in its extractable view.
&nbsp;             */
&nbsp;            ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                 AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                 TypeInitializer typeInitializer,
&nbsp;                                 ClassFileVersion classFileVersion,
&nbsp;                                 ClassFileVersion auxiliaryClassFileVersion,
&nbsp;                                 FrameGeneration frameGeneration);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation context that does not allow for any injections into the static initializer block. This can be useful when
&nbsp;         * redefining a class when it is not allowed to add methods to a class what is an implicit requirement when copying the static
&nbsp;         * initializer block into another method.
&nbsp;         */
&nbsp;        class Disabled extends ExtractableView.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new disabled implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param classFileVersion The class file version to create the class in.
&nbsp;             * @param frameGeneration  Determines the frame generation to be applied.
&nbsp;             */
&nbsp;            protected Disabled(TypeDescription instrumentedType, ClassFileVersion classFileVersion, FrameGeneration frameGeneration) {
<b class="fc">&nbsp;                super(instrumentedType, classFileVersion, frameGeneration);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isEnabled() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {
<b class="fc">&nbsp;                return Collections.emptyList();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void drain(TypeInitializer.Drain drain, ClassVisitor classVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                drain.apply(classVisitor, TypeInitializer.None.INSTANCE, this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Registration of auxiliary types was disabled: &quot; + auxiliaryType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, AccessType accessType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Registration of method accessors was disabled: &quot; + specialMethodInvocation.getMethodDescription());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, AccessType accessType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, AccessType accessType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Registration of field accessor was disabled: &quot; + fieldDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Field values caching was disabled: &quot; + fieldType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link net.bytebuddy.implementation.Implementation.Context.Disabled}.
&nbsp;             */
<b class="fc">&nbsp;            public enum Factory implements Context.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Deprecated
&nbsp;                public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                            AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                            TypeInitializer typeInitializer,
&nbsp;                                            ClassFileVersion classFileVersion,
&nbsp;                                            ClassFileVersion auxiliaryClassFileVersion) {
<b class="nc">&nbsp;                    return make(instrumentedType,</b>
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            typeInitializer,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryClassFileVersion,
<b class="nc">&nbsp;                            classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="nc">&nbsp;                                    ? FrameGeneration.GENERATE</b>
<b class="nc">&nbsp;                                    : FrameGeneration.DISABLED);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                            AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                            TypeInitializer typeInitializer,
&nbsp;                                            ClassFileVersion classFileVersion,
&nbsp;                                            ClassFileVersion auxiliaryClassFileVersion,
&nbsp;                                            FrameGeneration frameGeneration) {
<b class="fc">&nbsp;                    if (typeInitializer.isDefined()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define type initializer which was explicitly disabled: &quot; + typeInitializer);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Disabled(instrumentedType, classFileVersion, frameGeneration);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of an {@link Implementation.Context.ExtractableView}
&nbsp;         * which serves as its own {@link MethodAccessorFactory}.
&nbsp;         */
&nbsp;        class Default extends ExtractableView.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The name suffix to be appended to an accessor method.
&nbsp;             */
&nbsp;            public static final String ACCESSOR_METHOD_SUFFIX = &quot;accessor&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The name prefix to be prepended to a field storing a cached value.
&nbsp;             */
&nbsp;            public static final String FIELD_CACHE_PREFIX = &quot;cachedValue&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The naming strategy for naming auxiliary types that are registered.
&nbsp;             */
&nbsp;            private final AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The type initializer of the created instrumented type.
&nbsp;             */
&nbsp;            private final TypeInitializer typeInitializer;
&nbsp;
&nbsp;            /**
&nbsp;             * The class file version to use for auxiliary classes.
&nbsp;             */
&nbsp;            private final ClassFileVersion auxiliaryClassFileVersion;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of special method invocations to their accessor methods that each invoke their mapped invocation.
&nbsp;             */
&nbsp;            private final Map&lt;SpecialMethodInvocation, DelegationRecord&gt; registeredAccessorMethods;
&nbsp;
&nbsp;            /**
&nbsp;             * The registered getters.
&nbsp;             */
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredGetters;
&nbsp;
&nbsp;            /**
&nbsp;             * The registered setters.
&nbsp;             */
&nbsp;            private final Map&lt;FieldDescription, DelegationRecord&gt; registeredSetters;
&nbsp;
&nbsp;            /**
&nbsp;             * A map of registered auxiliary types to their dynamic type representation.
&nbsp;             */
&nbsp;            private final Map&lt;AuxiliaryType, DynamicType&gt; auxiliaryTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A map of already registered field caches to their field representation.
&nbsp;             */
&nbsp;            private final Map&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; registeredFieldCacheEntries;
&nbsp;
&nbsp;            /**
&nbsp;             * A set of registered field cache entries.
&nbsp;             */
&nbsp;            private final Set&lt;FieldDescription.InDefinedShape&gt; registeredFieldCacheFields;
&nbsp;
&nbsp;            /**
&nbsp;             * The suffix to append to the names of accessor methods.
&nbsp;             */
&nbsp;            private final String suffix;
&nbsp;
&nbsp;            /**
&nbsp;             * If {@code false}, the type initializer for this instance was already drained what prohibits the registration of additional cached field values.
&nbsp;             */
&nbsp;            private boolean fieldCacheCanAppendEntries;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default implementation context.
&nbsp;             *
&nbsp;             * @param instrumentedType            The description of the type that is currently subject of creation.
&nbsp;             * @param classFileVersion            The class file version of the created class.
&nbsp;             * @param auxiliaryTypeNamingStrategy The naming strategy for naming an auxiliary type.
&nbsp;             * @param typeInitializer             The type initializer of the created instrumented type.
&nbsp;             * @param auxiliaryClassFileVersion   The class file version to use for auxiliary classes.
&nbsp;             * @param frameGeneration             Determines the frame generation to be applied.
&nbsp;             * @param suffix                      The suffix to append to the names of accessor methods.
&nbsp;             */
&nbsp;            protected Default(TypeDescription instrumentedType,
&nbsp;                              ClassFileVersion classFileVersion,
&nbsp;                              AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                              TypeInitializer typeInitializer,
&nbsp;                              ClassFileVersion auxiliaryClassFileVersion,
&nbsp;                              FrameGeneration frameGeneration,
&nbsp;                              String suffix) {
<b class="fc">&nbsp;                super(instrumentedType, classFileVersion, frameGeneration);</b>
<b class="fc">&nbsp;                this.auxiliaryTypeNamingStrategy = auxiliaryTypeNamingStrategy;</b>
<b class="fc">&nbsp;                this.typeInitializer = typeInitializer;</b>
<b class="fc">&nbsp;                this.auxiliaryClassFileVersion = auxiliaryClassFileVersion;</b>
<b class="fc">&nbsp;                this.suffix = suffix;</b>
<b class="fc">&nbsp;                registeredAccessorMethods = new HashMap&lt;SpecialMethodInvocation, DelegationRecord&gt;();</b>
<b class="fc">&nbsp;                registeredGetters = new HashMap&lt;FieldDescription, DelegationRecord&gt;();</b>
<b class="fc">&nbsp;                registeredSetters = new HashMap&lt;FieldDescription, DelegationRecord&gt;();</b>
<b class="fc">&nbsp;                auxiliaryTypes = new HashMap&lt;AuxiliaryType, DynamicType&gt;();</b>
<b class="fc">&nbsp;                registeredFieldCacheEntries = new HashMap&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt;();</b>
<b class="fc">&nbsp;                registeredFieldCacheFields = new HashSet&lt;FieldDescription.InDefinedShape&gt;();</b>
<b class="fc">&nbsp;                fieldCacheCanAppendEntries = true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isEnabled() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape registerAccessorFor(SpecialMethodInvocation specialMethodInvocation, AccessType accessType) {
<b class="fc">&nbsp;                DelegationRecord record = registeredAccessorMethods.get(specialMethodInvocation);</b>
<b class="fc">&nbsp;                record = record == null</b>
<b class="fc">&nbsp;                        ? new AccessorMethodDelegation(instrumentedType, suffix, accessType, specialMethodInvocation)</b>
<b class="fc">&nbsp;                        : record.with(accessType);</b>
<b class="fc">&nbsp;                registeredAccessorMethods.put(specialMethodInvocation, record);</b>
<b class="fc">&nbsp;                return record.getMethod();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape registerGetterFor(FieldDescription fieldDescription, AccessType accessType) {
<b class="fc">&nbsp;                DelegationRecord record = registeredGetters.get(fieldDescription);</b>
<b class="fc">&nbsp;                record = record == null</b>
<b class="fc">&nbsp;                        ? new FieldGetterDelegation(instrumentedType, suffix, accessType, fieldDescription)</b>
<b class="fc">&nbsp;                        : record.with(accessType);</b>
<b class="fc">&nbsp;                registeredGetters.put(fieldDescription, record);</b>
<b class="fc">&nbsp;                return record.getMethod();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape registerSetterFor(FieldDescription fieldDescription, AccessType accessType) {
<b class="fc">&nbsp;                DelegationRecord record = registeredSetters.get(fieldDescription);</b>
<b class="fc">&nbsp;                record = record == null</b>
<b class="fc">&nbsp;                        ? new FieldSetterDelegation(instrumentedType, suffix, accessType, fieldDescription)</b>
<b class="fc">&nbsp;                        : record.with(accessType);</b>
<b class="fc">&nbsp;                registeredSetters.put(fieldDescription, record);</b>
<b class="fc">&nbsp;                return record.getMethod();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription register(AuxiliaryType auxiliaryType) {
<b class="fc">&nbsp;                DynamicType dynamicType = auxiliaryTypes.get(auxiliaryType);</b>
<b class="fc">&nbsp;                if (dynamicType == null) {</b>
<b class="fc">&nbsp;                    dynamicType = auxiliaryType.make(auxiliaryTypeNamingStrategy.name(instrumentedType, auxiliaryType),</b>
&nbsp;                            auxiliaryClassFileVersion,
&nbsp;                            this);
<b class="fc">&nbsp;                    auxiliaryTypes.put(auxiliaryType, dynamicType);</b>
&nbsp;                }
<b class="fc">&nbsp;                return dynamicType.getTypeDescription();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;DynamicType&gt; getAuxiliaryTypes() {
<b class="fc">&nbsp;                return new ArrayList&lt;DynamicType&gt;(auxiliaryTypes.values());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldDescription.InDefinedShape cache(StackManipulation fieldValue, TypeDescription fieldType) {
<b class="fc">&nbsp;                FieldCacheEntry fieldCacheEntry = new FieldCacheEntry(fieldValue, fieldType);</b>
<b class="fc">&nbsp;                FieldDescription.InDefinedShape fieldCache = registeredFieldCacheEntries.get(fieldCacheEntry);</b>
<b class="fc">&nbsp;                if (fieldCache != null) {</b>
<b class="fc">&nbsp;                    return fieldCache;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!fieldCacheCanAppendEntries) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cached values cannot be registered after defining the type initializer for &quot; + instrumentedType);</b>
&nbsp;                }
<b class="fc">&nbsp;                int hashCode = fieldValue.hashCode();</b>
&nbsp;                do {
<b class="fc">&nbsp;                    fieldCache = new CacheValueField(instrumentedType, fieldType.asGenericType(), suffix, hashCode++);</b>
<b class="fc">&nbsp;                } while (!registeredFieldCacheFields.add(fieldCache));</b>
<b class="fc">&nbsp;                registeredFieldCacheEntries.put(fieldCacheEntry, fieldCache);</b>
<b class="fc">&nbsp;                return fieldCache;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void drain(TypeInitializer.Drain drain,
&nbsp;                              ClassVisitor classVisitor,
&nbsp;                              AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                fieldCacheCanAppendEntries = false;</b>
<b class="fc">&nbsp;                TypeInitializer typeInitializer = this.typeInitializer;</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;FieldCacheEntry, FieldDescription.InDefinedShape&gt; entry : registeredFieldCacheEntries.entrySet()) {</b>
<b class="fc">&nbsp;                    FieldVisitor fieldVisitor = classVisitor.visitField(entry.getValue().getModifiers(),</b>
<b class="fc">&nbsp;                            entry.getValue().getInternalName(),</b>
<b class="fc">&nbsp;                            entry.getValue().getDescriptor(),</b>
<b class="fc">&nbsp;                            entry.getValue().getGenericSignature(),</b>
&nbsp;                            FieldDescription.NO_DEFAULT_VALUE);
<b class="fc">&nbsp;                    if (fieldVisitor != null) {</b>
<b class="fc">&nbsp;                        fieldVisitor.visitEnd();</b>
<b class="fc">&nbsp;                        typeInitializer = typeInitializer.expandWith(entry.getKey().storeIn(entry.getValue()));</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                drain.apply(classVisitor, typeInitializer, this);</b>
<b class="fc">&nbsp;                for (TypeWriter.MethodPool.Record record : registeredAccessorMethods.values()) {</b>
<b class="fc">&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (TypeWriter.MethodPool.Record record : registeredGetters.values()) {</b>
<b class="fc">&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (TypeWriter.MethodPool.Record record : registeredSetters.values()) {</b>
<b class="fc">&nbsp;                    record.apply(classVisitor, this, annotationValueFilterFactory);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a field that stores a cached value.
&nbsp;             */
&nbsp;            protected static class CacheValueField extends FieldDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the cache&#39;s field.
&nbsp;                 */
&nbsp;                private final TypeDescription.Generic fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new cache value field.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param fieldType        The type of the cache&#39;s field.
&nbsp;                 * @param suffix           The suffix to use for the cache field&#39;s name.
&nbsp;                 * @param hashCode         The hash value of the field&#39;s value for creating a unique field name.
&nbsp;                 */
<b class="fc">&nbsp;                protected CacheValueField(TypeDescription instrumentedType, TypeDescription.Generic fieldType, String suffix, int hashCode) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
<b class="fc">&nbsp;                    name = FIELD_CACHE_PREFIX + &quot;$&quot; + suffix + &quot;$&quot; + RandomString.hashOf(hashCode);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription.Generic getType() {
<b class="fc">&nbsp;                    return fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getModifiers() {
<b class="fc">&nbsp;                    return Opcodes.ACC_SYNTHETIC | Opcodes.ACC_FINAL | Opcodes.ACC_STATIC | (instrumentedType.isInterface()</b>
<b class="fc">&nbsp;                            ? Opcodes.ACC_PUBLIC</b>
<b class="fc">&nbsp;                            : Opcodes.ACC_PRIVATE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field cache entry for uniquely identifying a cached field. A cached field is described by the stack
&nbsp;             * manipulation that loads the field&#39;s value onto the operand stack and the type of the field.
&nbsp;             */
&nbsp;            protected static class FieldCacheEntry implements StackManipulation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field value that is represented by this field cache entry.
&nbsp;                 */
&nbsp;                private final StackManipulation fieldValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field type that is represented by this field cache entry.
&nbsp;                 */
&nbsp;                private final TypeDescription fieldType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field cache entry.
&nbsp;                 *
&nbsp;                 * @param fieldValue The field value that is represented by this field cache entry.
&nbsp;                 * @param fieldType  The field type that is represented by this field cache entry.
&nbsp;                 */
<b class="fc">&nbsp;                protected FieldCacheEntry(StackManipulation fieldValue, TypeDescription fieldType) {</b>
<b class="fc">&nbsp;                    this.fieldValue = fieldValue;</b>
<b class="fc">&nbsp;                    this.fieldType = fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a stack manipulation where the represented value is stored in the given field.
&nbsp;                 *
&nbsp;                 * @param fieldDescription A static field in which the value is to be stored.
&nbsp;                 * @return A byte code appender that represents this storage.
&nbsp;                 */
&nbsp;                protected ByteCodeAppender storeIn(FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    return new ByteCodeAppender.Simple(this, FieldAccess.forField(fieldDescription).write());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the field type that is represented by this field cache entry.
&nbsp;                 *
&nbsp;                 * @return The field type that is represented by this field cache entry.
&nbsp;                 */
&nbsp;                protected TypeDescription getFieldType() {
<b class="nc">&nbsp;                    return fieldType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isValid() {
<b class="nc">&nbsp;                    return fieldValue.isValid();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    return fieldValue.apply(methodVisitor, implementationContext);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    int result = fieldValue.hashCode();</b>
<b class="fc">&nbsp;                    result = 31 * result + fieldType.hashCode();</b>
<b class="fc">&nbsp;                    return result;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                    if (this == other) {</b>
<b class="nc">&nbsp;                        return true;</b>
<b class="fc">&nbsp;                    } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    FieldCacheEntry fieldCacheEntry = (FieldCacheEntry) other;</b>
<b class="fc">&nbsp;                    return fieldValue.equals(fieldCacheEntry.fieldValue) &amp;&amp; fieldType.equals(fieldCacheEntry.fieldType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A base implementation of a method that accesses a property of an instrumented type.
&nbsp;             */
<b class="fc">&nbsp;            protected abstract static class AbstractPropertyAccessorMethod extends MethodDescription.InDefinedShape.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getModifiers() {
<b class="fc">&nbsp;                    return Opcodes.ACC_SYNTHETIC | getBaseModifiers() | (getDeclaringType().isInterface()</b>
<b class="fc">&nbsp;                            ? Opcodes.ACC_PUBLIC</b>
<b class="fc">&nbsp;                            : Opcodes.ACC_FINAL);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the base modifiers, i.e. the modifiers that define the accessed property&#39;s features.
&nbsp;                 *
&nbsp;                 * @return Returns the base modifiers of the represented methods.
&nbsp;                 */
&nbsp;                protected abstract int getBaseModifiers();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of an accessor method to access another method from outside the instrumented type.
&nbsp;             */
&nbsp;            protected static class AccessorMethod extends AbstractPropertyAccessorMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method that is being accessed.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the method.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new accessor method.
&nbsp;                 *
&nbsp;                 * @param instrumentedType  The instrumented type.
&nbsp;                 * @param methodDescription The method that is being accessed.
&nbsp;                 * @param typeDescription   The targeted type of the accessor method.
&nbsp;                 * @param suffix            The suffix to append to the accessor method&#39;s name.
&nbsp;                 */
&nbsp;                protected AccessorMethod(TypeDescription instrumentedType,
&nbsp;                                         MethodDescription methodDescription,
&nbsp;                                         TypeDescription typeDescription,
<b class="fc">&nbsp;                                         String suffix) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    name = methodDescription.getInternalName()</b>
&nbsp;                            + &quot;$&quot; + ACCESSOR_METHOD_SUFFIX
&nbsp;                            + &quot;$&quot; + suffix
<b class="fc">&nbsp;                            + (typeDescription.isInterface() ? &quot;$&quot; + RandomString.hashOf(typeDescription.hashCode()) : &quot;&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;                    return methodDescription.getReturnType().asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                    return new ParameterList.Explicit.ForTypes(this, methodDescription.getParameters().asTypeList().asRawTypes());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                    return methodDescription.getExceptionTypes().asRawTypes();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                    return AnnotationValue.UNDEFINED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected int getBaseModifiers() {
<b class="fc">&nbsp;                    return methodDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? Opcodes.ACC_STATIC</b>
<b class="fc">&nbsp;                            : EMPTY_MASK;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getInternalName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a field getter method.
&nbsp;             */
&nbsp;            protected static class FieldGetter extends AbstractPropertyAccessorMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field for which a getter is described.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the getter method.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field getter.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param fieldDescription The field for which a getter is described.
&nbsp;                 * @param suffix           The name suffix for the field getter method.
&nbsp;                 */
<b class="fc">&nbsp;                protected FieldGetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                    name = fieldDescription.getName() + &quot;$&quot; + ACCESSOR_METHOD_SUFFIX + &quot;$&quot; + suffix;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;                    return fieldDescription.getType().asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                    return new ParameterList.Empty&lt;ParameterDescription.InDefinedShape&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                    return AnnotationValue.UNDEFINED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected int getBaseModifiers() {
<b class="fc">&nbsp;                    return fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? Opcodes.ACC_STATIC</b>
<b class="fc">&nbsp;                            : EMPTY_MASK;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getInternalName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a field setter method.
&nbsp;             */
&nbsp;            protected static class FieldSetter extends AbstractPropertyAccessorMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field for which a setter is described.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field setter.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field setter.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param fieldDescription The field for which a setter is described.
&nbsp;                 * @param suffix           The name suffix for the field setter method.
&nbsp;                 */
<b class="fc">&nbsp;                protected FieldSetter(TypeDescription instrumentedType, FieldDescription fieldDescription, String suffix) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                    name = fieldDescription.getName() + &quot;$&quot; + ACCESSOR_METHOD_SUFFIX + &quot;$&quot; + suffix;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                    return new ParameterList.Explicit.ForTypes(this, Collections.singletonList(fieldDescription.getType().asRawType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                    return AnnotationValue.UNDEFINED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected int getBaseModifiers() {
<b class="fc">&nbsp;                    return fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? Opcodes.ACC_STATIC</b>
<b class="fc">&nbsp;                            : EMPTY_MASK;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getInternalName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract method pool entry that delegates the implementation of a method to itself.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected abstract static class DelegationRecord extends TypeWriter.MethodPool.Record.ForDefinedMethod implements ByteCodeAppender {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegation method.
&nbsp;                 */
&nbsp;                protected final MethodDescription.InDefinedShape methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record&#39;s visibility.
&nbsp;                 */
&nbsp;                protected final Visibility visibility;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new delegation record.
&nbsp;                 *
&nbsp;                 * @param methodDescription The delegation method.
&nbsp;                 * @param visibility        The method&#39;s actual visibility.
&nbsp;                 */
<b class="fc">&nbsp;                protected DelegationRecord(MethodDescription.InDefinedShape methodDescription, Visibility visibility) {</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                    this.visibility = visibility;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns this delegation record with the minimal visibility represented by the supplied access type.
&nbsp;                 *
&nbsp;                 * @param accessType The access type to enforce.
&nbsp;                 * @return A new version of this delegation record with the minimal implied visibility.
&nbsp;                 */
&nbsp;                protected abstract DelegationRecord with(AccessType accessType);
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDescription.InDefinedShape getMethod() {
<b class="fc">&nbsp;                    return methodDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sort getSort() {
<b class="fc">&nbsp;                    return Sort.IMPLEMENTED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Visibility getVisibility() {
<b class="fc">&nbsp;                    return visibility;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyHead(MethodVisitor methodVisitor) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyBody(MethodVisitor methodVisitor, Context implementationContext, AnnotationValueFilter.Factory annotationValueFilterFactory) {
<b class="fc">&nbsp;                    methodVisitor.visitCode();</b>
<b class="fc">&nbsp;                    Size size = applyCode(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void applyAttributes(MethodVisitor methodVisitor, AnnotationValueFilter.Factory annotationValueFilterFactory) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size applyCode(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                    return apply(methodVisitor, implementationContext, getMethod());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeWriter.MethodPool.Record prepend(ByteCodeAppender byteCodeAppender) {
<b class="fc">&nbsp;                    throw new UnsupportedOperationException(&quot;Cannot prepend code to a delegation for &quot; + methodDescription);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a {@link TypeWriter.MethodPool.Record} for implementing
&nbsp;             * an accessor method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class AccessorMethodDelegation extends DelegationRecord {
&nbsp;
&nbsp;                /**
&nbsp;                 * The stack manipulation that represents the requested special method invocation.
&nbsp;                 */
&nbsp;                private final StackManipulation accessorMethodInvocation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a delegation to an accessor method.
&nbsp;                 *
&nbsp;                 * @param instrumentedType        The instrumented type.
&nbsp;                 * @param suffix                  The suffix to append to the method.
&nbsp;                 * @param accessType              The access type.
&nbsp;                 * @param specialMethodInvocation The actual method&#39;s invocation.
&nbsp;                 */
&nbsp;                protected AccessorMethodDelegation(TypeDescription instrumentedType,
&nbsp;                                                   String suffix,
&nbsp;                                                   AccessType accessType,
&nbsp;                                                   SpecialMethodInvocation specialMethodInvocation) {
<b class="fc">&nbsp;                    this(new AccessorMethod(instrumentedType,</b>
<b class="fc">&nbsp;                            specialMethodInvocation.getMethodDescription(),</b>
<b class="fc">&nbsp;                            specialMethodInvocation.getTypeDescription(),</b>
<b class="fc">&nbsp;                            suffix), accessType.getVisibility(), specialMethodInvocation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a delegation to an accessor method.
&nbsp;                 *
&nbsp;                 * @param methodDescription        The accessor method.
&nbsp;                 * @param visibility               The method&#39;s visibility.
&nbsp;                 * @param accessorMethodInvocation The actual method&#39;s invocation.
&nbsp;                 */
&nbsp;                private AccessorMethodDelegation(MethodDescription.InDefinedShape methodDescription,
&nbsp;                                                 Visibility visibility,
&nbsp;                                                 StackManipulation accessorMethodInvocation) {
<b class="fc">&nbsp;                    super(methodDescription, visibility);</b>
<b class="fc">&nbsp;                    this.accessorMethodInvocation = accessorMethodInvocation;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected DelegationRecord with(AccessType accessType) {
<b class="fc">&nbsp;                    return new AccessorMethodDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), accessorMethodInvocation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
&nbsp;                            accessorMethodInvocation,
<b class="fc">&nbsp;                            MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation for a field getter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class FieldGetterDelegation extends DelegationRecord {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to read from.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field getter implementation.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param suffix           The suffix to use for the setter method.
&nbsp;                 * @param accessType       The method&#39;s access type.
&nbsp;                 * @param fieldDescription The field to write to.
&nbsp;                 */
&nbsp;                protected FieldGetterDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    this(new FieldGetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field getter implementation.
&nbsp;                 *
&nbsp;                 * @param methodDescription The delegation method.
&nbsp;                 * @param visibility        The delegation method&#39;s visibility.
&nbsp;                 * @param fieldDescription  The field to read.
&nbsp;                 */
&nbsp;                private FieldGetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    super(methodDescription, visibility);</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected DelegationRecord with(AccessType accessType) {
<b class="fc">&nbsp;                    return new FieldGetterDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                                    ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                    : MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).read(),</b>
<b class="fc">&nbsp;                            MethodReturn.of(fieldDescription.getType())</b>
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation for a field setter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class FieldSetterDelegation extends DelegationRecord {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to write to.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field setter implementation.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @param suffix           The suffix to use for the setter method.
&nbsp;                 * @param accessType       The method&#39;s access type.
&nbsp;                 * @param fieldDescription The field to write to.
&nbsp;                 */
&nbsp;                protected FieldSetterDelegation(TypeDescription instrumentedType, String suffix, AccessType accessType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    this(new FieldSetter(instrumentedType, fieldDescription, suffix), accessType.getVisibility(), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field setter.
&nbsp;                 *
&nbsp;                 * @param methodDescription The field accessor method.
&nbsp;                 * @param visibility        The delegation method&#39;s visibility.
&nbsp;                 * @param fieldDescription  The field to write to.
&nbsp;                 */
&nbsp;                private FieldSetterDelegation(MethodDescription.InDefinedShape methodDescription, Visibility visibility, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    super(methodDescription, visibility);</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected DelegationRecord with(AccessType accessType) {
<b class="fc">&nbsp;                    return new FieldSetterDelegation(methodDescription, visibility.expandTo(accessType.getVisibility()), fieldDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).write(),</b>
&nbsp;                            MethodReturn.VOID
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link net.bytebuddy.implementation.Implementation.Context.Default}
&nbsp;             * that uses a random suffix for accessors.
&nbsp;             */
<b class="fc">&nbsp;            public enum Factory implements ExtractableView.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Deprecated
&nbsp;                public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                            AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                            TypeInitializer typeInitializer,
&nbsp;                                            ClassFileVersion classFileVersion,
&nbsp;                                            ClassFileVersion auxiliaryClassFileVersion) {
<b class="nc">&nbsp;                    return make(instrumentedType,</b>
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            typeInitializer,
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryClassFileVersion,
<b class="nc">&nbsp;                            classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="nc">&nbsp;                                    ? FrameGeneration.GENERATE</b>
<b class="nc">&nbsp;                                    : FrameGeneration.DISABLED);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                            AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                            TypeInitializer typeInitializer,
&nbsp;                                            ClassFileVersion classFileVersion,
&nbsp;                                            ClassFileVersion auxiliaryClassFileVersion,
&nbsp;                                            FrameGeneration frameGeneration) {
<b class="fc">&nbsp;                    return new Default(instrumentedType,</b>
&nbsp;                            classFileVersion,
&nbsp;                            auxiliaryTypeNamingStrategy,
&nbsp;                            typeInitializer,
&nbsp;                            auxiliaryClassFileVersion,
&nbsp;                            frameGeneration,
<b class="fc">&nbsp;                            RandomString.make());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for creating a {@link net.bytebuddy.implementation.Implementation.Context.Default}
&nbsp;                 * that uses a given suffix for accessors.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithFixedSuffix implements ExtractableView.Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The suffix to use.
&nbsp;                     */
&nbsp;                    private final String suffix;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a factory for an implementation context with a fixed suffix.
&nbsp;                     *
&nbsp;                     * @param suffix The suffix to use.
&nbsp;                     */
<b class="fc">&nbsp;                    public WithFixedSuffix(String suffix) {</b>
<b class="fc">&nbsp;                        this.suffix = suffix;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @Deprecated
&nbsp;                    public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                                AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                TypeInitializer typeInitializer,
&nbsp;                                                ClassFileVersion classFileVersion,
&nbsp;                                                ClassFileVersion auxiliaryClassFileVersion) {
<b class="nc">&nbsp;                        return make(instrumentedType,</b>
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                typeInitializer,
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryClassFileVersion,
<b class="nc">&nbsp;                                classFileVersion.isAtLeast(ClassFileVersion.JAVA_V6)</b>
<b class="nc">&nbsp;                                        ? FrameGeneration.GENERATE</b>
<b class="nc">&nbsp;                                        : FrameGeneration.DISABLED);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ExtractableView make(TypeDescription instrumentedType,
&nbsp;                                                AuxiliaryType.NamingStrategy auxiliaryTypeNamingStrategy,
&nbsp;                                                TypeInitializer typeInitializer,
&nbsp;                                                ClassFileVersion classFileVersion,
&nbsp;                                                ClassFileVersion auxiliaryClassFileVersion,
&nbsp;                                                FrameGeneration frameGeneration) {
<b class="fc">&nbsp;                        return new Default(instrumentedType,</b>
&nbsp;                                classFileVersion,
&nbsp;                                auxiliaryTypeNamingStrategy,
&nbsp;                                typeInitializer,
&nbsp;                                auxiliaryClassFileVersion,
&nbsp;                                frameGeneration,
&nbsp;                                suffix);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A compound implementation that allows to combine several implementations.
&nbsp;     * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;     * Note that the combination of two implementation might break the contract for implementing
&nbsp;     * {@link java.lang.Object#equals(Object)} and {@link Object#hashCode()} as described for
&nbsp;     * {@link Implementation}.
&nbsp;     *
&nbsp;     * @see Implementation
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;    class Compound implements Implementation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * All implementation that are represented by this compound implementation.
&nbsp;         */
&nbsp;        private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable compound implementation.
&nbsp;         *
&nbsp;         * @param implementation The implementations to combine in their order.
&nbsp;         */
&nbsp;        public Compound(Implementation... implementation) {
<b class="fc">&nbsp;            this(Arrays.asList(implementation));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable compound implementation.
&nbsp;         *
&nbsp;         * @param implementations The implementations to combine in their order.
&nbsp;         */
<b class="fc">&nbsp;        public Compound(List&lt;? extends Implementation&gt; implementations) {</b>
<b class="fc">&nbsp;            this.implementations = new ArrayList&lt;Implementation&gt;();</b>
<b class="fc">&nbsp;            for (Implementation implementation : implementations) {</b>
<b class="fc">&nbsp;                if (implementation instanceof Compound.Composable) {</b>
<b class="nc">&nbsp;                    this.implementations.addAll(((Compound.Composable) implementation).implementations);</b>
<b class="nc">&nbsp;                    this.implementations.add(((Compound.Composable) implementation).composable);</b>
<b class="fc">&nbsp;                } else if (implementation instanceof Compound) {</b>
<b class="fc">&nbsp;                    this.implementations.addAll(((Compound) implementation).implementations);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    this.implementations.add(implementation);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            for (Implementation implementation : implementations) {</b>
<b class="fc">&nbsp;                instrumentedType = implementation.prepare(instrumentedType);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[implementations.size()];</b>
<b class="fc">&nbsp;            int index = 0;</b>
<b class="fc">&nbsp;            for (Implementation implementation : implementations) {</b>
<b class="fc">&nbsp;                byteCodeAppender[index++] = implementation.appender(implementationTarget);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new ByteCodeAppender.Compound(byteCodeAppender);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound implementation that allows to combine several implementations and that is {@link Implementation.Composable}.
&nbsp;         * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;         * Note that the combination of two implementation might break the contract for implementing
&nbsp;         * {@link java.lang.Object#equals(Object)} and {@link Object#hashCode()} as described for
&nbsp;         * {@link Implementation}.
&nbsp;         *
&nbsp;         * @see Implementation
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;        public static class Composable implements Implementation.Composable {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The composable implementation that is applied last.
&nbsp;             */
&nbsp;            private final Implementation.Composable composable;
&nbsp;
&nbsp;            /**
&nbsp;             * All implementation that are represented by this compound implementation.
&nbsp;             */
&nbsp;            private final List&lt;Implementation&gt; implementations;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound composable.
&nbsp;             *
&nbsp;             * @param implementation An implementation that is represented by this compound implementation prior to the composable.
&nbsp;             * @param composable     The composable implementation that is applied last.
&nbsp;             */
&nbsp;            public Composable(Implementation implementation, Implementation.Composable composable) {
<b class="fc">&nbsp;                this(Collections.singletonList(implementation), composable);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound composable.
&nbsp;             *
&nbsp;             * @param implementations All implementation that are represented by this compound implementation excluding the composable.
&nbsp;             * @param composable      The composable implementation that is applied last.
&nbsp;             */
<b class="fc">&nbsp;            public Composable(List&lt;? extends Implementation&gt; implementations, Implementation.Composable composable) {</b>
<b class="fc">&nbsp;                this.implementations = new ArrayList&lt;Implementation&gt;();</b>
<b class="fc">&nbsp;                for (Implementation implementation : implementations) {</b>
<b class="fc">&nbsp;                    if (implementation instanceof Compound.Composable) {</b>
<b class="nc">&nbsp;                        this.implementations.addAll(((Compound.Composable) implementation).implementations);</b>
<b class="nc">&nbsp;                        this.implementations.add(((Compound.Composable) implementation).composable);</b>
<b class="fc">&nbsp;                    } else if (implementation instanceof Compound) {</b>
<b class="nc">&nbsp;                        this.implementations.addAll(((Compound) implementation).implementations);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        this.implementations.add(implementation);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (composable instanceof Compound.Composable) {</b>
<b class="fc">&nbsp;                    this.implementations.addAll(((Compound.Composable) composable).implementations);</b>
<b class="fc">&nbsp;                    this.composable = ((Compound.Composable) composable).composable;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    this.composable = composable;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                for (Implementation implementation : implementations) {</b>
<b class="fc">&nbsp;                    instrumentedType = implementation.prepare(instrumentedType);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return composable.prepare(instrumentedType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                ByteCodeAppender[] byteCodeAppender = new ByteCodeAppender[implementations.size() + 1];</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                for (Implementation implementation : implementations) {</b>
<b class="fc">&nbsp;                    byteCodeAppender[index++] = implementation.appender(implementationTarget);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                byteCodeAppender[index] = composable.appender(implementationTarget);</b>
<b class="fc">&nbsp;                return new ByteCodeAppender.Compound(byteCodeAppender);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation andThen(Implementation implementation) {
<b class="fc">&nbsp;                return new Compound(CompoundList.of(implementations, composable.andThen(implementation)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Implementation.Composable andThen(Implementation.Composable implementation) {
<b class="fc">&nbsp;                return new Compound.Composable(implementations, composable.andThen(implementation));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A simple implementation that does not register any members with the instrumented type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Simple implements Implementation {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that no additional local variable slots are required.
&nbsp;         */
&nbsp;        private static final int NO_ADDITIONAL_VARIABLES = 0;
&nbsp;
&nbsp;        /**
&nbsp;         * The byte code appender to emmit.
&nbsp;         */
&nbsp;        private final ByteCodeAppender byteCodeAppender;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new simple implementation for the given byte code appenders.
&nbsp;         *
&nbsp;         * @param byteCodeAppender The byte code appenders to apply in their order of application.
&nbsp;         */
<b class="fc">&nbsp;        public Simple(ByteCodeAppender... byteCodeAppender) {</b>
<b class="fc">&nbsp;            this.byteCodeAppender = new ByteCodeAppender.Compound(byteCodeAppender);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new simple instrumentation for the given stack manipulations which are summarized in a
&nbsp;         * byte code appender that defines any requested method by these manipulations.
&nbsp;         *
&nbsp;         * @param stackManipulation The stack manipulation to apply in their order of application.
&nbsp;         */
<b class="fc">&nbsp;        public Simple(StackManipulation... stackManipulation) {</b>
<b class="fc">&nbsp;            byteCodeAppender = new ByteCodeAppender.Simple(stackManipulation);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a simple implementation that applies the given dispatcher without defining additional local variables.
&nbsp;         *
&nbsp;         * @param dispatcher The dispatcher to use.
&nbsp;         * @return An implementation for the supplied dispatcher.
&nbsp;         */
&nbsp;        public static Implementation of(Dispatcher dispatcher) {
<b class="fc">&nbsp;            return of(dispatcher, NO_ADDITIONAL_VARIABLES);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a simple implementation that applies the given dispatcher.
&nbsp;         *
&nbsp;         * @param dispatcher               The dispatcher to use.
&nbsp;         * @param additionalVariableLength The amount of additional slots required in the local variable array.
&nbsp;         * @return An implementation for the supplied dispatcher.
&nbsp;         */
&nbsp;        public static Implementation of(Dispatcher dispatcher, int additionalVariableLength) {
<b class="fc">&nbsp;            return of(dispatcher, NoOp.INSTANCE, additionalVariableLength);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a simple implementation that applies the given dispatcher without defining additional local variables.
&nbsp;         *
&nbsp;         * @param dispatcher  The dispatcher to use.
&nbsp;         * @param prepareable A preparation of the instrumented type.
&nbsp;         * @return An implementation for the supplied dispatcher.
&nbsp;         */
&nbsp;        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable) {
<b class="nc">&nbsp;            return of(dispatcher, prepareable, NO_ADDITIONAL_VARIABLES);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a simple implementation that applies the given dispatcher.
&nbsp;         *
&nbsp;         * @param dispatcher               The dispatcher to use.
&nbsp;         * @param prepareable              A preparation of the instrumented type.
&nbsp;         * @param additionalVariableLength The amount of additional slots required in the local variable array.
&nbsp;         * @return An implementation for the supplied dispatcher.
&nbsp;         */
&nbsp;        public static Implementation of(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {
<b class="fc">&nbsp;            if (additionalVariableLength &lt; NO_ADDITIONAL_VARIABLES) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Additional variable length cannot be negative: &quot; + additionalVariableLength);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new ForDispatcher(dispatcher, prepareable, additionalVariableLength);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return byteCodeAppender;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for a simple {@link Implementation}, typically implemented as a lambda expression.
&nbsp;         */
&nbsp;        public interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a stack manipulation from a simple method dispatch.
&nbsp;             *
&nbsp;             * @param implementationTarget The implementation target to use.
&nbsp;             * @param instrumentedMethod   The instrumented method.
&nbsp;             * @return The stack manipulation to apply.
&nbsp;             */
&nbsp;            StackManipulation apply(Target implementationTarget, MethodDescription instrumentedMethod);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link ByteCodeAppender} for a dispatcher.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        protected static class ForDispatcher implements Implementation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The dispatcher to use.
&nbsp;             */
&nbsp;            private final Dispatcher dispatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * A preparation of the instrumented type.
&nbsp;             */
&nbsp;            private final InstrumentedType.Prepareable prepareable;
&nbsp;
&nbsp;            /**
&nbsp;             * The additional length of the local variable array.
&nbsp;             */
&nbsp;            private final int additionalVariableLength;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new byte code appender for a dispatcher.
&nbsp;             *
&nbsp;             * @param dispatcher               The dispatcher to use.
&nbsp;             * @param prepareable              A preparation of the instrumented type.
&nbsp;             * @param additionalVariableLength The additional length of the local variable array.
&nbsp;             */
<b class="fc">&nbsp;            protected ForDispatcher(Dispatcher dispatcher, InstrumentedType.Prepareable prepareable, int additionalVariableLength) {</b>
<b class="fc">&nbsp;                this.dispatcher = dispatcher;</b>
<b class="fc">&nbsp;                this.prepareable = prepareable;</b>
<b class="fc">&nbsp;                this.additionalVariableLength = additionalVariableLength;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                return prepareable.prepare(instrumentedType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                return new Appender(implementationTarget);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An appender for a dispatcher-based simple implementation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation target.
&nbsp;                 */
&nbsp;                private final Target implementationTarget;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new appender.
&nbsp;                 *
&nbsp;                 * @param implementationTarget The implementation target.
&nbsp;                 */
<b class="fc">&nbsp;                protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;                    this.implementationTarget = implementationTarget;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return new Size(dispatcher.apply(implementationTarget, instrumentedMethod)</b>
<b class="fc">&nbsp;                            .apply(methodVisitor, implementationContext)</b>
<b class="fc">&nbsp;                            .getMaximalSize(), instrumentedMethod.getStackSize() + additionalVariableLength);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
