


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AnnotationAppender</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.attribute</a>
</div>

<h1>Coverage Summary for Class: AnnotationAppender (net.bytebuddy.implementation.attribute)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationAppender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationAppender$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.3%
  </span>
  <span class="absValue">
    (41/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$ForTypeAnnotations</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (67/67)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$MockitoMock$1046379552</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$MockitoMock$1046379552$auxiliary$2n162syQ</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$MockitoMock$1046379552$auxiliary$6L43B3qw</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$MockitoMock$188370391</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$MockitoMock$188370391$auxiliary$GSgUrNwh</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$MockitoMock$188370391$auxiliary$mOngw9Xe</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$OnField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$OnMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$OnMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$OnRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationAppender$Target$OnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (41/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.5%
  </span>
  <span class="absValue">
    (131/133)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.attribute;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.*;
&nbsp;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Annotation appenders are capable of writing annotations to a specified target.
&nbsp; */
&nbsp;public interface AnnotationAppender {
&nbsp;
&nbsp;    /**
&nbsp;     * A constant for informing ASM over ignoring a given name.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    String NO_NAME = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Writes the given annotation to the target that this appender represents.
&nbsp;     *
&nbsp;     * @param annotationDescription The annotation to be written.
&nbsp;     * @param annotationValueFilter The annotation value filter to use.
&nbsp;     * @return Usually {@code this} or any other annotation appender capable of writing another annotation to the specified target.
&nbsp;     */
&nbsp;    AnnotationAppender append(AnnotationDescription annotationDescription, AnnotationValueFilter annotationValueFilter);
&nbsp;
&nbsp;    /**
&nbsp;     * Writes the given type annotation to the target that this appender represents.
&nbsp;     *
&nbsp;     * @param annotationDescription The annotation to be written.
&nbsp;     * @param annotationValueFilter The annotation value filter to use.
&nbsp;     * @param typeReference         The type variable&#39;s type reference.
&nbsp;     * @param typePath              The type variable&#39;s type path.
&nbsp;     * @return Usually {@code this} or any other annotation appender capable of writing another annotation to the specified target.
&nbsp;     */
&nbsp;    AnnotationAppender append(AnnotationDescription annotationDescription, AnnotationValueFilter annotationValueFilter, int typeReference, String typePath);
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a target for an annotation writing process.
&nbsp;     */
&nbsp;    interface Target {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation visitor for writing the specified annotation.
&nbsp;         *
&nbsp;         * @param annotationTypeDescriptor The type descriptor for the annotation to be written.
&nbsp;         * @param visible                  {@code true} if the annotation is to be visible at runtime.
&nbsp;         * @return An annotation visitor for consuming the specified annotation.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation visitor for writing the specified type annotation.
&nbsp;         *
&nbsp;         * @param annotationTypeDescriptor The type descriptor for the annotation to be written.
&nbsp;         * @param visible                  {@code true} if the annotation is to be visible at runtime.
&nbsp;         * @param typeReference            The type annotation&#39;s type reference.
&nbsp;         * @param typePath                 The type annotation&#39;s type path.
&nbsp;         * @return An annotation visitor for consuming the specified annotation.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible, int typeReference, String typePath);
&nbsp;
&nbsp;        /**
&nbsp;         * Target for an annotation that is written to a Java type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class OnType implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The class visitor to write the annotation to.
&nbsp;             */
&nbsp;            private final ClassVisitor classVisitor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new wrapper for a Java type.
&nbsp;             *
&nbsp;             * @param classVisitor The ASM class visitor to which the annotations are appended to.
&nbsp;             */
<b class="fc">&nbsp;            public OnType(ClassVisitor classVisitor) {</b>
<b class="fc">&nbsp;                this.classVisitor = classVisitor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible) {
<b class="fc">&nbsp;                return classVisitor.visitAnnotation(annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible, int typeReference, String typePath) {
<b class="fc">&nbsp;                return classVisitor.visitTypeAnnotation(typeReference, TypePath.fromString(typePath), annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Target for an annotation that is written to a Java field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class OnField implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The field visitor to write the annotation to.
&nbsp;             */
&nbsp;            private final FieldVisitor fieldVisitor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new wrapper for a Java field.
&nbsp;             *
&nbsp;             * @param fieldVisitor The ASM field visitor to which the annotations are appended to.
&nbsp;             */
<b class="fc">&nbsp;            public OnField(FieldVisitor fieldVisitor) {</b>
<b class="fc">&nbsp;                this.fieldVisitor = fieldVisitor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible) {
<b class="fc">&nbsp;                return fieldVisitor.visitAnnotation(annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible, int typeReference, String typePath) {
<b class="fc">&nbsp;                return fieldVisitor.visitTypeAnnotation(typeReference, TypePath.fromString(typePath), annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Target for an annotation that is written to a Java method or constructor.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class OnMethod implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The method visitor to write the annotation to.
&nbsp;             */
&nbsp;            private final MethodVisitor methodVisitor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new wrapper for a Java method or constructor.
&nbsp;             *
&nbsp;             * @param methodVisitor The ASM method visitor to which the annotations are appended to.
&nbsp;             */
<b class="fc">&nbsp;            public OnMethod(MethodVisitor methodVisitor) {</b>
<b class="fc">&nbsp;                this.methodVisitor = methodVisitor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible) {
<b class="fc">&nbsp;                return methodVisitor.visitAnnotation(annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible, int typeReference, String typePath) {
<b class="fc">&nbsp;                return methodVisitor.visitTypeAnnotation(typeReference, TypePath.fromString(typePath), annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Target for an annotation that is written to a Java method or constructor parameter.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class OnMethodParameter implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The method visitor to write the annotation to.
&nbsp;             */
&nbsp;            private final MethodVisitor methodVisitor;
&nbsp;
&nbsp;            /**
&nbsp;             * The method parameter index to write the annotation to.
&nbsp;             */
&nbsp;            private final int parameterIndex;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new wrapper for a Java method or constructor.
&nbsp;             *
&nbsp;             * @param methodVisitor  The ASM method visitor to which the annotations are appended to.
&nbsp;             * @param parameterIndex The index of the method parameter.
&nbsp;             */
<b class="fc">&nbsp;            public OnMethodParameter(MethodVisitor methodVisitor, int parameterIndex) {</b>
<b class="fc">&nbsp;                this.methodVisitor = methodVisitor;</b>
<b class="fc">&nbsp;                this.parameterIndex = parameterIndex;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible) {
<b class="fc">&nbsp;                return methodVisitor.visitParameterAnnotation(parameterIndex, annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible, int typeReference, String typePath) {
<b class="fc">&nbsp;                return methodVisitor.visitTypeAnnotation(typeReference, TypePath.fromString(typePath), annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Target for an annotation that is written to a Java record component.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class OnRecordComponent implements Target {
&nbsp;
&nbsp;            /**
&nbsp;             * The record component visitor to write the annotation to.
&nbsp;             */
&nbsp;            private final RecordComponentVisitor recordComponentVisitor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new wrapper for a Java record component.
&nbsp;             *
&nbsp;             * @param recordComponentVisitor The record component visitor to write the annotation to.
&nbsp;             */
<b class="fc">&nbsp;            public OnRecordComponent(RecordComponentVisitor recordComponentVisitor) {</b>
<b class="fc">&nbsp;                this.recordComponentVisitor = recordComponentVisitor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible) {
<b class="fc">&nbsp;                return recordComponentVisitor.visitAnnotation(annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public AnnotationVisitor visit(String annotationTypeDescriptor, boolean visible, int typeReference, String typePath) {
<b class="fc">&nbsp;                return recordComponentVisitor.visitTypeAnnotation(typeReference, TypePath.fromString(typePath), annotationTypeDescriptor, visible);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A default implementation for an annotation appender that writes annotations to a given byte consumer
&nbsp;     * represented by an ASM {@link org.objectweb.asm.AnnotationVisitor}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Default implements AnnotationAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The target onto which an annotation write process is to be applied.
&nbsp;         */
&nbsp;        private final Target target;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default annotation appender.
&nbsp;         *
&nbsp;         * @param target The target to which annotations are written to.
&nbsp;         */
<b class="fc">&nbsp;        public Default(Target target) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Handles the writing of a single annotation to an annotation visitor.
&nbsp;         *
&nbsp;         * @param annotationVisitor     The annotation visitor the write process is to be applied on.
&nbsp;         * @param annotation            The annotation to be written.
&nbsp;         * @param annotationValueFilter The value filter to apply for discovering which values of an annotation should be written.
&nbsp;         */
&nbsp;        private static void handle(AnnotationVisitor annotationVisitor, AnnotationDescription annotation, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : annotation.getAnnotationType().getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                if (annotationValueFilter.isRelevant(annotation, methodDescription)) {</b>
<b class="fc">&nbsp;                    apply(annotationVisitor, methodDescription.getReturnType().asErasure(), methodDescription.getName(), annotation.getValue(methodDescription).resolve());</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            annotationVisitor.visitEnd();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Performs the writing of a given annotation value to an annotation visitor.
&nbsp;         *
&nbsp;         * @param annotationVisitor The annotation visitor the write process is to be applied on.
&nbsp;         * @param valueType         The type of the annotation.
&nbsp;         * @param name              The name of the annotation type or {@code null} if no name is available..
&nbsp;         * @param value             The annotation&#39;s value.
&nbsp;         */
&nbsp;        public static void apply(AnnotationVisitor annotationVisitor, TypeDescription valueType, @MaybeNull String name, Object value) {
<b class="fc">&nbsp;            if (valueType.isArray()) { // The Android emulator reads annotation arrays as annotation types. Therefore, this check needs to come first.</b>
<b class="fc">&nbsp;                AnnotationVisitor arrayVisitor = annotationVisitor.visitArray(name);</b>
<b class="fc">&nbsp;                int length = Array.getLength(value);</b>
<b class="fc">&nbsp;                TypeDescription componentType = valueType.getComponentType();</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; length; index++) {</b>
<b class="fc">&nbsp;                    apply(arrayVisitor, componentType, NO_NAME, Array.get(value, index));</b>
&nbsp;                }
<b class="fc">&nbsp;                arrayVisitor.visitEnd();</b>
<b class="fc">&nbsp;            } else if (valueType.isAnnotation()) {</b>
<b class="fc">&nbsp;                handle(annotationVisitor.visitAnnotation(name, valueType.getDescriptor()), (AnnotationDescription) value, AnnotationValueFilter.Default.APPEND_DEFAULTS);</b>
<b class="fc">&nbsp;            } else if (valueType.isEnum()) {</b>
<b class="fc">&nbsp;                annotationVisitor.visitEnum(name, valueType.getDescriptor(), ((EnumerationDescription) value).getValue());</b>
<b class="fc">&nbsp;            } else if (valueType.represents(Class.class)) {</b>
<b class="fc">&nbsp;                annotationVisitor.visit(name, Type.getType(((TypeDescription) value).getDescriptor()));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                annotationVisitor.visit(name, value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationAppender append(AnnotationDescription annotationDescription, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            switch (annotationDescription.getRetention()) {</b>
&nbsp;                case RUNTIME:
<b class="fc">&nbsp;                    doAppend(annotationDescription, true, annotationValueFilter);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case CLASS:
<b class="fc">&nbsp;                    doAppend(annotationDescription, false, annotationValueFilter);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case SOURCE:
<b class="fc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected retention policy: &quot; + annotationDescription.getRetention());</b>
&nbsp;            }
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Tries to append a given annotation by reflectively reading an annotation.
&nbsp;         *
&nbsp;         * @param annotation            The annotation to be written.
&nbsp;         * @param visible               {@code true} if this annotation should be treated as visible at runtime.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         */
&nbsp;        private void doAppend(AnnotationDescription annotation, boolean visible, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            AnnotationVisitor annotationVisitor = target.visit(annotation.getAnnotationType().getDescriptor(), visible);</b>
<b class="fc">&nbsp;            if (annotationVisitor != null) {</b>
<b class="fc">&nbsp;                handle(annotationVisitor, annotation, annotationValueFilter);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationAppender append(AnnotationDescription annotationDescription, AnnotationValueFilter annotationValueFilter, int typeReference, String typePath) {
<b class="fc">&nbsp;            switch (annotationDescription.getRetention()) {</b>
&nbsp;                case RUNTIME:
<b class="fc">&nbsp;                    doAppend(annotationDescription, true, annotationValueFilter, typeReference, typePath);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case CLASS:
<b class="fc">&nbsp;                    doAppend(annotationDescription, false, annotationValueFilter, typeReference, typePath);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                case SOURCE:
<b class="fc">&nbsp;                    break;</b>
&nbsp;                default:
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected retention policy: &quot; + annotationDescription.getRetention());</b>
&nbsp;            }
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Tries to append a given annotation by reflectively reading an annotation.
&nbsp;         *
&nbsp;         * @param annotation            The annotation to be written.
&nbsp;         * @param visible               {@code true} if this annotation should be treated as visible at runtime.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @param typeReference         The type annotation&#39;s type reference.
&nbsp;         * @param typePath              The type annotation&#39;s type path.
&nbsp;         */
&nbsp;        private void doAppend(AnnotationDescription annotation,
&nbsp;                              boolean visible,
&nbsp;                              AnnotationValueFilter annotationValueFilter,
&nbsp;                              int typeReference,
&nbsp;                              String typePath) {
<b class="fc">&nbsp;            AnnotationVisitor annotationVisitor = target.visit(annotation.getAnnotationType().getDescriptor(), visible, typeReference, typePath);</b>
<b class="fc">&nbsp;            if (annotationVisitor != null) {</b>
<b class="fc">&nbsp;                handle(annotationVisitor, annotation, annotationValueFilter);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type visitor that visits all type annotations of a generic type and writes any discovered annotation to a
&nbsp;     * supplied {@link AnnotationAppender}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForTypeAnnotations implements TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that type variables type annotations are written on a Java type.
&nbsp;         */
&nbsp;        public static final boolean VARIABLE_ON_TYPE = true;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that type variables type annotations are written on a Java method or constructor.
&nbsp;         */
&nbsp;        public static final boolean VARIABLE_ON_INVOKEABLE = false;
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an empty type path.
&nbsp;         */
&nbsp;        private static final String EMPTY_TYPE_PATH = &quot;&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a step to a component type within a type path.
&nbsp;         */
&nbsp;        private static final char COMPONENT_TYPE_PATH = &#39;[&#39;;
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a wildcard type step within a type path.
&nbsp;         */
&nbsp;        private static final char WILDCARD_TYPE_PATH = &#39;*&#39;;
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a (reversed) type step to an inner class within a type path.
&nbsp;         */
&nbsp;        private static final char INNER_CLASS_PATH = &#39;.&#39;;
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an index type delimiter within a type path.
&nbsp;         */
&nbsp;        private static final char INDEXED_TYPE_DELIMITER = &#39;;&#39;;
&nbsp;
&nbsp;        /**
&nbsp;         * The index that indicates that super type type annotations are written onto a super class.
&nbsp;         */
&nbsp;        private static final int SUPER_CLASS_INDEX = -1;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation appender to use.
&nbsp;         */
&nbsp;        private final AnnotationAppender annotationAppender;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation value filter to use.
&nbsp;         */
&nbsp;        private final AnnotationValueFilter annotationValueFilter;
&nbsp;
&nbsp;        /**
&nbsp;         * The type reference to use.
&nbsp;         */
&nbsp;        private final int typeReference;
&nbsp;
&nbsp;        /**
&nbsp;         * The type path to use.
&nbsp;         */
&nbsp;        private final String typePath;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type annotation appending visitor for an empty type path.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to use.
&nbsp;         * @param annotationValueFilter The annotation value filter to use.
&nbsp;         * @param typeReference         The type reference to use.
&nbsp;         */
&nbsp;        protected ForTypeAnnotations(AnnotationAppender annotationAppender, AnnotationValueFilter annotationValueFilter, TypeReference typeReference) {
<b class="fc">&nbsp;            this(annotationAppender, annotationValueFilter, typeReference.getValue(), EMPTY_TYPE_PATH);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type annotation appending visitor.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to use.
&nbsp;         * @param annotationValueFilter The annotation value filter to use.
&nbsp;         * @param typeReference         The type reference to use.
&nbsp;         * @param typePath              The type path to use.
&nbsp;         */
<b class="fc">&nbsp;        protected ForTypeAnnotations(AnnotationAppender annotationAppender, AnnotationValueFilter annotationValueFilter, int typeReference, String typePath) {</b>
<b class="fc">&nbsp;            this.annotationAppender = annotationAppender;</b>
<b class="fc">&nbsp;            this.annotationValueFilter = annotationValueFilter;</b>
<b class="fc">&nbsp;            this.typeReference = typeReference;</b>
<b class="fc">&nbsp;            this.typePath = typePath;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for a type annotations of a super class type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @return A visitor for appending type annotations of a super class.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofSuperClass(AnnotationAppender annotationAppender,
&nbsp;                                                                                       AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newSuperTypeReference(SUPER_CLASS_INDEX));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for type annotations of an interface type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @param index                 The index of the interface type.
&nbsp;         * @return A visitor for appending type annotations of an interface type.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofInterfaceType(AnnotationAppender annotationAppender,
&nbsp;                                                                                          AnnotationValueFilter annotationValueFilter,
&nbsp;                                                                                          int index) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newSuperTypeReference(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for type annotations of a field&#39;s type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @return A visitor for appending type annotations of a field&#39;s type.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofFieldType(AnnotationAppender annotationAppender,
&nbsp;                                                                                      AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newTypeReference(TypeReference.FIELD));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for type annotations of a method&#39;s return type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @return A visitor for appending type annotations of a method&#39;s return type.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofMethodReturnType(AnnotationAppender annotationAppender,
&nbsp;                                                                                             AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newTypeReference(TypeReference.METHOD_RETURN));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for type annotations of a method&#39;s parameter type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @param index                 The parameter index.
&nbsp;         * @return A visitor for appending type annotations of a method&#39;s parameter type.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofMethodParameterType(AnnotationAppender annotationAppender,
&nbsp;                                                                                                AnnotationValueFilter annotationValueFilter,
&nbsp;                                                                                                int index) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newFormalParameterReference(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for type annotations of a method&#39;s exception type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @param index                 The exception type&#39;s index.
&nbsp;         * @return A visitor for appending type annotations of a method&#39;s exception type.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofExceptionType(AnnotationAppender annotationAppender,
&nbsp;                                                                                          AnnotationValueFilter annotationValueFilter,
&nbsp;                                                                                          int index) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newExceptionReference(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type annotation appender for type annotations of a method&#39;s receiver type.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @return A visitor for appending type annotations of a method&#39;s receiver type.
&nbsp;         */
&nbsp;        public static TypeDescription.Generic.Visitor&lt;AnnotationAppender&gt; ofReceiverType(AnnotationAppender annotationAppender,
&nbsp;                                                                                         AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            return new ForTypeAnnotations(annotationAppender, annotationValueFilter, TypeReference.newTypeReference(TypeReference.METHOD_RECEIVER));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Appends all supplied type variables to the supplied method appender.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @param variableOnType        {@code true} if the type variables are declared by a type, {@code false} if they are declared by a method.
&nbsp;         * @param typeVariables         The type variables to append.
&nbsp;         * @return The resulting annotation appender.
&nbsp;         */
&nbsp;        public static AnnotationAppender ofTypeVariable(AnnotationAppender annotationAppender,
&nbsp;                                                        AnnotationValueFilter annotationValueFilter,
&nbsp;                                                        boolean variableOnType,
&nbsp;                                                        List&lt;? extends TypeDescription.Generic&gt; typeVariables) {
<b class="fc">&nbsp;            return ofTypeVariable(annotationAppender, annotationValueFilter, variableOnType, 0, typeVariables);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Appends all supplied type variables to the supplied method appender.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to write any type annotation to.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply.
&nbsp;         * @param variableOnType        {@code true} if the type variables are declared by a type, {@code false} if they are declared by a method.
&nbsp;         * @param subListIndex          The index of the first type variable to append. All previous type variables are ignored.
&nbsp;         * @param typeVariables         The type variables to append.
&nbsp;         * @return The resulting annotation appender.
&nbsp;         */
&nbsp;        public static AnnotationAppender ofTypeVariable(AnnotationAppender annotationAppender,
&nbsp;                                                        AnnotationValueFilter annotationValueFilter,
&nbsp;                                                        boolean variableOnType,
&nbsp;                                                        int subListIndex,
&nbsp;                                                        List&lt;? extends TypeDescription.Generic&gt; typeVariables) {
<b class="fc">&nbsp;            int typeVariableIndex = subListIndex, variableBaseReference, variableBoundBaseBase;</b>
<b class="fc">&nbsp;            if (variableOnType) {</b>
<b class="fc">&nbsp;                variableBaseReference = TypeReference.CLASS_TYPE_PARAMETER;</b>
<b class="fc">&nbsp;                variableBoundBaseBase = TypeReference.CLASS_TYPE_PARAMETER_BOUND;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                variableBaseReference = TypeReference.METHOD_TYPE_PARAMETER;</b>
<b class="fc">&nbsp;                variableBoundBaseBase = TypeReference.METHOD_TYPE_PARAMETER_BOUND;</b>
&nbsp;            }
<b class="fc">&nbsp;            for (TypeDescription.Generic typeVariable : typeVariables.subList(subListIndex, typeVariables.size())) {</b>
<b class="fc">&nbsp;                int typeReference = TypeReference.newTypeParameterReference(variableBaseReference, typeVariableIndex).getValue();</b>
<b class="fc">&nbsp;                for (AnnotationDescription annotationDescription : typeVariable.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                    annotationAppender = annotationAppender.append(annotationDescription, annotationValueFilter, typeReference, EMPTY_TYPE_PATH);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                int boundIndex = !typeVariable.getUpperBounds().get(0).getSort().isTypeVariable() &amp;&amp; typeVariable.getUpperBounds().get(0).isInterface()</b>
<b class="fc">&nbsp;                        ? 1</b>
<b class="fc">&nbsp;                        : 0;</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic typeBound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                    annotationAppender = typeBound.accept(new ForTypeAnnotations(annotationAppender,</b>
&nbsp;                            annotationValueFilter,
<b class="fc">&nbsp;                            TypeReference.newTypeParameterBoundReference(variableBoundBaseBase, typeVariableIndex, boundIndex++)));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                typeVariableIndex++;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return annotationAppender;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public AnnotationAppender onGenericArray(TypeDescription.Generic genericArray) {
<b class="fc">&nbsp;            return genericArray.getComponentType().accept(new ForTypeAnnotations(apply(genericArray, typePath),</b>
&nbsp;                    annotationValueFilter,
&nbsp;                    typeReference,
&nbsp;                    typePath + COMPONENT_TYPE_PATH));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationAppender onWildcard(TypeDescription.Generic wildcard) {
<b class="fc">&nbsp;            TypeList.Generic lowerBounds = wildcard.getLowerBounds();</b>
<b class="fc">&nbsp;            return (lowerBounds.isEmpty()</b>
<b class="fc">&nbsp;                    ? wildcard.getUpperBounds().getOnly()</b>
<b class="fc">&nbsp;                    : lowerBounds.getOnly()).accept(new ForTypeAnnotations(apply(wildcard, typePath), annotationValueFilter, typeReference, typePath + WILDCARD_TYPE_PATH));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationAppender onParameterizedType(TypeDescription.Generic parameterizedType) {
<b class="fc">&nbsp;            StringBuilder typePath = new StringBuilder(this.typePath);</b>
<b class="fc">&nbsp;            for (int index = 0; index &lt; parameterizedType.asErasure().getInnerClassCount(); index++) {</b>
<b class="fc">&nbsp;                typePath = typePath.append(INNER_CLASS_PATH);</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationAppender annotationAppender = apply(parameterizedType, typePath.toString());</b>
<b class="fc">&nbsp;            TypeDescription.Generic ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;            if (ownerType != null) {</b>
<b class="fc">&nbsp;                annotationAppender = ownerType.accept(new ForTypeAnnotations(annotationAppender,</b>
&nbsp;                        annotationValueFilter,
&nbsp;                        typeReference,
&nbsp;                        this.typePath));
&nbsp;            }
<b class="fc">&nbsp;            int index = 0;</b>
<b class="fc">&nbsp;            for (TypeDescription.Generic typeArgument : parameterizedType.getTypeArguments()) {</b>
<b class="fc">&nbsp;                annotationAppender = typeArgument.accept(new ForTypeAnnotations(annotationAppender,</b>
&nbsp;                        annotationValueFilter,
&nbsp;                        typeReference,
<b class="fc">&nbsp;                        typePath.toString() + index++ + INDEXED_TYPE_DELIMITER));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return annotationAppender;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationAppender onTypeVariable(TypeDescription.Generic typeVariable) {
<b class="fc">&nbsp;            return apply(typeVariable, typePath);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationAppender onNonGenericType(TypeDescription.Generic typeDescription) {
<b class="fc">&nbsp;            StringBuilder typePath = new StringBuilder(this.typePath);</b>
<b class="fc">&nbsp;            for (int index = 0; index &lt; typeDescription.asErasure().getInnerClassCount(); index++) {</b>
<b class="fc">&nbsp;                typePath = typePath.append(INNER_CLASS_PATH);</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationAppender annotationAppender = apply(typeDescription, typePath.toString());</b>
<b class="fc">&nbsp;            TypeDescription.Generic componentType = typeDescription.getComponentType();</b>
<b class="fc">&nbsp;            if (componentType != null) {</b>
<b class="fc">&nbsp;                annotationAppender = componentType.accept(new ForTypeAnnotations(annotationAppender,</b>
&nbsp;                        annotationValueFilter,
&nbsp;                        typeReference,
&nbsp;                        this.typePath + COMPONENT_TYPE_PATH)); // Impossible to be inner class
&nbsp;            }
<b class="fc">&nbsp;            return annotationAppender;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Writes all annotations of the supplied type to this instance&#39;s annotation appender.
&nbsp;         *
&nbsp;         * @param typeDescription The type of what all annotations should be written of.
&nbsp;         * @param typePath        The type path to use.
&nbsp;         * @return The resulting annotation appender.
&nbsp;         */
&nbsp;        private AnnotationAppender apply(TypeDescription.Generic typeDescription, String typePath) {
<b class="fc">&nbsp;            AnnotationAppender annotationAppender = this.annotationAppender;</b>
<b class="fc">&nbsp;            for (AnnotationDescription annotationDescription : typeDescription.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                annotationAppender = annotationAppender.append(annotationDescription, annotationValueFilter, typeReference, typePath);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return annotationAppender;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
