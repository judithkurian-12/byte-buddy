


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodAttributeAppender</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.attribute</a>
</div>

<h1>Coverage Summary for Class: MethodAttributeAppender (net.bytebuddy.implementation.attribute)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">MethodAttributeAppender$1</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Explicit$Target</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Explicit$Target$OnMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Explicit$Target$OnMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Factory</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Factory$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Factory$MockitoMock$44977529</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Factory$MockitoMock$44977529$auxiliary$bZikPijT</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$Factory$MockitoMock$44977529$auxiliary$pHnSlEQm</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$ForInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$ForInstrumentedMethod$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$ForInstrumentedMethod$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$ForReceiverType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$MockitoMock$1586392976</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$MockitoMock$1586392976$auxiliary$cSJHDGCW</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$MockitoMock$1586392976$auxiliary$olcwwzUZ</td>
  </tr>
  <tr>
    <td class="name">MethodAttributeAppender$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (34/34)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.9%
  </span>
  <span class="absValue">
    (91/92)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.attribute;
&nbsp;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * An appender that writes attributes or annotations to a given ASM {@link org.objectweb.asm.MethodVisitor}.
&nbsp; */
&nbsp;public interface MethodAttributeAppender {
&nbsp;
&nbsp;    /**
&nbsp;     * Applies this attribute appender to a given method visitor.
&nbsp;     *
&nbsp;     * @param methodVisitor         The method visitor to which the attributes that are represented by this attribute
&nbsp;     *                              appender are written to.
&nbsp;     * @param methodDescription     The description of the method for which the given method visitor creates an
&nbsp;     *                              instrumentation for.
&nbsp;     * @param annotationValueFilter The annotation value filter to apply when the annotations are written.
&nbsp;     */
&nbsp;    void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter);
&nbsp;
&nbsp;    /**
&nbsp;     * A method attribute appender that does not append any attributes.
&nbsp;     */
<b class="fc">&nbsp;    enum NoOp implements MethodAttributeAppender, Factory {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodAttributeAppender make(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter) {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A factory that creates method attribute appenders for a given type.
&nbsp;     */
&nbsp;    interface Factory {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method attribute appender that is applicable for a given type description.
&nbsp;         *
&nbsp;         * @param typeDescription The type for which a method attribute appender is to be applied for.
&nbsp;         * @return The method attribute appender which should be applied for the given type.
&nbsp;         */
&nbsp;        MethodAttributeAppender make(TypeDescription typeDescription);
&nbsp;
&nbsp;        /**
&nbsp;         * A method attribute appender factory that combines several method attribute appender factories to be
&nbsp;         * represented as a single factory.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Compound implements Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The factories this compound factory represents in their application order.
&nbsp;             */
&nbsp;            private final List&lt;Factory&gt; factories;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound method attribute appender factory.
&nbsp;             *
&nbsp;             * @param factory The factories that are to be combined by this compound factory in the order of their application.
&nbsp;             */
&nbsp;            public Compound(Factory... factory) {
<b class="fc">&nbsp;                this(Arrays.asList(factory));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound method attribute appender factory.
&nbsp;             *
&nbsp;             * @param factories The factories that are to be combined by this compound factory in the order of their application.
&nbsp;             */
<b class="fc">&nbsp;            public Compound(List&lt;? extends Factory&gt; factories) {</b>
<b class="fc">&nbsp;                this.factories = new ArrayList&lt;Factory&gt;();</b>
<b class="fc">&nbsp;                for (Factory factory : factories) {</b>
<b class="fc">&nbsp;                    if (factory instanceof Compound) {</b>
<b class="fc">&nbsp;                        this.factories.addAll(((Compound) factory).factories);</b>
<b class="fc">&nbsp;                    } else if (!(factory instanceof NoOp)) {</b>
<b class="fc">&nbsp;                        this.factories.add(factory);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodAttributeAppender make(TypeDescription typeDescription) {
<b class="fc">&nbsp;                List&lt;MethodAttributeAppender&gt; methodAttributeAppenders = new ArrayList&lt;MethodAttributeAppender&gt;(factories.size());</b>
<b class="fc">&nbsp;                for (Factory factory : factories) {</b>
<b class="fc">&nbsp;                    methodAttributeAppenders.add(factory.make(typeDescription));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new MethodAttributeAppender.Compound(methodAttributeAppenders);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Implementation of a method attribute appender that writes all annotations of the instrumented method to the
&nbsp;     * method that is being created. This includes method and parameter annotations.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This attribute appender does not apply for annotation types within the {@code jdk.internal.} namespace
&nbsp;     * which are silently ignored. If such annotations should be inherited, they need to be added explicitly.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
<b class="fc">&nbsp;    enum ForInstrumentedMethod implements MethodAttributeAppender, Factory {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Appends all annotations of the instrumented method but not the annotations of the method&#39;s receiver type if such a type exists.
&nbsp;         */
<b class="fc">&nbsp;        EXCLUDING_RECEIVER {</b>
&nbsp;            @Override
&nbsp;            protected AnnotationAppender appendReceiver(AnnotationAppender annotationAppender,
&nbsp;                                                        AnnotationValueFilter annotationValueFilter,
&nbsp;                                                        MethodDescription methodDescription) {
<b class="fc">&nbsp;                return annotationAppender;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Appends all annotations of the instrumented method including the annotations of the method&#39;s receiver type if such a type exists.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * If a method is overridden, the annotations can be misplaced if the overriding class does not expose a similar structure to
&nbsp;         * the method that declared the method, i.e. the same amount of type variables and similar owner types. If this is not the case,
&nbsp;         * type annotations are appended as if the overridden method was declared by the original type. This does not corrupt the resulting
&nbsp;         * class file but it might result in type annotations not being visible via core reflection. This might however confuse other tools
&nbsp;         * that parse the resulting class file manually.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        INCLUDING_RECEIVER {</b>
&nbsp;            @Override
&nbsp;            protected AnnotationAppender appendReceiver(AnnotationAppender annotationAppender,
&nbsp;                                                        AnnotationValueFilter annotationValueFilter,
&nbsp;                                                        MethodDescription methodDescription) {
<b class="fc">&nbsp;                TypeDescription.Generic receiverType = methodDescription.getReceiverType();</b>
<b class="fc">&nbsp;                return receiverType == null</b>
<b class="fc">&nbsp;                        ? annotationAppender</b>
<b class="fc">&nbsp;                        : receiverType.accept(AnnotationAppender.ForTypeAnnotations.ofReceiverType(annotationAppender, annotationValueFilter));</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodAttributeAppender make(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            AnnotationAppender annotationAppender = new AnnotationAppender.Default(new AnnotationAppender.Target.OnMethod(methodVisitor));</b>
<b class="fc">&nbsp;            annotationAppender = methodDescription.getReturnType().accept(AnnotationAppender.ForTypeAnnotations.ofMethodReturnType(annotationAppender,</b>
&nbsp;                    annotationValueFilter));
<b class="fc">&nbsp;            annotationAppender = AnnotationAppender.ForTypeAnnotations.ofTypeVariable(annotationAppender,</b>
&nbsp;                    annotationValueFilter,
&nbsp;                    AnnotationAppender.ForTypeAnnotations.VARIABLE_ON_INVOKEABLE,
<b class="fc">&nbsp;                    methodDescription.getTypeVariables());</b>
<b class="fc">&nbsp;            for (AnnotationDescription annotation : methodDescription.getDeclaredAnnotations().filter(not(annotationType(nameStartsWith(&quot;jdk.internal.&quot;))))) {</b>
<b class="fc">&nbsp;                annotationAppender = annotationAppender.append(annotation, annotationValueFilter);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : methodDescription.getParameters()) {</b>
<b class="fc">&nbsp;                AnnotationAppender parameterAppender = new AnnotationAppender.Default(new AnnotationAppender.Target.OnMethodParameter(methodVisitor,</b>
<b class="fc">&nbsp;                        parameterDescription.getIndex()));</b>
<b class="fc">&nbsp;                parameterAppender = parameterDescription.getType().accept(AnnotationAppender.ForTypeAnnotations.ofMethodParameterType(parameterAppender,</b>
&nbsp;                        annotationValueFilter,
<b class="fc">&nbsp;                        parameterDescription.getIndex()));</b>
<b class="fc">&nbsp;                for (AnnotationDescription annotation : parameterDescription.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                    parameterAppender = parameterAppender.append(annotation, annotationValueFilter);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            annotationAppender = appendReceiver(annotationAppender, annotationValueFilter, methodDescription);</b>
<b class="fc">&nbsp;            int exceptionTypeIndex = 0;</b>
<b class="fc">&nbsp;            for (TypeDescription.Generic exceptionType : methodDescription.getExceptionTypes()) {</b>
<b class="fc">&nbsp;                annotationAppender = exceptionType.accept(AnnotationAppender.ForTypeAnnotations.ofExceptionType(annotationAppender,</b>
&nbsp;                        annotationValueFilter,
&nbsp;                        exceptionTypeIndex++));
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the annotations of the instrumented method&#39;s receiver type if this is enabled and such a type exists.
&nbsp;         *
&nbsp;         * @param annotationAppender    The annotation appender to use.
&nbsp;         * @param annotationValueFilter The annotation value filter to apply when the annotations are written.
&nbsp;         * @param methodDescription     The instrumented method.
&nbsp;         * @return The resulting annotation appender.
&nbsp;         */
&nbsp;        protected abstract AnnotationAppender appendReceiver(AnnotationAppender annotationAppender,
&nbsp;                                                             AnnotationValueFilter annotationValueFilter,
&nbsp;                                                             MethodDescription methodDescription);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Appends an annotation to a method or method parameter. The visibility of the annotation is determined by the
&nbsp;     * annotation type&#39;s {@link java.lang.annotation.RetentionPolicy} annotation.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Explicit implements MethodAttributeAppender, Factory {
&nbsp;
&nbsp;        /**
&nbsp;         * The target to which the annotations are written to.
&nbsp;         */
&nbsp;        private final Target target;
&nbsp;
&nbsp;        /**
&nbsp;         * the annotations this method attribute appender is writing to its target.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender for appending an annotation to a method.
&nbsp;         *
&nbsp;         * @param parameterIndex The index of the parameter to which the annotations should be written.
&nbsp;         * @param annotations    The annotations that should be written.
&nbsp;         */
&nbsp;        public Explicit(int parameterIndex, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;            this(new Target.OnMethodParameter(parameterIndex), annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender for appending an annotation to a method.
&nbsp;         *
&nbsp;         * @param annotations The annotations that should be written.
&nbsp;         */
&nbsp;        public Explicit(List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;            this(Target.OnMethod.INSTANCE, annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an explicit annotation appender for a either a method or one of its parameters..
&nbsp;         *
&nbsp;         * @param target      The target to which the annotation should be written to.
&nbsp;         * @param annotations The annotations to write.
&nbsp;         */
<b class="fc">&nbsp;        protected Explicit(Target target, List&lt;? extends AnnotationDescription&gt; annotations) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method attribute appender factory that writes all annotations of a given method, both the method
&nbsp;         * annotations themselves and all annotations that are defined for every parameter.
&nbsp;         *
&nbsp;         * @param methodDescription The method from which to extract the annotations.
&nbsp;         * @return A method attribute appender factory for an appender that writes all annotations of the supplied method.
&nbsp;         */
&nbsp;        public static Factory of(MethodDescription methodDescription) {
<b class="fc">&nbsp;            return new Factory.Compound(ofMethodAnnotations(methodDescription), ofParameterAnnotations(methodDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method attribute appender factory that writes all method annotations that are defined on the given method.
&nbsp;         *
&nbsp;         * @param methodDescription The method from which to extract the method annotations.
&nbsp;         * @return A method attribute appender factory for an appender that writes all method annotations of the supplied method.
&nbsp;         */
&nbsp;        public static Factory ofMethodAnnotations(MethodDescription methodDescription) {
<b class="fc">&nbsp;            return new Explicit(methodDescription.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method attribute appender factory that writes all annotations that are defined for every parameter
&nbsp;         * of the given method.
&nbsp;         *
&nbsp;         * @param methodDescription The method from which to extract the parameter annotations.
&nbsp;         * @return A method attribute appender factory for an appender that writes all parameter annotations of the supplied method.
&nbsp;         */
&nbsp;        public static Factory ofParameterAnnotations(MethodDescription methodDescription) {
<b class="fc">&nbsp;            ParameterList&lt;?&gt; parameters = methodDescription.getParameters();</b>
<b class="fc">&nbsp;            List&lt;MethodAttributeAppender.Factory&gt; factories = new ArrayList&lt;MethodAttributeAppender.Factory&gt;(parameters.size());</b>
<b class="fc">&nbsp;            for (ParameterDescription parameter : parameters) {</b>
<b class="fc">&nbsp;                factories.add(new Explicit(parameter.getIndex(), parameter.getDeclaredAnnotations()));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Factory.Compound(factories);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodAttributeAppender make(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            AnnotationAppender appender = new AnnotationAppender.Default(target.make(methodVisitor, methodDescription));</b>
<b class="fc">&nbsp;            for (AnnotationDescription annotation : annotations) {</b>
<b class="fc">&nbsp;                appender = appender.append(annotation, annotationValueFilter);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the target on which this method attribute appender should write its annotations to.
&nbsp;         */
&nbsp;        protected interface Target {
&nbsp;
&nbsp;            /**
&nbsp;             * Materializes the target for a given creation process.
&nbsp;             *
&nbsp;             * @param methodVisitor     The method visitor to which the attributes that are represented by this
&nbsp;             *                          attribute appender are written to.
&nbsp;             * @param methodDescription The description of the method for which the given method visitor creates an
&nbsp;             *                          instrumentation for.
&nbsp;             * @return The target of the annotation appender this target represents.
&nbsp;             */
&nbsp;            AnnotationAppender.Target make(MethodVisitor methodVisitor, MethodDescription methodDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * A method attribute appender target for writing annotations directly onto the method.
&nbsp;             */
<b class="fc">&nbsp;            enum OnMethod implements Target {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationAppender.Target make(MethodVisitor methodVisitor, MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return new AnnotationAppender.Target.OnMethod(methodVisitor);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method attribute appender target for writing annotations onto a given method parameter.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class OnMethodParameter implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the parameter to write the annotation to.
&nbsp;                 */
&nbsp;                private final int parameterIndex;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a target for a method attribute appender for a method parameter of the given index.
&nbsp;                 *
&nbsp;                 * @param parameterIndex The index of the target parameter.
&nbsp;                 */
<b class="fc">&nbsp;                protected OnMethodParameter(int parameterIndex) {</b>
<b class="fc">&nbsp;                    this.parameterIndex = parameterIndex;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationAppender.Target make(MethodVisitor methodVisitor, MethodDescription methodDescription) {
<b class="fc">&nbsp;                    if (parameterIndex &gt;= methodDescription.getParameters().size()) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;Method &quot; + methodDescription + &quot; has less then &quot; + parameterIndex + &quot; parameters&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new AnnotationAppender.Target.OnMethodParameter(methodVisitor, parameterIndex);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method attribute appender that writes a receiver type.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ForReceiverType implements MethodAttributeAppender, Factory {
&nbsp;
&nbsp;        /**
&nbsp;         * The receiver type for which annotations are appended to the instrumented method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic receiverType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new attribute appender that writes a receiver type.
&nbsp;         *
&nbsp;         * @param receiverType The receiver type for which annotations are appended to the instrumented method.
&nbsp;         */
<b class="fc">&nbsp;        public ForReceiverType(TypeDescription.Generic receiverType) {</b>
<b class="fc">&nbsp;            this.receiverType = receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodAttributeAppender make(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            receiverType.accept(AnnotationAppender.ForTypeAnnotations.ofReceiverType(new AnnotationAppender.Default(new AnnotationAppender.Target.OnMethod(methodVisitor)), annotationValueFilter));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method attribute appender that combines several method attribute appenders to be represented as a single
&nbsp;     * method attribute appender.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Compound implements MethodAttributeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The method attribute appenders this compound appender represents in their application order.
&nbsp;         */
&nbsp;        private final List&lt;MethodAttributeAppender&gt; methodAttributeAppenders;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new compound method attribute appender.
&nbsp;         *
&nbsp;         * @param methodAttributeAppender The method attribute appenders that are to be combined by this compound appender
&nbsp;         *                                in the order of their application.
&nbsp;         */
&nbsp;        public Compound(MethodAttributeAppender... methodAttributeAppender) {
<b class="fc">&nbsp;            this(Arrays.asList(methodAttributeAppender));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new compound method attribute appender.
&nbsp;         *
&nbsp;         * @param methodAttributeAppenders The method attribute appenders that are to be combined by this compound appender
&nbsp;         *                                 in the order of their application.
&nbsp;         */
<b class="fc">&nbsp;        public Compound(List&lt;? extends MethodAttributeAppender&gt; methodAttributeAppenders) {</b>
<b class="fc">&nbsp;            this.methodAttributeAppenders = new ArrayList&lt;MethodAttributeAppender&gt;();</b>
<b class="fc">&nbsp;            for (MethodAttributeAppender methodAttributeAppender : methodAttributeAppenders) {</b>
<b class="fc">&nbsp;                if (methodAttributeAppender instanceof Compound) {</b>
<b class="nc">&nbsp;                    this.methodAttributeAppenders.addAll(((Compound) methodAttributeAppender).methodAttributeAppenders);</b>
<b class="fc">&nbsp;                } else if (!(methodAttributeAppender instanceof NoOp)) {</b>
<b class="fc">&nbsp;                    this.methodAttributeAppenders.add(methodAttributeAppender);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;            for (MethodAttributeAppender methodAttributeAppender : methodAttributeAppenders) {</b>
<b class="fc">&nbsp;                methodAttributeAppender.apply(methodVisitor, methodDescription, annotationValueFilter);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
