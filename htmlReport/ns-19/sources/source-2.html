


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodCallProxy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.auxiliary</a>
</div>

<h1>Coverage Summary for Class: MethodCallProxy (net.bytebuddy.implementation.auxiliary)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodCallProxy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodCallProxy$1</td>
  </tr>
  <tr>
    <td class="name">MethodCallProxy$AssignableSignatureCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCallProxy$ConstructorCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCallProxy$ConstructorCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCallProxy$MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCallProxy$MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodCallProxy$PrecomputedMethodGraph</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    89.3%
  </span>
  <span class="absValue">
    (25/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.6%
  </span>
  <span class="absValue">
    (86/89)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.auxiliary;
&nbsp;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodAccessorFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.Callable;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
&nbsp;
&nbsp;/**
&nbsp; * A method call proxy represents a class that is compiled against a particular method which can then be called whenever
&nbsp; * either its {@link java.util.concurrent.Callable#call()} or {@link Runnable#run()} method is called where the method
&nbsp; * call proxy implements both interfaces.
&nbsp; * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp; * In order to do so, the method call proxy instances are constructed by providing all the necessary information for
&nbsp; * calling a particular method:
&nbsp; * &lt;ol&gt;
&nbsp; * &lt;li&gt;If the target method is not {@code static}, the first argument should be an instance on which the method is called.&lt;/li&gt;
&nbsp; * &lt;li&gt;All arguments for the called method in the order in which they are required.&lt;/li&gt;
&nbsp; * &lt;/ol&gt;
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class MethodCallProxy implements AuxiliaryType {
&nbsp;
&nbsp;    /**
&nbsp;     * The prefix of the fields holding the original method invocation&#39;s arguments.
&nbsp;     */
&nbsp;    private static final String FIELD_NAME_PREFIX = &quot;argument&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The special method invocation to invoke from the auxiliary type.
&nbsp;     */
&nbsp;    private final Implementation.SpecialMethodInvocation specialMethodInvocation;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the generated proxy should be serializableProxy.
&nbsp;     */
&nbsp;    private final boolean serializableProxy;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to use for invoking a bridge method target where the parameter and return types need to be
&nbsp;     * assigned.
&nbsp;     */
&nbsp;    private final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method call proxy for a given method and uses a default assigner for assigning the method&#39;s return
&nbsp;     * value to either the {@link java.util.concurrent.Callable#call()} or {@link Runnable#run()} method returns.
&nbsp;     *
&nbsp;     * @param specialMethodInvocation The special method invocation which should be invoked by this method call proxy.
&nbsp;     * @param serializableProxy       Determines if the generated proxy should be serializableProxy.
&nbsp;     */
&nbsp;    public MethodCallProxy(Implementation.SpecialMethodInvocation specialMethodInvocation, boolean serializableProxy) {
<b class="fc">&nbsp;        this(specialMethodInvocation, serializableProxy, Assigner.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new method call proxy for a given method.
&nbsp;     *
&nbsp;     * @param specialMethodInvocation The special method invocation which should be invoked by this method call proxy.
&nbsp;     * @param serializableProxy       Determines if the generated proxy should be serializableProxy.
&nbsp;     * @param assigner                An assigner for assigning the target method&#39;s return value to either the
&nbsp;     *                                {@link java.util.concurrent.Callable#call()} or {@link Runnable#run()}} methods&#39;
&nbsp;     *                                return values.
&nbsp;     */
<b class="fc">&nbsp;    public MethodCallProxy(Implementation.SpecialMethodInvocation specialMethodInvocation, boolean serializableProxy, Assigner assigner) {</b>
<b class="fc">&nbsp;        this.specialMethodInvocation = specialMethodInvocation;</b>
<b class="fc">&nbsp;        this.serializableProxy = serializableProxy;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a linked hash map of field names to their types where each field represents a parameter of the method.
&nbsp;     *
&nbsp;     * @param methodDescription The method to extract into fields.
&nbsp;     * @return A map of fields in the order they need to be loaded onto the operand stack for invoking the original
&nbsp;     * method, including a reference to the instance of the instrumented type that is invoked if applicable.
&nbsp;     */
&nbsp;    private static LinkedHashMap&lt;String, TypeDescription&gt; extractFields(MethodDescription methodDescription) {
<b class="fc">&nbsp;        LinkedHashMap&lt;String, TypeDescription&gt; typeDescriptions = new LinkedHashMap&lt;String, TypeDescription&gt;();</b>
<b class="fc">&nbsp;        int currentIndex = 0;</b>
<b class="fc">&nbsp;        if (!methodDescription.isStatic()) {</b>
<b class="fc">&nbsp;            typeDescriptions.put(fieldName(currentIndex++), methodDescription.getDeclaringType().asErasure());</b>
&nbsp;        }
<b class="fc">&nbsp;        for (ParameterDescription parameterDescription : methodDescription.getParameters()) {</b>
<b class="fc">&nbsp;            typeDescriptions.put(fieldName(currentIndex++), parameterDescription.getType().asErasure());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return typeDescriptions;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a field name for a method parameter of a given index.
&nbsp;     *
&nbsp;     * @param index The index for which the field name is to be created.
&nbsp;     * @return The name for the given parameter.
&nbsp;     */
&nbsp;    private static String fieldName(int index) {
<b class="fc">&nbsp;        return FIELD_NAME_PREFIX + index;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public String getSuffix() {
<b class="fc">&nbsp;        return RandomString.hashOf(specialMethodInvocation.getMethodDescription().hashCode()) + (serializableProxy ? &quot;S&quot; : &quot;0&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public DynamicType make(String auxiliaryTypeName,
&nbsp;                            ClassFileVersion classFileVersion,
&nbsp;                            MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;        MethodDescription accessorMethod = methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT);</b>
<b class="fc">&nbsp;        LinkedHashMap&lt;String, TypeDescription&gt; parameterFields = extractFields(accessorMethod);</b>
<b class="fc">&nbsp;        DynamicType.Builder&lt;?&gt; builder = new ByteBuddy(classFileVersion)</b>
<b class="fc">&nbsp;                .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                .with(PrecomputedMethodGraph.INSTANCE)</b>
<b class="fc">&nbsp;                .subclass(Object.class, ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="fc">&nbsp;                .name(auxiliaryTypeName)</b>
<b class="fc">&nbsp;                .modifiers(DEFAULT_TYPE_MODIFIER)</b>
<b class="fc">&nbsp;                .implement(Runnable.class, Callable.class).intercept(new MethodCall(accessorMethod, assigner))</b>
<b class="fc">&nbsp;                .implement(serializableProxy ? new Class&lt;?&gt;[]{Serializable.class} : new Class&lt;?&gt;[0])</b>
<b class="fc">&nbsp;                .defineConstructor().withParameters(parameterFields.values())</b>
<b class="fc">&nbsp;                .intercept(ConstructorCall.INSTANCE);</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;String, TypeDescription&gt; field : parameterFields.entrySet()) {</b>
<b class="fc">&nbsp;            builder = builder.defineField(field.getKey(), field.getValue(), Visibility.PRIVATE);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return builder.make();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A precomputed method graph that only displays the methods that are relevant for creating a method call proxy.
&nbsp;     */
<b class="fc">&nbsp;    protected enum PrecomputedMethodGraph implements MethodGraph.Compiler {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The precomputed method graph.
&nbsp;         */
&nbsp;        private final transient MethodGraph.Linked methodGraph;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates the precomputed method graph.
&nbsp;         */
&nbsp;        PrecomputedMethodGraph() {
&nbsp;            LinkedHashMap&lt;MethodDescription.SignatureToken, MethodGraph.Node&gt; nodes = new LinkedHashMap&lt;MethodDescription.SignatureToken, MethodGraph.Node&gt;();
&nbsp;            MethodDescription callMethod = new MethodDescription.Latent(TypeDescription.ForLoadedType.of(Callable.class),
&nbsp;                    &quot;call&quot;,
&nbsp;                    Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
&nbsp;                    Collections.&lt;TypeVariableToken&gt;emptyList(),
&nbsp;                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class),
&nbsp;                    Collections.&lt;ParameterDescription.Token&gt;emptyList(),
&nbsp;                    Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Exception.class)),
&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),
&nbsp;                    AnnotationValue.UNDEFINED,
&nbsp;                    TypeDescription.Generic.UNDEFINED);
&nbsp;            nodes.put(callMethod.asSignatureToken(), new MethodGraph.Node.Simple(callMethod));
&nbsp;            MethodDescription runMethod = new MethodDescription.Latent(TypeDescription.ForLoadedType.of(Runnable.class),
&nbsp;                    &quot;run&quot;,
&nbsp;                    Opcodes.ACC_PUBLIC | Opcodes.ACC_ABSTRACT,
&nbsp;                    Collections.&lt;TypeVariableToken&gt;emptyList(),
&nbsp;                    TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class),
&nbsp;                    Collections.&lt;ParameterDescription.Token&gt;emptyList(),
&nbsp;                    Collections.&lt;TypeDescription.Generic&gt;emptyList(),
&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),
&nbsp;                    AnnotationValue.UNDEFINED,
&nbsp;                    TypeDescription.Generic.UNDEFINED);
&nbsp;            nodes.put(runMethod.asSignatureToken(), new MethodGraph.Node.Simple(runMethod));
&nbsp;            MethodGraph methodGraph = new MethodGraph.Simple(nodes);
&nbsp;            this.methodGraph = new MethodGraph.Linked.Delegation(methodGraph, methodGraph, Collections.&lt;TypeDescription, MethodGraph&gt;emptyMap());
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodGraph.Linked compile(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return methodGraph;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public MethodGraph.Linked compile(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return methodGraph;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodGraph.Linked compile(TypeDefinition typeDefinition, TypeDescription viewPoint) {
<b class="nc">&nbsp;            return methodGraph;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Deprecated
&nbsp;        public MethodGraph.Linked compile(TypeDescription typeDefinition, TypeDescription viewPoint) {
<b class="nc">&nbsp;            return methodGraph;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation for a constructor of a {@link net.bytebuddy.implementation.auxiliary.MethodCallProxy}.
&nbsp;     */
<b class="fc">&nbsp;    protected enum ConstructorCall implements Implementation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A reference of the {@link Object} type default constructor.
&nbsp;         */
&nbsp;        private final MethodDescription objectTypeDefaultConstructor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates the constructor call singleton.
&nbsp;         */
&nbsp;        ConstructorCall() {
&nbsp;            objectTypeDefaultConstructor = TypeDescription.ForLoadedType.of(Object.class).getDeclaredMethods().filter(isConstructor()).getOnly();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The appender for implementing the {@link net.bytebuddy.implementation.auxiliary.MethodCallProxy.ConstructorCall}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        protected static class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type being created.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type that is being created.
&nbsp;             */
<b class="fc">&nbsp;            private Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                FieldList&lt;?&gt; fieldList = instrumentedType.getDeclaredFields();</b>
<b class="fc">&nbsp;                StackManipulation[] fieldLoading = new StackManipulation[fieldList.size()];</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                for (FieldDescription fieldDescription : fieldList) {</b>
<b class="fc">&nbsp;                    fieldLoading[index] = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                            MethodVariableAccess.load(instrumentedMethod.getParameters().get(index)),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).write()</b>
&nbsp;                    );
<b class="fc">&nbsp;                    index++;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                        MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(ConstructorCall.INSTANCE.objectTypeDefaultConstructor),</b>
&nbsp;                        new StackManipulation.Compound(fieldLoading),
&nbsp;                        MethodReturn.VOID
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation for a method of a {@link net.bytebuddy.implementation.auxiliary.MethodCallProxy}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    protected static class MethodCall implements Implementation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is accessed by the implemented method.
&nbsp;         */
&nbsp;        private final MethodDescription accessorMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The assigner to be used for invoking the accessor method.
&nbsp;         */
&nbsp;        private final Assigner assigner;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method call implementation.
&nbsp;         *
&nbsp;         * @param accessorMethod The method that is accessed by the implemented method.
&nbsp;         * @param assigner       The assigner to be used for invoking the accessor method.
&nbsp;         */
<b class="fc">&nbsp;        protected MethodCall(MethodDescription accessorMethod, Assigner assigner) {</b>
<b class="fc">&nbsp;            this.accessorMethod = accessorMethod;</b>
<b class="fc">&nbsp;            this.assigner = assigner;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The appender for implementing the {@link net.bytebuddy.implementation.auxiliary.MethodCallProxy.MethodCall}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;        protected class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type that is implemented.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type to be implemented.
&nbsp;             */
<b class="fc">&nbsp;            private Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor,
&nbsp;                              Context implementationContext,
&nbsp;                              MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                FieldList&lt;?&gt; fieldList = instrumentedType.getDeclaredFields();</b>
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; fieldLoadings = new ArrayList&lt;StackManipulation&gt;(fieldList.size());</b>
<b class="fc">&nbsp;                for (FieldDescription fieldDescription : fieldList) {</b>
<b class="fc">&nbsp;                    fieldLoadings.add(new StackManipulation.Compound(MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read()));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
&nbsp;                        new StackManipulation.Compound(fieldLoadings),
<b class="fc">&nbsp;                        MethodInvocation.invoke(accessorMethod),</b>
<b class="fc">&nbsp;                        assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),</b>
<b class="fc">&nbsp;                        MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A stack manipulation that creates a {@link net.bytebuddy.implementation.auxiliary.MethodCallProxy}
&nbsp;     * for a given method an pushes such an object onto the call stack. For this purpose, all arguments of the proxied method
&nbsp;     * are loaded onto the stack what is only possible if this instance is used from a method with an identical signature such
&nbsp;     * as the target method itself.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class AssignableSignatureCall extends StackManipulation.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The special method invocation to be proxied by this stack manipulation.
&nbsp;         */
&nbsp;        private final Implementation.SpecialMethodInvocation specialMethodInvocation;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the generated proxy should be serializableProxy.
&nbsp;         */
&nbsp;        private final boolean serializable;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an operand stack assignment that creates a
&nbsp;         * {@link net.bytebuddy.implementation.auxiliary.MethodCallProxy} for the
&nbsp;         * {@code targetMethod} and pushes this proxy object onto the stack.
&nbsp;         *
&nbsp;         * @param specialMethodInvocation The special method invocation which should be invoked by the created method
&nbsp;         *                                call proxy.
&nbsp;         * @param serializable            Determines if the generated proxy should be serializableProxy.
&nbsp;         */
&nbsp;        public AssignableSignatureCall(Implementation.SpecialMethodInvocation specialMethodInvocation,
<b class="fc">&nbsp;                                       boolean serializable) {</b>
<b class="fc">&nbsp;            this.specialMethodInvocation = specialMethodInvocation;</b>
<b class="fc">&nbsp;            this.serializable = serializable;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;            TypeDescription auxiliaryType = implementationContext</b>
<b class="fc">&nbsp;                    .register(new MethodCallProxy(specialMethodInvocation, serializable));</b>
<b class="fc">&nbsp;            return new Compound(</b>
<b class="fc">&nbsp;                    TypeCreation.of(auxiliaryType),</b>
&nbsp;                    Duplication.SINGLE,
<b class="fc">&nbsp;                    MethodVariableAccess.allArgumentsOf(specialMethodInvocation.getMethodDescription()).prependThisReference(),</b>
<b class="fc">&nbsp;                    MethodInvocation.invoke(auxiliaryType.getDeclaredMethods().filter(isConstructor()).getOnly())</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
