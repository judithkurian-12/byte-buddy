


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > TypeProxy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.auxiliary</a>
</div>

<h1>Coverage Summary for Class: TypeProxy (net.bytebuddy.implementation.auxiliary)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TypeProxy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TypeProxy$1</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$AbstractMethodErrorThrow</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$ForDefaultMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$ForSuperMethodByConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$ForSuperMethodByReflectionFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory$MockitoMock$965210628</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory$MockitoMock$965210628$auxiliary$at2xYoag</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$InvocationFactory$MockitoMock$965210628$auxiliary$ccaNb9TG</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$MethodCall$Appender$AccessorMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$SilentConstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeProxy$SilentConstruction$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (37/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (118/118)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.auxiliary;
&nbsp;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.modifier.Ownership;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodAccessorFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.*;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DefaultValue;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.util.List;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A type proxy creates accessor methods for all overridable methods of a given type by subclassing the given type and
&nbsp; * delegating all method calls to accessor methods of the instrumented type it was created for.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public class TypeProxy implements AuxiliaryType {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the {@code static} method that is added to this auxiliary type for creating instances by using the
&nbsp;     * Oracle JDK&#39;s {@link sun.reflect.ReflectionFactory}.
&nbsp;     */
&nbsp;    public static final String REFLECTION_METHOD = &quot;make&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the field that stores the delegation instance.
&nbsp;     */
&nbsp;    public static final String INSTANCE_FIELD = &quot;target&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The type that is proxied, i.e. the original instrumented type this proxy is created for.
&nbsp;     */
&nbsp;    private final TypeDescription proxiedType;
&nbsp;
&nbsp;    /**
&nbsp;     * The implementation target of the proxied type.
&nbsp;     */
&nbsp;    private final Implementation.Target implementationTarget;
&nbsp;
&nbsp;    /**
&nbsp;     * The invocation factory for creating special method invocations.
&nbsp;     */
&nbsp;    private final InvocationFactory invocationFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * {@code true} if the finalizer method should not be instrumented.
&nbsp;     */
&nbsp;    private final boolean ignoreFinalizer;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the proxy should be serializable.
&nbsp;     */
&nbsp;    private final boolean serializableProxy;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new type proxy.
&nbsp;     *
&nbsp;     * @param proxiedType          The type this proxy should implement which can either be a non-final class or an interface.
&nbsp;     * @param implementationTarget The implementation target this type proxy is created for.
&nbsp;     * @param invocationFactory    The invocation factory for creating special method invocations.
&nbsp;     * @param ignoreFinalizer      {@code true} if any finalizer methods should be ignored for proxying.
&nbsp;     * @param serializableProxy    Determines if the proxy should be serializable.
&nbsp;     */
&nbsp;    public TypeProxy(TypeDescription proxiedType,
&nbsp;                     Implementation.Target implementationTarget,
&nbsp;                     InvocationFactory invocationFactory,
&nbsp;                     boolean ignoreFinalizer,
<b class="fc">&nbsp;                     boolean serializableProxy) {</b>
<b class="fc">&nbsp;        this.proxiedType = proxiedType;</b>
<b class="fc">&nbsp;        this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;        this.invocationFactory = invocationFactory;</b>
<b class="fc">&nbsp;        this.ignoreFinalizer = ignoreFinalizer;</b>
<b class="fc">&nbsp;        this.serializableProxy = serializableProxy;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public String getSuffix() {
<b class="fc">&nbsp;        return RandomString.hashOf(proxiedType.hashCode())</b>
<b class="fc">&nbsp;                + (ignoreFinalizer ? &quot;I&quot; : &quot;0&quot;)</b>
<b class="fc">&nbsp;                + (serializableProxy ? &quot;S&quot; : &quot;0&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public DynamicType make(String auxiliaryTypeName,
&nbsp;                            ClassFileVersion classFileVersion,
&nbsp;                            MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;        return new ByteBuddy(classFileVersion)</b>
<b class="fc">&nbsp;                .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                .ignore(ignoreFinalizer ? isFinalizer() : ElementMatchers.&lt;MethodDescription&gt;none())</b>
<b class="fc">&nbsp;                .subclass(proxiedType)</b>
<b class="fc">&nbsp;                .name(auxiliaryTypeName)</b>
<b class="fc">&nbsp;                .modifiers(DEFAULT_TYPE_MODIFIER)</b>
<b class="fc">&nbsp;                .implement(serializableProxy ? new Class&lt;?&gt;[]{Serializable.class} : new Class&lt;?&gt;[0])</b>
<b class="fc">&nbsp;                .method(any()).intercept(new MethodCall(methodAccessorFactory))</b>
<b class="fc">&nbsp;                .defineMethod(REFLECTION_METHOD, TargetType.class, Ownership.STATIC).intercept(SilentConstruction.INSTANCE)</b>
<b class="fc">&nbsp;                .make();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A stack manipulation that throws an abstract method error in case that a given super method cannot be invoked.
&nbsp;     */
<b class="fc">&nbsp;    protected enum AbstractMethodErrorThrow implements StackManipulation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The stack manipulation that throws the abstract method error.
&nbsp;         */
&nbsp;        private final transient StackManipulation implementation;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates the singleton instance.
&nbsp;         */
&nbsp;        AbstractMethodErrorThrow() {
&nbsp;            TypeDescription abstractMethodError = TypeDescription.ForLoadedType.of(AbstractMethodError.class);
&nbsp;            MethodDescription constructor = abstractMethodError.getDeclaredMethods()
&nbsp;                    .filter(isConstructor().and(takesArguments(0))).getOnly();
&nbsp;            implementation = new Compound(TypeCreation.of(abstractMethodError),
&nbsp;                    Duplication.SINGLE,
&nbsp;                    MethodInvocation.invoke(constructor),
&nbsp;                    Throw.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isValid() {
<b class="fc">&nbsp;            return implementation.isValid();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;            return implementation.apply(methodVisitor, implementationContext);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of a &lt;i&gt;silent construction&lt;/i&gt; of a given type by using the non-standardized
&nbsp;     * {@link sun.reflect.ReflectionFactory}. This way, a constructor invocation can be avoided. However, this comes
&nbsp;     * at the cost of potentially breaking compatibility as the reflection factory is not standardized.
&nbsp;     */
<b class="fc">&nbsp;    protected enum SilentConstruction implements Implementation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The appender for implementing a {@link net.bytebuddy.implementation.auxiliary.TypeProxy.SilentConstruction}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        protected static class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the reflection factory class.
&nbsp;             */
&nbsp;            public static final String REFLECTION_FACTORY_INTERNAL_NAME = &quot;sun/reflect/ReflectionFactory&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the factory method for getting hold of an instance of the reflection factory class.
&nbsp;             */
&nbsp;            public static final String GET_REFLECTION_FACTORY_METHOD_NAME = &quot;getReflectionFactory&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the factory method for getting hold of an instance of the reflection factory class.
&nbsp;             */
&nbsp;            public static final String GET_REFLECTION_FACTORY_METHOD_DESCRIPTOR = &quot;()Lsun/reflect/ReflectionFactory;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the method for creating a new serialization constructor.
&nbsp;             */
&nbsp;            public static final String NEW_CONSTRUCTOR_FOR_SERIALIZATION_METHOD_NAME = &quot;newConstructorForSerialization&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the method for creating a new serialization constructor.
&nbsp;             */
&nbsp;            public static final String NEW_CONSTRUCTOR_FOR_SERIALIZATION_METHOD_DESCRIPTOR =
&nbsp;                    &quot;(Ljava/lang/Class;Ljava/lang/reflect/Constructor;)Ljava/lang/reflect/Constructor;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the {@link java.lang.Object} class.
&nbsp;             */
&nbsp;            public static final String JAVA_LANG_OBJECT_DESCRIPTOR = &quot;Ljava/lang/Object;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the {@link java.lang.Object} class.
&nbsp;             */
&nbsp;            public static final String JAVA_LANG_OBJECT_INTERNAL_NAME = &quot;java/lang/Object&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the {@link java.lang.reflect.Constructor} class.
&nbsp;             */
&nbsp;            public static final String JAVA_LANG_CONSTRUCTOR_INTERNAL_NAME = &quot;java/lang/reflect/Constructor&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the {@link java.lang.reflect.Constructor#newInstance(Object...)} method.
&nbsp;             */
&nbsp;            public static final String NEW_INSTANCE_METHOD_NAME = &quot;newInstance&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the {@link java.lang.reflect.Constructor#newInstance(Object...)} method.
&nbsp;             */
&nbsp;            public static final String NEW_INSTANCE_METHOD_DESCRIPTOR = &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the {@link java.lang.Class} class.
&nbsp;             */
&nbsp;            public static final String JAVA_LANG_CLASS_INTERNAL_NAME = &quot;java/lang/Class&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the {@link Class#getDeclaredClasses()} method.
&nbsp;             */
&nbsp;            public static final String GET_DECLARED_CONSTRUCTOR_METHOD_NAME = &quot;getDeclaredConstructor&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of the {@link Class#getDeclaredClasses()} method.
&nbsp;             */
&nbsp;            public static final String GET_DECLARED_CONSTRUCTOR_METHOD_DESCRIPTOR =
&nbsp;                    &quot;([Ljava/lang/Class;)Ljava/lang/reflect/Constructor;&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type that this factory method is created for.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type that the factory method is created for.
&nbsp;             */
<b class="fc">&nbsp;            private Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
&nbsp;                        REFLECTION_FACTORY_INTERNAL_NAME,
&nbsp;                        GET_REFLECTION_FACTORY_METHOD_NAME,
&nbsp;                        GET_REFLECTION_FACTORY_METHOD_DESCRIPTOR,
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(instrumentedType.getDescriptor()));</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(JAVA_LANG_OBJECT_DESCRIPTOR));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, JAVA_LANG_CLASS_INTERNAL_NAME);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
&nbsp;                        JAVA_LANG_CLASS_INTERNAL_NAME,
&nbsp;                        GET_DECLARED_CONSTRUCTOR_METHOD_NAME,
&nbsp;                        GET_DECLARED_CONSTRUCTOR_METHOD_DESCRIPTOR,
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
&nbsp;                        REFLECTION_FACTORY_INTERNAL_NAME,
&nbsp;                        NEW_CONSTRUCTOR_FOR_SERIALIZATION_METHOD_NAME,
&nbsp;                        NEW_CONSTRUCTOR_FOR_SERIALIZATION_METHOD_DESCRIPTOR,
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, JAVA_LANG_OBJECT_INTERNAL_NAME);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, JAVA_LANG_CONSTRUCTOR_INTERNAL_NAME,</b>
&nbsp;                        NEW_INSTANCE_METHOD_NAME,
&nbsp;                        NEW_INSTANCE_METHOD_DESCRIPTOR,
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, instrumentedType.getInternalName());</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                return new Size(4, 0);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An invocation factory is responsible for creating a special method invocation for any method that is to be
&nbsp;     * invoked. These special method invocations are then implemented by the
&nbsp;     * {@link net.bytebuddy.implementation.auxiliary.TypeProxy}.
&nbsp;     * Illegal {@link Implementation.SpecialMethodInvocation} are implemented by
&nbsp;     * throwing an {@link java.lang.AbstractMethodError}.
&nbsp;     */
&nbsp;    public interface InvocationFactory {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a special method invocation to implement for a given method.
&nbsp;         *
&nbsp;         * @param implementationTarget The implementation target the type proxy is created for.
&nbsp;         * @param proxiedType          The type for the type proxy to subclass or implement.
&nbsp;         * @param instrumentedMethod   The instrumented method that is to be invoked.
&nbsp;         * @return A special method invocation of the given method or an illegal invocation if the proxy should
&nbsp;         * throw an {@link java.lang.AbstractMethodError} when the instrumented method is invoked.
&nbsp;         */
&nbsp;        Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
&nbsp;                                                      TypeDescription proxiedType,
&nbsp;                                                      MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Default implementations of the
&nbsp;         * {@link net.bytebuddy.implementation.auxiliary.TypeProxy.InvocationFactory}.
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements InvocationFactory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Invokes the super method of the instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            SUPER_METHOD {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
&nbsp;                                                                     TypeDescription proxiedType,
&nbsp;                                                                     MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return implementationTarget.invokeDominant(instrumentedMethod.asSignatureToken());</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Invokes the default method of the instrumented method if it exists and is not ambiguous.
&nbsp;             */
<b class="fc">&nbsp;            DEFAULT_METHOD {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public Implementation.SpecialMethodInvocation invoke(Implementation.Target implementationTarget,
&nbsp;                                                                     TypeDescription proxiedType,
&nbsp;                                                                     MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return implementationTarget.invokeDefault(instrumentedMethod.asSignatureToken(), proxiedType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a type proxy onto the operand stack which is created by calling one of its constructors. When this
&nbsp;     * stack manipulation is applied, an instance of the instrumented type must lie on top of the operand stack.
&nbsp;     * All constructor parameters will be assigned their default values when this stack operation is applied.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class ForSuperMethodByConstructor extends StackManipulation.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type for the type proxy to subclass or implement.
&nbsp;         */
&nbsp;        private final TypeDescription proxiedType;
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation target this type proxy is created for.
&nbsp;         */
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter types of the constructor that should be called.
&nbsp;         */
&nbsp;        private final List&lt;TypeDescription&gt; constructorParameters;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if any finalizers should be ignored for the delegation.
&nbsp;         */
&nbsp;        private final boolean ignoreFinalizer;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the proxy should be serializable.
&nbsp;         */
&nbsp;        private final boolean serializableProxy;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new stack operation for creating a type proxy by calling one of its constructors.
&nbsp;         *
&nbsp;         * @param proxiedType           The type for the type proxy to subclass or implement.
&nbsp;         * @param implementationTarget  The implementation target this type proxy is created for.
&nbsp;         * @param constructorParameters The parameter types of the constructor that should be called.
&nbsp;         * @param ignoreFinalizer       {@code true} if any finalizers should be ignored for the delegation.
&nbsp;         * @param serializableProxy     Determines if the proxy should be serializable.
&nbsp;         */
&nbsp;        public ForSuperMethodByConstructor(TypeDescription proxiedType,
&nbsp;                                           Implementation.Target implementationTarget,
&nbsp;                                           List&lt;TypeDescription&gt; constructorParameters,
&nbsp;                                           boolean ignoreFinalizer,
<b class="fc">&nbsp;                                           boolean serializableProxy) {</b>
<b class="fc">&nbsp;            this.proxiedType = proxiedType;</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;            this.constructorParameters = constructorParameters;</b>
<b class="fc">&nbsp;            this.ignoreFinalizer = ignoreFinalizer;</b>
<b class="fc">&nbsp;            this.serializableProxy = serializableProxy;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;            TypeDescription proxyType = implementationContext</b>
<b class="fc">&nbsp;                    .register(new TypeProxy(proxiedType,</b>
&nbsp;                            implementationTarget,
&nbsp;                            InvocationFactory.Default.SUPER_METHOD,
&nbsp;                            ignoreFinalizer,
&nbsp;                            serializableProxy));
<b class="fc">&nbsp;            StackManipulation[] constructorValue = new StackManipulation[constructorParameters.size()];</b>
<b class="fc">&nbsp;            int index = 0;</b>
<b class="fc">&nbsp;            for (TypeDescription parameterType : constructorParameters) {</b>
<b class="fc">&nbsp;                constructorValue[index++] = DefaultValue.of(parameterType);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Compound(</b>
<b class="fc">&nbsp;                    TypeCreation.of(proxyType),</b>
&nbsp;                    Duplication.SINGLE,
&nbsp;                    new Compound(constructorValue),
<b class="fc">&nbsp;                    MethodInvocation.invoke(proxyType.getDeclaredMethods().filter(isConstructor().and(takesArguments(constructorParameters))).getOnly()),</b>
&nbsp;                    Duplication.SINGLE,
<b class="fc">&nbsp;                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                    FieldAccess.forField(proxyType.getDeclaredFields().filter((named(INSTANCE_FIELD))).getOnly()).write()</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a type proxy onto the operand stack which is created by constructing a serialization constructor using
&nbsp;     * the Oracle JDK&#39;s {@link sun.reflect.ReflectionFactory#newConstructorForSerialization(Class, java.lang.reflect.Constructor)}
&nbsp;     * method which might not be available in any Java runtime. When this stack manipulation is applied, an instance of
&nbsp;     * the instrumented type must lie on top of the operand stack.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class ForSuperMethodByReflectionFactory extends StackManipulation.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type for which a proxy type is created.
&nbsp;         */
&nbsp;        private final TypeDescription proxiedType;
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation target of the proxied type.
&nbsp;         */
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} {@code true} if any finalizer methods should be ignored for proxying.
&nbsp;         */
&nbsp;        private final boolean ignoreFinalizer;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the proxy should be serializable.
&nbsp;         */
&nbsp;        private final boolean serializableProxy;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new stack operation for reflectively creating a type proxy for the given arguments.
&nbsp;         *
&nbsp;         * @param proxiedType          The type for the type proxy to subclass or implement.
&nbsp;         * @param implementationTarget The implementation target this type proxy is created for.
&nbsp;         * @param ignoreFinalizer      {@code true} if any finalizer methods should be ignored for proxying.
&nbsp;         * @param serializableProxy    Determines if the proxy should be serializable.
&nbsp;         */
&nbsp;        public ForSuperMethodByReflectionFactory(TypeDescription proxiedType,
&nbsp;                                                 Implementation.Target implementationTarget,
&nbsp;                                                 boolean ignoreFinalizer,
<b class="fc">&nbsp;                                                 boolean serializableProxy) {</b>
<b class="fc">&nbsp;            this.proxiedType = proxiedType;</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;            this.ignoreFinalizer = ignoreFinalizer;</b>
<b class="fc">&nbsp;            this.serializableProxy = serializableProxy;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;            TypeDescription proxyType = implementationContext.register(new TypeProxy(proxiedType,</b>
&nbsp;                    implementationTarget,
&nbsp;                    InvocationFactory.Default.SUPER_METHOD,
&nbsp;                    ignoreFinalizer,
&nbsp;                    serializableProxy));
<b class="fc">&nbsp;            return new Compound(</b>
<b class="fc">&nbsp;                    MethodInvocation.invoke(proxyType.getDeclaredMethods().filter(named(REFLECTION_METHOD).and(takesArguments(0))).getOnly()),</b>
&nbsp;                    Duplication.SINGLE,
<b class="fc">&nbsp;                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                    FieldAccess.forField(proxyType.getDeclaredFields().filter((named(INSTANCE_FIELD))).getOnly()).write()</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a type proxy which delegates its super method calls to any invokable default method of
&nbsp;     * a given interface and loads an instance of this proxy onto the operand stack.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class ForDefaultMethod extends StackManipulation.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The proxied interface type.
&nbsp;         */
&nbsp;        private final TypeDescription proxiedType;
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation target for the original instrumentation.
&nbsp;         */
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if the proxy should be {@link java.io.Serializable}.
&nbsp;         */
&nbsp;        private final boolean serializableProxy;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new proxy creation for a default interface type proxy.
&nbsp;         *
&nbsp;         * @param proxiedType          The proxied interface type.
&nbsp;         * @param implementationTarget The implementation target for the original implementation.
&nbsp;         * @param serializableProxy    {@code true} if the proxy should be {@link java.io.Serializable}.
&nbsp;         */
&nbsp;        public ForDefaultMethod(TypeDescription proxiedType,
&nbsp;                                Implementation.Target implementationTarget,
<b class="fc">&nbsp;                                boolean serializableProxy) {</b>
<b class="fc">&nbsp;            this.proxiedType = proxiedType;</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;            this.serializableProxy = serializableProxy;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;            TypeDescription proxyType = implementationContext.register(new TypeProxy(proxiedType,</b>
&nbsp;                    implementationTarget,
&nbsp;                    InvocationFactory.Default.DEFAULT_METHOD,
&nbsp;                    true,
&nbsp;                    serializableProxy));
<b class="fc">&nbsp;            return new Compound(</b>
<b class="fc">&nbsp;                    TypeCreation.of(proxyType),</b>
&nbsp;                    Duplication.SINGLE,
<b class="fc">&nbsp;                    MethodInvocation.invoke(proxyType.getDeclaredMethods().filter(isConstructor()).getOnly()),</b>
&nbsp;                    Duplication.SINGLE,
<b class="fc">&nbsp;                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                    FieldAccess.forField(proxyType.getDeclaredFields().filter((named(INSTANCE_FIELD))).getOnly()).write()</b>
<b class="fc">&nbsp;            ).apply(methodVisitor, implementationContext);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation for a method call of a {@link net.bytebuddy.implementation.auxiliary.TypeProxy}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;    protected class MethodCall implements Implementation {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The method accessor factory to query for the super method invocation.
&nbsp;         */
&nbsp;        private final MethodAccessorFactory methodAccessorFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method call implementation.
&nbsp;         *
&nbsp;         * @param methodAccessorFactory The method accessor factory to query for the super method invocation.
&nbsp;         */
<b class="fc">&nbsp;        protected MethodCall(MethodAccessorFactory methodAccessorFactory) {</b>
<b class="fc">&nbsp;            this.methodAccessorFactory = methodAccessorFactory;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;            return instrumentedType.withField(new FieldDescription.Token(INSTANCE_FIELD,</b>
&nbsp;                    Opcodes.ACC_PUBLIC | Opcodes.ACC_VOLATILE,
<b class="fc">&nbsp;                    implementationTarget.getInstrumentedType().asGenericType()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;            return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implementation of a byte code appender for a {@link net.bytebuddy.implementation.auxiliary.TypeProxy.MethodCall}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;        protected class Appender implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation for loading the proxied instance onto the stack.
&nbsp;             */
&nbsp;            private final StackManipulation fieldLoadingInstruction;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new appender.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type that is proxied by the enclosing instrumentation.
&nbsp;             */
<b class="fc">&nbsp;            protected Appender(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                fieldLoadingInstruction = FieldAccess.forField(instrumentedType.getDeclaredFields().filter((named(INSTANCE_FIELD))).getOnly()).read();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                SpecialMethodInvocation specialMethodInvocation = invocationFactory.invoke(implementationTarget, proxiedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                StackManipulation.Size size = (specialMethodInvocation.isValid()</b>
<b class="fc">&nbsp;                        ? new AccessorMethodInvocation(instrumentedMethod, specialMethodInvocation)</b>
<b class="fc">&nbsp;                        : AbstractMethodErrorThrow.INSTANCE).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                return new Size(size.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Stack manipulation for invoking an accessor method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class AccessorMethodInvocation implements StackManipulation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented method that is implemented.
&nbsp;                 */
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The special method invocation that is invoked by this accessor method invocation.
&nbsp;                 */
&nbsp;                private final SpecialMethodInvocation specialMethodInvocation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new accessor method invocation.
&nbsp;                 *
&nbsp;                 * @param instrumentedMethod      The instrumented method that is implemented.
&nbsp;                 * @param specialMethodInvocation The special method invocation that is invoked by this accessor
&nbsp;                 *                                method invocation.
&nbsp;                 */
&nbsp;                protected AccessorMethodInvocation(MethodDescription instrumentedMethod,
<b class="fc">&nbsp;                                                   SpecialMethodInvocation specialMethodInvocation) {</b>
<b class="fc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                    this.specialMethodInvocation = specialMethodInvocation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isValid() {
<b class="fc">&nbsp;                    return specialMethodInvocation.isValid();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;                    MethodDescription.InDefinedShape proxyMethod = methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT);</b>
<b class="fc">&nbsp;                    return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                            fieldLoadingInstruction,</b>
<b class="fc">&nbsp;                            MethodVariableAccess.allArgumentsOf(instrumentedMethod).asBridgeOf(proxyMethod),</b>
<b class="fc">&nbsp;                            MethodInvocation.invoke(proxyMethod),</b>
<b class="fc">&nbsp;                            MethodReturn.of(instrumentedMethod.getReturnType())</b>
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
