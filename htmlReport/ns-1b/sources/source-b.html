


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FieldProxy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.bind.annotation</a>
</div>

<h1>Coverage Summary for Class: FieldProxy (net.bytebuddy.implementation.bind.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">FieldProxy$Binder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (54/56)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$AccessorProxy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (27/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldGetter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldGetter$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$Factory</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$Factory$Duplex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$Factory$Simplex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$ForGetter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$ForGetterSetterPair</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$ForSetter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$MockitoMock$1234972805</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$MockitoMock$1234972805$auxiliary$QAHj2232</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$MockitoMock$1234972805$auxiliary$XjDD9zGk</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldResolver$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldSetter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$FieldSetter$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$InstanceFieldConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$InstanceFieldConstructor$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$Binder$StaticFieldConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$MockitoMock$1227310565</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$MockitoMock$1227310565$auxiliary$cP1e2vOX</td>
  </tr>
  <tr>
    <td class="name">FieldProxy$MockitoMock$1227310565$auxiliary$m9aVzxzq</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (59/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.4%
  </span>
  <span class="absValue">
    (188/191)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.bind.annotation;
&nbsp;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.ExceptionMethod;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodAccessorFactory;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bind.MethodDelegationBinder;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.util.Collections;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * Using this annotation it is possible to access fields by getter and setter types. Before this annotation can be
&nbsp; * used, it needs to be installed with two types. The getter type must be defined in a single-method interface
&nbsp; * with a single method that returns an {@link java.lang.Object} type and takes no arguments. The setter interface
&nbsp; * must similarly return {@code void} and take a single {@link java.lang.Object} argument. After installing these
&nbsp; * interfaces with the {@link FieldProxy.Binder}, this
&nbsp; * binder needs to be registered with a {@link net.bytebuddy.implementation.MethodDelegation} before it can be used.
&nbsp; *
&nbsp; * @see net.bytebuddy.implementation.MethodDelegation
&nbsp; * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
&nbsp; */
&nbsp;@Documented
&nbsp;@Retention(RetentionPolicy.RUNTIME)
&nbsp;@Target(ElementType.PARAMETER)
&nbsp;public @interface FieldProxy {
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the proxy should be serializable.
&nbsp;     *
&nbsp;     * @return {@code true} if the proxy should be serializable.
&nbsp;     */
&nbsp;    boolean serializableProxy() default false;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the name of the field that is to be accessed. If this property is not set, a field name is inferred
&nbsp;     * by the intercepted method after the Java beans naming conventions.
&nbsp;     *
&nbsp;     * @return The name of the field to be accessed.
&nbsp;     */
&nbsp;    String value() default TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFieldBinding.BEAN_PROPERTY;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines which type defines the field that is to be accessed. If this property is not set, the most field
&nbsp;     * that is defined highest in the type hierarchy is accessed.
&nbsp;     *
&nbsp;     * @return The type that defines the accessed field.
&nbsp;     */
&nbsp;    Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;    /**
&nbsp;     * A binder for the {@link FieldProxy} annotation.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Binder extends TargetMethodAnnotationDrivenBinder.ParameterBinder.ForFieldBinding&lt;FieldProxy&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * A reference to the method that declares the field annotation&#39;s defining type property.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape DECLARING_TYPE;
&nbsp;
&nbsp;        /**
&nbsp;         * A reference to the method that declares the field annotation&#39;s field name property.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape FIELD_NAME;
&nbsp;
&nbsp;        /**
&nbsp;         * A reference to the method that declares the field annotation&#39;s serializable proxy property.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape SERIALIZABLE_PROXY;
&nbsp;
&nbsp;        /*
&nbsp;         * Fetches a reference to all annotation properties.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; methodList = TypeDescription.ForLoadedType.of(FieldProxy.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;            DECLARING_TYPE = methodList.filter(named(&quot;declaringType&quot;)).getOnly();</b>
<b class="fc">&nbsp;            FIELD_NAME = methodList.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;            SERIALIZABLE_PROXY = methodList.filter(named(&quot;serializableProxy&quot;)).getOnly();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a binder by installing a single proxy type where annotating a parameter with {@link FieldProxy} allows
&nbsp;         * getting and setting values for a given field.
&nbsp;         *
&nbsp;         * @param type A type which declares exactly one abstract getter and an abstract setter for the {@link Object}
&nbsp;         *             type. The type is allowed to be generic.
&nbsp;         * @return A binder for the {@link FieldProxy} annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;FieldProxy&gt; install(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return install(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a binder by installing a single proxy type where annotating a parameter with {@link FieldProxy} allows
&nbsp;         * getting and setting values for a given field.
&nbsp;         *
&nbsp;         * @param typeDescription A type which declares exactly one abstract getter and an abstract setter for the {@link Object}
&nbsp;         *                        type. The type is allowed to be generic.
&nbsp;         * @return A binder for the {@link FieldProxy} annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;FieldProxy&gt; install(TypeDescription typeDescription) {
<b class="fc">&nbsp;            if (!typeDescription.isInterface()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not an interface&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.getInterfaces().isEmpty()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must not extend other interfaces&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.isPublic()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not public&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());</b>
<b class="fc">&nbsp;            if (methodCandidates.size() != 2) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; does not declare exactly two non-abstract methods&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; getterCandidates = methodCandidates.filter(isGetter(Object.class));</b>
<b class="fc">&nbsp;            if (getterCandidates.size() != 1) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; does not declare a getter with an Object type&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; setterCandidates = methodCandidates.filter(isSetter(Object.class));</b>
<b class="fc">&nbsp;            if (setterCandidates.size() != 1) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; does not declare a setter with an Object type&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Binder(typeDescription, getterCandidates.getOnly(), setterCandidates.getOnly());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a binder by installing two proxy types which are implemented by this binder if a field getter
&nbsp;         * or a field setter is requested by using the
&nbsp;         * {@link FieldProxy} annotation.
&nbsp;         *
&nbsp;         * @param getterType The type which should be used for getter proxies. The type must
&nbsp;         *                   represent an interface which defines a single method which returns an
&nbsp;         *                   {@link java.lang.Object} return type and does not take any arguments. The use of generics
&nbsp;         *                   is permitted.
&nbsp;         * @param setterType The type which should be uses for setter proxies. The type must
&nbsp;         *                   represent an interface which defines a single method which returns {@code void}
&nbsp;         *                   and takes a single {@link java.lang.Object}-typed argument. The use of generics
&nbsp;         *                   is permitted.
&nbsp;         * @return A binder for the {@link FieldProxy} annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;FieldProxy&gt; install(Class&lt;?&gt; getterType, Class&lt;?&gt; setterType) {
<b class="fc">&nbsp;            return install(TypeDescription.ForLoadedType.of(getterType), TypeDescription.ForLoadedType.of(setterType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a binder by installing two proxy types which are implemented by this binder if a field getter
&nbsp;         * or a field setter is requested by using the
&nbsp;         * {@link FieldProxy} annotation.
&nbsp;         *
&nbsp;         * @param getterType The type which should be used for getter proxies. The type must
&nbsp;         *                   represent an interface which defines a single method which returns an
&nbsp;         *                   {@link java.lang.Object} return type and does not take any arguments. The use of generics
&nbsp;         *                   is permitted.
&nbsp;         * @param setterType The type which should be uses for setter proxies. The type must
&nbsp;         *                   represent an interface which defines a single method which returns {@code void}
&nbsp;         *                   and takes a single {@link java.lang.Object}-typed argument. The use of generics
&nbsp;         *                   is permitted.
&nbsp;         * @return A binder for the {@link FieldProxy} annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;FieldProxy&gt; install(TypeDescription getterType, TypeDescription setterType) {
<b class="fc">&nbsp;            MethodDescription.InDefinedShape getterMethod = onlyMethod(getterType);</b>
<b class="fc">&nbsp;            if (!getterMethod.getReturnType().asErasure().represents(Object.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(getterMethod + &quot; must take a single Object-typed parameter&quot;);</b>
<b class="fc">&nbsp;            } else if (getterMethod.getParameters().size() != 0) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(getterMethod + &quot; must not declare parameters&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodDescription.InDefinedShape setterMethod = onlyMethod(setterType);</b>
<b class="fc">&nbsp;            if (!setterMethod.getReturnType().asErasure().represents(void.class)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(setterMethod + &quot; must return void&quot;);</b>
<b class="fc">&nbsp;            } else if (setterMethod.getParameters().size() != 1 || !setterMethod.getParameters().get(0).getType().asErasure().represents(Object.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(setterMethod + &quot; must declare a single Object-typed parameters&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Binder(getterMethod, setterMethod);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Extracts the only method from a given type description which is validated for the required properties for
&nbsp;         * using the type as a proxy base type.
&nbsp;         *
&nbsp;         * @param typeDescription The type description to evaluate.
&nbsp;         * @return The only method which was found to be compatible to the proxy requirements.
&nbsp;         */
&nbsp;        private static MethodDescription.InDefinedShape onlyMethod(TypeDescription typeDescription) {
<b class="fc">&nbsp;            if (!typeDescription.isInterface()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not an interface&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.getInterfaces().isEmpty()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must not extend other interfaces&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.isPublic()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not public&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());</b>
<b class="fc">&nbsp;            if (methodCandidates.size() != 1) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must declare exactly one abstract method&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return methodCandidates.getOnly();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The field resolver factory to apply by this binder.
&nbsp;         */
&nbsp;        private final FieldResolver.Factory fieldResolverFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new binder for a {@link FieldProxy} in simplex mode.
&nbsp;         *
&nbsp;         * @param getterMethod The getter method.
&nbsp;         * @param setterMethod The setter method.
&nbsp;         */
&nbsp;        protected Binder(MethodDescription.InDefinedShape getterMethod, MethodDescription.InDefinedShape setterMethod) {
<b class="fc">&nbsp;            this(new FieldResolver.Factory.Simplex(getterMethod, setterMethod));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new binder for a {@link FieldProxy} in duplex mode.
&nbsp;         *
&nbsp;         * @param proxyType    The proxy type.
&nbsp;         * @param getterMethod The getter method.
&nbsp;         * @param setterMethod The setter method.
&nbsp;         */
&nbsp;        protected Binder(TypeDescription proxyType, MethodDescription.InDefinedShape getterMethod, MethodDescription.InDefinedShape setterMethod) {
<b class="fc">&nbsp;            this(new FieldResolver.Factory.Duplex(proxyType, getterMethod, setterMethod));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new binder for a {@link FieldProxy}.
&nbsp;         *
&nbsp;         * @param fieldResolverFactory The field resolver factory to apply by this binder.
&nbsp;         */
<b class="fc">&nbsp;        protected Binder(FieldResolver.Factory fieldResolverFactory) {</b>
<b class="fc">&nbsp;            this.fieldResolverFactory = fieldResolverFactory;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Class&lt;FieldProxy&gt; getHandledType() {
<b class="fc">&nbsp;            return FieldProxy.class;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected String fieldName(AnnotationDescription.Loadable&lt;FieldProxy&gt; annotation) {
<b class="fc">&nbsp;            return annotation.getValue(FIELD_NAME).resolve(String.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected TypeDescription declaringType(AnnotationDescription.Loadable&lt;FieldProxy&gt; annotation) {
<b class="fc">&nbsp;            return annotation.getValue(DECLARING_TYPE).resolve(TypeDescription.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected MethodDelegationBinder.ParameterBinding&lt;?&gt; bind(FieldDescription fieldDescription,
&nbsp;                                                                  AnnotationDescription.Loadable&lt;FieldProxy&gt; annotation,
&nbsp;                                                                  MethodDescription source,
&nbsp;                                                                  ParameterDescription target,
&nbsp;                                                                  Implementation.Target implementationTarget,
&nbsp;                                                                  Assigner assigner) {
<b class="fc">&nbsp;            FieldResolver fieldResolver = fieldResolverFactory.resolve(target.getType().asErasure(), fieldDescription);</b>
<b class="fc">&nbsp;            if (fieldResolver.isResolved()) {</b>
<b class="fc">&nbsp;                return new MethodDelegationBinder.ParameterBinding.Anonymous(new AccessorProxy(fieldDescription,</b>
<b class="fc">&nbsp;                        implementationTarget.getInstrumentedType(),</b>
&nbsp;                        fieldResolver,
&nbsp;                        assigner,
<b class="fc">&nbsp;                        annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)));</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resolver for creating an instrumentation for a field access.
&nbsp;         */
&nbsp;        protected interface FieldResolver {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the field access can be established.
&nbsp;             *
&nbsp;             * @return {@code true} if the field access can be established.
&nbsp;             */
&nbsp;            boolean isResolved();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the type of the field access proxy.
&nbsp;             *
&nbsp;             * @return The type of the field access proxy.
&nbsp;             */
&nbsp;            TypeDescription getProxyType();
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this field resolver to a dynamic type.
&nbsp;             *
&nbsp;             * @param builder               The dynamic type builder to use.
&nbsp;             * @param fieldDescription      The accessed field.
&nbsp;             * @param assigner              The assigner to use.
&nbsp;             * @param methodAccessorFactory The method accessor factory to use.
&nbsp;             * @return The builder for creating the field accessor proxy type.
&nbsp;             */
&nbsp;            DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                         FieldDescription fieldDescription,
&nbsp;                                         Assigner assigner,
&nbsp;                                         MethodAccessorFactory methodAccessorFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a field resolver.
&nbsp;             */
&nbsp;            interface Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a field resolver.
&nbsp;                 *
&nbsp;                 * @param parameterType    The type of the annotated parameter.
&nbsp;                 * @param fieldDescription The field being proxied.
&nbsp;                 * @return An appropriate field resolver.
&nbsp;                 */
&nbsp;                FieldResolver resolve(TypeDescription parameterType, FieldDescription fieldDescription);
&nbsp;
&nbsp;                /**
&nbsp;                 * A duplex factory for a type that both sets and gets a field value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Duplex implements Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type of the accessor proxy.
&nbsp;                     */
&nbsp;                    private final TypeDescription proxyType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The getter method.
&nbsp;                     */
&nbsp;                    private final MethodDescription.InDefinedShape getterMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The setter method.
&nbsp;                     */
&nbsp;                    private final MethodDescription.InDefinedShape setterMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new duplex factory.
&nbsp;                     *
&nbsp;                     * @param proxyType    The type of the accessor proxy.
&nbsp;                     * @param getterMethod The getter method.
&nbsp;                     * @param setterMethod The setter method.
&nbsp;                     */
&nbsp;                    protected Duplex(TypeDescription proxyType,
&nbsp;                                     MethodDescription.InDefinedShape getterMethod,
<b class="fc">&nbsp;                                     MethodDescription.InDefinedShape setterMethod) {</b>
<b class="fc">&nbsp;                        this.proxyType = proxyType;</b>
<b class="fc">&nbsp;                        this.getterMethod = getterMethod;</b>
<b class="fc">&nbsp;                        this.setterMethod = setterMethod;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldResolver resolve(TypeDescription parameterType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                        if (parameterType.equals(proxyType)) {</b>
<b class="fc">&nbsp;                            return new ForGetterSetterPair(proxyType, getterMethod, setterMethod);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot use @FieldProxy on a non-installed type&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A simplex factory where field getters and setters both have their own type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simplex implements Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The getter method.
&nbsp;                     */
&nbsp;                    private final MethodDescription.InDefinedShape getterMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The setter method.
&nbsp;                     */
&nbsp;                    private final MethodDescription.InDefinedShape setterMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a simplex factory.
&nbsp;                     *
&nbsp;                     * @param getterMethod The getter method.
&nbsp;                     * @param setterMethod The setter method.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Simplex(MethodDescription.InDefinedShape getterMethod, MethodDescription.InDefinedShape setterMethod) {</b>
<b class="fc">&nbsp;                        this.getterMethod = getterMethod;</b>
<b class="fc">&nbsp;                        this.setterMethod = setterMethod;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldResolver resolve(TypeDescription parameterType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                        if (parameterType.equals(getterMethod.getDeclaringType())) {</b>
<b class="fc">&nbsp;                            return new ForGetter(getterMethod);</b>
<b class="fc">&nbsp;                        } else if (parameterType.equals(setterMethod.getDeclaringType())) {</b>
<b class="fc">&nbsp;                            return fieldDescription.isFinal()</b>
<b class="fc">&nbsp;                                    ? Unresolved.INSTANCE</b>
<b class="fc">&nbsp;                                    : new ForSetter(setterMethod);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot use @FieldProxy on a non-installed type&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An unresolved field resolver.
&nbsp;             */
<b class="fc">&nbsp;            enum Unresolved implements FieldResolver {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isResolved() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getProxyType() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot read type for unresolved field resolver&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                                    FieldDescription fieldDescription,
&nbsp;                                                    Assigner assigner,
&nbsp;                                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot apply unresolved field resolver&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field resolver for a getter accessor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForGetter implements FieldResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * The getter method.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape getterMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new getter field resolver.
&nbsp;                 *
&nbsp;                 * @param getterMethod The getter method.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForGetter(MethodDescription.InDefinedShape getterMethod) {</b>
<b class="fc">&nbsp;                    this.getterMethod = getterMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isResolved() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getProxyType() {
<b class="fc">&nbsp;                    return getterMethod.getDeclaringType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                                    FieldDescription fieldDescription,
&nbsp;                                                    Assigner assigner,
&nbsp;                                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                    return builder.method(definedMethod(is(getterMethod))).intercept(new FieldGetter(fieldDescription, assigner, methodAccessorFactory));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field resolver for a setter accessor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForSetter implements FieldResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * The setter method.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape setterMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field resolver for a setter accessor.
&nbsp;                 *
&nbsp;                 * @param setterMethod The setter method.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForSetter(MethodDescription.InDefinedShape setterMethod) {</b>
<b class="fc">&nbsp;                    this.setterMethod = setterMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isResolved() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getProxyType() {
<b class="fc">&nbsp;                    return setterMethod.getDeclaringType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                                    FieldDescription fieldDescription,
&nbsp;                                                    Assigner assigner,
&nbsp;                                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                    return builder.method(is(setterMethod)).intercept(new FieldSetter(fieldDescription, assigner, methodAccessorFactory));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field resolver for an accessor that both gets and sets a field value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForGetterSetterPair implements FieldResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the accessor proxy.
&nbsp;                 */
&nbsp;                private final TypeDescription proxyType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The getter method.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape getterMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The setter method.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape setterMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field resolver for an accessor that both gets and sets a field value.
&nbsp;                 *
&nbsp;                 * @param proxyType    The type of the accessor proxy.
&nbsp;                 * @param getterMethod The getter method.
&nbsp;                 * @param setterMethod The setter method.
&nbsp;                 */
&nbsp;                protected ForGetterSetterPair(TypeDescription proxyType,
&nbsp;                                              MethodDescription.InDefinedShape getterMethod,
<b class="fc">&nbsp;                                              MethodDescription.InDefinedShape setterMethod) {</b>
<b class="fc">&nbsp;                    this.proxyType = proxyType;</b>
<b class="fc">&nbsp;                    this.getterMethod = getterMethod;</b>
<b class="fc">&nbsp;                    this.setterMethod = setterMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isResolved() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getProxyType() {
<b class="fc">&nbsp;                    return proxyType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                                    FieldDescription fieldDescription,
&nbsp;                                                    Assigner assigner,
&nbsp;                                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                    return builder</b>
<b class="fc">&nbsp;                            .method(is(getterMethod)).intercept(new FieldGetter(fieldDescription, assigner, methodAccessorFactory))</b>
<b class="fc">&nbsp;                            .method(is(setterMethod)).intercept(fieldDescription.isFinal()</b>
<b class="fc">&nbsp;                                    ? ExceptionMethod.throwing(UnsupportedOperationException.class, &quot;Cannot set final field &quot; + fieldDescription)</b>
<b class="fc">&nbsp;                                    : new FieldSetter(fieldDescription, assigner, methodAccessorFactory));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an implementation for implementing a proxy type constructor when a static field is accessed.
&nbsp;         */
<b class="fc">&nbsp;        protected enum StaticFieldConstructor implements Implementation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A reference of the {@link Object} type default constructor.
&nbsp;             */
&nbsp;            private final MethodDescription objectTypeDefaultConstructor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates the constructor call singleton.
&nbsp;             */
&nbsp;            StaticFieldConstructor() {
&nbsp;                objectTypeDefaultConstructor = TypeDescription.ForLoadedType.of(Object.class).getDeclaredMethods().filter(isConstructor()).getOnly();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                return new ByteCodeAppender.Simple(MethodVariableAccess.loadThis(), MethodInvocation.invoke(objectTypeDefaultConstructor), MethodReturn.VOID);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an implementation for implementing a proxy type constructor when a non-static field is accessed.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class InstanceFieldConstructor implements Implementation {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type from which a field is to be accessed.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new implementation for implementing a field accessor proxy&#39;s constructor when accessing
&nbsp;             * a non-static field.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type from which a field is to be accessed.
&nbsp;             */
<b class="fc">&nbsp;            protected InstanceFieldConstructor(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType.withField(new FieldDescription.Token(AccessorProxy.FIELD_NAME,</b>
&nbsp;                        Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
<b class="fc">&nbsp;                        this.instrumentedType.asGenericType()));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                return new Appender(implementationTarget);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An appender for implementing an
&nbsp;             * {@link FieldProxy.Binder.InstanceFieldConstructor}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to be set within the constructor.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new appender.
&nbsp;                 *
&nbsp;                 * @param implementationTarget The implementation target of the current implementation.
&nbsp;                 */
<b class="fc">&nbsp;                protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;                    fieldDescription = implementationTarget.getInstrumentedType()</b>
<b class="fc">&nbsp;                            .getDeclaredFields()</b>
<b class="fc">&nbsp;                            .filter((named(AccessorProxy.FIELD_NAME)))</b>
<b class="fc">&nbsp;                            .getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor,
&nbsp;                                  Context implementationContext,
&nbsp;                                  MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                            MethodInvocation.invoke(StaticFieldConstructor.INSTANCE.objectTypeDefaultConstructor),</b>
<b class="fc">&nbsp;                            MethodVariableAccess.allArgumentsOf(instrumentedMethod.asDefined()).prependThisReference(),</b>
<b class="fc">&nbsp;                            FieldAccess.forField(fieldDescription).write(),</b>
&nbsp;                            MethodReturn.VOID
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implementation for a getter method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        protected static class FieldGetter implements Implementation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The field that is being accessed.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * The accessed type&#39;s method accessor factory.
&nbsp;             */
&nbsp;            private final MethodAccessorFactory methodAccessorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new getter implementation.
&nbsp;             *
&nbsp;             * @param fieldDescription      The field that is being accessed.
&nbsp;             * @param assigner              The assigner to use.
&nbsp;             * @param methodAccessorFactory The accessed type&#39;s method accessor factory.
&nbsp;             */
&nbsp;            protected FieldGetter(FieldDescription fieldDescription,
&nbsp;                                  Assigner assigner,
<b class="fc">&nbsp;                                  MethodAccessorFactory methodAccessorFactory) {</b>
<b class="fc">&nbsp;                this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.methodAccessorFactory = methodAccessorFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                return new Appender(implementationTarget);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A byte code appender for a getter method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                /**
&nbsp;                 * The generated accessor type.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new appender for a setter method.
&nbsp;                 *
&nbsp;                 * @param implementationTarget The implementation target of the current instrumentation.
&nbsp;                 */
<b class="fc">&nbsp;                protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;                    typeDescription = implementationTarget.getInstrumentedType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor,
&nbsp;                                  Context implementationContext,
&nbsp;                                  MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    MethodDescription getterMethod = methodAccessorFactory.registerGetterFor(fieldDescription, MethodAccessorFactory.AccessType.DEFAULT);</b>
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                                    ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                    : new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                    FieldAccess.forField(typeDescription.getDeclaredFields().filter((named(AccessorProxy.FIELD_NAME))).getOnly()).read()),</b>
<b class="fc">&nbsp;                            MethodInvocation.invoke(getterMethod),</b>
<b class="fc">&nbsp;                            assigner.assign(getterMethod.getReturnType(), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),</b>
<b class="fc">&nbsp;                            MethodReturn.of(instrumentedMethod.getReturnType().asErasure())</b>
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implementation for a setter method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        protected static class FieldSetter implements Implementation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The field that is being accessed.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * The accessed type&#39;s method accessor factory.
&nbsp;             */
&nbsp;            private final MethodAccessorFactory methodAccessorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new setter implementation.
&nbsp;             *
&nbsp;             * @param fieldDescription      The field that is being accessed.
&nbsp;             * @param assigner              The assigner to use.
&nbsp;             * @param methodAccessorFactory The accessed type&#39;s method accessor factory.
&nbsp;             */
&nbsp;            protected FieldSetter(FieldDescription fieldDescription,
&nbsp;                                  Assigner assigner,
<b class="fc">&nbsp;                                  MethodAccessorFactory methodAccessorFactory) {</b>
<b class="fc">&nbsp;                this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.methodAccessorFactory = methodAccessorFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                return instrumentedType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                return new Appender(implementationTarget);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A byte code appender for a setter method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                /**
&nbsp;                 * The generated accessor type.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new appender for a setter method.
&nbsp;                 *
&nbsp;                 * @param implementationTarget The implementation target of the current instrumentation.
&nbsp;                 */
<b class="fc">&nbsp;                protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;                    typeDescription = implementationTarget.getInstrumentedType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Size apply(MethodVisitor methodVisitor,
&nbsp;                                  Context implementationContext,
&nbsp;                                  MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    TypeDescription.Generic parameterType = instrumentedMethod.getParameters().get(0).getType();</b>
<b class="fc">&nbsp;                    MethodDescription setterMethod = methodAccessorFactory.registerSetterFor(fieldDescription, MethodAccessorFactory.AccessType.DEFAULT);</b>
<b class="fc">&nbsp;                    StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                                    ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                    : new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                    FieldAccess.forField(typeDescription.getDeclaredFields()</b>
<b class="fc">&nbsp;                                            .filter((named(AccessorProxy.FIELD_NAME))).getOnly()).read()),</b>
<b class="fc">&nbsp;                            MethodVariableAccess.of(parameterType).loadFrom(1),</b>
<b class="fc">&nbsp;                            assigner.assign(parameterType, setterMethod.getParameters().get(0).getType(), Assigner.Typing.DYNAMIC),</b>
<b class="fc">&nbsp;                            MethodInvocation.invoke(setterMethod),</b>
&nbsp;                            MethodReturn.VOID
<b class="fc">&nbsp;                    ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                    return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy type for accessing a field either by a getter or a setter.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected static class AccessorProxy extends StackManipulation.AbstractBase implements AuxiliaryType {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the field that stores the accessed instance if any.
&nbsp;             */
&nbsp;            protected static final String FIELD_NAME = &quot;instance&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The field that is being accessed.
&nbsp;             */
&nbsp;            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The type which is accessed.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The field resolver to use.
&nbsp;             */
&nbsp;            private final FieldResolver fieldResolver;
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the generated proxy should be serializable.
&nbsp;             */
&nbsp;            private final boolean serializableProxy;
&nbsp;
&nbsp;            /**
&nbsp;             * @param fieldDescription  The field that is being accessed.
&nbsp;             * @param instrumentedType  The type which is accessed.
&nbsp;             * @param fieldResolver     The field resolver to use.
&nbsp;             * @param assigner          The assigner to use.
&nbsp;             * @param serializableProxy {@code true} if the generated proxy should be serializable.
&nbsp;             */
&nbsp;            protected AccessorProxy(FieldDescription fieldDescription,
&nbsp;                                    TypeDescription instrumentedType,
&nbsp;                                    FieldResolver fieldResolver,
&nbsp;                                    Assigner assigner,
<b class="fc">&nbsp;                                    boolean serializableProxy) {</b>
<b class="fc">&nbsp;                this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.fieldResolver = fieldResolver;</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.serializableProxy = serializableProxy;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSuffix() {
<b class="fc">&nbsp;                return RandomString.hashOf(fieldDescription.hashCode()) + (serializableProxy ? &quot;S&quot; : &quot;0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType make(String auxiliaryTypeName,
&nbsp;                                    ClassFileVersion classFileVersion,
&nbsp;                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                return fieldResolver.apply(new ByteBuddy(classFileVersion)</b>
<b class="fc">&nbsp;                        .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                        .subclass(fieldResolver.getProxyType(), ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="fc">&nbsp;                        .name(auxiliaryTypeName)</b>
<b class="fc">&nbsp;                        .modifiers(DEFAULT_TYPE_MODIFIER)</b>
<b class="fc">&nbsp;                        .implement(serializableProxy ? new Class&lt;?&gt;[]{Serializable.class} : new Class&lt;?&gt;[0])</b>
<b class="fc">&nbsp;                        .defineConstructor().withParameters(fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                                ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                                : Collections.singletonList(instrumentedType))</b>
<b class="fc">&nbsp;                        .intercept(fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                                ? StaticFieldConstructor.INSTANCE</b>
<b class="fc">&nbsp;                                : new InstanceFieldConstructor(instrumentedType)), fieldDescription, assigner, methodAccessorFactory).make();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;                TypeDescription auxiliaryType = implementationContext.register(this);</b>
<b class="fc">&nbsp;                return new Compound(</b>
<b class="fc">&nbsp;                        TypeCreation.of(auxiliaryType),</b>
&nbsp;                        Duplication.SINGLE,
<b class="fc">&nbsp;                        fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                                ? Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                : MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(auxiliaryType.getDeclaredMethods().filter(isConstructor()).getOnly())</b>
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
