


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Morph</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.implementation.bind.annotation</a>
</div>

<h1>Coverage Summary for Class: Morph (net.bytebuddy.implementation.bind.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Morph$Binder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.6%
  </span>
  <span class="absValue">
    (35/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$DefaultMethodLocator</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$DefaultMethodLocator$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$DefaultMethodLocator$Implicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$RedirectionProxy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (27/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$RedirectionProxy$InstanceFieldConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$RedirectionProxy$InstanceFieldConstructor$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$RedirectionProxy$MethodCall</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$RedirectionProxy$MethodCall$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$Binder$RedirectionProxy$StaticFieldConstructor</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Morph$MockitoMock$1907205629</td>
  </tr>
  <tr>
    <td class="name">Morph$MockitoMock$1907205629$auxiliary$8CrOMMP3</td>
  </tr>
  <tr>
    <td class="name">Morph$MockitoMock$1907205629$auxiliary$BX6h2Z6J</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    93.5%
  </span>
  <span class="absValue">
    (29/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93%
  </span>
  <span class="absValue">
    (119/128)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.implementation.bind.annotation;
&nbsp;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodAccessorFactory;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bind.MethodDelegationBinder;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.util.Collections;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * This annotation instructs Byte Buddy to inject a proxy class that calls a method&#39;s super method with
&nbsp; * explicit arguments. For this, the {@link Morph.Binder}
&nbsp; * needs to be installed for an interface type that takes an argument of the array type {@link java.lang.Object} and
&nbsp; * returns a non-array type of {@link java.lang.Object}. This is an alternative to using the
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.SuperCall} or
&nbsp; * {@link net.bytebuddy.implementation.bind.annotation.DefaultCall} annotations which call a super
&nbsp; * method using the same arguments as the intercepted method was invoked with.
&nbsp; *
&nbsp; * @see net.bytebuddy.implementation.MethodDelegation
&nbsp; * @see net.bytebuddy.implementation.bind.annotation.TargetMethodAnnotationDrivenBinder
&nbsp; */
&nbsp;@Documented
&nbsp;@Retention(RetentionPolicy.RUNTIME)
&nbsp;@Target(ElementType.PARAMETER)
&nbsp;public @interface Morph {
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the injected proxy for this parameter should be serializable.
&nbsp;     *
&nbsp;     * @return {@code true} if the proxy should be serializable.
&nbsp;     */
&nbsp;    boolean serializableProxy() default false;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the proxy should attempt to invoke a default method. If the default method is ambiguous,
&nbsp;     * use the {@link Morph#defaultTarget()} property instead which allows to determine an explicit interface
&nbsp;     * on which the default method should be invoked on. If this other method is used, this property is ignored.
&nbsp;     *
&nbsp;     * @return {@code true} if a default method should be ignored.
&nbsp;     */
&nbsp;    boolean defaultMethod() default false;
&nbsp;
&nbsp;    /**
&nbsp;     * The type on which a default method should be invoked. When this property is not set and the
&nbsp;     * {@link Morph#defaultMethod()} property is set to {@code false}, a normal super method invocation is attempted.
&nbsp;     *
&nbsp;     * @return The target interface of a default method call.
&nbsp;     */
&nbsp;    Class&lt;?&gt; defaultTarget() default void.class;
&nbsp;
&nbsp;    /**
&nbsp;     * A binder for the {@link net.bytebuddy.implementation.bind.annotation.Morph} annotation.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Binder implements TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;Morph&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * A reference to the serializable proxy method.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape SERIALIZABLE_PROXY;
&nbsp;
&nbsp;        /**
&nbsp;         * A reference to the default method method.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape DEFAULT_METHOD;
&nbsp;
&nbsp;        /**
&nbsp;         * A reference to the default target method.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape DEFAULT_TARGET;
&nbsp;
&nbsp;        /*
&nbsp;         * Looks up references for all annotation properties of the morph annotation.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; methodList = TypeDescription.ForLoadedType.of(Morph.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;            SERIALIZABLE_PROXY = methodList.filter(named(&quot;serializableProxy&quot;)).getOnly();</b>
<b class="fc">&nbsp;            DEFAULT_METHOD = methodList.filter(named(&quot;defaultMethod&quot;)).getOnly();</b>
<b class="fc">&nbsp;            DEFAULT_TARGET = methodList.filter(named(&quot;defaultTarget&quot;)).getOnly();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The method which is overridden for generating the proxy class.
&nbsp;         */
&nbsp;        private final MethodDescription forwardingMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new binder.
&nbsp;         *
&nbsp;         * @param forwardingMethod The method which is overridden for generating the proxy class.
&nbsp;         */
<b class="fc">&nbsp;        protected Binder(MethodDescription forwardingMethod) {</b>
<b class="fc">&nbsp;            this.forwardingMethod = forwardingMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Installs a given type for use on a {@link net.bytebuddy.implementation.bind.annotation.Morph}
&nbsp;         * annotation. The given type must be an interface without any super interfaces and a single method which
&nbsp;         * maps an {@link java.lang.Object} array to a {@link java.lang.Object} type. The use of generics is
&nbsp;         * permitted.
&nbsp;         *
&nbsp;         * @param type The type to install.
&nbsp;         * @return A binder for the {@link net.bytebuddy.implementation.bind.annotation.Morph}
&nbsp;         * annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;Morph&gt; install(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return install(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Installs a given type for use on a {@link net.bytebuddy.implementation.bind.annotation.Morph}
&nbsp;         * annotation. The given type must be an interface without any super interfaces and a single method which
&nbsp;         * maps an {@link java.lang.Object} array to a {@link java.lang.Object} type. The use of generics is
&nbsp;         * permitted.
&nbsp;         *
&nbsp;         * @param typeDescription The type to install.
&nbsp;         * @return A binder for the {@link net.bytebuddy.implementation.bind.annotation.Morph}
&nbsp;         * annotation.
&nbsp;         */
&nbsp;        public static TargetMethodAnnotationDrivenBinder.ParameterBinder&lt;Morph&gt; install(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return new Binder(onlyMethod(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Extracts the only method of a given type and validates to fit the constraints of the morph annotation.
&nbsp;         *
&nbsp;         * @param typeDescription The type to extract the method from.
&nbsp;         * @return The only method after validation.
&nbsp;         */
&nbsp;        private static MethodDescription onlyMethod(TypeDescription typeDescription) {
<b class="fc">&nbsp;            if (!typeDescription.isInterface()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not an interface&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.getInterfaces().isEmpty()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must not extend other interfaces&quot;);</b>
<b class="fc">&nbsp;            } else if (!typeDescription.isPublic()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is mot public&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;?&gt; methodCandidates = typeDescription.getDeclaredMethods().filter(isAbstract());</b>
<b class="fc">&nbsp;            if (methodCandidates.size() != 1) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; must declare exactly one abstract method&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodDescription methodDescription = methodCandidates.getOnly();</b>
<b class="fc">&nbsp;            if (!methodDescription.getReturnType().asErasure().represents(Object.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(methodDescription + &quot; does not return an Object-type&quot;);</b>
<b class="fc">&nbsp;            } else if (methodDescription.getParameters().size() != 1 || !methodDescription.getParameters().get(0).getType().asErasure().represents(Object[].class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(methodDescription + &quot; does not take a single argument of type Object[]&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return methodDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Class&lt;Morph&gt; getHandledType() {
<b class="fc">&nbsp;            return Morph.class;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDelegationBinder.ParameterBinding&lt;?&gt; bind(AnnotationDescription.Loadable&lt;Morph&gt; annotation,
&nbsp;                                                               MethodDescription source,
&nbsp;                                                               ParameterDescription target,
&nbsp;                                                               Implementation.Target implementationTarget,
&nbsp;                                                               Assigner assigner,
&nbsp;                                                               Assigner.Typing typing) {
<b class="fc">&nbsp;            if (!target.getType().asErasure().equals(forwardingMethod.getDeclaringType())) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Illegal use of @Morph for &quot; + target + &quot; which was installed for &quot; + forwardingMethod.getDeclaringType());</b>
&nbsp;            }
&nbsp;            Implementation.SpecialMethodInvocation specialMethodInvocation;
<b class="fc">&nbsp;            TypeDescription typeDescription = annotation.getValue(DEFAULT_TARGET).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;            if (typeDescription.represents(void.class) &amp;&amp; !annotation.getValue(DEFAULT_METHOD).resolve(Boolean.class)) {</b>
<b class="fc">&nbsp;                specialMethodInvocation = implementationTarget.invokeSuper(source.asSignatureToken()).withCheckedCompatibilityTo(source.asTypeToken());</b>
&nbsp;            } else {
<b class="fc">&nbsp;                specialMethodInvocation = (typeDescription.represents(void.class)</b>
<b class="fc">&nbsp;                        ? DefaultMethodLocator.Implicit.INSTANCE</b>
<b class="fc">&nbsp;                        : new DefaultMethodLocator.Explicit(typeDescription)).resolve(implementationTarget, source);</b>
&nbsp;            }
<b class="fc">&nbsp;            return specialMethodInvocation.isValid()</b>
<b class="fc">&nbsp;                    ? new MethodDelegationBinder.ParameterBinding.Anonymous(new RedirectionProxy(forwardingMethod.getDeclaringType().asErasure(),</b>
<b class="fc">&nbsp;                    implementationTarget.getInstrumentedType(),</b>
&nbsp;                    specialMethodInvocation,
&nbsp;                    assigner,
<b class="fc">&nbsp;                    annotation.getValue(SERIALIZABLE_PROXY).resolve(Boolean.class)))</b>
<b class="fc">&nbsp;                    : MethodDelegationBinder.ParameterBinding.Illegal.INSTANCE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default method locator is responsible for looking up a default method to a given source method.
&nbsp;         */
&nbsp;        protected interface DefaultMethodLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * Locates the correct default method to a given source method.
&nbsp;             *
&nbsp;             * @param implementationTarget The current implementation target.
&nbsp;             * @param source               The source method for which a default method should be looked up.
&nbsp;             * @return A special method invocation of the default method or an illegal special method invocation,
&nbsp;             * if no suitable invocation could be located.
&nbsp;             */
&nbsp;            Implementation.SpecialMethodInvocation resolve(Implementation.Target implementationTarget,
&nbsp;                                                           MethodDescription source);
&nbsp;
&nbsp;            /**
&nbsp;             * An implicit default method locator that only permits the invocation of a default method if the source
&nbsp;             * method itself represents a method that was defined on a default method interface.
&nbsp;             */
<b class="fc">&nbsp;            enum Implicit implements DefaultMethodLocator {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Implementation.SpecialMethodInvocation resolve(Implementation.Target implementationTarget, MethodDescription source) {
<b class="fc">&nbsp;                    return implementationTarget.invokeDefault(source.asSignatureToken()).withCheckedCompatibilityTo(source.asTypeToken());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An explicit default method locator attempts to look up a default method in the specified interface type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Explicit implements DefaultMethodLocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the type on which the default method should be invoked.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new explicit default method locator.
&nbsp;                 *
&nbsp;                 * @param typeDescription The actual target interface as explicitly defined by
&nbsp;                 *                        {@link DefaultCall#targetType()}.
&nbsp;                 */
<b class="fc">&nbsp;                public Explicit(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Implementation.SpecialMethodInvocation resolve(Implementation.Target implementationTarget, MethodDescription source) {
<b class="fc">&nbsp;                    if (!typeDescription.isInterface()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(source + &quot; method carries default method call parameter on non-interface type&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return implementationTarget</b>
<b class="fc">&nbsp;                            .invokeDefault(source.asSignatureToken(), typeDescription)</b>
<b class="fc">&nbsp;                            .withCheckedCompatibilityTo(source.asTypeToken());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy that implements the installed interface in order to allow for a morphed super method invocation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class RedirectionProxy extends StackManipulation.AbstractBase implements AuxiliaryType {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the field that carries an instance for invoking a super method on.
&nbsp;             */
&nbsp;            protected static final String FIELD_NAME = &quot;target&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The interface type that is implemented by the generated proxy.
&nbsp;             */
&nbsp;            private final TypeDescription morphingType;
&nbsp;
&nbsp;            /**
&nbsp;             * The type that is instrumented on which the super method is invoked.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The special method invocation to be executed by the morphing type via an accessor on the
&nbsp;             * instrumented type.
&nbsp;             */
&nbsp;            private final Implementation.SpecialMethodInvocation specialMethodInvocation;
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if the generated proxy should be {@link java.io.Serializable}.
&nbsp;             */
&nbsp;            private final boolean serializableProxy;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new redirection proxy.
&nbsp;             *
&nbsp;             * @param morphingType            The interface type that is implemented by the generated proxy.
&nbsp;             * @param instrumentedType        The type that is instrumented on which the super method is invoked.
&nbsp;             * @param specialMethodInvocation The special method invocation to be executed by the morphing type via
&nbsp;             *                                an accessor on the instrumented type.
&nbsp;             * @param assigner                The assigner to use.
&nbsp;             * @param serializableProxy       {@code true} if the proxy should be serializable.
&nbsp;             */
&nbsp;            protected RedirectionProxy(TypeDescription morphingType,
&nbsp;                                       TypeDescription instrumentedType,
&nbsp;                                       Implementation.SpecialMethodInvocation specialMethodInvocation,
&nbsp;                                       Assigner assigner,
<b class="fc">&nbsp;                                       boolean serializableProxy) {</b>
<b class="fc">&nbsp;                this.morphingType = morphingType;</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.specialMethodInvocation = specialMethodInvocation;</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.serializableProxy = serializableProxy;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSuffix() {
<b class="fc">&nbsp;                return RandomString.hashOf(morphingType.hashCode()) + (serializableProxy ? &quot;S&quot; : &quot;0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType make(String auxiliaryTypeName,
&nbsp;                                    ClassFileVersion classFileVersion,
&nbsp;                                    MethodAccessorFactory methodAccessorFactory) {
<b class="fc">&nbsp;                return new ByteBuddy(classFileVersion)</b>
<b class="fc">&nbsp;                        .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                        .subclass(morphingType, ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="fc">&nbsp;                        .name(auxiliaryTypeName)</b>
<b class="fc">&nbsp;                        .modifiers(DEFAULT_TYPE_MODIFIER)</b>
<b class="fc">&nbsp;                        .implement(serializableProxy ? new Class&lt;?&gt;[]{Serializable.class} : new Class&lt;?&gt;[0])</b>
<b class="fc">&nbsp;                        .defineConstructor().withParameters(specialMethodInvocation.getMethodDescription().isStatic()</b>
<b class="nc">&nbsp;                                ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                                : Collections.singletonList(instrumentedType))</b>
<b class="fc">&nbsp;                        .intercept(specialMethodInvocation.getMethodDescription().isStatic()</b>
<b class="nc">&nbsp;                                ? StaticFieldConstructor.INSTANCE</b>
<b class="fc">&nbsp;                                : new InstanceFieldConstructor(instrumentedType))</b>
<b class="fc">&nbsp;                        .method(ElementMatchers.&lt;MethodDescription&gt;isAbstract().and(isDeclaredBy(morphingType)))</b>
<b class="fc">&nbsp;                        .intercept(new MethodCall(methodAccessorFactory.registerAccessorFor(specialMethodInvocation, MethodAccessorFactory.AccessType.DEFAULT), assigner))</b>
<b class="fc">&nbsp;                        .make();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext) {
<b class="fc">&nbsp;                TypeDescription forwardingType = implementationContext.register(this);</b>
<b class="fc">&nbsp;                return new Compound(</b>
<b class="fc">&nbsp;                        TypeCreation.of(forwardingType),</b>
&nbsp;                        Duplication.SINGLE,
<b class="fc">&nbsp;                        specialMethodInvocation.getMethodDescription().isStatic()</b>
<b class="nc">&nbsp;                                ? Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                : MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                        MethodInvocation.invoke(forwardingType.getDeclaredMethods().filter(isConstructor()).getOnly())</b>
<b class="fc">&nbsp;                ).apply(methodVisitor, implementationContext);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an instance of the proxy when instrumenting a static method.
&nbsp;             */
<b class="fc">&nbsp;            protected enum StaticFieldConstructor implements Implementation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference of the {@link Object} type default constructor.
&nbsp;                 */
&nbsp;                private final MethodDescription objectTypeDefaultConstructor;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates the constructor call singleton.
&nbsp;                 */
&nbsp;                StaticFieldConstructor() {
&nbsp;                    objectTypeDefaultConstructor = TypeDescription.ForLoadedType.of(Object.class).getDeclaredMethods()
&nbsp;                            .filter(isConstructor())
&nbsp;                            .getOnly();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="nc">&nbsp;                    return new ByteCodeAppender.Simple(MethodVariableAccess.loadThis(), MethodInvocation.invoke(objectTypeDefaultConstructor), MethodReturn.VOID);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an instance of the proxy when instrumenting an instance method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class InstanceFieldConstructor implements Implementation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new instance field constructor implementation.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 */
<b class="fc">&nbsp;                protected InstanceFieldConstructor(TypeDescription instrumentedType) {</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType.withField(new FieldDescription.Token(RedirectionProxy.FIELD_NAME,</b>
&nbsp;                            Opcodes.ACC_FINAL | Opcodes.ACC_PRIVATE,
<b class="fc">&nbsp;                            this.instrumentedType.asGenericType()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                    return new Appender(implementationTarget);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The byte code appender that implements the constructor.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field that carries the instance on which the super method is invoked.
&nbsp;                     */
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender.
&nbsp;                     *
&nbsp;                     * @param implementationTarget The current implementation target.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;                        fieldDescription = implementationTarget.getInstrumentedType()</b>
<b class="fc">&nbsp;                                .getDeclaredFields()</b>
<b class="fc">&nbsp;                                .filter((named(RedirectionProxy.FIELD_NAME)))</b>
<b class="fc">&nbsp;                                .getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor,
&nbsp;                                      Context implementationContext,
&nbsp;                                      MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                MethodInvocation.invoke(StaticFieldConstructor.INSTANCE.objectTypeDefaultConstructor),</b>
<b class="fc">&nbsp;                                MethodVariableAccess.allArgumentsOf(instrumentedMethod).prependThisReference(),</b>
<b class="fc">&nbsp;                                FieldAccess.forField(fieldDescription).write(),</b>
&nbsp;                                MethodReturn.VOID
<b class="fc">&nbsp;                        ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                        return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements a the method call of the morphing method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class MethodCall implements Implementation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessor method to invoke from the proxy&#39;s method.
&nbsp;                 */
&nbsp;                private final MethodDescription accessorMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The assigner to be used.
&nbsp;                 */
&nbsp;                private final Assigner assigner;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new method call implementation for a proxy method.
&nbsp;                 *
&nbsp;                 * @param accessorMethod The accessor method to invoke from the proxy&#39;s method.
&nbsp;                 * @param assigner       The assigner to be used.
&nbsp;                 */
<b class="fc">&nbsp;                protected MethodCall(MethodDescription accessorMethod, Assigner assigner) {</b>
<b class="fc">&nbsp;                    this.accessorMethod = accessorMethod;</b>
<b class="fc">&nbsp;                    this.assigner = assigner;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;                    return new Appender(implementationTarget);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The byte code appender to implement the method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The proxy type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender.
&nbsp;                     *
&nbsp;                     * @param implementationTarget The current implementation target.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Appender(Target implementationTarget) {</b>
<b class="fc">&nbsp;                        typeDescription = implementationTarget.getInstrumentedType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor,
&nbsp;                                      Context implementationContext,
&nbsp;                                      MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        StackManipulation arrayReference = MethodVariableAccess.REFERENCE.loadFrom(1);</b>
<b class="fc">&nbsp;                        StackManipulation[] parameterLoading = new StackManipulation[accessorMethod.getParameters().size()];</b>
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        for (TypeDescription.Generic parameterType : accessorMethod.getParameters().asTypeList()) {</b>
<b class="fc">&nbsp;                            parameterLoading[index] = new StackManipulation.Compound(arrayReference,</b>
<b class="fc">&nbsp;                                    IntegerConstant.forValue(index),</b>
<b class="fc">&nbsp;                                    ArrayAccess.REFERENCE.load(),</b>
<b class="fc">&nbsp;                                    assigner.assign(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), parameterType, Assigner.Typing.DYNAMIC));</b>
<b class="fc">&nbsp;                            index++;</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        StackManipulation.Size stackSize = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                accessorMethod.isStatic()</b>
<b class="nc">&nbsp;                                        ? Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                        : new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                        MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                        FieldAccess.forField(typeDescription.getDeclaredFields()</b>
<b class="fc">&nbsp;                                                .filter((named(RedirectionProxy.FIELD_NAME)))</b>
<b class="fc">&nbsp;                                                .getOnly()).read()),</b>
&nbsp;                                new StackManipulation.Compound(parameterLoading),
<b class="fc">&nbsp;                                MethodInvocation.invoke(accessorMethod),</b>
<b class="fc">&nbsp;                                assigner.assign(accessorMethod.getReturnType(), instrumentedMethod.getReturnType(), Assigner.Typing.DYNAMIC),</b>
&nbsp;                                MethodReturn.REFERENCE
<b class="fc">&nbsp;                        ).apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                        return new Size(stackSize.getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
