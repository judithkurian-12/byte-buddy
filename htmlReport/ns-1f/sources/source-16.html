


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ElementMatchers</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.matcher</a>
</div>

<h1>Coverage Summary for Class: ElementMatchers (net.bytebuddy.matcher)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ElementMatchers</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.5%
  </span>
  <span class="absValue">
    (194/197)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.6%
  </span>
  <span class="absValue">
    (245/251)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.matcher;
&nbsp;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;
&nbsp;/**
&nbsp; * A utility class that contains a human-readable language for creating {@link net.bytebuddy.matcher.ElementMatcher}s.
&nbsp; */
&nbsp;public final class ElementMatchers {
&nbsp;
&nbsp;    /**
&nbsp;     * A private constructor that must not be invoked.
&nbsp;     */
<b class="fc">&nbsp;    private ElementMatchers() {</b>
<b class="fc">&nbsp;        throw new UnsupportedOperationException(&quot;This class is a utility class and not supposed to be instantiated&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps another matcher to assure that an element is not matched in case that the matching causes an {@link Exception}.
&nbsp;     *
&nbsp;     * @param matcher The element matcher that potentially throws an exception.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that returns {@code false} in case that the given matcher throws an exception.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; failSafe(ElementMatcher&lt;? super T&gt; matcher) {
<b class="fc">&nbsp;        return new FailSafeMatcher&lt;T&gt;(matcher, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Wraps another matcher but caches the result of previously matched elements. Caching can be important if a
&nbsp;     * matcher requires expensive calculations.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: The supplied map can however introduce a memory leak as the matched elements are stored within the map.
&nbsp;     * It is therefore important to dereference this matcher at some point or to regularly evict entries from the supplied map.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param matcher The actual matcher for which the results are cached.
&nbsp;     * @param map     The map for storing results of previously matched elements.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that stores the results of a previous matching in the supplied map.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; cached(ElementMatcher&lt;? super T&gt; matcher, ConcurrentMap&lt;? super T, Boolean&gt; map) {
<b class="fc">&nbsp;        return new CachingMatcher&lt;T&gt;(matcher, map);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Wraps another matcher but caches the result of previously matched elements. Caching can be important if a
&nbsp;     * matcher requires expensive calculations.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: The cache will hold {@code evictionSize} elements and evict a random element once the cache
&nbsp;     * contains more than the specified amount of elements. Cached elements are referenced strongly and might cause
&nbsp;     * a memory leak if instance are of a significant size. Using {@link ElementMatchers#cached(ElementMatcher, ConcurrentMap)}
&nbsp;     * allows for explicit control over cache eviction.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param matcher      The actual matcher for which the results are cached.
&nbsp;     * @param evictionSize The maximum amount of elements that are stored in the cache. Must be a positive number.
&nbsp;     * @param &lt;T&gt;          The type of the matched object.
&nbsp;     * @return A matcher that stores the results of a previous matching in the supplied map.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; cached(ElementMatcher&lt;? super T&gt; matcher, int evictionSize) {
<b class="fc">&nbsp;        if (evictionSize &lt; 1) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Eviction size must be a positive number: &quot; + evictionSize);</b>
&nbsp;        }
<b class="fc">&nbsp;        return new CachingMatcher.WithInlineEviction&lt;T&gt;(matcher, new ConcurrentHashMap&lt;T, Boolean&gt;(), evictionSize);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches the given value which can also be {@code null} by the {@link java.lang.Object#equals(Object)} method or
&nbsp;     * by a null-check.
&nbsp;     *
&nbsp;     * @param value The value that is to be matched.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that matches an exact value.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; is(@MaybeNull Object value) {
<b class="fc">&nbsp;        return value == null</b>
<b class="fc">&nbsp;                ? NullMatcher.&lt;T&gt;make()</b>
<b class="fc">&nbsp;                : new EqualityMatcher&lt;T&gt;(value);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given field as a {@link FieldDescription} in its defined shape.
&nbsp;     *
&nbsp;     * @param field The field to match by its description
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given field in its defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; is(Field field) {
<b class="fc">&nbsp;        return is(new FieldDescription.ForLoadedField(field));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given field as a {@link FieldDescription} in its defined shape.
&nbsp;     *
&nbsp;     * @param field The field to match by its description
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given field in its defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; is(FieldDescription.InDefinedShape field) {
<b class="fc">&nbsp;        return definedField(new EqualityMatcher&lt;FieldDescription.InDefinedShape&gt;(field));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field in its defined shape.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the matched field&#39;s defined shape.
&nbsp;     * @param &lt;T&gt;     The matched object&#39;s type.
&nbsp;     * @return A matcher that matches a matched field&#39;s defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; definedField(ElementMatcher&lt;? super FieldDescription.InDefinedShape&gt; matcher) {
<b class="fc">&nbsp;        return new DefinedShapeMatcher&lt;T, FieldDescription.InDefinedShape&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given method as a {@link MethodDescription} in its defined shape.
&nbsp;     *
&nbsp;     * @param method The method to match by its description
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given method in its defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; is(Method method) {
<b class="fc">&nbsp;        return is(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given constructor as a {@link MethodDescription} in its defined shape.
&nbsp;     *
&nbsp;     * @param constructor The constructor to match by its description
&nbsp;     * @param &lt;T&gt;         The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given constructor in its defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; is(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;        return is(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given method or constructor as a {@link MethodDescription} in its defined shape.
&nbsp;     *
&nbsp;     * @param method The method to match by its description
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given method or constructor in its defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; is(MethodDescription.InDefinedShape method) {
<b class="fc">&nbsp;        return definedMethod(new EqualityMatcher&lt;MethodDescription.InDefinedShape&gt;(method));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method in its defined shape.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the matched method&#39;s defined shape.
&nbsp;     * @param &lt;T&gt;     The matched object&#39;s type.
&nbsp;     * @return A matcher that matches a matched method&#39;s defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; definedMethod(ElementMatcher&lt;? super MethodDescription.InDefinedShape&gt; matcher) {
<b class="fc">&nbsp;        return new DefinedShapeMatcher&lt;T, MethodDescription.InDefinedShape&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given parameter as a {@link ParameterDescription} in its defined shape.
&nbsp;     *
&nbsp;     * @param parameter The parameter to match by its description
&nbsp;     * @param &lt;T&gt;       The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given parameter in its defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends ParameterDescription&gt; ElementMatcher.Junction&lt;T&gt; is(ParameterDescription.InDefinedShape parameter) {
<b class="fc">&nbsp;        return definedParameter(new EqualityMatcher&lt;ParameterDescription.InDefinedShape&gt;(parameter));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a parameter in its defined shape.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the matched parameter&#39;s defined shape.
&nbsp;     * @param &lt;T&gt;     The matched object&#39;s type.
&nbsp;     * @return A matcher that matches a matched parameter&#39;s defined shape.
&nbsp;     */
&nbsp;    public static &lt;T extends ParameterDescription&gt; ElementMatcher.Junction&lt;T&gt; definedParameter(ElementMatcher&lt;? super ParameterDescription.InDefinedShape&gt; matcher) {
<b class="fc">&nbsp;        return new DefinedShapeMatcher&lt;T, ParameterDescription.InDefinedShape&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a parameter&#39;s type by the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the parameter&#39;s type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a parameter&#39;s type by the given matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends ParameterDescription&gt; ElementMatcher.Junction&lt;T&gt; hasType(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return hasGenericType(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method parameter by its generic type.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to a parameter&#39;s generic type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches the matched parameter&#39;s generic type.
&nbsp;     */
&nbsp;    public static &lt;T extends ParameterDescription&gt; ElementMatcher.Junction&lt;T&gt; hasGenericType(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new MethodParameterTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a parameter description for a {@code mandated} parameter.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code mandated} parameter.
&nbsp;     */
&nbsp;    public static &lt;T extends ParameterDescription&gt; ElementMatcher.Junction&lt;T&gt; isMandated() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.MANDATED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given type as a {@link TypeDescription}.
&nbsp;     *
&nbsp;     * @param type The type to match by its description
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; is(Type type) {
<b class="fc">&nbsp;        return is(TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Exactly matches a given annotation as an {@link AnnotationDescription}.
&nbsp;     *
&nbsp;     * @param annotation The annotation to match by its description.
&nbsp;     * @param &lt;T&gt;        The type of the matched object.
&nbsp;     * @return An element matcher that exactly matches the given annotation.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; is(Annotation annotation) {
<b class="fc">&nbsp;        return is(AnnotationDescription.ForLoadedAnnotation.of(annotation));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inverts another matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to invert.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return An inverted version of the given {@code matcher}.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; not(ElementMatcher&lt;? super T&gt; matcher) {
<b class="fc">&nbsp;        return new NegatingMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that always returns {@code true}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches anything.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; any() {
<b class="fc">&nbsp;        return BooleanMatcher.of(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that always returns {@code false}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches nothing.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; none() {
<b class="fc">&nbsp;        return BooleanMatcher.of(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a matcher that matches any of the given objects by the {@link java.lang.Object#equals(Object)} method.
&nbsp;     * None of the values must be {@code null}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This method cannot be used interchangeably with any of its overloaded versions which also apply a type
&nbsp;     * conversion.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Object... value) {
<b class="fc">&nbsp;        return anyOf(Arrays.asList(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates a matcher that matches any of the given objects by the {@link java.lang.Object#equals(Object)} method.
&nbsp;     * None of the values must be {@code null}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This method cannot be used interchangeably with any of the overloaded versions of {@link ElementMatchers#anyOf(Object...)}
&nbsp;     * which also apply a type conversion.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param values The input values to be compared against.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Iterable&lt;?&gt; values) {
<b class="fc">&nbsp;        ElementMatcher.Junction&lt;T&gt; matcher = null;</b>
<b class="fc">&nbsp;        for (Object value : values) {</b>
<b class="fc">&nbsp;            matcher = matcher == null</b>
<b class="fc">&nbsp;                    ? ElementMatchers.&lt;T&gt;is(value)</b>
<b class="fc">&nbsp;                    : matcher.or(is(value));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return matcher == null</b>
<b class="fc">&nbsp;                ? ElementMatchers.&lt;T&gt;none()</b>
<b class="fc">&nbsp;                : matcher;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches any of the given types as {@link TypeDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Type... value) {
<b class="fc">&nbsp;        return anyOf(new TypeList.Generic.ForLoadedTypes(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches any of the given constructors as {@link MethodDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Constructor&lt;?&gt;... value) {
<b class="fc">&nbsp;        return definedMethod(anyOf(new MethodList.ForLoadedMethods(value, new Method[0])));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches any of the given methods as {@link MethodDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Method... value) {
<b class="fc">&nbsp;        return definedMethod(anyOf(new MethodList.ForLoadedMethods(new Constructor&lt;?&gt;[0], value)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches any of the given fields as {@link FieldDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Field... value) {
<b class="fc">&nbsp;        return definedField(anyOf(new FieldList.ForLoadedFields(value)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches any of the given annotations as {@link AnnotationDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; anyOf(Annotation... value) {
<b class="fc">&nbsp;        return anyOf(new AnnotationList.ForLoadedAnnotations(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given objects by the {@link java.lang.Object#equals(Object)} method.
&nbsp;     * None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with none of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Object... value) {
<b class="fc">&nbsp;        return noneOf(Arrays.asList(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given objects by the {@link java.lang.Object#equals(Object)} method.
&nbsp;     * None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param values The input values to be compared against.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with none of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Iterable&lt;?&gt; values) {
<b class="fc">&nbsp;        ElementMatcher.Junction&lt;T&gt; matcher = null;</b>
<b class="fc">&nbsp;        for (Object value : values) {</b>
<b class="fc">&nbsp;            matcher = matcher == null</b>
<b class="fc">&nbsp;                    ? ElementMatchers.&lt;T&gt;not(is(value))</b>
<b class="fc">&nbsp;                    : matcher.and(not(is(value)));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return matcher == null</b>
<b class="nc">&nbsp;                ? ElementMatchers.&lt;T&gt;any()</b>
<b class="fc">&nbsp;                : matcher;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given types as {@link TypeDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with none of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Type... value) {
<b class="fc">&nbsp;        return noneOf(new TypeList.Generic.ForLoadedTypes(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given constructors as {@link MethodDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with none of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Constructor&lt;?&gt;... value) {
<b class="fc">&nbsp;        return definedMethod(noneOf(new MethodList.ForLoadedMethods(value, new Method[0])));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given methods as {@link MethodDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with none of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Method... value) {
<b class="fc">&nbsp;        return definedMethod(noneOf(new MethodList.ForLoadedMethods(new Constructor&lt;?&gt;[0], value)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given methods as {@link FieldDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with none of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Field... value) {
<b class="fc">&nbsp;        return definedField(noneOf(new FieldList.ForLoadedFields(value)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a matcher that matches none of the given annotations as {@link AnnotationDescription}s
&nbsp;     * by the {@link java.lang.Object#equals(Object)} method. None of the values must be {@code null}.
&nbsp;     *
&nbsp;     * @param value The input values to be compared against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that checks for the equality with any of the given objects.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; noneOf(Annotation... value) {
<b class="fc">&nbsp;        return noneOf(new AnnotationList.ForLoadedAnnotations(value));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an iterable by assuring that at least one element of the iterable collection matches the
&nbsp;     * provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to each element.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches an iterable if at least one element matches the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;Iterable&lt;? extends T&gt;&gt; whereAny(ElementMatcher&lt;? super T&gt; matcher) {
<b class="fc">&nbsp;        return new CollectionItemMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an iterable by assuring that no element of the iterable collection matches the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to each element.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches an iterable if no element matches the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T&gt; ElementMatcher.Junction&lt;Iterable&lt;? extends T&gt;&gt; whereNone(ElementMatcher&lt;? super T&gt; matcher) {
<b class="fc">&nbsp;        return not(whereAny(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a generic type&#39;s erasure against the provided type. As a wildcard does not define an erasure, a runtime exception is thrown when
&nbsp;     * this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param type The type to match a generic type&#39;s erasure against.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a generic type&#39;s raw type against the provided non-generic type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription.Generic&gt; ElementMatcher.Junction&lt;T&gt; erasure(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return erasure(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a generic type&#39;s erasure against the provided type. As a wildcard does not define an erasure, a runtime exception is thrown
&nbsp;     * when this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param type The type to match a generic type&#39;s erasure against.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a generic type&#39;s raw type against the provided non-generic type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription.Generic&gt; ElementMatcher.Junction&lt;T&gt; erasure(TypeDescription type) {
<b class="fc">&nbsp;        return erasure(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Converts a matcher for a type description into a matcher for the matched type&#39;s erasure. As a wildcard does not define an erasure,
&nbsp;     * a runtime exception is thrown when this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param matcher The matcher to match the matched object&#39;s raw type against.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A type matcher for a generic type that matches the matched type&#39;s raw type against the given type description matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription.Generic&gt; ElementMatcher.Junction&lt;T&gt; erasure(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return new ErasureMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an iteration of generic types&#39; erasures against the provided types. As a wildcard does not define an erasure, a runtime
&nbsp;     * exception is thrown when this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param type The types to match.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches an iteration of generic types&#39; raw types against the provided non-generic types.
&nbsp;     */
&nbsp;    public static &lt;T extends Iterable&lt;? extends TypeDescription.Generic&gt;&gt; ElementMatcher.Junction&lt;T&gt; erasures(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;        return erasures(new TypeList.ForLoadedTypes(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an iteration of generic types&#39; erasures against the provided types. As a wildcard does not define an erasure, a runtime
&nbsp;     * exception is thrown when this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param type The types to match.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches an iteration of generic types&#39; raw types against the provided non-generic types.
&nbsp;     */
&nbsp;    public static &lt;T extends Iterable&lt;? extends TypeDescription.Generic&gt;&gt; ElementMatcher.Junction&lt;T&gt; erasures(TypeDescription... type) {
<b class="fc">&nbsp;        return erasures(Arrays.asList(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an iteration of generic types&#39; erasures against the provided types. As a wildcard does not define an erasure, a runtime
&nbsp;     * exception is thrown when this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param types The types to match.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher that matches an iteration of generic types&#39; raw types against the provided non-generic types.
&nbsp;     */
&nbsp;    public static &lt;T extends Iterable&lt;? extends TypeDescription.Generic&gt;&gt; ElementMatcher.Junction&lt;T&gt; erasures(
&nbsp;            Iterable&lt;? extends TypeDescription&gt; types) {
<b class="fc">&nbsp;        List&lt;ElementMatcher&lt;? super TypeDescription&gt;&gt; typeMatchers = new ArrayList&lt;ElementMatcher&lt;? super TypeDescription&gt;&gt;();</b>
<b class="fc">&nbsp;        for (TypeDescription type : types) {</b>
<b class="fc">&nbsp;            typeMatchers.add(is(type));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return erasures(new CollectionOneToOneMatcher&lt;TypeDescription&gt;(typeMatchers));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies the provided matchers to an iteration og generic types&#39; erasures. As a wildcard does not define an erasure, a runtime
&nbsp;     * exception is thrown when this matcher is applied to a wildcard.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply at the erased types.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches an iteration of generic types&#39; raw types against the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends Iterable&lt;? extends TypeDescription.Generic&gt;&gt; ElementMatcher.Junction&lt;T&gt; erasures(
&nbsp;            ElementMatcher&lt;? super Iterable&lt;? extends TypeDescription&gt;&gt; matcher) {
<b class="fc">&nbsp;        return new CollectionErasureMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type variable with the given name.
&nbsp;     *
&nbsp;     * @param symbol The name of the type variable to be match.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return A matcher that matches type variables with the given name.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; isVariable(String symbol) {
<b class="fc">&nbsp;        return isVariable(named(symbol));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type variable with the given name.
&nbsp;     *
&nbsp;     * @param matcher A matcher for the type variable&#39;s name.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches type variables with the given name.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; isVariable(ElementMatcher&lt;? super NamedElement&gt; matcher) {
<b class="fc">&nbsp;        return new TypeSortMatcher&lt;T&gt;(anyOf(TypeDefinition.Sort.VARIABLE, TypeDefinition.Sort.VARIABLE_SYMBOLIC)).and(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its exact name.
&nbsp;     *
&nbsp;     * @param name The expected name.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s exact name.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; named(String name) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(name, StringMatcher.Mode.EQUALS_FULLY));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its membership of a set.
&nbsp;     *
&nbsp;     * @param names The set of expected names.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher which matches if the element&#39;s name is found in the set.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; namedOneOf(String... names) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringSetMatcher(new HashSet&lt;String&gt;(Arrays.asList(names))));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its name. The name&#39;s
&nbsp;     * capitalization is ignored.
&nbsp;     *
&nbsp;     * @param name The expected name.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; namedIgnoreCase(String name) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(name, StringMatcher.Mode.EQUALS_FULLY_IGNORE_CASE));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its name&#39;s prefix.
&nbsp;     *
&nbsp;     * @param prefix The expected name&#39;s prefix.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s prefix.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameStartsWith(String prefix) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(prefix, StringMatcher.Mode.STARTS_WITH));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its name&#39;s prefix. The name&#39;s
&nbsp;     * capitalization is ignored.
&nbsp;     *
&nbsp;     * @param prefix The expected name&#39;s prefix.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s prefix.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameStartsWithIgnoreCase(String prefix) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(prefix, StringMatcher.Mode.STARTS_WITH_IGNORE_CASE));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its name&#39;s suffix.
&nbsp;     *
&nbsp;     * @param suffix The expected name&#39;s suffix.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s suffix.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameEndsWith(String suffix) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(suffix, StringMatcher.Mode.ENDS_WITH));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for its name&#39;s suffix. The name&#39;s
&nbsp;     * capitalization is ignored.
&nbsp;     *
&nbsp;     * @param suffix The expected name&#39;s suffix.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s suffix.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameEndsWithIgnoreCase(String suffix) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(suffix, StringMatcher.Mode.ENDS_WITH_IGNORE_CASE));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for an infix of its name.
&nbsp;     *
&nbsp;     * @param infix The expected infix of the name.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s infix.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameContains(String infix) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(infix, StringMatcher.Mode.CONTAINS));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} for an infix of its name. The name&#39;s
&nbsp;     * capitalization is ignored.
&nbsp;     *
&nbsp;     * @param infix The expected infix of the name.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s infix.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameContainsIgnoreCase(String infix) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(infix, StringMatcher.Mode.CONTAINS_IGNORE_CASE));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement} name against a regular expression.
&nbsp;     *
&nbsp;     * @param regex The regular expression to match the name against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher for a named element&#39;s name&#39;s against the given regular expression.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement&gt; ElementMatcher.Junction&lt;T&gt; nameMatches(String regex) {
<b class="fc">&nbsp;        return new NameMatcher&lt;T&gt;(new StringMatcher(regex, StringMatcher.Mode.MATCHES));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement.WithOptionalName} for having an explicit name.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return An element matcher that checks if the matched optionally named element has an explicit name.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement.WithOptionalName&gt; ElementMatcher.Junction&lt;T&gt; isNamed() {
<b class="fc">&nbsp;        return new IsNamedMatcher&lt;T&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link NamedElement.WithDescriptor}&#39;s descriptor against a given value.
&nbsp;     *
&nbsp;     * @param descriptor The expected descriptor.
&nbsp;     * @param &lt;T&gt;        The type of the matched object.
&nbsp;     * @return A matcher for the given {@code descriptor}.
&nbsp;     */
&nbsp;    public static &lt;T extends NamedElement.WithDescriptor&gt; ElementMatcher.Junction&lt;T&gt; hasDescriptor(String descriptor) {
<b class="fc">&nbsp;        return new DescriptorMatcher&lt;T&gt;(new StringMatcher(descriptor, StringMatcher.Mode.EQUALS_FULLY));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} for being declared by a given {@link java.lang.Class}. This matcher matches
&nbsp;     * a declared element&#39;s raw declaring type.
&nbsp;     *
&nbsp;     * @param type The type that is expected to declare the matched byte code element.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for byte code elements being declared by the given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isDeclaredBy(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isDeclaredBy(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} for being declared by a given {@link TypeDescription}. This matcher matches
&nbsp;     * a declared element&#39;s raw declaring type.
&nbsp;     *
&nbsp;     * @param type The type that is expected to declare the matched byte code element.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for byte code elements being declared by the given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isDeclaredBy(TypeDescription type) {
<b class="fc">&nbsp;        return isDeclaredBy(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} for being declared by a {@link TypeDescription} that is matched by the given matcher. This matcher matches
&nbsp;     * a declared element&#39;s raw declaring type.
&nbsp;     *
&nbsp;     * @param matcher A matcher for the declaring type of the matched byte code element as long as it
&nbsp;     *                is not {@code null}.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher for byte code elements being declared by a type matched by the given {@code matcher}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isDeclaredBy(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return isDeclaredByGeneric(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} for being declared by a given generic {@link Type}.
&nbsp;     *
&nbsp;     * @param type The type that is expected to declare the matched byte code element.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for byte code elements being declared by the given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isDeclaredByGeneric(Type type) {
<b class="fc">&nbsp;        return isDeclaredByGeneric(TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} for being declared by a given {@link TypeDescription.Generic}.
&nbsp;     *
&nbsp;     * @param type The type that is expected to declare the matched byte code element.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for byte code elements being declared by the given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isDeclaredByGeneric(TypeDescription.Generic type) {
<b class="fc">&nbsp;        return isDeclaredByGeneric(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} for being declared by a {@link TypeDescription.Generic} that is matched by the given matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher for the declaring type of the matched byte code element as long as it is not {@code null}.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher for byte code elements being declared by a type matched by the given {@code matcher}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isDeclaredByGeneric(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new DeclaringTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} that is visible to a given {@link java.lang.Class}.
&nbsp;     *
&nbsp;     * @param type The type that a matched byte code element is expected to be visible to.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for a byte code element to be visible to a given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isVisibleTo(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isVisibleTo(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} that is visible to a given {@link TypeDescription}.
&nbsp;     *
&nbsp;     * @param type The type that a matched byte code element is expected to be visible to.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for a byte code element to be visible to a given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isVisibleTo(TypeDescription type) {
<b class="fc">&nbsp;        return new VisibilityMatcher&lt;T&gt;(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} that is accessible to a given {@link java.lang.Class}.
&nbsp;     *
&nbsp;     * @param type The type that a matched byte code element is expected to be accessible to.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for a byte code element to be accessible to a given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isAccessibleTo(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isAccessibleTo(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ByteCodeElement} that is accessible to a given {@link java.lang.Class}.
&nbsp;     *
&nbsp;     * @param type The type that a matched byte code element is expected to be accessible to.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher for a byte code element to be accessible to a given {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends ByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isAccessibleTo(TypeDescription type) {
<b class="fc">&nbsp;        return new AccessibilityMatcher&lt;T&gt;(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable.OfAbstraction} that is {@code abstract}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code abstract} modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfAbstraction&gt; ElementMatcher.Junction&lt;T&gt; isAbstract() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.ABSTRACT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable.OfEnumeration} that is an {@code enum} or a field holding an enum.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for an enum.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfEnumeration&gt; ElementMatcher.Junction&lt;T&gt; isEnum() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.ENUMERATION);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an {@link AnnotationSource} for declared annotations.
&nbsp;     * This matcher does not match inherited annotations which only exist for classes. Use
&nbsp;     * {@link net.bytebuddy.matcher.ElementMatchers#inheritsAnnotation(Class)} for matching inherited annotations.
&nbsp;     *
&nbsp;     * @param type The annotation type to match against.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that validates that an annotated element is annotated with an annotation of {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationSource&gt; ElementMatcher.Junction&lt;T&gt; isAnnotatedWith(Class&lt;? extends Annotation&gt; type) {
<b class="fc">&nbsp;        return isAnnotatedWith(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an {@link AnnotationSource} for declared annotations.
&nbsp;     * This matcher does not match inherited annotations which only exist for classes. Use
&nbsp;     * {@link net.bytebuddy.matcher.ElementMatchers#inheritsAnnotation(TypeDescription)}
&nbsp;     * for matching inherited annotations.
&nbsp;     *
&nbsp;     * @param type The annotation type to match against.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that validates that an annotated element is annotated with an annotation of {@code type}.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationSource&gt; ElementMatcher.Junction&lt;T&gt; isAnnotatedWith(TypeDescription type) {
<b class="fc">&nbsp;        return isAnnotatedWith(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an {@link AnnotationSource} for declared annotations.
&nbsp;     * This matcher does not match inherited annotations which only exist for classes. Use
&nbsp;     * {@link net.bytebuddy.matcher.ElementMatchers#inheritsAnnotation(net.bytebuddy.matcher.ElementMatcher)}
&nbsp;     * for matching inherited annotations.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to any annotation&#39;s type found on the matched annotated element.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that validates that an annotated element is annotated with an annotation of a type
&nbsp;     * that matches the given {@code matcher}.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationSource&gt; ElementMatcher.Junction&lt;T&gt; isAnnotatedWith(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return declaresAnnotation(annotationType(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches an {@link AnnotationSource} to declare any annotation
&nbsp;     * that matches the given matcher. Note that this matcher does not match inherited annotations that only exist
&nbsp;     * for types. Use {@link net.bytebuddy.matcher.ElementMatchers#inheritsAnnotation(net.bytebuddy.matcher.ElementMatcher)}
&nbsp;     * for matching inherited annotations.
&nbsp;     *
&nbsp;     * @param matcher A matcher to apply on any declared annotation of the matched annotated element.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that validates that an annotated element is annotated with an annotation that matches
&nbsp;     * the given {@code matcher}.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationSource&gt; ElementMatcher.Junction&lt;T&gt; declaresAnnotation(ElementMatcher&lt;? super AnnotationDescription&gt; matcher) {
<b class="fc">&nbsp;        return new DeclaringAnnotationMatcher&lt;T&gt;(new CollectionItemMatcher&lt;AnnotationDescription&gt;(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is {@code public}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code public} modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isPublic() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.PUBLIC);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is {@code protected}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code protected} modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isProtected() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.PROTECTED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is package-private.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a package-private modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isPackagePrivate() {
<b class="fc">&nbsp;        return not(isPublic().or(isProtected()).or(isPrivate()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is {@code private}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code private} modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isPrivate() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.PRIVATE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is {@code static}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code static} modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.OfByteCodeElement&gt; ElementMatcher.Junction&lt;T&gt; isStatic() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.STATIC);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is {@code final}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code final} modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable&gt; ElementMatcher.Junction&lt;T&gt; isFinal() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.FINAL);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link ModifierReviewable} that is synthetic.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a synthetic modifier reviewable.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable&gt; ElementMatcher.Junction&lt;T&gt; isSynthetic() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.SYNTHETIC);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} that is {@code synchronized}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code synchronized} method description.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.ForMethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isSynchronized() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.SYNCHRONIZED);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} that is {@code native}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code native} method description.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.ForMethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isNative() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.NATIVE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} that is {@code strictfp}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code strictfp} method description.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.ForMethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isStrict() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.STRICT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} that is a var-args.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a var-args method description.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.ForMethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isVarArgs() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.VAR_ARGS);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} that is a bridge.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a bridge method.
&nbsp;     */
&nbsp;    public static &lt;T extends ModifierReviewable.ForMethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isBridge() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.BRIDGE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that return a given generic type.
&nbsp;     *
&nbsp;     * @param type The generic type the matched method is expected to return.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher that matches a given generic return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; returnsGeneric(Type type) {
<b class="fc">&nbsp;        return returnsGeneric(TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that returns a given
&nbsp;     * {@link TypeDescription}.
&nbsp;     *
&nbsp;     * @param type The type the matched method is expected to return.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher that matches a given return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; returnsGeneric(TypeDescription.Generic type) {
<b class="fc">&nbsp;        return returnsGeneric(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that return a given erasure type.
&nbsp;     *
&nbsp;     * @param type The raw type the matched method is expected to return.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher that matches a given return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; returns(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return returnsGeneric(erasure(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that return a given erasure type.
&nbsp;     *
&nbsp;     * @param type The raw type the matched method is expected to return.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return An element matcher that matches a given return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; returns(TypeDescription type) {
<b class="fc">&nbsp;        return returns(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method&#39;s return type&#39;s erasure by the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to a method&#39;s return type&#39;s erasure.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches the matched method&#39;s return type&#39;s erasure.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; returns(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return returnsGeneric(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that match a matched method&#39;s return type.
&nbsp;     *
&nbsp;     * @param matcher A matcher to apply onto a matched method&#39;s return type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return An element matcher that matches a given return type against another {@code matcher}.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; returnsGeneric(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new MethodReturnTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that define a given generic type as a parameter at the given index.
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param type  The generic type the matched method is expected to define as a parameter type.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher that matches a given generic return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArgument(int index, Type type) {
<b class="fc">&nbsp;        return takesGenericArgument(index, TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that define a given generic type as a parameter at the given index.
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param type  The generic type the matched method is expected to define as a parameter type.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher that matches a given generic return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArgument(int index, TypeDescription.Generic type) {
<b class="fc">&nbsp;        return takesGenericArgument(index, is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that define a given generic type as a parameter at the given index.
&nbsp;     *
&nbsp;     * @param index   The index of the parameter.
&nbsp;     * @param matcher A matcher for the generic type the matched method is expected to define as a parameter type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return An element matcher that matches a given generic return type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArgument(int index, ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return takesGenericArguments(new CollectionElementMatcher&lt;TypeDescription.Generic&gt;(index, matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method description that takes the provided generic arguments.
&nbsp;     *
&nbsp;     * @param type The arguments to match against the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A method matcher that matches a method&#39;s generic parameter types against the supplied arguments.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArguments(Type... type) {
<b class="fc">&nbsp;        return takesGenericArguments(new TypeList.Generic.ForLoadedTypes(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method description that takes the provided generic arguments.
&nbsp;     *
&nbsp;     * @param type The arguments to match against the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A method matcher that matches a method&#39;s generic parameter types against the supplied arguments.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArguments(TypeDefinition... type) {
<b class="fc">&nbsp;        return takesGenericArguments((Arrays.asList(type)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method description that takes the provided generic arguments.
&nbsp;     *
&nbsp;     * @param types The arguments to match against the matched method.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A method matcher that matches a method&#39;s generic parameter types against the supplied arguments.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArguments(List&lt;? extends TypeDefinition&gt; types) {
<b class="fc">&nbsp;        List&lt;ElementMatcher&lt;? super TypeDescription.Generic&gt;&gt; typeMatchers = new ArrayList&lt;ElementMatcher&lt;? super TypeDescription.Generic&gt;&gt;();</b>
<b class="fc">&nbsp;        for (TypeDefinition type : types) {</b>
<b class="fc">&nbsp;            typeMatchers.add(is(type));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return takesGenericArguments(new CollectionOneToOneMatcher&lt;TypeDescription.Generic&gt;(typeMatchers));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} by applying an iterable collection of element matcher on any parameter&#39;s {@link TypeDescription.Generic}.
&nbsp;     *
&nbsp;     * @param matchers The matcher that are applied onto the parameter types of the matched method description.
&nbsp;     * @param &lt;T&gt;      The type of the matched object.
&nbsp;     * @return A matcher that matches a method description by applying another element matcher onto each parameter&#39;s type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesGenericArguments(ElementMatcher&lt;? super Iterable&lt;? extends TypeDescription.Generic&gt;&gt; matchers) {
<b class="fc">&nbsp;        return new MethodParametersMatcher&lt;T&gt;(new MethodParameterTypesMatcher&lt;ParameterList&lt;?&gt;&gt;(matchers));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that define a given generic type as a parameter at the given index.
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param type  The erasure of the type the matched method is expected to define as a parameter type.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher that matches a given argument type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArgument(int index, Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return takesArgument(index, TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that define a given type erasure as a parameter at the given index.
&nbsp;     *
&nbsp;     * @param index The index of the parameter.
&nbsp;     * @param type  The erasure of the type the matched method is expected to define as a parameter type.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return An element matcher that matches a given argument type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArgument(int index, TypeDescription type) {
<b class="fc">&nbsp;        return takesArgument(index, is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches {@link MethodDescription}s that define a type erasure as a parameter at the given index that matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param index   The index of the parameter.
&nbsp;     * @param matcher A matcher to apply to the argument at the specified index.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return An element matcher that matches a given argument type for a method description.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArgument(int index, ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return takesGenericArgument(index, erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method description that takes the provided raw arguments.
&nbsp;     *
&nbsp;     * @param type The arguments to match against the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A method matcher that matches a method&#39;s raw parameter types against the supplied arguments.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArguments(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;        return takesGenericArguments(erasures(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method description that takes the provided raw arguments.
&nbsp;     *
&nbsp;     * @param type The arguments to match against the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A method matcher that matches a method&#39;s raw parameter types against the supplied arguments.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArguments(TypeDescription... type) {
<b class="fc">&nbsp;        return takesGenericArguments(erasures(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method description that takes the provided raw arguments.
&nbsp;     *
&nbsp;     * @param types The arguments to match against the matched method.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A method matcher that matches a method&#39;s raw parameter types against the supplied arguments.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArguments(Iterable&lt;? extends TypeDescription&gt; types) {
<b class="fc">&nbsp;        List&lt;ElementMatcher&lt;? super TypeDescription.Generic&gt;&gt; typeMatchers = new ArrayList&lt;ElementMatcher&lt;? super TypeDescription.Generic&gt;&gt;();</b>
<b class="fc">&nbsp;        for (TypeDescription type : types) {</b>
<b class="fc">&nbsp;            typeMatchers.add(erasure(type));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return takesGenericArguments(new CollectionOneToOneMatcher&lt;TypeDescription.Generic&gt;(typeMatchers));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} by applying an iterable collection of element matcher on any parameter&#39;s {@link TypeDescription}.
&nbsp;     *
&nbsp;     * @param matchers The matcher that are applied onto the parameter types of the matched method description.
&nbsp;     * @param &lt;T&gt;      The type of the matched object.
&nbsp;     * @return A matcher that matches a method description by applying another element matcher onto each parameter&#39;s type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArguments(ElementMatcher&lt;? super Iterable&lt;? extends TypeDescription&gt;&gt; matchers) {
<b class="nc">&nbsp;        return new MethodParametersMatcher&lt;T&gt;(new MethodParameterTypesMatcher&lt;ParameterList&lt;?&gt;&gt;(erasures(matchers)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} by the number of its parameters.
&nbsp;     *
&nbsp;     * @param length The expected length.
&nbsp;     * @param &lt;T&gt;    The type of the matched object.
&nbsp;     * @return A matcher that matches a method description by the number of its parameters.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesArguments(int length) {
<b class="fc">&nbsp;        return new MethodParametersMatcher&lt;T&gt;(new CollectionSizeMatcher&lt;ParameterList&lt;?&gt;&gt;(length));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} with no parameters.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches a method description by the number of its parameters.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; takesNoArguments() {
<b class="fc">&nbsp;        return takesArguments(0);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} by validating that its parameters
&nbsp;     * fulfill a given constraint.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply for validating the parameters.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a method description&#39;s parameters against the given constraint.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; hasParameters(
&nbsp;            ElementMatcher&lt;? super Iterable&lt;? extends ParameterDescription&gt;&gt; matcher) {
<b class="fc">&nbsp;        return new MethodParametersMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} by its capability to throw a given
&nbsp;     * checked exception. For specifying a non-checked exception, any method is matched.
&nbsp;     *
&nbsp;     * @param exceptionType The type of the exception that should be declared by the method to be matched.
&nbsp;     * @param &lt;T&gt;           The type of the matched object.
&nbsp;     * @return A matcher that matches a method description by its declaration of throwing a checked exception.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; canThrow(Class&lt;? extends Throwable&gt; exceptionType) {
<b class="fc">&nbsp;        return canThrow(TypeDescription.ForLoadedType.of(exceptionType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link MethodDescription} by its capability to throw a given
&nbsp;     * checked exception. For specifying a non-checked exception, any method is matched.
&nbsp;     *
&nbsp;     * @param exceptionType The type of the exception that should be declared by the method to be matched.
&nbsp;     * @param &lt;T&gt;           The type of the matched object.
&nbsp;     * @return A matcher that matches a method description by its declaration of throwing a checked exception.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; canThrow(TypeDescription exceptionType) {
<b class="fc">&nbsp;        return exceptionType.isAssignableTo(RuntimeException.class) || exceptionType.isAssignableTo(Error.class)</b>
<b class="fc">&nbsp;                ? BooleanMatcher.&lt;T&gt;of(true)</b>
<b class="fc">&nbsp;                : ElementMatchers.&lt;T&gt;declaresGenericException(new CollectionItemMatcher&lt;TypeDescription.Generic&gt;(erasure(isSuperTypeOf(exceptionType))));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method that declares the given generic exception type. For non-generic type, this matcher behaves identically to
&nbsp;     * {@link ElementMatchers#declaresException(Class)}. For exceptions that are expressed as type variables, only exceptions
&nbsp;     * that are represented as this type variable are matched.
&nbsp;     *
&nbsp;     * @param exceptionType The generic exception type that is matched exactly.
&nbsp;     * @param &lt;T&gt;           The type of the matched object.
&nbsp;     * @return A matcher that matches any method that exactly matches the provided generic exception.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; declaresGenericException(Type exceptionType) {
<b class="fc">&nbsp;        return declaresGenericException(TypeDefinition.Sort.describe(exceptionType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method that declares the given generic exception type. For non-generic type, this matcher behaves identically to
&nbsp;     * {@link ElementMatchers#declaresException(TypeDescription)}. For exceptions that are expressed as type variables, only exceptions
&nbsp;     * that are represented as this type variable are matched.
&nbsp;     *
&nbsp;     * @param exceptionType The generic exception type that is matched exactly.
&nbsp;     * @param &lt;T&gt;           The type of the matched object.
&nbsp;     * @return A matcher that matches any method that exactly matches the provided generic exception.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; declaresGenericException(TypeDescription.Generic exceptionType) {
<b class="fc">&nbsp;        return !exceptionType.getSort().isWildcard() &amp;&amp; exceptionType.asErasure().isAssignableTo(Throwable.class)</b>
<b class="fc">&nbsp;                ? ElementMatchers.&lt;T&gt;declaresGenericException(new CollectionItemMatcher&lt;TypeDescription.Generic&gt;(is(exceptionType)))</b>
<b class="nc">&nbsp;                : BooleanMatcher.&lt;T&gt;of(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method that declares the given generic exception type as a (erased) exception type.
&nbsp;     *
&nbsp;     * @param exceptionType The exception type that is matched.
&nbsp;     * @param &lt;T&gt;           The type of the matched object.
&nbsp;     * @return A matcher that matches any method that exactly matches the provided exception.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; declaresException(Class&lt;? extends Throwable&gt; exceptionType) {
<b class="fc">&nbsp;        return declaresException(TypeDescription.ForLoadedType.of(exceptionType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method that declares the given generic exception type as a (erased) exception type.
&nbsp;     *
&nbsp;     * @param exceptionType The exception type that is matched.
&nbsp;     * @param &lt;T&gt;           The type of the matched object.
&nbsp;     * @return A matcher that matches any method that exactly matches the provided exception.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; declaresException(TypeDescription exceptionType) {
<b class="fc">&nbsp;        return exceptionType.isAssignableTo(Throwable.class)</b>
<b class="fc">&nbsp;                ? ElementMatchers.&lt;T&gt;declaresGenericException(new CollectionItemMatcher&lt;TypeDescription.Generic&gt;(erasure(exceptionType)))</b>
<b class="fc">&nbsp;                : BooleanMatcher.&lt;T&gt;of(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method&#39;s generic exception types against the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The exception matcher to apply onto the matched method&#39;s generic exceptions.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that applies the provided matcher to a method&#39;s generic exception types.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; declaresGenericException(
&nbsp;            ElementMatcher&lt;? super Iterable&lt;? extends TypeDescription.Generic&gt;&gt; matcher) {
<b class="fc">&nbsp;        return new MethodExceptionTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any virtual method with a signature that is compatible to a method that is declared the supplied type.
&nbsp;     *
&nbsp;     * @param type The super type of interest for which to check if it declares a method with the same signature as the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that checks a method&#39;s signature equality for any method declared by the declaring type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isOverriddenFrom(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isOverriddenFrom(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any virtual method with a signature that is compatible to a method that is declared the supplied type.
&nbsp;     *
&nbsp;     * @param type The super type of interest for which to check if it declares a method with the same signature as the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that checks a method&#39;s signature equality for any method declared by the declaring type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isOverriddenFrom(TypeDescription type) {
<b class="fc">&nbsp;        return isOverriddenFrom(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any virtual method with a signature that is compatible to a method that is declared by a type that matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher for a method&#39;s declaring type that needs to be matched if that type declares a method with the same signature
&nbsp;     *                as the matched method.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that checks a method&#39;s signature equality for any method declared by the declaring type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isOverriddenFrom(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return isOverriddenFromGeneric(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any virtual method with a signature that is compatible to a method that is declared the supplied type.
&nbsp;     *
&nbsp;     * @param type The super type of interest for which to check if it declares a method with the same signature as the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that checks a method&#39;s signature equality for any method declared by the declaring type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isOverriddenFromGeneric(Type type) {
<b class="fc">&nbsp;        return isOverriddenFromGeneric(TypeDescription.Generic.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any virtual method with a signature that is compatible to a method that is declared the supplied type.
&nbsp;     *
&nbsp;     * @param type The super type of interest for which to check if it declares a method with the same signature as the matched method.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that checks a method&#39;s signature equality for any method declared by the declaring type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isOverriddenFromGeneric(TypeDescription.Generic type) {
<b class="fc">&nbsp;        return isOverriddenFromGeneric(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any virtual method with a signature that is compatible to a method that is declared by a type that matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher for a method&#39;s declaring type that needs to be matched if that type declares a method with the same signature
&nbsp;     *                as the matched method.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that checks a method&#39;s signature equality for any method declared by the declaring type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isOverriddenFromGeneric(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new MethodOverrideMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link TypeDescription} that is an interface. Annotation types are also considered interface types.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for an interface.
&nbsp;     * @see ElementMatchers#isAnnotation()
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; isInterface() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.INTERFACE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@link TypeDescription} that is an annotation type.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for an annotation type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; isAnnotation() {
<b class="nc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.ANNOTATION);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches method descriptions that represent a {@link java.lang.reflect.Method}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches method descriptions that represent a Java method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isMethod() {
<b class="fc">&nbsp;        return MethodSortMatcher.of(MethodSortMatcher.Sort.METHOD);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches method descriptions that represent a {@link java.lang.reflect.Constructor}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches method descriptions that represent a Java constructor.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isConstructor() {
<b class="fc">&nbsp;        return MethodSortMatcher.of(MethodSortMatcher.Sort.CONSTRUCTOR);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches method descriptions that represent a {@link java.lang.Class} type initializer.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches method descriptions that represent the type initializer.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isTypeInitializer() {
<b class="fc">&nbsp;        return MethodSortMatcher.of(MethodSortMatcher.Sort.TYPE_INITIALIZER);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any method that is virtual, i.e. non-constructors that are non-static and non-private.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for virtual methods.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isVirtual() {
<b class="fc">&nbsp;        return MethodSortMatcher.of(MethodSortMatcher.Sort.VIRTUAL);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches Java 8 default methods.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches Java 8 default methods.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isDefaultMethod() {
<b class="fc">&nbsp;        return MethodSortMatcher.of(MethodSortMatcher.Sort.DEFAULT_METHOD);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a default constructor, i.e. a constructor without arguments.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches a default constructor.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isDefaultConstructor() {
<b class="fc">&nbsp;        return isConstructor().and(takesNoArguments());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a Java &lt;i&gt;main&lt;/i&gt; method as an application entry point.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches a Java &lt;i&gt;main&lt;/i&gt; method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isMain() {
<b class="fc">&nbsp;        return named(&quot;main&quot;).and(takesArguments(String[].class)).and(returns(TypeDescription.ForLoadedType.of(void.class)).and(isStatic()).and(isPublic()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches the {@link Object#finalize()} method if it was not overridden.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches a non-overridden {@link Object#finalize()} method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isDefaultFinalizer() {
<b class="fc">&nbsp;        return isFinalizer().and(isDeclaredBy(TypeDescription.ForLoadedType.of(Object.class)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches the {@link Object#finalize()} method, even if it was overridden.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the {@link Object#finalize()} method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isFinalizer() {
<b class="fc">&nbsp;        return named(&quot;finalize&quot;).and(takesNoArguments()).and(returns(TypeDescription.ForLoadedType.of(void.class)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches the {@link Object#hashCode()} method, also if it was overridden.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the {@link Object#hashCode()} method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isHashCode() {
<b class="fc">&nbsp;        return named(&quot;hashCode&quot;).and(takesNoArguments()).and(returns(int.class));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches the {@link Object#equals(Object)} method, also if it was overridden.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the {@link Object#equals(Object)} method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isEquals() {
<b class="fc">&nbsp;        return named(&quot;equals&quot;).and(takesArguments(TypeDescription.ForLoadedType.of(Object.class))).and(returns(boolean.class));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches the {@link Object#clone()} method, also if it was overridden.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the {@link Object#clone()} method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isClone() {
<b class="fc">&nbsp;        return named(&quot;clone&quot;).and(takesNoArguments());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches the {@link Object#toString()} method, also if it was overridden.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the {@link Object#toString()} method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isToString() {
<b class="fc">&nbsp;        return named(&quot;toString&quot;).and(takesNoArguments()).and(returns(TypeDescription.ForLoadedType.of(String.class)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches any setter method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isSetter() {
<b class="fc">&nbsp;        return nameStartsWith(&quot;set&quot;).and(takesArguments(1)).and(returns(TypeDescription.ForLoadedType.of(void.class)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An element matcher that matches any setter for the given property. When given an empty string, any setter named {@code set}
&nbsp;     * is matched despite that such a setter is not fulfilling the Java bean naming conventions.
&nbsp;     *
&nbsp;     * @param property The property to match a setter for.
&nbsp;     * @param &lt;T&gt;      The type of the matched object.
&nbsp;     * @return A matcher that matches any setter method for the supplied property.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isSetter(String property) {
<b class="fc">&nbsp;        return isSetter().and(property.length() == 0</b>
<b class="fc">&nbsp;                ? named(&quot;set&quot;)</b>
<b class="fc">&nbsp;                : named(&quot;set&quot; + Character.toUpperCase(property.charAt(0)) + property.substring(1)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method which takes an argument the given type.
&nbsp;     *
&nbsp;     * @param type The required setter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any setter method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isSetter(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isSetter(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method which takes an argument the given type.
&nbsp;     *
&nbsp;     * @param type The required setter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any setter method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGenericSetter(Type type) {
<b class="fc">&nbsp;        return isGenericSetter(TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method which takes an argument the given type.
&nbsp;     *
&nbsp;     * @param type The required setter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a setter method with the specified argument type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isSetter(TypeDescription type) {
<b class="fc">&nbsp;        return isSetter(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method which takes an argument the given type.
&nbsp;     *
&nbsp;     * @param type The required setter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a setter method with the specified argument type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGenericSetter(TypeDescription.Generic type) {
<b class="fc">&nbsp;        return isGenericSetter(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method which takes an argument that matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher to be allied to a setter method&#39;s argument type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a setter method with an argument type that matches the supplied matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isSetter(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return isGenericSetter(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean setter method which takes an argument that matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher to be allied to a setter method&#39;s argument type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a setter method with an argument type that matches the supplied matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGenericSetter(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return isSetter().and(takesGenericArguments(new CollectionOneToOneMatcher&lt;TypeDescription.Generic&gt;(Collections.singletonList(matcher))));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that matches any getter method.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGetter() {
<b class="fc">&nbsp;        return takesNoArguments().and(not(returns(TypeDescription.ForLoadedType.of(void.class)))).and(nameStartsWith(&quot;get&quot;).or(nameStartsWith(&quot;is&quot;).and(returnsGeneric(anyOf(boolean.class, Boolean.class)))));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An element matcher that matches any getter for the given property. When given an empty string, any getter named {@code get}
&nbsp;     * is matched despite that such a getter is not fulfilling the Java bean naming conventions. If a getter&#39;s type is {@code boolean}
&nbsp;     * or {@link Boolean}, {@code is} is also accepted as a prefix.
&nbsp;     *
&nbsp;     * @param property The property to match a getter for.
&nbsp;     * @param &lt;T&gt;      The type of the matched object.
&nbsp;     * @return A matcher that matches any getter method for the supplied property.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGetter(String property) {
<b class="fc">&nbsp;        return isGetter().and(property.length() == 0</b>
<b class="fc">&nbsp;                ? named(&quot;get&quot;).or(named(&quot;is&quot;))</b>
<b class="fc">&nbsp;                : named(&quot;get&quot; + Character.toUpperCase(property.charAt(0)) + property.substring(1)).or(named(&quot;is&quot; + Character.toUpperCase(property.charAt(0)) + property.substring(1))));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method which returns the given type.
&nbsp;     *
&nbsp;     * @param type The required getter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a getter method with the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGetter(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isGetter(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method which returns the given type.
&nbsp;     *
&nbsp;     * @param type The required getter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a getter method with the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGenericGetter(Type type) {
<b class="fc">&nbsp;        return isGenericGetter(TypeDefinition.Sort.describe(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method which returns the given type.
&nbsp;     *
&nbsp;     * @param type The required getter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a getter method with the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGetter(TypeDescription type) {
<b class="fc">&nbsp;        return isGetter(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method which returns the given type.
&nbsp;     *
&nbsp;     * @param type The required getter type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches a getter method with the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGenericGetter(TypeDescription.Generic type) {
<b class="fc">&nbsp;        return isGenericGetter(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method which returns a value with a type matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher to be allied to a getter method&#39;s argument type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a getter method with a return type that matches the supplied matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGetter(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return isGenericGetter(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any Java bean getter method which returns a value with a type matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher A matcher to be allied to a getter method&#39;s argument type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a getter method with a return type that matches the supplied matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; isGenericGetter(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return isGetter().and(returnsGeneric(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a method against its internal name such that constructors and type initializers are matched appropriately.
&nbsp;     *
&nbsp;     * @param internalName The internal name of the method.
&nbsp;     * @param &lt;T&gt;          The type of the matched object.
&nbsp;     * @return A matcher for a method with the provided internal name.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; hasMethodName(String internalName) {
<b class="fc">&nbsp;        if (MethodDescription.CONSTRUCTOR_INTERNAL_NAME.equals(internalName)) {</b>
<b class="fc">&nbsp;            return isConstructor();</b>
<b class="fc">&nbsp;        } else if (MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME.equals(internalName)) {</b>
<b class="fc">&nbsp;            return isTypeInitializer();</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return named(internalName);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Only matches method descriptions that yield the provided signature token.
&nbsp;     *
&nbsp;     * @param token The signature token to match against.
&nbsp;     * @param &lt;T&gt;   The type of the matched object.
&nbsp;     * @return A matcher for a method with the provided signature token.
&nbsp;     */
&nbsp;    public static &lt;T extends MethodDescription&gt; ElementMatcher.Junction&lt;T&gt; hasSignature(MethodDescription.SignatureToken token) {
<b class="fc">&nbsp;        return new SignatureTokenMatcher&lt;T&gt;(is(token));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that is a subtype of the given type.
&nbsp;     *
&nbsp;     * @param type The type to be checked for being a subtype of the matched type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that represents a sub type of the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; isSubTypeOf(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isSubTypeOf(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that is a subtype of the given type.
&nbsp;     *
&nbsp;     * @param type The type to be checked for being a subtype of the matched type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that represents a sub type of the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; isSubTypeOf(TypeDescription type) {
<b class="fc">&nbsp;        return new SubTypeMatcher&lt;T&gt;(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that is a super type of the given type.
&nbsp;     *
&nbsp;     * @param type The type to be checked for being a subtype of the matched type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that represents a super type of the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; isSuperTypeOf(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return isSuperTypeOf(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that is a super type of the given type.
&nbsp;     *
&nbsp;     * @param type The type to be checked for being a subtype of the matched type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that represents a super type of the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; isSuperTypeOf(TypeDescription type) {
<b class="fc">&nbsp;        return new SuperTypeMatcher&lt;T&gt;(type);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that declares a super class (but not interface) that matches the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The type to be checked for being a super class of the matched type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that declares a super class that matches the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasSuperClass(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return hasGenericSuperClass(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that declares a super class (but not interface) that matches the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The type to be checked for being a super class of the matched type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that declares a super class that matches the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasGenericSuperClass(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new HasSuperClassMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that declares a super type that matches the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The type to be checked for being a super type of the matched type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that declares a super type that matches the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasSuperType(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return hasGenericSuperType(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any type description that declares a super type that matches the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The type to be checked for being a super type of the matched type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any type description that declares a super type that matches the provided matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasGenericSuperType(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new HasSuperTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any annotations by their type on a type that declared these annotations or inherited them from its
&nbsp;     * super classes.
&nbsp;     *
&nbsp;     * @param type The annotation type to be matched.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any inherited annotation by their type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; inheritsAnnotation(Class&lt;?&gt; type) {
<b class="fc">&nbsp;        return inheritsAnnotation(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any annotations by their type on a type that declared these annotations or inherited them from its
&nbsp;     * super classes.
&nbsp;     *
&nbsp;     * @param type The annotation type to be matched.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches any inherited annotation by their type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; inheritsAnnotation(TypeDescription type) {
<b class="fc">&nbsp;        return inheritsAnnotation(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any annotations by a given matcher on a type that declared these annotations or inherited them from its
&nbsp;     * super classes.
&nbsp;     *
&nbsp;     * @param matcher A matcher to apply onto the inherited annotations.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any inherited annotation by a given matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; inheritsAnnotation(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return hasAnnotation(annotationType(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a list of annotations by a given matcher on a type that declared these annotations or inherited them
&nbsp;     * from its super classes.
&nbsp;     *
&nbsp;     * @param matcher A matcher to apply onto a list of inherited annotations.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches a list of inherited annotation by a given matcher.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasAnnotation(ElementMatcher&lt;? super AnnotationDescription&gt; matcher) {
<b class="fc">&nbsp;        return new InheritedAnnotationMatcher&lt;T&gt;(new CollectionItemMatcher&lt;AnnotationDescription&gt;(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type to have a minimal class file version. If a type description is not implying a class file version, it is not matched.
&nbsp;     *
&nbsp;     * @param classFileVersion The minimal class file version to match.
&nbsp;     * @param &lt;T&gt;              The type of the matched object.
&nbsp;     * @return A matcher that matches a type description by its class file version.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasClassFileVersionAtLeast(ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;        return new ClassFileVersionMatcher&lt;T&gt;(classFileVersion, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type to have a maximal class file version. If a type description is not implying a class file version, it is not matched.
&nbsp;     *
&nbsp;     * @param classFileVersion The maximal class file version to match.
&nbsp;     * @param &lt;T&gt;              The type of the matched object.
&nbsp;     * @return A matcher that matches a type description by its class file version.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDescription&gt; ElementMatcher.Junction&lt;T&gt; hasClassFileVersionAtMost(ClassFileVersion classFileVersion) {
<b class="fc">&nbsp;        return new ClassFileVersionMatcher&lt;T&gt;(classFileVersion, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type by another matcher that is applied on any of its declared fields.
&nbsp;     *
&nbsp;     * @param matcher The matcher that is applied onto each declared field.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any type where another matcher is matched positively on at least on declared field.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; declaresField(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;        return new DeclaringFieldMatcher&lt;T&gt;(new CollectionItemMatcher&lt;FieldDescription&gt;(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type by another matcher that is applied on any of its declared methods.
&nbsp;     *
&nbsp;     * @param matcher The matcher that is applied onto each declared method.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches any type where another matcher is matched positively on at least on declared methods.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; declaresMethod(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;        return new DeclaringMethodMatcher&lt;T&gt;(new CollectionItemMatcher&lt;MethodDescription&gt;(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches generic type descriptions of the given sort.
&nbsp;     *
&nbsp;     * @param sort The generic type sort to match.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches generic types of the given sort.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; ofSort(TypeDefinition.Sort sort) {
<b class="fc">&nbsp;        return ofSort(is(sort));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches generic type descriptions of the given sort.
&nbsp;     *
&nbsp;     * @param matcher A matcher for a generic type&#39;s sort.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches generic types of the given sort.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; ofSort(ElementMatcher&lt;? super TypeDefinition.Sort&gt; matcher) {
<b class="fc">&nbsp;        return new TypeSortMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type if it is primitive.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that determines if a type is primitive.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; isPrimitive() {
<b class="fc">&nbsp;        return new PrimitiveTypeMatcher&lt;T&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type if it is an array type.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that determines if a type is an array type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; isArray() {
<b class="fc">&nbsp;        return new ArrayTypeMatcher&lt;T&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a type if it is a record type.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that determines if a type is a record type.
&nbsp;     */
&nbsp;    public static &lt;T extends TypeDefinition&gt; ElementMatcher.Junction&lt;T&gt; isRecord() {
<b class="nc">&nbsp;        return new RecordMatcher&lt;T&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field&#39;s generic type against the provided matcher.
&nbsp;     *
&nbsp;     * @param fieldType The field type to match.
&nbsp;     * @param &lt;T&gt;       The type of the matched object.
&nbsp;     * @return A matcher matching the provided field type.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; genericFieldType(Type fieldType) {
<b class="fc">&nbsp;        return genericFieldType(TypeDefinition.Sort.describe(fieldType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field&#39;s generic type against the provided matcher.
&nbsp;     *
&nbsp;     * @param fieldType The field type to match.
&nbsp;     * @param &lt;T&gt;       The type of the matched object.
&nbsp;     * @return A matcher matching the provided field type.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; genericFieldType(TypeDescription.Generic fieldType) {
<b class="fc">&nbsp;        return genericFieldType(is(fieldType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field&#39;s generic type against the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the field&#39;s type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher matching the provided field type.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; genericFieldType(ElementMatcher&lt;? super TypeDescription.Generic&gt; matcher) {
<b class="fc">&nbsp;        return new FieldTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field&#39;s raw type against the provided matcher.
&nbsp;     *
&nbsp;     * @param fieldType The field type to match.
&nbsp;     * @param &lt;T&gt;       The type of the matched object.
&nbsp;     * @return A matcher matching the provided field type.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; fieldType(Class&lt;?&gt; fieldType) {
<b class="fc">&nbsp;        return fieldType(TypeDescription.ForLoadedType.of(fieldType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field&#39;s raw type against the provided matcher.
&nbsp;     *
&nbsp;     * @param fieldType The field type to match.
&nbsp;     * @param &lt;T&gt;       The type of the matched object.
&nbsp;     * @return A matcher matching the provided field type.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; fieldType(TypeDescription fieldType) {
<b class="fc">&nbsp;        return fieldType(is(fieldType));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a field&#39;s raw type against the provided matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the field&#39;s type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher matching the provided field type.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; fieldType(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return genericFieldType(erasure(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@code volatile} field.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code volatile} field.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; isVolatile() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.VOLATILE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a {@code transient} field.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher for a {@code transient} field.
&nbsp;     */
&nbsp;    public static &lt;T extends FieldDescription&gt; ElementMatcher.Junction&lt;T&gt; isTransient() {
<b class="fc">&nbsp;        return ModifierMatcher.of(ModifierMatcher.Mode.TRANSIENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches if an annotation is of a given type.
&nbsp;     *
&nbsp;     * @param type The expected annotation type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches the annotation&#39;s type for being equal to the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; annotationType(Class&lt;? extends Annotation&gt; type) {
<b class="fc">&nbsp;        return annotationType(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches if an annotation is of a given type.
&nbsp;     *
&nbsp;     * @param type The expected annotation type.
&nbsp;     * @param &lt;T&gt;  The type of the matched object.
&nbsp;     * @return A matcher that matches the annotation&#39;s type for being equal to the given type.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; annotationType(TypeDescription type) {
<b class="fc">&nbsp;        return annotationType(is(type));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches if an annotation&#39;s type matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to match the annotation&#39;s type against.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches the annotation&#39;s type.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; annotationType(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return new AnnotationTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches if an annotation can target a given element type.
&nbsp;     *
&nbsp;     * @param elementType The element type we target.
&nbsp;     * @param &lt;T&gt;         The type of the matched object.
&nbsp;     * @return A matcher that matches annotations that target an element type.
&nbsp;     */
&nbsp;    public static &lt;T extends AnnotationDescription&gt; ElementMatcher.Junction&lt;T&gt; targetsElement(ElementType elementType) {
<b class="fc">&nbsp;        return new AnnotationTargetMatcher&lt;T&gt;(elementType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches exactly the bootstrap {@link java.lang.ClassLoader}. The returned matcher is a synonym to
&nbsp;     * a matcher matching {@code null}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the bootstrap class loader.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; isBootstrapClassLoader() {
<b class="fc">&nbsp;        return NullMatcher.make();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches exactly the system {@link java.lang.ClassLoader}. The returned matcher is a synonym to
&nbsp;     * a matcher matching {@code ClassLoader.gerSystemClassLoader()}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the system class loader.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; isSystemClassLoader() {
<b class="fc">&nbsp;        return new EqualityMatcher&lt;T&gt;(ClassLoader.getSystemClassLoader());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches exactly the extension {@link java.lang.ClassLoader}. The returned matcher is a synonym to
&nbsp;     * a matcher matching {@code ClassLoader.gerSystemClassLoader().getParent()}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that only matches the extension class loader.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; isExtensionClassLoader() {
<b class="fc">&nbsp;        ClassLoader classLoader = ClassLoader.getSystemClassLoader().getParent();</b>
<b class="fc">&nbsp;        return classLoader == null // Check if VM supports the extension class loader.</b>
<b class="nc">&nbsp;                ? ElementMatchers.&lt;T&gt;none()</b>
<b class="fc">&nbsp;                : new EqualityMatcher&lt;T&gt;(classLoader);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any class loader that is either the given class loader or a child of the given class loader.
&nbsp;     *
&nbsp;     * @param classLoader The class loader of which child class loaders are matched.
&nbsp;     * @param &lt;T&gt;         The type of the matched object.
&nbsp;     * @return A matcher that matches the given class loader and any class loader that is a child of the given
&nbsp;     * class loader.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; isChildOf(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;        return classLoader == ClassLoadingStrategy.BOOTSTRAP_LOADER</b>
<b class="fc">&nbsp;                ? BooleanMatcher.&lt;T&gt;of(true)</b>
<b class="fc">&nbsp;                : ElementMatchers.&lt;T&gt;hasChild(is(classLoader));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches all class loaders in the hierarchy of the matched class loader against a given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to all class loaders in the hierarchy of the matched class loader.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches all class loaders in the hierarchy of the matched class loader.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; hasChild(ElementMatcher&lt;? super ClassLoader&gt; matcher) {
<b class="fc">&nbsp;        return new ClassLoaderHierarchyMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches any class loader that is either the given class loader or a parent of the given class loader.
&nbsp;     *
&nbsp;     * @param classLoader The class loader of which parent class loaders are matched.
&nbsp;     * @param &lt;T&gt;         The type of the matched object.
&nbsp;     * @return A matcher that matches the given class loader and any class loader that is a parent of the given
&nbsp;     * class loader.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; isParentOf(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;        return classLoader == ClassLoadingStrategy.BOOTSTRAP_LOADER</b>
<b class="fc">&nbsp;                ? ElementMatchers.&lt;T&gt;isBootstrapClassLoader()</b>
<b class="fc">&nbsp;                : new ClassLoaderParentMatcher&lt;T&gt;(classLoader);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a class loader&#39;s type unless it is the bootstrap class loader which is never matched.
&nbsp;     *
&nbsp;     * @param matcher The matcher to apply to the class loader&#39;s type.
&nbsp;     * @param &lt;T&gt;     The type of the matched object.
&nbsp;     * @return A matcher that matches the class loader&#39;s type.
&nbsp;     */
&nbsp;    public static &lt;T extends ClassLoader&gt; ElementMatcher.Junction&lt;T&gt; ofType(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;        return new InstanceTypeMatcher&lt;T&gt;(matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches a module if it exists, i.e. not {@code null}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the matched object.
&nbsp;     * @return A matcher that validates a module&#39;s existence.
&nbsp;     */
&nbsp;    public static &lt;T extends JavaModule&gt; ElementMatcher.Junction&lt;T&gt; supportsModules() {
<b class="fc">&nbsp;        return not(NullMatcher.make());</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 16:00</div>
</div>
</body>
</html>
