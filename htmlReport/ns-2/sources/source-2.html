


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ByteBuddyAgent</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.agent</a>
</div>

<h1>Coverage Summary for Class: ByteBuddyAgent (net.bytebuddy.agent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ByteBuddyAgent</td>
<td class="coverageStat">
  <span class="percent">
    41.4%
  </span>
  <span class="absValue">
    (12/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.5%
  </span>
  <span class="absValue">
    (80/126)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider$ForByteBuddyAgent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61.3%
  </span>
  <span class="absValue">
    (38/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AgentProvider$ForExistingAgent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$ExternalAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple$WithDirectAttachment</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Simple$WithExternalAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Accessor$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForEmulatedAttachment</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForJ9Vm</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForModularizedVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForStandardToolsJarVm</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentProvider$ForUserDefinedToolsJar</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    22.2%
  </span>
  <span class="absValue">
    (2/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$AttachmentTypeEvaluator$InstallationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (6/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyAgent$ProcessProvider$ForCurrentVm$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    71%
  </span>
  <span class="absValue">
    (66/93)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    61%
  </span>
  <span class="absValue">
    (191/313)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.agent;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.agent.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.agent.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.security.CodeSource;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.*;
&nbsp;import java.util.jar.*;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * The Byte Buddy agent provides a JVM {@link java.lang.instrument.Instrumentation} in order to allow Byte Buddy the
&nbsp; * redefinition of already loaded classes. An agent must normally be specified via the command line via the
&nbsp; * {@code javaagent} parameter. As an argument to this parameter, one must specify the location of this agent&#39;s jar
&nbsp; * file such as for example in
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;code&gt;
&nbsp; * java -javaagent:byte-buddy-agent.jar -jar app.jar
&nbsp; * &lt;/code&gt;
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: The runtime installation of a Java agent is not possible on all JVMs. See the documentation for
&nbsp; * {@link ByteBuddyAgent#install()} for details on JVMs that are supported out of the box.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Important&lt;/b&gt;: This class&#39;s name is known to the Byte Buddy main application and must not be altered.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: Byte Buddy does not execute code using an {@code java.security.AccessController}. If a security manager
&nbsp; * is present, the user of this class is responsible for assuring any required privileges. To read an
&nbsp; * {@link Instrumentation}, the &lt;i&gt;net.bytebuddy.agent.getInstrumentation&lt;/i&gt; runtime permission is required.
&nbsp; * &lt;/p&gt;
&nbsp; */
<b class="fc">&nbsp;public class ByteBuddyAgent {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that the agent should not resolve its own code location for a self-attachment.
&nbsp;     */
&nbsp;    public static final String LATENT_RESOLVE = &quot;net.bytebuddy.agent.latent&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The manifest property specifying the agent class.
&nbsp;     */
&nbsp;    private static final String AGENT_CLASS_PROPERTY = &quot;Agent-Class&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The manifest property specifying the &lt;i&gt;can redefine&lt;/i&gt; property.
&nbsp;     */
&nbsp;    private static final String CAN_REDEFINE_CLASSES_PROPERTY = &quot;Can-Redefine-Classes&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The manifest property specifying the &lt;i&gt;can retransform&lt;/i&gt; property.
&nbsp;     */
&nbsp;    private static final String CAN_RETRANSFORM_CLASSES_PROPERTY = &quot;Can-Retransform-Classes&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The manifest property specifying the &lt;i&gt;can set native method prefix&lt;/i&gt; property.
&nbsp;     */
&nbsp;    private static final String CAN_SET_NATIVE_METHOD_PREFIX = &quot;Can-Set-Native-Method-Prefix&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The manifest property value for the manifest version.
&nbsp;     */
&nbsp;    private static final String MANIFEST_VERSION_VALUE = &quot;1.0&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The size of the buffer for copying the agent installer file into another jar.
&nbsp;     */
&nbsp;    private static final int BUFFER_SIZE = 1024 * 8;
&nbsp;
&nbsp;    /**
&nbsp;     * Convenience indices for reading and writing to the buffer to make the code more readable.
&nbsp;     */
&nbsp;    private static final int START_INDEX = 0, END_OF_FILE = -1;
&nbsp;
&nbsp;    /**
&nbsp;     * The status code expected as a result of a successful attachment.
&nbsp;     */
&nbsp;    private static final int SUCCESSFUL_ATTACH = 0;
&nbsp;
&nbsp;    /**
&nbsp;     * Representation of the bootstrap {@link java.lang.ClassLoader}.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final ClassLoader BOOTSTRAP_CLASS_LOADER = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a no-op argument for a dynamic agent attachment.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final String WITHOUT_ARGUMENT = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The naming prefix of all artifacts for an attacher jar.
&nbsp;     */
&nbsp;    private static final String ATTACHER_FILE_NAME = &quot;byteBuddyAttacher&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The file extension for a class file.
&nbsp;     */
&nbsp;    private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The file extension for a jar file.
&nbsp;     */
&nbsp;    private static final String JAR_FILE_EXTENSION = &quot;.jar&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The class path argument to specify the class path elements.
&nbsp;     */
&nbsp;    private static final String CLASS_PATH_ARGUMENT = &quot;-cp&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The character that is used to mark the beginning of the argument to the agent.
&nbsp;     */
&nbsp;    private static final String AGENT_ARGUMENT_SEPARATOR = &quot;=&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The Java property denoting the Java home directory.
&nbsp;     */
&nbsp;    private static final String JAVA_HOME = &quot;java.home&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The Java property denoting the operating system name.
&nbsp;     */
&nbsp;    private static final String OS_NAME = &quot;os.name&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the method for reading the installer&#39;s instrumentation.
&nbsp;     */
&nbsp;    private static final String INSTRUMENTATION_METHOD = &quot;getInstrumentation&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the {@code file} URL protocol.
&nbsp;     */
&nbsp;    private static final String FILE_PROTOCOL = &quot;file&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * An indicator variable to express that no instrumentation is available.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final Instrumentation UNAVAILABLE = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a failed attempt to self-resolve a jar file location.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final File CANNOT_SELF_RESOLVE = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The attachment type evaluator to be used for determining if an attachment requires an external process.
&nbsp;     */
<b class="fc">&nbsp;    private static final AttachmentTypeEvaluator ATTACHMENT_TYPE_EVALUATOR = doPrivileged(AttachmentTypeEvaluator.InstallationAction.INSTANCE);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The agent provides only {@code static} utility methods and should not be instantiated.
&nbsp;     */
<b class="fc">&nbsp;    private ByteBuddyAgent() {</b>
<b class="fc">&nbsp;        throw new UnsupportedOperationException(&quot;This class is a utility class and not supposed to be instantiated&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;     *
&nbsp;     * @param action The action to execute from a privileged context.
&nbsp;     * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;     * @return The action&#39;s resolved value.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
&nbsp;        try {
<b class="fc">&nbsp;            return (T) Class.forName(&quot;java.security.AccessController&quot;)</b>
<b class="fc">&nbsp;                    .getMethod(&quot;doPrivileged&quot;, PrivilegedAction.class)</b>
<b class="fc">&nbsp;                    .invoke(null, action);</b>
<b class="nc">&nbsp;        } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;            return action.run();</b>
<b class="nc">&nbsp;        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Failed to invoke access controller&quot;, exception.getTargetException());</b>
<b class="nc">&nbsp;        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Failed to access access controller&quot;, exception);</b>
<b class="nc">&nbsp;        } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Failed to resolve well-known access controller method&quot;, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Looks up the {@link java.lang.instrument.Instrumentation} instance of an installed Byte Buddy agent. Note that
&nbsp;     * this method implies reflective lookup and reflective invocation such that the returned value should be cached
&nbsp;     * rather than calling this method several times.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This method throws an {@link java.lang.IllegalStateException} If the Byte Buddy agent is not
&nbsp;     * properly installed.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return The {@link java.lang.instrument.Instrumentation} instance which is provided by an installed
&nbsp;     * Byte Buddy agent.
&nbsp;     */
&nbsp;    public static Instrumentation getInstrumentation() {
<b class="fc">&nbsp;        Instrumentation instrumentation = doGetInstrumentation();</b>
<b class="fc">&nbsp;        if (instrumentation == null) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;The Byte Buddy agent is not initialized or unavailable&quot;);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return instrumentation;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar  The agent jar file.
&nbsp;     * @param processId The target process id.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, String processId) {
<b class="nc">&nbsp;        attach(agentJar, processId, WITHOUT_ARGUMENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar  The agent jar file.
&nbsp;     * @param processId The target process id.
&nbsp;     * @param argument  The argument to provide to the agent.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, String processId, @MaybeNull String argument) {
<b class="nc">&nbsp;        attach(agentJar, processId, argument, AttachmentProvider.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar           The agent jar file.
&nbsp;     * @param processId          The target process id.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, String processId, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        attach(agentJar, processId, WITHOUT_ARGUMENT, attachmentProvider);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar           The agent jar file.
&nbsp;     * @param processId          The target process id.
&nbsp;     * @param argument           The argument to provide to the agent.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentJar), false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar        The agent jar file.
&nbsp;     * @param processProvider A provider of the target process id.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider) {
<b class="nc">&nbsp;        attach(agentJar, processProvider, WITHOUT_ARGUMENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar        The agent jar file.
&nbsp;     * @param processProvider A provider of the target process id.
&nbsp;     * @param argument        The argument to provide to the agent.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument) {
<b class="nc">&nbsp;        attach(agentJar, processProvider, argument, AttachmentProvider.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar           The agent jar file.
&nbsp;     * @param processProvider    A provider of the target process id.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        attach(agentJar, processProvider, WITHOUT_ARGUMENT, attachmentProvider);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent Jar on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentJar           The agent jar file.
&nbsp;     * @param processProvider    A provider of the target process id.
&nbsp;     * @param argument           The argument to provide to the agent.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attach(File agentJar, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentJar), false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary The agent jar file.
&nbsp;     * @param processId    The target process id.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, String processId) {
<b class="nc">&nbsp;        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary The agent library.
&nbsp;     * @param processId    The target process id.
&nbsp;     * @param argument     The argument to provide to the agent.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument) {
<b class="nc">&nbsp;        attachNative(agentLibrary, processId, argument, AttachmentProvider.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary       The agent library.
&nbsp;     * @param processId          The target process id.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, String processId, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        attachNative(agentLibrary, processId, WITHOUT_ARGUMENT, attachmentProvider);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary       The agent library.
&nbsp;     * @param processId          The target process id.
&nbsp;     * @param argument           The argument to provide to the agent.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, String processId, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        install(attachmentProvider, processId, argument, new AgentProvider.ForExistingAgent(agentLibrary), true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary    The agent library.
&nbsp;     * @param processProvider A provider of the target process id.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider) {
<b class="nc">&nbsp;        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. The default attachment provider
&nbsp;     * is used for applying the attachment. This operation blocks until the attachment is complete. If the current VM does not supply
&nbsp;     * any known form of attachment to a remote VM, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary    The agent library.
&nbsp;     * @param processProvider A provider of the target process id.
&nbsp;     * @param argument        The argument to provide to the agent.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument) {
<b class="nc">&nbsp;        attachNative(agentLibrary, processProvider, argument, AttachmentProvider.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete. The agent is not provided an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary       The agent library.
&nbsp;     * @param processProvider    A provider of the target process id.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        attachNative(agentLibrary, processProvider, WITHOUT_ARGUMENT, attachmentProvider);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Attaches the given agent library on the target process which must be a virtual machine process. This operation blocks until the
&nbsp;     * attachment is complete.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: It is only possible to attach to processes that are executed by the same operating system user.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param agentLibrary       The agent library.
&nbsp;     * @param processProvider    A provider of the target process id.
&nbsp;     * @param argument           The argument to provide to the agent.
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     */
&nbsp;    public static void attachNative(File agentLibrary, ProcessProvider processProvider, @MaybeNull String argument, AttachmentProvider attachmentProvider) {
<b class="nc">&nbsp;        install(attachmentProvider, processProvider.resolve(), argument, new AgentProvider.ForExistingAgent(agentLibrary), true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Installs an agent on the currently running Java virtual machine. Unfortunately, this does
&nbsp;     * not always work. The runtime installation of a Java agent is supported for:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;&lt;b&gt;JVM version 9+&lt;/b&gt;: For Java VM of at least version 9, the attachment API was moved
&nbsp;     * into a module and the runtime installation is possible if the {@code jdk.attach} module is
&nbsp;     * available to Byte Buddy which is typically only available for VMs shipped with a JDK.&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;b&gt;OpenJDK / Oracle JDK / IBM J9 versions 8-&lt;/b&gt;: The installation for HotSpot is only
&nbsp;     * possible when bundled with a JDK and requires a {@code tools.jar} bundled with the VM which
&nbsp;     * is typically only available for JDK-versions of the JVM.&lt;/li&gt;
&nbsp;     * &lt;li&gt;When running Linux and including the optional &lt;i&gt;junixsocket-native-common&lt;/i&gt; depedency,
&nbsp;     * Byte Buddy emulates a Unix socket connection to attach to the target VM.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If an agent cannot be installed, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This is a rather computation-heavy operation. Therefore, this operation is
&nbsp;     * not repeated after an agent was successfully installed for the first time. Instead, the previous
&nbsp;     * instrumentation instance is returned. However, invoking this method requires synchronization
&nbsp;     * such that subsequently to an installation, {@link ByteBuddyAgent#getInstrumentation()} should
&nbsp;     * be invoked instead.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return An instrumentation instance representing the currently running JVM.
&nbsp;     */
&nbsp;    public static Instrumentation install() {
<b class="fc">&nbsp;        return install(AttachmentProvider.DEFAULT);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Installs an agent on the currently running Java virtual machine using the supplied
&nbsp;     * attachment provider.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If an agent cannot be installed, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This is a rather computation-heavy operation. Therefore, this operation is
&nbsp;     * not repeated after an agent was successfully installed for the first time. Instead, the previous
&nbsp;     * instrumentation instance is returned. However, invoking this method requires synchronization
&nbsp;     * such that subsequently to an installation, {@link ByteBuddyAgent#getInstrumentation()} should
&nbsp;     * be invoked instead.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param attachmentProvider The attachment provider to use for the installation.
&nbsp;     * @return An instrumentation instance representing the currently running JVM.
&nbsp;     */
&nbsp;    public static Instrumentation install(AttachmentProvider attachmentProvider) {
<b class="fc">&nbsp;        return install(attachmentProvider, ProcessProvider.ForCurrentVm.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Installs an agent on the Java virtual machine resolved by the process provider. Unfortunately, this does
&nbsp;     * not always work. The runtime installation of a Java agent is supported for:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;&lt;b&gt;JVM version 9+&lt;/b&gt;: For Java VM of at least version 9, the attachment API was moved
&nbsp;     * into a module and the runtime installation is possible if the {@code jdk.attach} module is
&nbsp;     * available to Byte Buddy which is typically only available for VMs shipped with a JDK.&lt;/li&gt;
&nbsp;     * &lt;li&gt;&lt;b&gt;OpenJDK / Oracle JDK / IBM J9 versions 8-&lt;/b&gt;: The installation for HotSpot is only
&nbsp;     * possible when bundled with a JDK and requires a {@code tools.jar} bundled with the VM which
&nbsp;     * is typically only available for JDK-versions of the JVM.&lt;/li&gt;
&nbsp;     * &lt;li&gt;When running Linux and including the optional &lt;i&gt;junixsocket-native-common&lt;/i&gt; depedency,
&nbsp;     * Byte Buddy emulates a Unix socket connection to attach to the target VM.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If an agent cannot be installed, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param processProvider The provider for the current JVM&#39;s process id.
&nbsp;     * @return An instrumentation instance representing the currently running JVM.
&nbsp;     */
&nbsp;    public static Instrumentation install(ProcessProvider processProvider) {
<b class="nc">&nbsp;        return install(AttachmentProvider.DEFAULT, processProvider);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Installs an agent on the currently running Java virtual machine using the supplied
&nbsp;     * attachment provider and process provider.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If an agent cannot be installed, an {@link IllegalStateException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param attachmentProvider The attachment provider to use for the installation.
&nbsp;     * @param processProvider    The provider for the current JVM&#39;s process id.
&nbsp;     * @return An instrumentation instance representing the currently running JVM.
&nbsp;     */
&nbsp;    public static synchronized Instrumentation install(AttachmentProvider attachmentProvider, ProcessProvider processProvider) {
<b class="fc">&nbsp;        Instrumentation instrumentation = doGetInstrumentation();</b>
<b class="fc">&nbsp;        if (instrumentation != null) {</b>
<b class="fc">&nbsp;            return instrumentation;</b>
&nbsp;        }
<b class="fc">&nbsp;        install(attachmentProvider, processProvider.resolve(), WITHOUT_ARGUMENT, AgentProvider.ForByteBuddyAgent.INSTANCE, false);</b>
<b class="fc">&nbsp;        return getInstrumentation();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Installs a Java agent on a target VM.
&nbsp;     *
&nbsp;     * @param attachmentProvider The attachment provider to use.
&nbsp;     * @param processId          The process id of the target JVM process.
&nbsp;     * @param argument           The argument to provide to the agent.
&nbsp;     * @param agentProvider      The agent provider for the agent jar or library.
&nbsp;     * @param isNative           {@code true} if the agent is native.
&nbsp;     */
&nbsp;    private static void install(AttachmentProvider attachmentProvider, String processId, @MaybeNull String argument, AgentProvider agentProvider, boolean isNative) {
<b class="fc">&nbsp;        AttachmentProvider.Accessor attachmentAccessor = attachmentProvider.attempt();</b>
<b class="fc">&nbsp;        if (!attachmentAccessor.isAvailable()) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;No compatible attachment provider is available&quot;);</b>
&nbsp;        }
&nbsp;        try {
<b class="fc">&nbsp;            if (attachmentAccessor.isExternalAttachmentRequired() &amp;&amp; ATTACHMENT_TYPE_EVALUATOR.requiresExternalAttachment(processId)) {</b>
<b class="fc">&nbsp;                installExternal(attachmentAccessor.getExternalAttachment(), processId, agentProvider.resolve(), isNative, argument);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Attacher.install(attachmentAccessor.getVirtualMachineType(), processId, agentProvider.resolve().getAbsolutePath(), isNative, argument);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;            throw exception;</b>
<b class="nc">&nbsp;        } catch (Exception exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Error during attachment using: &quot; + attachmentProvider, exception);</b>
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Installs a Java agent to the current VM via an external process. This is typically required starting with OpenJDK 9
&nbsp;     * when the {@code jdk.attach.allowAttachSelf} property is set to {@code false} what is the default setting.
&nbsp;     *
&nbsp;     * @param externalAttachment A description of the external attachment.
&nbsp;     * @param processId          The process id of the current process.
&nbsp;     * @param agent              The Java agent to install.
&nbsp;     * @param isNative           {@code true} if the agent is native.
&nbsp;     * @param argument           The argument to provide to the agent or {@code null} if no argument should be supplied.
&nbsp;     * @throws Exception If an exception occurs during the attachment or the external process fails the attachment.
&nbsp;     */
&nbsp;    private static void installExternal(AttachmentProvider.Accessor.ExternalAttachment externalAttachment,
&nbsp;                                        String processId,
&nbsp;                                        File agent,
&nbsp;                                        boolean isNative,
&nbsp;                                        @MaybeNull String argument) throws Exception {
<b class="fc">&nbsp;        File selfResolvedJar = trySelfResolve(), attachmentJar = null;</b>
&nbsp;        try {
<b class="fc">&nbsp;            if (selfResolvedJar == null) {</b>
<b class="fc">&nbsp;                InputStream inputStream = Attacher.class.getResourceAsStream(&#39;/&#39; + Attacher.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;                if (inputStream == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot locate class file for Byte Buddy installation process&quot;);</b>
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    attachmentJar = File.createTempFile(ATTACHER_FILE_NAME, JAR_FILE_EXTENSION);</b>
<b class="fc">&nbsp;                    JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(attachmentJar));</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        jarOutputStream.putNextEntry(new JarEntry(Attacher.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION));</b>
<b class="fc">&nbsp;                        byte[] buffer = new byte[BUFFER_SIZE];</b>
&nbsp;                        int index;
<b class="fc">&nbsp;                        while ((index = inputStream.read(buffer)) != END_OF_FILE) {</b>
<b class="fc">&nbsp;                            jarOutputStream.write(buffer, START_INDEX, index);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        jarOutputStream.closeEntry();</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        jarOutputStream.close();</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            StringBuilder classPath = new StringBuilder().append((selfResolvedJar == null</b>
<b class="fc">&nbsp;                    ? attachmentJar</b>
<b class="fc">&nbsp;                    : selfResolvedJar).getCanonicalPath());</b>
<b class="fc">&nbsp;            for (File jar : externalAttachment.getClassPath()) {</b>
<b class="nc">&nbsp;                classPath.append(File.pathSeparatorChar).append(jar.getCanonicalPath());</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (new ProcessBuilder(System.getProperty(JAVA_HOME)</b>
&nbsp;                    + File.separatorChar + &quot;bin&quot;
<b class="fc">&nbsp;                    + File.separatorChar + (System.getProperty(OS_NAME, &quot;&quot;).toLowerCase(Locale.US).contains(&quot;windows&quot;) ? &quot;java.exe&quot; : &quot;java&quot;),</b>
<b class="fc">&nbsp;                    &quot;-D&quot; + Attacher.DUMP_PROPERTY + AGENT_ARGUMENT_SEPARATOR + System.getProperty(Attacher.DUMP_PROPERTY, &quot;&quot;),</b>
&nbsp;                    CLASS_PATH_ARGUMENT,
<b class="fc">&nbsp;                    classPath.toString(),</b>
<b class="fc">&nbsp;                    Attacher.class.getName(),</b>
<b class="fc">&nbsp;                    externalAttachment.getVirtualMachineType(),</b>
&nbsp;                    processId,
<b class="fc">&nbsp;                    agent.getAbsolutePath(),</b>
<b class="fc">&nbsp;                    Boolean.toString(isNative),</b>
<b class="fc">&nbsp;                    argument == null ? &quot;&quot; : (AGENT_ARGUMENT_SEPARATOR + argument)).start().waitFor() != SUCCESSFUL_ATTACH) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Could not self-attach to current VM using external process&quot;);</b>
&nbsp;            }
&nbsp;        } finally {
<b class="fc">&nbsp;            if (attachmentJar != null) {</b>
<b class="fc">&nbsp;                if (!attachmentJar.delete()) {</b>
<b class="nc">&nbsp;                    attachmentJar.deleteOnExit();</b>
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Attempts to resolve the location of the {@link Attacher} class for a self-attachment. Doing so avoids the creation of a temporary jar file.
&nbsp;     *
&nbsp;     * @return The self-resolved jar file or {@code null} if the jar file cannot be located.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;    private static File trySelfResolve() {
&nbsp;        try {
<b class="fc">&nbsp;            if (Boolean.getBoolean(LATENT_RESOLVE)) {</b>
<b class="nc">&nbsp;                return CANNOT_SELF_RESOLVE;</b>
&nbsp;            }
<b class="fc">&nbsp;            ProtectionDomain protectionDomain = Attacher.class.getProtectionDomain();</b>
<b class="fc">&nbsp;            if (protectionDomain == null) {</b>
<b class="nc">&nbsp;                return CANNOT_SELF_RESOLVE;</b>
&nbsp;            }
<b class="fc">&nbsp;            CodeSource codeSource = protectionDomain.getCodeSource();</b>
<b class="fc">&nbsp;            if (codeSource == null) {</b>
<b class="nc">&nbsp;                return CANNOT_SELF_RESOLVE;</b>
&nbsp;            }
<b class="fc">&nbsp;            URL location = codeSource.getLocation();</b>
<b class="fc">&nbsp;            if (!location.getProtocol().equals(FILE_PROTOCOL)) {</b>
<b class="nc">&nbsp;                return CANNOT_SELF_RESOLVE;</b>
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                File file = new File(location.toURI());</b>
<b class="fc">&nbsp;                if (file.getPath().contains(AGENT_ARGUMENT_SEPARATOR)) {</b>
<b class="nc">&nbsp;                    return CANNOT_SELF_RESOLVE;</b>
&nbsp;                }
<b class="fc">&nbsp;                return file;</b>
<b class="nc">&nbsp;            } catch (URISyntaxException ignored) {</b>
<b class="nc">&nbsp;                return new File(location.getPath());</b>
&nbsp;            }
<b class="fc">&nbsp;        } catch (Exception ignored) {</b>
<b class="fc">&nbsp;            return CANNOT_SELF_RESOLVE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Performs the actual lookup of the {@link java.lang.instrument.Instrumentation} from an installed
&nbsp;     * Byte Buddy agent and returns the instance, or returns {@code null} if not present.
&nbsp;     *
&nbsp;     * @return The Byte Buddy agent&#39;s {@link java.lang.instrument.Instrumentation} instance.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;    private static Instrumentation doGetInstrumentation() {
&nbsp;        try {
<b class="fc">&nbsp;            Class&lt;?&gt; installer = Class.forName(Installer.class.getName(), true, ClassLoader.getSystemClassLoader());</b>
&nbsp;            try {
<b class="fc">&nbsp;                Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;);</b>
<b class="fc">&nbsp;                Method getModule = Class.class.getMethod(&quot;getModule&quot;);</b>
<b class="fc">&nbsp;                Object source = getModule.invoke(ByteBuddyAgent.class), target = getModule.invoke(installer);</b>
<b class="fc">&nbsp;                if (!((Boolean) module.getMethod(&quot;canRead&quot;, module).invoke(source, target))) {</b>
<b class="nc">&nbsp;                    module.getMethod(&quot;addReads&quot;, module).invoke(source, target);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (ClassNotFoundException ignored) {</b>
&nbsp;                /* empty */
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return (Instrumentation) Class.forName(Installer.class.getName(), true, ClassLoader.getSystemClassLoader())</b>
<b class="fc">&nbsp;                    .getMethod(INSTRUMENTATION_METHOD)</b>
<b class="fc">&nbsp;                    .invoke(null);</b>
<b class="fc">&nbsp;        } catch (Exception ignored) {</b>
<b class="fc">&nbsp;            return UNAVAILABLE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An attachment provider is responsible for making the Java attachment API available.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION&quot;, justification = &quot;Safe initialization is implied&quot;)
&nbsp;    public interface AttachmentProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * The default attachment provider to be used.
&nbsp;         */
<b class="fc">&nbsp;        AttachmentProvider DEFAULT = new Compound(ForModularizedVm.INSTANCE,</b>
&nbsp;                ForJ9Vm.INSTANCE,
&nbsp;                ForStandardToolsJarVm.JVM_ROOT,
&nbsp;                ForStandardToolsJarVm.JDK_ROOT,
&nbsp;                ForStandardToolsJarVm.MACINTOSH,
&nbsp;                ForUserDefinedToolsJar.INSTANCE,
&nbsp;                ForEmulatedAttachment.INSTANCE);
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts the creation of an accessor for a specific JVM&#39;s attachment API.
&nbsp;         *
&nbsp;         * @return The accessor this attachment provider can supply for the currently running JVM.
&nbsp;         */
&nbsp;        Accessor attempt();
&nbsp;
&nbsp;        /**
&nbsp;         * An accessor for a JVM&#39;s attachment API.
&nbsp;         */
&nbsp;        interface Accessor {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the {@code VirtualMachine} class on any OpenJDK or Oracle JDK implementation.
&nbsp;             */
&nbsp;            String VIRTUAL_MACHINE_TYPE_NAME = &quot;com.sun.tools.attach.VirtualMachine&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the {@code VirtualMachine} class on IBM J9 VMs.
&nbsp;             */
&nbsp;            String VIRTUAL_MACHINE_TYPE_NAME_J9 = &quot;com.ibm.tools.attach.VirtualMachine&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if this accessor is applicable for the currently running JVM.
&nbsp;             *
&nbsp;             * @return {@code true} if this accessor is available.
&nbsp;             */
&nbsp;            boolean isAvailable();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if this accessor prohibits attachment to the same virtual machine in Java 9 and later.
&nbsp;             *
&nbsp;             * @return {@code true} if this accessor prohibits attachment to the same virtual machine in Java 9 and later.
&nbsp;             */
&nbsp;            boolean isExternalAttachmentRequired();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a {@code VirtualMachine} class. This method must only be called for available accessors.
&nbsp;             *
&nbsp;             * @return The virtual machine type.
&nbsp;             */
&nbsp;            Class&lt;?&gt; getVirtualMachineType();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a description of a virtual machine class for an external attachment.
&nbsp;             *
&nbsp;             * @return A description of the external attachment.
&nbsp;             */
&nbsp;            ExternalAttachment getExternalAttachment();
&nbsp;
&nbsp;            /**
&nbsp;             * A canonical implementation of an unavailable accessor.
&nbsp;             */
<b class="fc">&nbsp;            enum Unavailable implements Accessor {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isExternalAttachmentRequired() {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; getVirtualMachineType() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ExternalAttachment getExternalAttachment() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot read the virtual machine type for an unavailable accessor&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Describes an external attachment to a Java virtual machine.
&nbsp;             */
&nbsp;            class ExternalAttachment {
&nbsp;
&nbsp;                /**
&nbsp;                 * The fully-qualified binary name of the virtual machine type.
&nbsp;                 */
&nbsp;                private final String virtualMachineType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class path elements required for loading the supplied virtual machine type.
&nbsp;                 */
&nbsp;                private final List&lt;File&gt; classPath;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an external attachment.
&nbsp;                 *
&nbsp;                 * @param virtualMachineType The fully-qualified binary name of the virtual machine type.
&nbsp;                 * @param classPath          The class path elements required for loading the supplied virtual machine type.
&nbsp;                 */
<b class="fc">&nbsp;                public ExternalAttachment(String virtualMachineType, List&lt;File&gt; classPath) {</b>
<b class="fc">&nbsp;                    this.virtualMachineType = virtualMachineType;</b>
<b class="fc">&nbsp;                    this.classPath = classPath;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the fully-qualified binary name of the virtual machine type.
&nbsp;                 *
&nbsp;                 * @return The fully-qualified binary name of the virtual machine type.
&nbsp;                 */
&nbsp;                public String getVirtualMachineType() {
<b class="fc">&nbsp;                    return virtualMachineType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the class path elements required for loading the supplied virtual machine type.
&nbsp;                 *
&nbsp;                 * @return The class path elements required for loading the supplied virtual machine type.
&nbsp;                 */
&nbsp;                public List&lt;File&gt; getClassPath() {
<b class="fc">&nbsp;                    return classPath;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A simple implementation of an accessible accessor.
&nbsp;             */
&nbsp;            abstract class Simple implements Accessor {
&nbsp;
&nbsp;                /**
&nbsp;                 * A {@code VirtualMachine} class.
&nbsp;                 */
&nbsp;                protected final Class&lt;?&gt; virtualMachineType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new simple accessor.
&nbsp;                 *
&nbsp;                 * @param virtualMachineType A {@code VirtualMachine} class.
&nbsp;                 */
<b class="fc">&nbsp;                protected Simple(Class&lt;?&gt; virtualMachineType) {</b>
<b class="fc">&nbsp;                    this.virtualMachineType = virtualMachineType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Creates an accessor by reading the process id from the JMX runtime bean and by attempting
&nbsp;                 * to load the {@code com.sun.tools.attach.VirtualMachine} class from the provided class loader.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * This accessor is supposed to work on any implementation of the OpenJDK or Oracle JDK.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @param classLoader A class loader that is capable of loading the virtual machine type.
&nbsp;                 * @param classPath   The class path required to load the virtual machine class.
&nbsp;                 * @return An appropriate accessor.
&nbsp;                 */
&nbsp;                public static Accessor of(@MaybeNull ClassLoader classLoader, File... classPath) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return new Simple.WithExternalAttachment(Class.forName(VIRTUAL_MACHINE_TYPE_NAME,</b>
&nbsp;                                false,
<b class="fc">&nbsp;                                classLoader), Arrays.asList(classPath));</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                        return Unavailable.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Creates an accessor by reading the process id from the JMX runtime bean and by attempting
&nbsp;                 * to load the {@code com.ibm.tools.attach.VirtualMachine} class from the provided class loader.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * This accessor is supposed to work on any implementation of IBM&#39;s J9.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @return An appropriate accessor.
&nbsp;                 */
&nbsp;                public static Accessor ofJ9() {
&nbsp;                    try {
<b class="nc">&nbsp;                        return new Simple.WithExternalAttachment(ClassLoader.getSystemClassLoader().loadClass(VIRTUAL_MACHINE_TYPE_NAME_J9),</b>
<b class="nc">&nbsp;                                Collections.&lt;File&gt;emptyList());</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                        return Unavailable.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAvailable() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; getVirtualMachineType() {
<b class="fc">&nbsp;                    return virtualMachineType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple implementation of an accessible accessor that allows for external attachment.
&nbsp;                 */
&nbsp;                protected static class WithExternalAttachment extends Simple {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The class path required for loading the virtual machine type.
&nbsp;                     */
&nbsp;                    private final List&lt;File&gt; classPath;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple accessor that allows for external attachment.
&nbsp;                     *
&nbsp;                     * @param virtualMachineType The {@code com.sun.tools.attach.VirtualMachine} class.
&nbsp;                     * @param classPath          The class path required for loading the virtual machine type.
&nbsp;                     */
&nbsp;                    public WithExternalAttachment(Class&lt;?&gt; virtualMachineType, List&lt;File&gt; classPath) {
<b class="fc">&nbsp;                        super(virtualMachineType);</b>
<b class="fc">&nbsp;                        this.classPath = classPath;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isExternalAttachmentRequired() {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ExternalAttachment getExternalAttachment() {
<b class="fc">&nbsp;                        return new ExternalAttachment(virtualMachineType.getName(), classPath);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple implementation of an accessible accessor that attaches using a virtual machine emulation that does not require external attachment.
&nbsp;                 */
&nbsp;                protected static class WithDirectAttachment extends Simple {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple accessor that implements direct attachment.
&nbsp;                     *
&nbsp;                     * @param virtualMachineType A {@code VirtualMachine} class.
&nbsp;                     */
&nbsp;                    public WithDirectAttachment(Class&lt;?&gt; virtualMachineType) {
<b class="fc">&nbsp;                        super(virtualMachineType);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isExternalAttachmentRequired() {
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ExternalAttachment getExternalAttachment() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot apply external attachment&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment provider that locates the attach API directly from the system class loader, as possible since
&nbsp;         * introducing the Java module system via the {@code jdk.attach} module.
&nbsp;         */
<b class="fc">&nbsp;        enum ForModularizedVm implements AttachmentProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Accessor attempt() {
<b class="fc">&nbsp;                return Accessor.Simple.of(ClassLoader.getSystemClassLoader());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment provider that locates the attach API directly from the system class loader expecting
&nbsp;         * an IBM J9 VM.
&nbsp;         */
<b class="fc">&nbsp;        enum ForJ9Vm implements AttachmentProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Accessor attempt() {
<b class="nc">&nbsp;                return Accessor.Simple.ofJ9();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment provider that is dependant on the existence of a &lt;i&gt;tools.jar&lt;/i&gt; file on the local
&nbsp;         * file system.
&nbsp;         */
<b class="fc">&nbsp;        enum ForStandardToolsJarVm implements AttachmentProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An attachment provider that locates the &lt;i&gt;tools.jar&lt;/i&gt; from a Java home directory.
&nbsp;             */
<b class="fc">&nbsp;            JVM_ROOT(&quot;../lib/tools.jar&quot;),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An attachment provider that locates the &lt;i&gt;tools.jar&lt;/i&gt; from a Java installation directory.
&nbsp;             * In practice, several virtual machines do not return the JRE&#39;s location for the
&nbsp;             * &lt;i&gt;java.home&lt;/i&gt; property against the property&#39;s specification.
&nbsp;             */
<b class="fc">&nbsp;            JDK_ROOT(&quot;lib/tools.jar&quot;),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An attachment provider that locates the &lt;i&gt;tools.jar&lt;/i&gt; as it is set for several JVM
&nbsp;             * installations on Apple Macintosh computers.
&nbsp;             */
<b class="fc">&nbsp;            MACINTOSH(&quot;../Classes/classes.jar&quot;);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The Java home system property.
&nbsp;             */
&nbsp;            private static final String JAVA_HOME_PROPERTY = &quot;java.home&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The path to the &lt;i&gt;tools.jar&lt;/i&gt; file, starting from the Java home directory.
&nbsp;             */
&nbsp;            private final String toolsJarPath;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new attachment provider that loads the virtual machine class from the &lt;i&gt;tools.jar&lt;/i&gt;.
&nbsp;             *
&nbsp;             * @param toolsJarPath The path to the &lt;i&gt;tools.jar&lt;/i&gt; file, starting from the Java home directory.
&nbsp;             */
<b class="fc">&nbsp;            ForStandardToolsJarVm(String toolsJarPath) {</b>
<b class="fc">&nbsp;                this.toolsJarPath = toolsJarPath;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;            public Accessor attempt() {
<b class="nc">&nbsp;                File toolsJar = new File(System.getProperty(JAVA_HOME_PROPERTY), toolsJarPath);</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return toolsJar.isFile() &amp;&amp; toolsJar.canRead()</b>
<b class="nc">&nbsp;                            ? Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, BOOTSTRAP_CLASS_LOADER), toolsJar)</b>
<b class="nc">&nbsp;                            : Accessor.Unavailable.INSTANCE;</b>
<b class="nc">&nbsp;                } catch (MalformedURLException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not represent &quot; + toolsJar + &quot; as URL&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment provider that attempts to locate a {@code tools.jar} from a custom location set via a system property.
&nbsp;         */
<b class="fc">&nbsp;        enum ForUserDefinedToolsJar implements AttachmentProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singelton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The property being read for locating {@code tools.jar}.
&nbsp;             */
&nbsp;            public static final String PROPERTY = &quot;net.bytebuddy.agent.toolsjar&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Assuring privilege is explicit user responsibility.&quot;)
&nbsp;            public Accessor attempt() {
<b class="nc">&nbsp;                String location = System.getProperty(PROPERTY);</b>
<b class="nc">&nbsp;                if (location == null) {</b>
<b class="nc">&nbsp;                    return Accessor.Unavailable.INSTANCE;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    File toolsJar = new File(location);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        return Accessor.Simple.of(new URLClassLoader(new URL[]{toolsJar.toURI().toURL()}, BOOTSTRAP_CLASS_LOADER), toolsJar);</b>
<b class="nc">&nbsp;                    } catch (MalformedURLException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not represent &quot; + toolsJar + &quot; as URL&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment provider that uses Byte Buddy&#39;s attachment API emulation. To use this feature, JNA is required.
&nbsp;         */
<b class="fc">&nbsp;        enum ForEmulatedAttachment implements AttachmentProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Accessor attempt() {
&nbsp;                try {
<b class="nc">&nbsp;                    return new Accessor.Simple.WithDirectAttachment(doPrivileged(VirtualMachine.Resolver.INSTANCE));</b>
<b class="nc">&nbsp;                } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;                    return Accessor.Unavailable.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound attachment provider that attempts the attachment by delegation to other providers. If
&nbsp;         * none of the providers of this compound provider is capable of providing a valid accessor, an
&nbsp;         * non-available accessor is returned.
&nbsp;         */
&nbsp;        class Compound implements AttachmentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * A list of attachment providers in the order of their application.
&nbsp;             */
&nbsp;            private final List&lt;AttachmentProvider&gt; attachmentProviders;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound attachment provider.
&nbsp;             *
&nbsp;             * @param attachmentProvider A list of attachment providers in the order of their application.
&nbsp;             */
&nbsp;            public Compound(AttachmentProvider... attachmentProvider) {
<b class="fc">&nbsp;                this(Arrays.asList(attachmentProvider));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound attachment provider.
&nbsp;             *
&nbsp;             * @param attachmentProviders A list of attachment providers in the order of their application.
&nbsp;             */
<b class="fc">&nbsp;            public Compound(List&lt;? extends AttachmentProvider&gt; attachmentProviders) {</b>
<b class="fc">&nbsp;                this.attachmentProviders = new ArrayList&lt;AttachmentProvider&gt;();</b>
<b class="fc">&nbsp;                for (AttachmentProvider attachmentProvider : attachmentProviders) {</b>
<b class="fc">&nbsp;                    if (attachmentProvider instanceof Compound) {</b>
<b class="nc">&nbsp;                        this.attachmentProviders.addAll(((Compound) attachmentProvider).attachmentProviders);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        this.attachmentProviders.add(attachmentProvider);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Accessor attempt() {
<b class="fc">&nbsp;                for (AttachmentProvider attachmentProvider : attachmentProviders) {</b>
<b class="fc">&nbsp;                    Accessor accessor = attachmentProvider.attempt();</b>
<b class="fc">&nbsp;                    if (accessor.isAvailable()) {</b>
<b class="fc">&nbsp;                        return accessor;</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return Accessor.Unavailable.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A process provider is responsible for providing the process id of the current VM.
&nbsp;     */
&nbsp;    public interface ProcessProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a process id for the current JVM.
&nbsp;         *
&nbsp;         * @return The resolved process id.
&nbsp;         */
&nbsp;        String resolve();
&nbsp;
&nbsp;        /**
&nbsp;         * Supplies the current VM&#39;s process id.
&nbsp;         */
<b class="fc">&nbsp;        enum ForCurrentVm implements ProcessProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The best process provider for the current VM.
&nbsp;             */
&nbsp;            private final ProcessProvider dispatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a process provider that supplies the current VM&#39;s process id.
&nbsp;             */
&nbsp;            ForCurrentVm() {
&nbsp;                dispatcher = ForJava9CapableVm.make();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String resolve() {
<b class="fc">&nbsp;                return dispatcher.resolve();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A process provider for a legacy VM that reads the process id from its JMX properties. This strategy
&nbsp;             * is only used prior to Java 9 such that the &lt;i&gt;java.management&lt;/i&gt; module never is resolved, even if
&nbsp;             * the module system is used, as the module system was not available in any relevant JVM version.
&nbsp;             */
<b class="nc">&nbsp;            protected enum ForLegacyVm implements ProcessProvider {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                public String resolve() {
&nbsp;                    String runtimeName;
&nbsp;                    try {
<b class="nc">&nbsp;                        Method method = Class.forName(&quot;java.lang.management.ManagementFactory&quot;).getMethod(&quot;getRuntimeMXBean&quot;);</b>
<b class="nc">&nbsp;                        runtimeName = (String) method.getReturnType().getMethod(&quot;getName&quot;).invoke(method.invoke(null));</b>
<b class="nc">&nbsp;                    } catch (Exception exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Failed to access VM name via management factory&quot;, exception);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    int processIdIndex = runtimeName.indexOf(&#39;@&#39;);</b>
<b class="nc">&nbsp;                    if (processIdIndex == -1) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot extract process id from runtime management bean&quot;);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return runtimeName.substring(0, processIdIndex);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A process provider for a Java 9 capable VM with access to the introduced process API.
&nbsp;             */
&nbsp;            protected static class ForJava9CapableVm implements ProcessProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.ProcessHandle#current()} method.
&nbsp;                 */
&nbsp;                private final Method current;
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.ProcessHandle#pid()} method.
&nbsp;                 */
&nbsp;                private final Method pid;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new Java 9 capable dispatcher for reading the current process&#39;s id.
&nbsp;                 *
&nbsp;                 * @param current The {@code java.lang.ProcessHandle#current()} method.
&nbsp;                 * @param pid     The {@code java.lang.ProcessHandle#pid()} method.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForJava9CapableVm(Method current, Method pid) {</b>
<b class="fc">&nbsp;                    this.current = current;</b>
<b class="fc">&nbsp;                    this.pid = pid;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Attempts to create a dispatcher for a Java 9 VM and falls back to a legacy dispatcher
&nbsp;                 * if this is not possible.
&nbsp;                 *
&nbsp;                 * @return A dispatcher for the current VM.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                public static ProcessProvider make() {
&nbsp;                    try {
<b class="fc">&nbsp;                        return new ForJava9CapableVm(Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;current&quot;),</b>
<b class="fc">&nbsp;                                Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;pid&quot;));</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                        return ForLegacyVm.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String resolve() {
&nbsp;                    try {
<b class="fc">&nbsp;                        return pid.invoke(current.invoke(null)).toString();</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access Java 9 process API&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Error when accessing Java 9 process API&quot;, exception.getTargetException());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An agent provider is responsible for handling and providing the jar file of an agent that is being attached.
&nbsp;     */
&nbsp;    protected interface AgentProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * Provides an agent jar file for attachment.
&nbsp;         *
&nbsp;         * @return The provided agent.
&nbsp;         * @throws IOException If the agent cannot be written to disk.
&nbsp;         */
&nbsp;        File resolve() throws IOException;
&nbsp;
&nbsp;        /**
&nbsp;         * An agent provider for a temporary Byte Buddy agent.
&nbsp;         */
<b class="fc">&nbsp;        enum ForByteBuddyAgent implements AgentProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The default prefix of the Byte Buddy agent jar file.
&nbsp;             */
&nbsp;            private static final String AGENT_FILE_NAME = &quot;byteBuddyAgent&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * Attempts to resolve the {@link Installer} class from this jar file if it can be located. Doing so, it is possible
&nbsp;             * to avoid the creation of a temporary jar file which can remain undeleted on Windows operating systems where the agent
&nbsp;             * is linked by a class loader such that {@link File#deleteOnExit()} does not have an effect.
&nbsp;             *
&nbsp;             * @return This jar file&#39;s location or {@code null} if this jar file&#39;s location is inaccessible.
&nbsp;             * @throws IOException If an I/O exception occurs.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private static File trySelfResolve() throws IOException {
<b class="fc">&nbsp;                ProtectionDomain protectionDomain = Installer.class.getProtectionDomain();</b>
<b class="fc">&nbsp;                if (Boolean.getBoolean(LATENT_RESOLVE)) {</b>
<b class="nc">&nbsp;                    return CANNOT_SELF_RESOLVE;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (protectionDomain == null) {</b>
<b class="nc">&nbsp;                    return CANNOT_SELF_RESOLVE;</b>
&nbsp;                }
<b class="fc">&nbsp;                CodeSource codeSource = protectionDomain.getCodeSource();</b>
<b class="fc">&nbsp;                if (codeSource == null) {</b>
<b class="nc">&nbsp;                    return CANNOT_SELF_RESOLVE;</b>
&nbsp;                }
<b class="fc">&nbsp;                URL location = codeSource.getLocation();</b>
<b class="fc">&nbsp;                if (!location.getProtocol().equals(FILE_PROTOCOL)) {</b>
<b class="nc">&nbsp;                    return CANNOT_SELF_RESOLVE;</b>
&nbsp;                }
&nbsp;                File agentJar;
&nbsp;                try {
<b class="fc">&nbsp;                    agentJar = new File(location.toURI());</b>
<b class="nc">&nbsp;                } catch (URISyntaxException ignored) {</b>
<b class="nc">&nbsp;                    agentJar = new File(location.getPath());</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (!agentJar.isFile() || !agentJar.canRead()) {</b>
<b class="fc">&nbsp;                    return CANNOT_SELF_RESOLVE;</b>
&nbsp;                }
&nbsp;                // It is necessary to check the manifest of the containing file as this code can be shaded into another artifact.
<b class="nc">&nbsp;                JarInputStream jarInputStream = new JarInputStream(new FileInputStream(agentJar));</b>
&nbsp;                try {
<b class="nc">&nbsp;                    Manifest manifest = jarInputStream.getManifest();</b>
<b class="nc">&nbsp;                    if (manifest == null) {</b>
<b class="nc">&nbsp;                        return CANNOT_SELF_RESOLVE;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    Attributes attributes = manifest.getMainAttributes();</b>
<b class="nc">&nbsp;                    if (attributes == null) {</b>
<b class="nc">&nbsp;                        return CANNOT_SELF_RESOLVE;</b>
&nbsp;                    }
<b class="nc">&nbsp;                    if (Installer.class.getName().equals(attributes.getValue(AGENT_CLASS_PROPERTY))</b>
<b class="nc">&nbsp;                            &amp;&amp; Boolean.parseBoolean(attributes.getValue(CAN_REDEFINE_CLASSES_PROPERTY))</b>
<b class="nc">&nbsp;                            &amp;&amp; Boolean.parseBoolean(attributes.getValue(CAN_RETRANSFORM_CLASSES_PROPERTY))</b>
<b class="nc">&nbsp;                            &amp;&amp; Boolean.parseBoolean(attributes.getValue(CAN_SET_NATIVE_METHOD_PREFIX))) {</b>
<b class="nc">&nbsp;                        return agentJar;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return CANNOT_SELF_RESOLVE;</b>
&nbsp;                    }
&nbsp;                } finally {
<b class="nc">&nbsp;                    jarInputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an agent jar file containing the {@link Installer} class.
&nbsp;             *
&nbsp;             * @return The agent jar file.
&nbsp;             * @throws IOException If an I/O exception occurs.
&nbsp;             */
&nbsp;            private static File createJarFile() throws IOException {
<b class="fc">&nbsp;                InputStream inputStream = Installer.class.getResourceAsStream(&#39;/&#39; + Installer.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;                if (inputStream == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot locate class file for Byte Buddy installer&quot;);</b>
&nbsp;                }
&nbsp;                try {
<b class="fc">&nbsp;                    File agentJar = File.createTempFile(AGENT_FILE_NAME, JAR_FILE_EXTENSION);</b>
<b class="fc">&nbsp;                    agentJar.deleteOnExit(); // Agent jar is required until VM shutdown due to lazy class loading.</b>
<b class="fc">&nbsp;                    Manifest manifest = new Manifest();</b>
<b class="fc">&nbsp;                    manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, MANIFEST_VERSION_VALUE);</b>
<b class="fc">&nbsp;                    manifest.getMainAttributes().put(new Attributes.Name(AGENT_CLASS_PROPERTY), Installer.class.getName());</b>
<b class="fc">&nbsp;                    manifest.getMainAttributes().put(new Attributes.Name(CAN_REDEFINE_CLASSES_PROPERTY), Boolean.TRUE.toString());</b>
<b class="fc">&nbsp;                    manifest.getMainAttributes().put(new Attributes.Name(CAN_RETRANSFORM_CLASSES_PROPERTY), Boolean.TRUE.toString());</b>
<b class="fc">&nbsp;                    manifest.getMainAttributes().put(new Attributes.Name(CAN_SET_NATIVE_METHOD_PREFIX), Boolean.TRUE.toString());</b>
<b class="fc">&nbsp;                    JarOutputStream jarOutputStream = new JarOutputStream(new FileOutputStream(agentJar), manifest);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        jarOutputStream.putNextEntry(new JarEntry(Installer.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION));</b>
<b class="fc">&nbsp;                        byte[] buffer = new byte[BUFFER_SIZE];</b>
&nbsp;                        int index;
<b class="fc">&nbsp;                        while ((index = inputStream.read(buffer)) != END_OF_FILE) {</b>
<b class="fc">&nbsp;                            jarOutputStream.write(buffer, START_INDEX, index);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        jarOutputStream.closeEntry();</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        jarOutputStream.close();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return agentJar;</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    inputStream.close();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public File resolve() throws IOException {
&nbsp;                try {
<b class="fc">&nbsp;                    File resolved = trySelfResolve();</b>
<b class="fc">&nbsp;                    if (resolved != null) {</b>
<b class="nc">&nbsp;                        return resolved;</b>
&nbsp;                    }
<b class="fc">&nbsp;                } catch (Exception ignored) {</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return createJarFile();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An agent provider that supplies an existing agent that is not deleted after attachment.
&nbsp;         */
&nbsp;        class ForExistingAgent implements AgentProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The supplied agent.
&nbsp;             */
&nbsp;            private final File agent;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an agent provider for an existing agent.
&nbsp;             *
&nbsp;             * @param agent The supplied agent.
&nbsp;             */
<b class="fc">&nbsp;            protected ForExistingAgent(File agent) {</b>
<b class="fc">&nbsp;                this.agent = agent;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public File resolve() {
<b class="fc">&nbsp;                return agent;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An attachment evaluator is responsible for deciding if an agent can be attached from the current process.
&nbsp;     */
&nbsp;    protected interface AttachmentTypeEvaluator {
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the current VM requires external attachment for the supplied process id.
&nbsp;         *
&nbsp;         * @param processId The process id of the process to which to attach.
&nbsp;         * @return {@code true} if the current VM requires external attachment for the supplied process.
&nbsp;         */
&nbsp;        boolean requiresExternalAttachment(String processId);
&nbsp;
&nbsp;        /**
&nbsp;         * An installation action for creating an attachment type evaluator.
&nbsp;         */
<b class="fc">&nbsp;        enum InstallationAction implements PrivilegedAction&lt;AttachmentTypeEvaluator&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The OpenJDK&#39;s property for specifying the legality of self-attachment.
&nbsp;             */
&nbsp;            private static final String JDK_ALLOW_SELF_ATTACH = &quot;jdk.attach.allowAttachSelf&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;            public AttachmentTypeEvaluator run() {
&nbsp;                try {
<b class="fc">&nbsp;                    if (Boolean.getBoolean(JDK_ALLOW_SELF_ATTACH)) {</b>
<b class="nc">&nbsp;                        return Disabled.INSTANCE;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForJava9CapableVm(Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;current&quot;),</b>
<b class="fc">&nbsp;                                Class.forName(&quot;java.lang.ProcessHandle&quot;).getMethod(&quot;pid&quot;));</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                    return Disabled.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment type evaluator that never requires external attachment.
&nbsp;         */
<b class="fc">&nbsp;        enum Disabled implements AttachmentTypeEvaluator {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean requiresExternalAttachment(String processId) {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An attachment type evaluator that checks a process id against the current process id.
&nbsp;         */
&nbsp;        class ForJava9CapableVm implements AttachmentTypeEvaluator {
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.lang.ProcessHandle#current()} method.
&nbsp;             */
&nbsp;            private final Method current;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.lang.ProcessHandle#pid()} method.
&nbsp;             */
&nbsp;            private final Method pid;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new attachment type evaluator.
&nbsp;             *
&nbsp;             * @param current The {@code java.lang.ProcessHandle#current()} method.
&nbsp;             * @param pid     The {@code java.lang.ProcessHandle#pid()} method.
&nbsp;             */
<b class="fc">&nbsp;            protected ForJava9CapableVm(Method current, Method pid) {</b>
<b class="fc">&nbsp;                this.current = current;</b>
<b class="fc">&nbsp;                this.pid = pid;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean requiresExternalAttachment(String processId) {
&nbsp;                try {
<b class="fc">&nbsp;                    return pid.invoke(current.invoke(null)).toString().equals(processId);</b>
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access Java 9 process API&quot;, exception);</b>
<b class="nc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Error when accessing Java 9 process API&quot;, exception.getTargetException());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
