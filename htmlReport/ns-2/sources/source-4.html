


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > VirtualMachine</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.agent</a>
</div>

<h1>Coverage Summary for Class: VirtualMachine (net.bytebuddy.agent)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">VirtualMachine$1</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (60/68)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$Factory</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$Factory$ForSocketFile</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaPosixSocket</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaPosixSocket$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaPosixSocket$Factory$MacLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaPosixSocket$PosixLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaPosixSocket$PosixLibrary$SocketAddress</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaSolarisDoor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaSolarisDoor$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaSolarisDoor$Response</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaSolarisDoor$SolarisLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaSolarisDoor$SolarisLibrary$DoorArgument</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaWindowsNamedPipe</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.3%
  </span>
  <span class="absValue">
    (32/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaWindowsNamedPipe$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (8/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaWindowsNamedPipe$NamedPipeResponse</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaWindowsNamedPipe$WindowsAttachLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$ForJnaWindowsNamedPipe$WindowsLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$MockitoMock$746244447</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$MockitoMock$746244447$auxiliary$A6HIAIrq</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$MockitoMock$746244447$auxiliary$QqTmZnDq</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$OnPersistentByteChannel</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$OnPersistentByteChannel$Response</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$Response</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$Response$MockitoMock$1017778523</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$Response$MockitoMock$1017778523$auxiliary$2xm3Udnx</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$Connection$Response$MockitoMock$1017778523$auxiliary$3EcQCQP9</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$3FsGdOez</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$5NSLYfKZ</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$a5ia5n1x</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$a8OfTslb</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$hVSIkr8X</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$Kpm94djT</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$Ln3l0VDJ</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$n7v6U2AN</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$owiui05b</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$P5QpCmxS</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$rgyajjLf</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$rvzFpQoN</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$sLTpH9yw</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForHotSpot$MockitoMock$29163432$auxiliary$VFAwxcqg</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.5%
  </span>
  <span class="absValue">
    (137/179)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaPosixEnvironment</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/54)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaPosixEnvironment$PosixLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaPosixEnvironment$PosixLibrary$SemaphoreOperation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaWindowsEnvironment</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/74)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaWindowsEnvironment$AttachmentHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaWindowsEnvironment$WindowsLibrary</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$ForJnaWindowsEnvironment$WindowsLibrary$SecurityAttributes</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$MockitoMock$893245667</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$MockitoMock$893245667$auxiliary$5v7YwPdM</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$ForOpenJ9$Dispatcher$MockitoMock$893245667$auxiliary$ZyN4XZHk</td>
  </tr>
  <tr>
    <td class="name">VirtualMachine$Resolver</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    40.8%
  </span>
  <span class="absValue">
    (42/103)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41%
  </span>
  <span class="absValue">
    (257/627)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.agent;
&nbsp;
&nbsp;import com.sun.jna.*;
&nbsp;import com.sun.jna.platform.win32.*;
&nbsp;import com.sun.jna.ptr.IntByReference;
&nbsp;import com.sun.jna.win32.StdCallLibrary;
&nbsp;import com.sun.jna.win32.W32APIOptions;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.agent.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.agent.utility.nullability.UnknownNull;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.net.ServerSocket;
&nbsp;import java.net.Socket;
&nbsp;import java.nio.ByteBuffer;
&nbsp;import java.nio.channels.FileLock;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.SecureRandom;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * An implementation for attachment on a virtual machine. This interface mimics the tooling API&#39;s virtual
&nbsp; * machine interface to allow for similar usage by {@link ByteBuddyAgent} where all calls are made via
&nbsp; * reflection such that this structural typing suffices for interoperability.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: Implementations are required to declare a static method {@code attach(String)} returning an
&nbsp; * instance of a class that declares the methods defined by {@link VirtualMachine}.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;public interface VirtualMachine {
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the target VMs system properties.
&nbsp;     *
&nbsp;     * @return The target VM properties.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    Properties getSystemProperties() throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads the target VMs agent properties.
&nbsp;     *
&nbsp;     * @return The target VM properties.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    Properties getAgentProperties() throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads an agent into the represented virtual machine.
&nbsp;     *
&nbsp;     * @param jarFile The jar file to attach.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void loadAgent(String jarFile) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads an agent into the represented virtual machine.
&nbsp;     *
&nbsp;     * @param jarFile  The jar file to attach.
&nbsp;     * @param argument The argument to provide or {@code null} if no argument should be provided.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void loadAgent(String jarFile, @MaybeNull String argument) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a native agent into the represented virtual machine.
&nbsp;     *
&nbsp;     * @param path The agent path.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void loadAgentPath(String path) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a native agent into the represented virtual machine.
&nbsp;     *
&nbsp;     * @param path     The agent path.
&nbsp;     * @param argument The argument to provide or {@code null} if no argument should be provided.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void loadAgentPath(String path, @MaybeNull String argument) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a native agent library into the represented virtual machine.
&nbsp;     *
&nbsp;     * @param library The agent library.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void loadAgentLibrary(String library) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Loads a native agent library into the represented virtual machine.
&nbsp;     *
&nbsp;     * @param library  The agent library.
&nbsp;     * @param argument The argument to provide or {@code null} if no argument should be provided.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void loadAgentLibrary(String library, @MaybeNull String argument) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Starts a JMX management agent.
&nbsp;     *
&nbsp;     * @param properties The properties to transfer to the JMX agent.
&nbsp;     * @throws IOException If an I/O error occurs.
&nbsp;     */
&nbsp;    void startManagementAgent(Properties properties) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Starts a local management agent.
&nbsp;     *
&nbsp;     * @return The local connector address.
&nbsp;     * @throws IOException If an I/O error occurs.
&nbsp;     */
&nbsp;    String startLocalManagementAgent() throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * Detaches this virtual machine representation.
&nbsp;     *
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    void detach() throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * A resolver for the current VM&#39;s virtual machine attachment emulation.
&nbsp;     */
<b class="fc">&nbsp;    enum Resolver implements PrivilegedAction&lt;Class&lt;? extends VirtualMachine&gt;&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Class&lt;? extends VirtualMachine&gt; run() {
&nbsp;            try {
<b class="fc">&nbsp;                Class.forName(&quot;com.sun.jna.Platform&quot;);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Optional JNA dependency is not available&quot;, exception);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return System.getProperty(&quot;java.vm.name&quot;, &quot;&quot;).toUpperCase(Locale.US).contains(&quot;J9&quot;)</b>
<b class="nc">&nbsp;                    ? ForOpenJ9.class</b>
<b class="fc">&nbsp;                    : ForHotSpot.class;</b>
&nbsp;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation for a virtual machine.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase implements VirtualMachine {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgent(String jarFile) throws IOException {
<b class="fc">&nbsp;            loadAgent(jarFile, null);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgentPath(String path) throws IOException {
<b class="fc">&nbsp;            loadAgentPath(path, null);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgentLibrary(String library) throws IOException {
<b class="fc">&nbsp;            loadAgentLibrary(library, null);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A virtual machine attachment implementation for a HotSpot VM or any compatible JVM.
&nbsp;     */
&nbsp;    class ForHotSpot extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The protocol version to use for communication.
&nbsp;         */
&nbsp;        private static final String PROTOCOL_VERSION = &quot;1&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code load} command.
&nbsp;         */
&nbsp;        private static final String LOAD_COMMAND = &quot;load&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code instrument} command.
&nbsp;         */
&nbsp;        private static final String INSTRUMENT_COMMAND = &quot;instrument&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A delimiter to be used for attachment.
&nbsp;         */
&nbsp;        private static final String ARGUMENT_DELIMITER = &quot;=&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The virtual machine connection.
&nbsp;         */
&nbsp;        private final Connection connection;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new virtual machine connection for HotSpot.
&nbsp;         *
&nbsp;         * @param connection The virtual machine connection.
&nbsp;         */
<b class="fc">&nbsp;        protected ForHotSpot(Connection connection) {</b>
<b class="fc">&nbsp;            this.connection = connection;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attaches to the supplied process id using the default JNA implementation.
&nbsp;         *
&nbsp;         * @param processId The process id.
&nbsp;         * @return A suitable virtual machine implementation.
&nbsp;         * @throws IOException If an IO exception occurs during establishing the connection.
&nbsp;         */
&nbsp;        public static VirtualMachine attach(String processId) throws IOException {
<b class="fc">&nbsp;            if (Platform.isWindows()) {</b>
<b class="fc">&nbsp;                return attach(processId, new Connection.ForJnaWindowsNamedPipe.Factory());</b>
<b class="nc">&nbsp;            } else if (Platform.isSolaris()) {</b>
<b class="nc">&nbsp;                return attach(processId, new Connection.ForJnaSolarisDoor.Factory(15, 100, TimeUnit.MILLISECONDS));</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return attach(processId, Connection.ForJnaPosixSocket.Factory.withDefaultTemporaryFolder(15, 100, TimeUnit.MILLISECONDS));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attaches to the supplied process id using the supplied connection factory.
&nbsp;         *
&nbsp;         * @param processId         The process id.
&nbsp;         * @param connectionFactory The connection factory to use.
&nbsp;         * @return A suitable virtual machine implementation.
&nbsp;         * @throws IOException If an IO exception occurs during establishing the connection.
&nbsp;         */
&nbsp;        public static VirtualMachine attach(String processId, Connection.Factory connectionFactory) throws IOException {
<b class="fc">&nbsp;            return new ForHotSpot(connectionFactory.connect(processId));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks the header of a response.
&nbsp;         *
&nbsp;         * @param response The response to check the header for.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        private static void checkHeader(Connection.Response response) throws IOException {
<b class="fc">&nbsp;            byte[] buffer = new byte[1];</b>
<b class="fc">&nbsp;            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
&nbsp;            int length;
<b class="fc">&nbsp;            while ((length = response.read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                if (length &gt; 0) {</b>
<b class="fc">&nbsp;                    if (buffer[0] == &#39;\n&#39;) {</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    outputStream.write(buffer[0]);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            switch (Integer.parseInt(outputStream.toString(&quot;UTF-8&quot;))) {</b>
&nbsp;                case 0:
&nbsp;                    return;
&nbsp;                case 101:
<b class="fc">&nbsp;                    throw new IOException(&quot;Protocol mismatch with target VM&quot;);</b>
&nbsp;                default:
<b class="fc">&nbsp;                    buffer = new byte[1024];</b>
<b class="fc">&nbsp;                    outputStream = new ByteArrayOutputStream();</b>
<b class="fc">&nbsp;                    while ((length = response.read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                        outputStream.write(buffer, 0, length);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    throw new IllegalStateException(outputStream.toString(&quot;UTF-8&quot;));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Properties getSystemProperties() throws IOException {
<b class="fc">&nbsp;            return getProperties(&quot;properties&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Properties getAgentProperties() throws IOException {
<b class="fc">&nbsp;            return getProperties(&quot;agentProperties&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads properties of the target VM.
&nbsp;         *
&nbsp;         * @param command The command for fetching properties.
&nbsp;         * @return The read properties.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        private Properties getProperties(String command) throws IOException {
<b class="fc">&nbsp;            Connection.Response response = connection.execute(PROTOCOL_VERSION, command, null, null, null);</b>
&nbsp;            try {
<b class="fc">&nbsp;                checkHeader(response);</b>
<b class="fc">&nbsp;                byte[] buffer = new byte[1024];</b>
<b class="fc">&nbsp;                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
&nbsp;                int length;
<b class="fc">&nbsp;                while ((length = response.read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                    outputStream.write(buffer, 0, length);</b>
&nbsp;                }
<b class="fc">&nbsp;                Properties properties = new Properties();</b>
<b class="fc">&nbsp;                properties.load(new ByteArrayInputStream(outputStream.toByteArray()));</b>
<b class="fc">&nbsp;                return properties;</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                response.close();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgent(String jarFile, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            load(jarFile, false, argument);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgentPath(String path, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            load(path, true, argument);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgentLibrary(String library, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            load(library, false, argument);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Loads an agent by the given command.
&nbsp;         *
&nbsp;         * @param file     The Java agent or library to be loaded.
&nbsp;         * @param absolute {@code true} if the agent location is absolute.
&nbsp;         * @param argument The argument to the agent or {@code null} if no argument is given.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        protected void load(String file, boolean absolute, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            Connection.Response response = connection.execute(PROTOCOL_VERSION, LOAD_COMMAND, INSTRUMENT_COMMAND, Boolean.toString(absolute), (argument == null</b>
<b class="fc">&nbsp;                    ? file</b>
<b class="fc">&nbsp;                    : file + ARGUMENT_DELIMITER + argument));</b>
&nbsp;            try {
<b class="fc">&nbsp;                checkHeader(response);</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                response.close();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void startManagementAgent(Properties properties) throws IOException {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(&quot;ManagementAgent.start &quot;);</b>
<b class="fc">&nbsp;            boolean first = true;</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;Object, Object&gt; entry : properties.entrySet()) {</b>
<b class="fc">&nbsp;                if (!(entry.getKey() instanceof String) || !((String) entry.getKey()).startsWith(&quot;com.sun.management.&quot;)) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Illegal property name: &quot; + entry.getKey());</b>
<b class="fc">&nbsp;                } else if (first) {</b>
<b class="fc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(&#39; &#39;);</b>
&nbsp;                }
<b class="fc">&nbsp;                stringBuilder.append(((String) entry.getKey()).substring(&quot;com.sun.management.&quot;.length())).append(&#39;=&#39;);</b>
<b class="fc">&nbsp;                String value = entry.getValue().toString();</b>
<b class="fc">&nbsp;                if (value.contains(&quot; &quot;)) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;\&#39;&#39;).append(value).append(&#39;\&#39;&#39;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    stringBuilder.append(value);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            Connection.Response response = connection.execute(PROTOCOL_VERSION, &quot;jcmd&quot;, stringBuilder.toString(), null, null);</b>
&nbsp;            try {
<b class="fc">&nbsp;                checkHeader(response);</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                response.close();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String startLocalManagementAgent() throws IOException {
<b class="fc">&nbsp;            Connection.Response response = connection.execute(PROTOCOL_VERSION, &quot;jcmd&quot;, &quot;ManagementAgent.start_local&quot;, null, null);</b>
&nbsp;            try {
<b class="fc">&nbsp;                checkHeader(response);</b>
<b class="fc">&nbsp;                return getAgentProperties().getProperty(&quot;com.sun.management.jmxremote.localConnectorAddress&quot;);</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                response.close();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void detach() throws IOException {
<b class="fc">&nbsp;            connection.close();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a connection to a virtual machine.
&nbsp;         */
&nbsp;        public interface Connection extends Closeable {
&nbsp;
&nbsp;            /**
&nbsp;             * Executes a command on the current connection.
&nbsp;             *
&nbsp;             * @param protocol The target VMs protocol version for the attach API.
&nbsp;             * @param argument The arguments to send to the target VM.
&nbsp;             * @return The response of the target JVM.
&nbsp;             * @throws IOException If an I/O error occurred.
&nbsp;             */
&nbsp;            Response execute(String protocol, String... argument) throws IOException;
&nbsp;
&nbsp;            /**
&nbsp;             * A response to an execution command to a VM.
&nbsp;             */
&nbsp;            interface Response extends Closeable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Reads a buffer from the target VM.
&nbsp;                 *
&nbsp;                 * @param buffer The buffer to read to.
&nbsp;                 * @return The bytes read or {@code -1} if no more bytes could be read.
&nbsp;                 * @throws IOException If an I/O exception occurred.
&nbsp;                 */
&nbsp;                int read(byte[] buffer) throws IOException;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating connections to virtual machines.
&nbsp;             */
&nbsp;            interface Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * Connects to the supplied process.
&nbsp;                 *
&nbsp;                 * @param processId The process id.
&nbsp;                 * @return The connection to the virtual machine with the supplied process id.
&nbsp;                 * @throws IOException If an I/O exception occurs during connecting to the targeted VM.
&nbsp;                 */
&nbsp;                Connection connect(String processId) throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for attaching via a socket file.
&nbsp;                 */
&nbsp;                abstract class ForSocketFile implements Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name prefix for a socket.
&nbsp;                     */
&nbsp;                    private static final String SOCKET_FILE_PREFIX = &quot;.java_pid&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name prefix for an attachment file indicator.
&nbsp;                     */
&nbsp;                    private static final String ATTACH_FILE_PREFIX = &quot;.attach_pid&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The temporary directory to use.
&nbsp;                     */
&nbsp;                    private final String temporaryDirectory;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The maximum amount of attempts for checking the establishment of a socket connection.
&nbsp;                     */
&nbsp;                    private final int attempts;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The pause between two checks for an established socket connection.
&nbsp;                     */
&nbsp;                    private final long pause;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The time unit of the pause time.
&nbsp;                     */
&nbsp;                    private final TimeUnit timeUnit;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a connection factory for creating a socket connection via a file.
&nbsp;                     *
&nbsp;                     * @param temporaryDirectory The temporary directory to use.
&nbsp;                     * @param attempts           The maximum amount of attempts for checking the establishment of a socket connection.
&nbsp;                     * @param pause              The pause between two checks for an established socket connection.
&nbsp;                     * @param timeUnit           The time unit of the pause time.
&nbsp;                     */
<b class="nc">&nbsp;                    protected ForSocketFile(String temporaryDirectory, int attempts, long pause, TimeUnit timeUnit) {</b>
<b class="nc">&nbsp;                        this.temporaryDirectory = temporaryDirectory;</b>
<b class="nc">&nbsp;                        this.attempts = attempts;</b>
<b class="nc">&nbsp;                        this.pause = pause;</b>
<b class="nc">&nbsp;                        this.timeUnit = timeUnit;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;DMI_HARDCODED_ABSOLUTE_FILENAME&quot;, justification = &quot;File name convention is specified.&quot;)
&nbsp;                    public Connection connect(String processId) throws IOException {
<b class="nc">&nbsp;                        File socket = new File(temporaryDirectory, SOCKET_FILE_PREFIX + processId);</b>
<b class="nc">&nbsp;                        if (!socket.exists()) {</b>
<b class="nc">&nbsp;                            String target = ATTACH_FILE_PREFIX + processId, path = &quot;/proc/&quot; + processId + &quot;/cwd/&quot; + target;</b>
<b class="nc">&nbsp;                            File attachFile = new File(path);</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                if (!attachFile.createNewFile() &amp;&amp; !attachFile.isFile()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Could not create attach file: &quot; + attachFile);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } catch (IOException ignored) {</b>
<b class="nc">&nbsp;                                attachFile = new File(temporaryDirectory, target);</b>
<b class="nc">&nbsp;                                if (!attachFile.createNewFile() &amp;&amp; !attachFile.isFile()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Could not create attach file: &quot; + attachFile);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                kill(processId, 3);</b>
<b class="nc">&nbsp;                                int attempts = this.attempts;</b>
<b class="nc">&nbsp;                                while (!socket.exists() &amp;&amp; attempts-- &gt; 0) {</b>
<b class="nc">&nbsp;                                    timeUnit.sleep(pause);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                if (!socket.exists()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Target VM did not respond: &quot; + processId);</b>
&nbsp;                                }
<b class="nc">&nbsp;                            } catch (InterruptedException exception) {</b>
<b class="nc">&nbsp;                                Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(exception);</b>
&nbsp;                            } finally {
<b class="nc">&nbsp;                                if (!attachFile.delete()) {</b>
<b class="nc">&nbsp;                                    attachFile.deleteOnExit();</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return doConnect(socket);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Sends a kill signal to the target process.
&nbsp;                     *
&nbsp;                     * @param processId The process id.
&nbsp;                     * @param signal    The signal to send.
&nbsp;                     */
&nbsp;                    protected abstract void kill(String processId, int signal);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Connects to the supplied POSIX socket.
&nbsp;                     *
&nbsp;                     * @param socket The socket to connect to.
&nbsp;                     * @return An active connection to the supplied socket.
&nbsp;                     * @throws IOException If an error occurs during connection.
&nbsp;                     */
&nbsp;                    protected abstract Connection doConnect(File socket) throws IOException;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A connection that is represented by a byte channel that is persistent during communication.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The connection representation.
&nbsp;             */
<b class="nc">&nbsp;            abstract class OnPersistentByteChannel&lt;T&gt; implements Connection {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A blank line argument.
&nbsp;                 */
<b class="nc">&nbsp;                private static final byte[] BLANK = new byte[]{0};</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Connection.Response execute(String protocol, String... argument) throws IOException {
<b class="nc">&nbsp;                    T connection = connect();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        write(connection, protocol.getBytes(&quot;UTF-8&quot;));</b>
<b class="nc">&nbsp;                        write(connection, BLANK);</b>
<b class="nc">&nbsp;                        for (String anArgument : argument) {</b>
<b class="nc">&nbsp;                            if (anArgument != null) {</b>
<b class="nc">&nbsp;                                write(connection, anArgument.getBytes(&quot;UTF-8&quot;));</b>
&nbsp;                            }
<b class="nc">&nbsp;                            write(connection, BLANK);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new Response(connection);</b>
<b class="nc">&nbsp;                    } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                        close(connection);</b>
<b class="nc">&nbsp;                        if (throwable instanceof RuntimeException) {</b>
<b class="nc">&nbsp;                            throw (RuntimeException) throwable;</b>
<b class="nc">&nbsp;                        } else if (throwable instanceof IOException) {</b>
<b class="nc">&nbsp;                            throw (IOException) throwable;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(throwable);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A response of a persistent byte channel.
&nbsp;                 */
<b class="nc">&nbsp;                private class Response implements Connection.Response {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The connection representing this response.
&nbsp;                     */
&nbsp;                    private final T connection;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new response for a persistent byte channel.
&nbsp;                     *
&nbsp;                     * @param connection The connection representing this response.
&nbsp;                     */
<b class="nc">&nbsp;                    private Response(T connection) {</b>
<b class="nc">&nbsp;                        this.connection = connection;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int read(byte[] buffer) throws IOException {
<b class="nc">&nbsp;                        return OnPersistentByteChannel.this.read(connection, buffer);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() throws IOException {
<b class="nc">&nbsp;                        OnPersistentByteChannel.this.close(connection);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new connection to the target VM.
&nbsp;                 *
&nbsp;                 * @return Returns a new connection to the target VM.
&nbsp;                 * @throws IOException If an I/O exception occurs.
&nbsp;                 */
&nbsp;                protected abstract T connect() throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Closes the connection to the target VM.
&nbsp;                 *
&nbsp;                 * @param connection The connection to close.
&nbsp;                 * @throws IOException If an I/O exception occurs.
&nbsp;                 */
&nbsp;                protected abstract void close(T connection) throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Writes to the target VM.
&nbsp;                 *
&nbsp;                 * @param connection The connection to write to.
&nbsp;                 * @param buffer     The buffer to write to.
&nbsp;                 * @throws IOException If an I/O exception occurs during writing.
&nbsp;                 */
&nbsp;                protected abstract void write(T connection, byte[] buffer) throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Reads from the target VM.
&nbsp;                 *
&nbsp;                 * @param connection The connection to read from.
&nbsp;                 * @param buffer     The buffer to store the result in.
&nbsp;                 * @return The number of byte that were read.
&nbsp;                 * @throws IOException If an I/O exception occurs.
&nbsp;                 */
&nbsp;                protected abstract int read(T connection, byte[] buffer) throws IOException;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements a connection for a Posix socket in JNA.
&nbsp;             */
&nbsp;            class ForJnaPosixSocket extends OnPersistentByteChannel&lt;Integer&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The JNA library to use.
&nbsp;                 */
&nbsp;                private final PosixLibrary library;
&nbsp;
&nbsp;                /**
&nbsp;                 * The POSIX socket.
&nbsp;                 */
&nbsp;                private final File socket;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a connection for a virtual posix socket implemented in JNA.
&nbsp;                 *
&nbsp;                 * @param library The JNA library to use.
&nbsp;                 * @param socket  The POSIX socket.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForJnaPosixSocket(PosixLibrary library, File socket) {</b>
<b class="nc">&nbsp;                    this.library = library;</b>
<b class="nc">&nbsp;                    this.socket = socket;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Integer connect() {
<b class="nc">&nbsp;                    int handle = library.socket(1, 1, 0);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        PosixLibrary.SocketAddress address = new PosixLibrary.SocketAddress();</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            address.setPath(socket.getAbsolutePath());</b>
<b class="nc">&nbsp;                            library.connect(handle, address, address.size());</b>
<b class="nc">&nbsp;                            return handle;</b>
&nbsp;                        } finally {
<b class="nc">&nbsp;                            address = null;</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                        library.close(handle);</b>
<b class="nc">&nbsp;                        throw exception;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected int read(Integer handle, byte[] buffer) {
<b class="nc">&nbsp;                    int read = library.read(handle, ByteBuffer.wrap(buffer), buffer.length);</b>
<b class="nc">&nbsp;                    return read == 0 ? -1 : read;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void write(Integer handle, byte[] buffer) {
<b class="nc">&nbsp;                    library.write(handle, ByteBuffer.wrap(buffer), buffer.length);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void close(Integer handle) {
<b class="nc">&nbsp;                    library.close(handle);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A JNA library binding for Posix sockets.
&nbsp;                 */
&nbsp;                protected interface PosixLibrary extends Library {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Sends a kill command.
&nbsp;                     *
&nbsp;                     * @param processId The process id to kill.
&nbsp;                     * @param signal    The signal to send.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If an error occurs.
&nbsp;                     */
&nbsp;                    int kill(int processId, int signal) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a POSIX socket connection.
&nbsp;                     *
&nbsp;                     * @param domain   The socket&#39;s domain.
&nbsp;                     * @param type     The socket&#39;s type.
&nbsp;                     * @param protocol The protocol version.
&nbsp;                     * @return A handle to the socket that was created or {@code 0} if no socket could be created.
&nbsp;                     * @throws LastErrorException If an error occurs.
&nbsp;                     */
&nbsp;                    int socket(int domain, int type, int protocol) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Connects a socket connection.
&nbsp;                     *
&nbsp;                     * @param handle  The socket&#39;s handle.
&nbsp;                     * @param address The address of the POSIX socket.
&nbsp;                     * @param length  The length of the socket value.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If an error occurs.
&nbsp;                     */
&nbsp;                    int connect(int handle, SocketAddress address, int length) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Reads from a POSIX socket.
&nbsp;                     *
&nbsp;                     * @param handle The socket&#39;s handle.
&nbsp;                     * @param buffer The buffer to read from.
&nbsp;                     * @param count  The bytes being read.
&nbsp;                     * @return The amount of bytes that could be read.
&nbsp;                     * @throws LastErrorException If an error occurs.
&nbsp;                     */
&nbsp;                    int read(int handle, ByteBuffer buffer, int count) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Writes to a POSIX socket.
&nbsp;                     *
&nbsp;                     * @param handle The socket&#39;s handle.
&nbsp;                     * @param buffer The buffer to write to.
&nbsp;                     * @param count  The bytes being written.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If an error occurs.
&nbsp;                     */
&nbsp;                    int write(int handle, ByteBuffer buffer, int count) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Closes the socket connection.
&nbsp;                     *
&nbsp;                     * @param handle The handle of the connection.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If an error occurs.
&nbsp;                     */
&nbsp;                    int close(int handle) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents an address for a POSIX socket.
&nbsp;                     */
<b class="nc">&nbsp;                    class SocketAddress extends Structure {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The socket family.
&nbsp;                         */
<b class="nc">&nbsp;                        @SuppressWarnings(&quot;unused&quot;)</b>
&nbsp;                        @SuppressFBWarnings(value = &quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, justification = &quot;Field required by native implementation.&quot;)
&nbsp;                        public short family = 1;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The socket path.
&nbsp;                         */
<b class="nc">&nbsp;                        public byte[] path = new byte[100];</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * Sets the socket path.
&nbsp;                         *
&nbsp;                         * @param path The socket path.
&nbsp;                         */
&nbsp;                        protected void setPath(String path) {
&nbsp;                            try {
<b class="nc">&nbsp;                                System.arraycopy(path.getBytes(&quot;UTF-8&quot;), 0, this.path, 0, path.length());</b>
<b class="nc">&nbsp;                                System.arraycopy(new byte[]{0}, 0, this.path, path.length(), 1);</b>
<b class="nc">&nbsp;                            } catch (UnsupportedEncodingException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected List&lt;String&gt; getFieldOrder() {
<b class="nc">&nbsp;                            return Arrays.asList(&quot;family&quot;, &quot;path&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a POSIX socket connection to a JVM using JNA.
&nbsp;                 */
&nbsp;                public static class Factory extends Connection.Factory.ForSocketFile {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The socket library API.
&nbsp;                     */
&nbsp;                    private final PosixLibrary library;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a connection factory for a POSIX socket using JNA.
&nbsp;                     *
&nbsp;                     * @param temporaryDirectory The temporary directory to use.
&nbsp;                     * @param attempts           The maximum amount of attempts for checking the establishment of a socket connection.
&nbsp;                     * @param pause              The pause between two checks for an established socket connection.
&nbsp;                     * @param timeUnit           The time unit of the pause time.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;                    public Factory(String temporaryDirectory, int attempts, long pause, TimeUnit timeUnit) {
<b class="nc">&nbsp;                        super(temporaryDirectory, attempts, pause, timeUnit);</b>
<b class="nc">&nbsp;                        library = Native.loadLibrary(&quot;c&quot;, PosixLibrary.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a connection factory for a POSIX socket using JNA while locating the default temporary directory used on the
&nbsp;                     * current platform.
&nbsp;                     *
&nbsp;                     * @param attempts The maximum amount of attempts for checking the establishment of a socket connection.
&nbsp;                     * @param pause    The pause between two checks for an established socket connection.
&nbsp;                     * @param timeUnit The time unit of the pause time.
&nbsp;                     * @return An appropriate connection factory.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;                    public static Connection.Factory withDefaultTemporaryFolder(int attempts, long pause, TimeUnit timeUnit) {
&nbsp;                        String temporaryDirectory;
<b class="nc">&nbsp;                        if (Platform.isMac()) {</b>
<b class="nc">&nbsp;                            MacLibrary library = Native.loadLibrary(&quot;c&quot;, MacLibrary.class);</b>
<b class="nc">&nbsp;                            Memory memory = new Memory(4096);</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                long length = library.confstr(MacLibrary.CS_DARWIN_USER_TEMP_DIR, memory, memory.size());</b>
<b class="nc">&nbsp;                                if (length == 0 || length &gt; 4096) {</b>
<b class="nc">&nbsp;                                    temporaryDirectory = &quot;/tmp&quot;;</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    temporaryDirectory = memory.getString(0);</b>
&nbsp;                                }
&nbsp;                            } finally {
<b class="nc">&nbsp;                                memory = null;</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            temporaryDirectory = &quot;/tmp&quot;;</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new Factory(temporaryDirectory, attempts, pause, timeUnit);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected void kill(String processId, int signal) {
<b class="nc">&nbsp;                        library.kill(Integer.parseInt(processId), signal);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public Connection doConnect(File socket) {
<b class="nc">&nbsp;                        return new Connection.ForJnaPosixSocket(library, socket);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A library for reading a Mac user&#39;s temporary directory.
&nbsp;                     */
&nbsp;                    public interface MacLibrary extends Library {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The temporary directory.
&nbsp;                         */
&nbsp;                        int CS_DARWIN_USER_TEMP_DIR = 65537;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Reads a configuration dependant variable into a memory segment.
&nbsp;                         *
&nbsp;                         * @param name   The name of the variable.
&nbsp;                         * @param buffer The buffer to read the variable into.
&nbsp;                         * @param length The length of the buffer.
&nbsp;                         * @return The amount of bytes written to the buffer.
&nbsp;                         */
&nbsp;                        long confstr(int name, Pointer buffer, long length);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements a connection for a Windows named pipe in JNA.
&nbsp;             */
&nbsp;            class ForJnaWindowsNamedPipe implements Connection {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates a memory release.
&nbsp;                 */
&nbsp;                private static final int MEM_RELEASE = 0x8000;
&nbsp;
&nbsp;                /**
&nbsp;                 * The library to use for communicating with Windows native functions.
&nbsp;                 */
&nbsp;                private final WindowsLibrary library;
&nbsp;
&nbsp;                /**
&nbsp;                 * The library to use for communicating with Windows attachment extension that is included as a DLL.
&nbsp;                 */
&nbsp;                private final WindowsAttachLibrary attachLibrary;
&nbsp;
&nbsp;                /**
&nbsp;                 * The handle of the target VM&#39;s process.
&nbsp;                 */
&nbsp;                private final WinNT.HANDLE process;
&nbsp;
&nbsp;                /**
&nbsp;                 * A pointer to the code that was injected into the target process.
&nbsp;                 */
&nbsp;                private final WinDef.LPVOID code;
&nbsp;
&nbsp;                /**
&nbsp;                 * A source of random values being used for generating pipe names.
&nbsp;                 */
&nbsp;                private final SecureRandom random;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new connection via a named pipe.
&nbsp;                 *
&nbsp;                 * @param library       The library to use for communicating with Windows native functions.
&nbsp;                 * @param attachLibrary The library to use for communicating with Windows attachment extension that is included as a DLL.
&nbsp;                 * @param process       The handle of the target VM&#39;s process.
&nbsp;                 * @param code          A pointer to the code that was injected into the target process.
&nbsp;                 */
&nbsp;                protected ForJnaWindowsNamedPipe(WindowsLibrary library,
&nbsp;                                                 WindowsAttachLibrary attachLibrary,
&nbsp;                                                 WinNT.HANDLE process,
<b class="fc">&nbsp;                                                 WinDef.LPVOID code) {</b>
<b class="fc">&nbsp;                    this.library = library;</b>
<b class="fc">&nbsp;                    this.attachLibrary = attachLibrary;</b>
<b class="fc">&nbsp;                    this.process = process;</b>
<b class="fc">&nbsp;                    this.code = code;</b>
<b class="fc">&nbsp;                    random = new SecureRandom();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Response execute(String protocol, String... argument) {
<b class="fc">&nbsp;                    if (!&quot;1&quot;.equals(protocol)) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Unknown protocol version: &quot; + protocol);</b>
<b class="fc">&nbsp;                    } else if (argument.length &gt; 4) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Cannot supply more then four arguments to Windows attach mechanism: &quot; + Arrays.asList(argument));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    String name = &quot;\\\\.\\pipe\\javatool&quot; + Math.abs(random.nextInt() + 1);</b>
<b class="fc">&nbsp;                    WinNT.HANDLE pipe = Kernel32.INSTANCE.CreateNamedPipe(name,</b>
&nbsp;                            WinBase.PIPE_ACCESS_INBOUND,
&nbsp;                            WinBase.PIPE_TYPE_BYTE | WinBase.PIPE_READMODE_BYTE | WinBase.PIPE_WAIT,
&nbsp;                            1,
&nbsp;                            4096,
&nbsp;                            8192,
&nbsp;                            WinBase.NMPWAIT_USE_DEFAULT_WAIT,
&nbsp;                            null);
<b class="fc">&nbsp;                    if (pipe == null) {</b>
<b class="nc">&nbsp;                        throw new Win32Exception(Native.getLastError());</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        WinDef.LPVOID data = attachLibrary.allocate_remote_argument(process,</b>
&nbsp;                                name,
<b class="fc">&nbsp;                                argument.length &lt; 1 ? null : argument[0],</b>
<b class="fc">&nbsp;                                argument.length &lt; 2 ? null : argument[1],</b>
<b class="fc">&nbsp;                                argument.length &lt; 3 ? null : argument[2],</b>
<b class="fc">&nbsp;                                argument.length &lt; 4 ? null : argument[3]);</b>
<b class="fc">&nbsp;                        if (data == null) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Native.getLastError());</b>
&nbsp;                        }
&nbsp;                        try {
<b class="fc">&nbsp;                            WinNT.HANDLE thread = library.CreateRemoteThread(process, null, 0, code.getPointer(), data.getPointer(), null, null);</b>
<b class="fc">&nbsp;                            if (thread == null) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Native.getLastError());</b>
&nbsp;                            }
&nbsp;                            try {
<b class="fc">&nbsp;                                int result = Kernel32.INSTANCE.WaitForSingleObject(thread, WinBase.INFINITE);</b>
<b class="fc">&nbsp;                                if (result != 0) {</b>
<b class="nc">&nbsp;                                    throw new Win32Exception(result);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                IntByReference exitCode = new IntByReference();</b>
<b class="fc">&nbsp;                                if (!library.GetExitCodeThread(thread, exitCode)) {</b>
<b class="nc">&nbsp;                                    throw new Win32Exception(Native.getLastError());</b>
<b class="fc">&nbsp;                                } else if (exitCode.getValue() != 0) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Target VM could not dispatch command successfully: &quot; + exitCode.getValue());</b>
&nbsp;                                }
<b class="fc">&nbsp;                                if (!Kernel32.INSTANCE.ConnectNamedPipe(pipe, null)) {</b>
<b class="fc">&nbsp;                                    int code = Native.getLastError();</b>
<b class="fc">&nbsp;                                    if (code != WinError.ERROR_PIPE_CONNECTED) {</b>
<b class="nc">&nbsp;                                        throw new Win32Exception(code);</b>
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;                                return new NamedPipeResponse(pipe);</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                if (!Kernel32.INSTANCE.CloseHandle(thread)) {</b>
<b class="nc">&nbsp;                                    throw new Win32Exception(Native.getLastError());</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            if (!library.VirtualFreeEx(process, data.getPointer(), 0, MEM_RELEASE)) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Native.getLastError());</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                        if (!Kernel32.INSTANCE.CloseHandle(pipe)) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Native.getLastError());</b>
<b class="nc">&nbsp;                        } else if (throwable instanceof RuntimeException) {</b>
<b class="nc">&nbsp;                            throw (RuntimeException) throwable;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(throwable);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    try {
<b class="fc">&nbsp;                        if (!library.VirtualFreeEx(process, code.getPointer(), 0, MEM_RELEASE)) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Native.getLastError());</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="fc">&nbsp;                        if (!Kernel32.INSTANCE.CloseHandle(process)) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Native.getLastError());</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A library for interacting with Windows.
&nbsp;                 */
&nbsp;                protected interface WindowsLibrary extends StdCallLibrary {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Changes the state of memory in a given process.
&nbsp;                     *
&nbsp;                     * @param process        The process in which to change the memory.
&nbsp;                     * @param address        The address of the memory to allocate.
&nbsp;                     * @param size           The size of the allocated region.
&nbsp;                     * @param allocationType The allocation type.
&nbsp;                     * @param protect        The memory protection.
&nbsp;                     * @return A pointer to the allocated memory.
&nbsp;                     */
&nbsp;                    @SuppressWarnings({&quot;unused&quot;, &quot;checkstyle:methodname&quot;})
&nbsp;                    Pointer VirtualAllocEx(WinNT.HANDLE process, Pointer address, int size, int allocationType, int protect);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Frees memory in the given process.
&nbsp;                     *
&nbsp;                     * @param process  The process in which to change the memory.
&nbsp;                     * @param address  The address of the memory to free.
&nbsp;                     * @param size     The size of the freed region.
&nbsp;                     * @param freeType The freeing type.
&nbsp;                     * @return {@code true} if the operation succeeded.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    boolean VirtualFreeEx(WinNT.HANDLE process, Pointer address, int size, int freeType);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An alternative implementation of
&nbsp;                     * {@link Kernel32#CreateRemoteThread(WinNT.HANDLE, WinBase.SECURITY_ATTRIBUTES, int, WinBase.FOREIGN_THREAD_START_ROUTINE, Pointer, WinDef.DWORD, Pointer)}
&nbsp;                     * that uses a pointer as the {@code code} argument rather then a structure to avoid accessing foreign memory.
&nbsp;                     *
&nbsp;                     * @param process            A handle of the target process.
&nbsp;                     * @param securityAttributes The security attributes to use or {@code null} if no attributes are provided.
&nbsp;                     * @param stackSize          The stack size or {@code 0} for using the system default.
&nbsp;                     * @param code               A pointer to the code to execute.
&nbsp;                     * @param argument           A pointer to the argument to provide to the code being executed.
&nbsp;                     * @param creationFlags      The creation flags or {@code null} if no flags are set.
&nbsp;                     * @param threadId           A pointer to the thread id or {@code null} if no thread reference is set.
&nbsp;                     * @return A handle to the created remote thread or {@code null} if the creation failed.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinNT.HANDLE CreateRemoteThread(WinNT.HANDLE process,
&nbsp;                                                    @MaybeNull WinBase.SECURITY_ATTRIBUTES securityAttributes,
&nbsp;                                                    int stackSize,
&nbsp;                                                    Pointer code,
&nbsp;                                                    Pointer argument,
&nbsp;                                                    @MaybeNull WinDef.DWORD creationFlags,
&nbsp;                                                    @MaybeNull Pointer threadId);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Receives the exit code of a given thread.
&nbsp;                     *
&nbsp;                     * @param thread   A handle to the targeted thread.
&nbsp;                     * @param exitCode A reference to the exit code value.
&nbsp;                     * @return {@code true} if the exit code retrieval succeeded.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    boolean GetExitCodeThread(WinNT.HANDLE thread, IntByReference exitCode);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A library for interacting with Windows.
&nbsp;                 */
&nbsp;                protected interface WindowsAttachLibrary extends StdCallLibrary {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Allocates the code to invoke on the remote VM.
&nbsp;                     *
&nbsp;                     * @param process A handle to the target process.
&nbsp;                     * @return A pointer to the allocated code or {@code null} if the code could not be allocated.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinDef.LPVOID allocate_remote_code(WinNT.HANDLE process);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Allocates the remote argument to supply to the remote code upon execution.
&nbsp;                     *
&nbsp;                     * @param process   A handle to the target process.
&nbsp;                     * @param pipe      The name of the pipe used for supplying an answer.
&nbsp;                     * @param argument0 The first argument or {@code null} if no such argument is provided.
&nbsp;                     * @param argument1 The second argument or {@code null} if no such argument is provided.
&nbsp;                     * @param argument2 The third argument or {@code null} if no such argument is provided.
&nbsp;                     * @param argument3 The forth  argument or {@code null} if no such argument is provided.
&nbsp;                     * @return A pointer to the allocated argument or {@code null} if the argument could not be allocated.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinDef.LPVOID allocate_remote_argument(WinNT.HANDLE process,
&nbsp;                                                           String pipe,
&nbsp;                                                           @MaybeNull String argument0,
&nbsp;                                                           @MaybeNull String argument1,
&nbsp;                                                           @MaybeNull String argument2,
&nbsp;                                                           @MaybeNull String argument3);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A response that is sent via a named pipe.
&nbsp;                 */
&nbsp;                protected static class NamedPipeResponse implements Response {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handle of the named pipe.
&nbsp;                     */
&nbsp;                    private final WinNT.HANDLE pipe;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new response via a named pipe.
&nbsp;                     *
&nbsp;                     * @param pipe The handle of the named pipe.
&nbsp;                     */
<b class="fc">&nbsp;                    protected NamedPipeResponse(WinNT.HANDLE pipe) {</b>
<b class="fc">&nbsp;                        this.pipe = pipe;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int read(byte[] buffer) {
<b class="fc">&nbsp;                        IntByReference read = new IntByReference();</b>
<b class="fc">&nbsp;                        if (!Kernel32.INSTANCE.ReadFile(pipe, buffer, buffer.length, read, null)) {</b>
<b class="fc">&nbsp;                            int code = Native.getLastError();</b>
<b class="fc">&nbsp;                            if (code == WinError.ERROR_BROKEN_PIPE) {</b>
<b class="fc">&nbsp;                                return -1;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                throw new Win32Exception(code);</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        return read.getValue();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() {
&nbsp;                        try {
<b class="fc">&nbsp;                            if (!Kernel32.INSTANCE.DisconnectNamedPipe(pipe)) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Native.getLastError());</b>
&nbsp;                            }
&nbsp;                        } finally {
<b class="fc">&nbsp;                            if (!Kernel32.INSTANCE.CloseHandle(pipe)) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Native.getLastError());</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for establishing a connection to a JVM using a named pipe in JNA.
&nbsp;                 */
&nbsp;                public static class Factory implements Connection.Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the native code library that is included in this artifact to support Windows attachment.
&nbsp;                     * This property can be set by other libraries that shade Byte Buddy agent and relocates the library.
&nbsp;                     */
&nbsp;                    public static final String LIBRARY_NAME = &quot;net.bytebuddy.library.name&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The library to use for communicating with Windows native functions.
&nbsp;                     */
&nbsp;                    private final WindowsLibrary library;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The library to use for communicating with Windows attachment extension that is included as a DLL.
&nbsp;                     */
&nbsp;                    private final WindowsAttachLibrary attachLibrary;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new connection factory for Windows using JNA.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;deprecation&quot;)
<b class="fc">&nbsp;                    public Factory() {</b>
<b class="fc">&nbsp;                        library = Native.loadLibrary(&quot;kernel32&quot;, WindowsLibrary.class, W32APIOptions.DEFAULT_OPTIONS);</b>
<b class="fc">&nbsp;                        attachLibrary = Native.loadLibrary(System.getProperty(LIBRARY_NAME, &quot;attach_hotspot_windows&quot;), WindowsAttachLibrary.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Connection connect(String processId) {
<b class="fc">&nbsp;                        WinNT.HANDLE process = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_ALL_ACCESS, false, Integer.parseInt(processId));</b>
<b class="fc">&nbsp;                        if (process == null) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Native.getLastError());</b>
&nbsp;                        }
&nbsp;                        try {
<b class="fc">&nbsp;                            WinDef.LPVOID code = attachLibrary.allocate_remote_code(process);</b>
<b class="fc">&nbsp;                            if (code == null) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Native.getLastError());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return new ForJnaWindowsNamedPipe(library, attachLibrary, process, code);</b>
<b class="nc">&nbsp;                        } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                            if (!Kernel32.INSTANCE.CloseHandle(process)) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Native.getLastError());</b>
<b class="nc">&nbsp;                            } else if (throwable instanceof RuntimeException) {</b>
<b class="nc">&nbsp;                                throw (RuntimeException) throwable;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                throw new IllegalStateException(throwable);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A connection to a VM using a Solaris door.
&nbsp;             */
&nbsp;            class ForJnaSolarisDoor implements Connection {
&nbsp;
&nbsp;                /**
&nbsp;                 * The library to use for interacting with Solaris.
&nbsp;                 */
&nbsp;                private final SolarisLibrary library;
&nbsp;
&nbsp;                /**
&nbsp;                 * The socket used for communication.
&nbsp;                 */
&nbsp;                private final File socket;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new connection using a Solaris door.
&nbsp;                 *
&nbsp;                 * @param library The library to use for interacting with Solaris.
&nbsp;                 * @param socket  The socket used for communication.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForJnaSolarisDoor(SolarisLibrary library, File socket) {</b>
<b class="nc">&nbsp;                    this.library = library;</b>
<b class="nc">&nbsp;                    this.socket = socket;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = {&quot;UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD&quot;, &quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;}, justification = &quot;This pattern is required for use of JNA.&quot;)
&nbsp;                public Connection.Response execute(String protocol, String... argument) throws IOException {
<b class="nc">&nbsp;                    int handle = library.open(socket.getAbsolutePath(), 2);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        SolarisLibrary.DoorArgument door = new SolarisLibrary.DoorArgument();</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
<b class="nc">&nbsp;                            outputStream.write(protocol.getBytes(&quot;UTF-8&quot;));</b>
<b class="nc">&nbsp;                            outputStream.write(0);</b>
<b class="nc">&nbsp;                            for (String anArgument : argument) {</b>
<b class="nc">&nbsp;                                if (anArgument != null) {</b>
<b class="nc">&nbsp;                                    outputStream.write(anArgument.getBytes(&quot;UTF-8&quot;));</b>
&nbsp;                                }
<b class="nc">&nbsp;                                outputStream.write(0);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            door.dataSize = outputStream.size();</b>
<b class="nc">&nbsp;                            Memory dataPointer = new Memory(outputStream.size());</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                dataPointer.write(0, outputStream.toByteArray(), 0, outputStream.size());</b>
<b class="nc">&nbsp;                                door.dataPointer = dataPointer;</b>
<b class="nc">&nbsp;                                Memory result = new Memory(128);</b>
&nbsp;                                try {
<b class="nc">&nbsp;                                    door.resultPointer = result;</b>
<b class="nc">&nbsp;                                    door.resultSize = (int) result.size();</b>
<b class="nc">&nbsp;                                    if (library.door_call(handle, door) != 0) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Door call to target VM failed&quot;);</b>
<b class="nc">&nbsp;                                    } else if (door.resultSize &lt; 4 || door.resultPointer.getInt(0) != 0) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Target VM could not execute door call&quot;);</b>
<b class="nc">&nbsp;                                    } else if (door.descriptorCount != 1 || door.descriptorPointer == null) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Did not receive communication descriptor from target VM&quot;);</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        return new Response(library, door.descriptorPointer.getInt(4));</b>
&nbsp;                                    }
&nbsp;                                } finally {
<b class="nc">&nbsp;                                    result = null;</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            } finally {
<b class="nc">&nbsp;                                dataPointer = null;</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } finally {
<b class="nc">&nbsp;                            door = null;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        library.close(handle);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A library for interacting with Solaris.
&nbsp;                 */
&nbsp;                protected interface SolarisLibrary extends Library {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Sends a kill signal to the target VM.
&nbsp;                     *
&nbsp;                     * @param processId The target process&#39;s id.
&nbsp;                     * @param signal    The signal to send.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If an error occurred while sending the signal.
&nbsp;                     */
&nbsp;                    int kill(int processId, int signal) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Opens a file.
&nbsp;                     *
&nbsp;                     * @param file  The file name.
&nbsp;                     * @param flags the flags for opening.
&nbsp;                     * @return The file descriptor.
&nbsp;                     * @throws LastErrorException If the file could not be opened.
&nbsp;                     */
&nbsp;                    int open(String file, int flags) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Reads from a handle.
&nbsp;                     *
&nbsp;                     * @param handle The handle representing the source being read.
&nbsp;                     * @param buffer The buffer to read to.
&nbsp;                     * @param length The buffer length.
&nbsp;                     * @return The amount of bytes being read.
&nbsp;                     * @throws LastErrorException If a read operation failed.
&nbsp;                     */
&nbsp;                    int read(int handle, ByteBuffer buffer, int length) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Releases a descriptor.
&nbsp;                     *
&nbsp;                     * @param descriptor The descriptor to release.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If the descriptor could not be closed.
&nbsp;                     */
&nbsp;                    int close(int descriptor) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Executes a door call.
&nbsp;                     *
&nbsp;                     * @param descriptor The door&#39;s descriptor.
&nbsp;                     * @param argument   A pointer to the argument.
&nbsp;                     * @return The door&#39;s handle.
&nbsp;                     * @throws LastErrorException If the door call failed.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    int door_call(int descriptor, DoorArgument argument) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A structure representing the argument to a Solaris door operation.
&nbsp;                     */
<b class="nc">&nbsp;                    class DoorArgument extends Structure {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * A pointer to the operation argument.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Pointer dataPointer;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The size of the argument being pointed to.
&nbsp;                         */
&nbsp;                        public int dataSize;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A pointer to the operation descriptor.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Pointer descriptorPointer;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The size of the operation argument.
&nbsp;                         */
&nbsp;                        public int descriptorCount;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A pointer to the operation result.
&nbsp;                         */
&nbsp;                        @UnknownNull
&nbsp;                        public Pointer resultPointer;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The size of the operation argument.
&nbsp;                         */
&nbsp;                        public int resultSize;
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected List&lt;String&gt; getFieldOrder() {
<b class="nc">&nbsp;                            return Arrays.asList(&quot;dataPointer&quot;, &quot;dataSize&quot;, &quot;descriptorPointer&quot;, &quot;descriptorCount&quot;, &quot;resultPointer&quot;, &quot;resultSize&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A response from a VM using a Solaris door.
&nbsp;                 */
&nbsp;                protected static class Response implements Connection.Response {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The Solaris library to use.
&nbsp;                     */
&nbsp;                    private final SolarisLibrary library;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The door handle.
&nbsp;                     */
&nbsp;                    private final int handle;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a response from a VM using a Solaris door.
&nbsp;                     *
&nbsp;                     * @param library The Solaris library to use.
&nbsp;                     * @param handle  The door handle.
&nbsp;                     */
<b class="nc">&nbsp;                    protected Response(SolarisLibrary library, int handle) {</b>
<b class="nc">&nbsp;                        this.library = library;</b>
<b class="nc">&nbsp;                        this.handle = handle;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int read(byte[] buffer) {
<b class="nc">&nbsp;                        int read = library.read(handle, ByteBuffer.wrap(buffer), buffer.length);</b>
<b class="nc">&nbsp;                        return read == 0 ? -1 : read;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() {
<b class="nc">&nbsp;                        library.close(handle);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for establishing a connection to a JVM using a Solaris door in JNA.
&nbsp;                 */
&nbsp;                public static class Factory extends Connection.Factory.ForSocketFile {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The library to use for interacting with Solaris.
&nbsp;                     */
&nbsp;                    private final SolarisLibrary library;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new connection factory for a Solaris VM.
&nbsp;                     *
&nbsp;                     * @param attempts The maximum amount of attempts for checking the establishment of a socket connection.
&nbsp;                     * @param pause    The pause between two checks for an established socket connection.
&nbsp;                     * @param timeUnit The time unit of the pause time.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;deprecation&quot;)
&nbsp;                    public Factory(int attempts, long pause, TimeUnit timeUnit) {
<b class="nc">&nbsp;                        super(&quot;/tmp&quot;, attempts, pause, timeUnit);</b>
<b class="nc">&nbsp;                        library = Native.loadLibrary(&quot;c&quot;, SolarisLibrary.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    protected void kill(String processId, int signal) {
<b class="nc">&nbsp;                        library.kill(Integer.parseInt(processId), signal);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    protected Connection doConnect(File socket) {
<b class="nc">&nbsp;                        return new ForJnaSolarisDoor(library, socket);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A virtual machine attachment implementation for OpenJ9 or any compatible JVM.
&nbsp;     */
&nbsp;    class ForOpenJ9 extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The temporary folder for attachment files for OpenJ9 VMs.
&nbsp;         */
&nbsp;        private static final String IBM_TEMPORARY_FOLDER = &quot;com.ibm.tools.attach.directory&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A secure random for generating randomized ids.
&nbsp;         */
<b class="fc">&nbsp;        private static final SecureRandom SECURE_RANDOM = new SecureRandom();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The socket on which this VM and the target VM communicate.
&nbsp;         */
&nbsp;        private final Socket socket;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new virtual machine connection for OpenJ9.
&nbsp;         *
&nbsp;         * @param socket The socket on which this VM and the target VM communicate.
&nbsp;         */
<b class="fc">&nbsp;        protected ForOpenJ9(Socket socket) {</b>
<b class="fc">&nbsp;            this.socket = socket;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attaches to the supplied process id using the default JNA implementation.
&nbsp;         *
&nbsp;         * @param processId The process id.
&nbsp;         * @return A suitable virtual machine implementation.
&nbsp;         * @throws IOException If an IO exception occurs during establishing the connection.
&nbsp;         */
&nbsp;        public static VirtualMachine attach(String processId) throws IOException {
<b class="nc">&nbsp;            return attach(processId, 5000, Platform.isWindows()</b>
<b class="nc">&nbsp;                    ? new Dispatcher.ForJnaWindowsEnvironment()</b>
<b class="nc">&nbsp;                    : new Dispatcher.ForJnaPosixEnvironment(15, 100, TimeUnit.MILLISECONDS));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Attaches to the supplied process id.
&nbsp;         *
&nbsp;         * @param processId  The process id.
&nbsp;         * @param timeout    The timeout for establishing the socket connection.
&nbsp;         * @param dispatcher The connector to use to communicate with the target VM.
&nbsp;         * @return A suitable virtual machine implementation.
&nbsp;         * @throws IOException If an IO exception occurs during establishing the connection.
&nbsp;         */
&nbsp;        public static VirtualMachine attach(String processId, int timeout, Dispatcher dispatcher) throws IOException {
<b class="fc">&nbsp;            File directory = new File(System.getProperty(IBM_TEMPORARY_FOLDER, dispatcher.getTemporaryFolder(processId)), &quot;.com_ibm_tools_attach&quot;);</b>
<b class="fc">&nbsp;            RandomAccessFile attachLock = new RandomAccessFile(new File(directory, &quot;_attachlock&quot;), &quot;rw&quot;);</b>
&nbsp;            try {
<b class="fc">&nbsp;                FileLock attachLockLock = attachLock.getChannel().lock();</b>
&nbsp;                try {
&nbsp;                    List&lt;Properties&gt; virtualMachines;
<b class="fc">&nbsp;                    RandomAccessFile master = new RandomAccessFile(new File(directory, &quot;_master&quot;), &quot;rw&quot;);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        FileLock masterLock = master.getChannel().lock();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            File[] vmFolder = directory.listFiles();</b>
<b class="fc">&nbsp;                            if (vmFolder == null) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;No descriptor files found in &quot; + directory);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            long userId = dispatcher.userId();</b>
<b class="fc">&nbsp;                            virtualMachines = new ArrayList&lt;Properties&gt;();</b>
<b class="fc">&nbsp;                            for (File aVmFolder : vmFolder) {</b>
<b class="fc">&nbsp;                                if (aVmFolder.isDirectory() &amp;&amp; dispatcher.getOwnerIdOf(aVmFolder) == userId) {</b>
<b class="fc">&nbsp;                                    File attachInfo = new File(aVmFolder, &quot;attachInfo&quot;);</b>
<b class="fc">&nbsp;                                    if (attachInfo.isFile()) {</b>
<b class="fc">&nbsp;                                        Properties virtualMachine = new Properties();</b>
<b class="fc">&nbsp;                                        FileInputStream inputStream = new FileInputStream(attachInfo);</b>
&nbsp;                                        try {
<b class="fc">&nbsp;                                            virtualMachine.load(inputStream);</b>
&nbsp;                                        } finally {
<b class="fc">&nbsp;                                            inputStream.close();</b>
<b class="fc">&nbsp;                                        }</b>
<b class="fc">&nbsp;                                        int targetProcessId = Integer.parseInt(virtualMachine.getProperty(&quot;processId&quot;));</b>
&nbsp;                                        long targetUserId;
&nbsp;                                        try {
<b class="fc">&nbsp;                                            targetUserId = Long.parseLong(virtualMachine.getProperty(&quot;userUid&quot;));</b>
<b class="nc">&nbsp;                                        } catch (NumberFormatException ignored) {</b>
<b class="nc">&nbsp;                                            targetUserId = 0L;</b>
<b class="fc">&nbsp;                                        }</b>
<b class="fc">&nbsp;                                        if (userId != 0L &amp;&amp; targetUserId == 0L) {</b>
<b class="nc">&nbsp;                                            targetUserId = dispatcher.getOwnerIdOf(attachInfo);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        if (targetProcessId == 0L || dispatcher.isExistingProcess(targetProcessId)) {</b>
<b class="fc">&nbsp;                                            virtualMachines.add(virtualMachine);</b>
<b class="nc">&nbsp;                                        } else if (userId == 0L || targetUserId == userId) {</b>
<b class="nc">&nbsp;                                            File[] vmFile = aVmFolder.listFiles();</b>
<b class="nc">&nbsp;                                            if (vmFile != null) {</b>
<b class="nc">&nbsp;                                                for (File aVmFile : vmFile) {</b>
<b class="nc">&nbsp;                                                    if (!aVmFile.delete()) {</b>
<b class="nc">&nbsp;                                                        aVmFile.deleteOnExit();</b>
&nbsp;                                                    }
&nbsp;                                                }
&nbsp;                                            }
<b class="nc">&nbsp;                                            if (!aVmFolder.delete()) {</b>
<b class="nc">&nbsp;                                                aVmFolder.deleteOnExit();</b>
&nbsp;                                            }
&nbsp;                                        }
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        } finally {
<b class="fc">&nbsp;                            masterLock.release();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        master.close();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    Properties target = null;</b>
<b class="fc">&nbsp;                    for (Properties virtualMachine : virtualMachines) {</b>
<b class="fc">&nbsp;                        if (virtualMachine.getProperty(&quot;processId&quot;).equalsIgnoreCase(processId)) {</b>
<b class="fc">&nbsp;                            target = virtualMachine;</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    if (target == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not locate target process info in &quot; + directory);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    ServerSocket serverSocket = new ServerSocket(0);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        serverSocket.setSoTimeout(timeout);</b>
<b class="fc">&nbsp;                        File receiver = new File(directory, target.getProperty(&quot;vmId&quot;));</b>
&nbsp;                        String key;
<b class="fc">&nbsp;                        synchronized (SECURE_RANDOM) {</b>
<b class="fc">&nbsp;                            key = Long.toHexString(SECURE_RANDOM.nextLong());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        File reply = new File(receiver, &quot;replyInfo&quot;);</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            if (reply.createNewFile()) {</b>
<b class="fc">&nbsp;                                dispatcher.setPermissions(reply, 0600);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            FileOutputStream outputStream = new FileOutputStream(reply);</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                outputStream.write(key.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;                                outputStream.write(&quot;\n&quot;.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;                                outputStream.write(Long.toString(serverSocket.getLocalPort()).getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;                                outputStream.write(&quot;\n&quot;.getBytes(&quot;UTF-8&quot;));</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                outputStream.close();</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            Map&lt;RandomAccessFile, FileLock&gt; locks = new HashMap&lt;RandomAccessFile, FileLock&gt;();</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                String pid = Long.toString(dispatcher.pid());</b>
<b class="fc">&nbsp;                                for (Properties virtualMachine : virtualMachines) {</b>
<b class="fc">&nbsp;                                    if (!virtualMachine.getProperty(&quot;processId&quot;).equalsIgnoreCase(pid)) {</b>
<b class="fc">&nbsp;                                        String attachNotificationSync = virtualMachine.getProperty(&quot;attachNotificationSync&quot;);</b>
<b class="fc">&nbsp;                                        RandomAccessFile syncFile = new RandomAccessFile(attachNotificationSync == null</b>
<b class="fc">&nbsp;                                                ? new File(directory, &quot;attachNotificationSync&quot;)</b>
<b class="nc">&nbsp;                                                : new File(attachNotificationSync), &quot;rw&quot;);</b>
&nbsp;                                        try {
<b class="fc">&nbsp;                                            locks.put(syncFile, syncFile.getChannel().lock());</b>
<b class="nc">&nbsp;                                        } catch (IOException ignored) {</b>
<b class="nc">&nbsp;                                            syncFile.close();</b>
<b class="fc">&nbsp;                                        }</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                int notifications = 0;</b>
<b class="fc">&nbsp;                                File[] item = directory.listFiles();</b>
<b class="fc">&nbsp;                                if (item != null) {</b>
<b class="fc">&nbsp;                                    for (File anItem : item) {</b>
<b class="fc">&nbsp;                                        String name = anItem.getName();</b>
<b class="fc">&nbsp;                                        if (!name.startsWith(&quot;.trash_&quot;)</b>
<b class="fc">&nbsp;                                                &amp;&amp; !name.equalsIgnoreCase(&quot;_attachlock&quot;)</b>
<b class="fc">&nbsp;                                                &amp;&amp; !name.equalsIgnoreCase(&quot;_master&quot;)</b>
<b class="fc">&nbsp;                                                &amp;&amp; !name.equalsIgnoreCase(&quot;_notifier&quot;)) {</b>
<b class="fc">&nbsp;                                            notifications += 1;</b>
&nbsp;                                        }
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;                                boolean global = Boolean.parseBoolean(target.getProperty(&quot;globalSemaphore&quot;));</b>
<b class="fc">&nbsp;                                dispatcher.incrementSemaphore(directory, &quot;_notifier&quot;, global, notifications);</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    Socket socket = serverSocket.accept();</b>
<b class="fc">&nbsp;                                    String answer = new String(read(socket), &quot;UTF-8&quot;);</b>
<b class="fc">&nbsp;                                    if (answer.contains(&#39; &#39; + key + &#39; &#39;)) {</b>
<b class="fc">&nbsp;                                        return new ForOpenJ9(socket);</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        socket.close();</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Unexpected answered to attachment: &quot; + answer);</b>
&nbsp;                                    }
&nbsp;                                } finally {
<b class="fc">&nbsp;                                    dispatcher.decrementSemaphore(directory, &quot;_notifier&quot;, global, notifications);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                for (Map.Entry&lt;RandomAccessFile, FileLock&gt; entry : locks.entrySet()) {</b>
&nbsp;                                    try {
&nbsp;                                        try {
<b class="fc">&nbsp;                                            entry.getValue().release();</b>
&nbsp;                                        } finally {
<b class="fc">&nbsp;                                            entry.getKey().close();</b>
<b class="fc">&nbsp;                                        }</b>
<b class="nc">&nbsp;                                    } catch (Throwable ignored) {</b>
&nbsp;                                        /* do nothing */
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            if (!reply.delete()) {</b>
<b class="nc">&nbsp;                                reply.deleteOnExit();</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        serverSocket.close();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    attachLockLock.release();</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                attachLock.close();</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Properties getSystemProperties() throws IOException {
<b class="fc">&nbsp;            write(socket, &quot;ATTACH_GETSYSTEMPROPERTIES&quot;.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            Properties properties = new Properties();</b>
<b class="fc">&nbsp;            properties.load(new ByteArrayInputStream(read(socket)));</b>
<b class="fc">&nbsp;            return properties;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Properties getAgentProperties() throws IOException {
<b class="fc">&nbsp;            write(socket, &quot;ATTACH_GETAGENTPROPERTIES&quot;.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            Properties properties = new Properties();</b>
<b class="fc">&nbsp;            properties.load(new ByteArrayInputStream(read(socket)));</b>
<b class="fc">&nbsp;            return properties;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgent(String jarFile, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            write(socket, (&quot;ATTACH_LOADAGENT(instrument,&quot; + jarFile + &#39;=&#39; + (argument == null ? &quot;&quot; : argument) + &#39;)&#39;).getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            String answer = new String(read(socket), &quot;UTF-8&quot;);</b>
<b class="fc">&nbsp;            if (answer.startsWith(&quot;ATTACH_ERR&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Target VM failed loading agent: &quot; + answer);</b>
<b class="fc">&nbsp;            } else if (!answer.startsWith(&quot;ATTACH_ACK&quot;) &amp;&amp; !answer.startsWith(&quot;ATTACH_RESULT=&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected response: &quot; + answer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgentPath(String path, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            write(socket, (&quot;ATTACH_LOADAGENTPATH(&quot; + path + (argument == null ? &quot;&quot; : (&#39;,&#39; + argument)) + &#39;)&#39;).getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            String answer = new String(read(socket), &quot;UTF-8&quot;);</b>
<b class="fc">&nbsp;            if (answer.startsWith(&quot;ATTACH_ERR&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Target VM failed loading native agent: &quot; + answer);</b>
<b class="fc">&nbsp;            } else if (!answer.startsWith(&quot;ATTACH_ACK&quot;) &amp;&amp; !answer.startsWith(&quot;ATTACH_RESULT=&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected response: &quot; + answer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void loadAgentLibrary(String library, @MaybeNull String argument) throws IOException {
<b class="fc">&nbsp;            write(socket, (&quot;ATTACH_LOADAGENTLIBRARY(&quot; + library + (argument == null ? &quot;&quot; : (&#39;,&#39; + argument)) + &#39;)&#39;).getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            String answer = new String(read(socket), &quot;UTF-8&quot;);</b>
<b class="fc">&nbsp;            if (answer.startsWith(&quot;ATTACH_ERR&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Target VM failed loading native library: &quot; + answer);</b>
<b class="fc">&nbsp;            } else if (!answer.startsWith(&quot;ATTACH_ACK&quot;) &amp;&amp; !answer.startsWith(&quot;ATTACH_RESULT=&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected response: &quot; + answer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void startManagementAgent(Properties properties) throws IOException {
<b class="fc">&nbsp;            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
<b class="fc">&nbsp;            properties.store(outputStream, null);</b>
<b class="fc">&nbsp;            write(socket, &quot;ATTACH_START_MANAGEMENT_AGENT&quot;.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            write(socket, outputStream.toByteArray());</b>
<b class="fc">&nbsp;            String answer = new String(read(socket), &quot;UTF-8&quot;);</b>
<b class="fc">&nbsp;            if (answer.startsWith(&quot;ATTACH_ERR&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Target VM could not start management agent: &quot; + answer);</b>
<b class="fc">&nbsp;            } else if (!answer.startsWith(&quot;ATTACH_ACK&quot;) &amp;&amp; !answer.startsWith(&quot;ATTACH_RESULT=&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected response: &quot; + answer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String startLocalManagementAgent() throws IOException {
<b class="fc">&nbsp;            write(socket, &quot;ATTACH_START_LOCAL_MANAGEMENT_AGENT&quot;.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;            String answer = new String(read(socket), &quot;UTF-8&quot;);</b>
<b class="fc">&nbsp;            if (answer.startsWith(&quot;ATTACH_ERR&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Target VM could not start management agent: &quot; + answer);</b>
<b class="fc">&nbsp;            } else if (answer.startsWith(&quot;ATTACH_ACK&quot;)) {</b>
<b class="fc">&nbsp;                return answer.substring(&quot;ATTACH_ACK&quot;.length());</b>
<b class="nc">&nbsp;            } else if (answer.startsWith(&quot;ATTACH_RESULT=&quot;)) {</b>
<b class="nc">&nbsp;                return answer.substring(&quot;ATTACH_RESULT=&quot;.length());</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Unexpected response: &quot; + answer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void detach() throws IOException {
&nbsp;            try {
<b class="fc">&nbsp;                write(socket, &quot;ATTACH_DETACH&quot;.getBytes(&quot;UTF-8&quot;));</b>
<b class="fc">&nbsp;                read(socket); // The answer is intentionally ignored.</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                socket.close();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Writes the supplied value to the target socket.
&nbsp;         *
&nbsp;         * @param socket The socket to write to.
&nbsp;         * @param value  The value being written.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        private static void write(Socket socket, byte[] value) throws IOException {
<b class="fc">&nbsp;            socket.getOutputStream().write(value);</b>
<b class="fc">&nbsp;            socket.getOutputStream().write(0);</b>
<b class="fc">&nbsp;            socket.getOutputStream().flush();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Reads a {@code &#39;\0&#39;}-terminated value from the target socket.
&nbsp;         *
&nbsp;         * @param socket The socket to read from.
&nbsp;         * @return The value that was read.
&nbsp;         * @throws IOException If an I/O exception occurs.
&nbsp;         */
&nbsp;        private static byte[] read(Socket socket) throws IOException {
<b class="fc">&nbsp;            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
<b class="fc">&nbsp;            byte[] buffer = new byte[1024];</b>
&nbsp;            int length;
<b class="fc">&nbsp;            while ((length = socket.getInputStream().read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                if (length &gt; 0 &amp;&amp; buffer[length - 1] == 0) {</b>
<b class="fc">&nbsp;                    outputStream.write(buffer, 0, length - 1);</b>
<b class="fc">&nbsp;                    break;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    outputStream.write(buffer, 0, length);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return outputStream.toByteArray();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for native operations being used for communication with an OpenJ9 virtual machine.
&nbsp;         */
&nbsp;        public interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns this machine&#39;s temporary folder.
&nbsp;             *
&nbsp;             * @param processId The target process&#39;s id.
&nbsp;             * @return The temporary folder.
&nbsp;             */
&nbsp;            String getTemporaryFolder(String processId);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the process id of this process.
&nbsp;             *
&nbsp;             * @return The process id of this process.
&nbsp;             */
&nbsp;            int pid();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the user id of this process.
&nbsp;             *
&nbsp;             * @return The user id of this process
&nbsp;             */
&nbsp;            int userId();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the supplied process id is a running process.
&nbsp;             *
&nbsp;             * @param processId The process id to evaluate.
&nbsp;             * @return {@code true} if the supplied process id is currently running.
&nbsp;             */
&nbsp;            boolean isExistingProcess(int processId);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the user id of the owner of the supplied file.
&nbsp;             *
&nbsp;             * @param file The file for which to locate the owner.
&nbsp;             * @return The owner id of the supplied file.
&nbsp;             */
&nbsp;            int getOwnerIdOf(File file);
&nbsp;
&nbsp;            /**
&nbsp;             * Sets permissions for the supplied file.
&nbsp;             *
&nbsp;             * @param file        The file for which to set the permissions.
&nbsp;             * @param permissions The permission bits to set.
&nbsp;             */
&nbsp;            void setPermissions(File file, int permissions);
&nbsp;
&nbsp;            /**
&nbsp;             * Increments a semaphore.
&nbsp;             *
&nbsp;             * @param directory The sempahore&#39;s control directory.
&nbsp;             * @param name      The semaphore&#39;s name.
&nbsp;             * @param global    {@code true} if the semaphore is in the global namespace (only applicable on Windows).
&nbsp;             * @param count     The amount of increments.
&nbsp;             */
&nbsp;            void incrementSemaphore(File directory, String name, boolean global, int count);
&nbsp;
&nbsp;            /**
&nbsp;             * Decrements a semaphore.
&nbsp;             *
&nbsp;             * @param directory The sempahore&#39;s control directory.
&nbsp;             * @param name      The semaphore&#39;s name.
&nbsp;             * @param global    {@code true} if the semaphore is in the global namespace (only applicable on Windows).
&nbsp;             * @param count     The amount of decrements.
&nbsp;             */
&nbsp;            void decrementSemaphore(File directory, String name, boolean global, int count);
&nbsp;
&nbsp;            /**
&nbsp;             * A connector implementation for a POSIX environment using JNA.
&nbsp;             */
&nbsp;            class ForJnaPosixEnvironment implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The JNA library to use.
&nbsp;                 */
&nbsp;                private final PosixLibrary library;
&nbsp;
&nbsp;                /**
&nbsp;                 * The maximum amount of attempts for checking the result of a foreign process.
&nbsp;                 */
&nbsp;                private final int attempts;
&nbsp;
&nbsp;                /**
&nbsp;                 * The pause between two checks for another process to return.
&nbsp;                 */
&nbsp;                private final long pause;
&nbsp;
&nbsp;                /**
&nbsp;                 * The time unit of the pause time.
&nbsp;                 */
&nbsp;                private final TimeUnit timeUnit;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new connector for a POSIX enviornment using JNA.
&nbsp;                 *
&nbsp;                 * @param attempts The maximum amount of attempts for checking the result of a foreign process.
&nbsp;                 * @param pause    The pause between two checks for another process to return.
&nbsp;                 * @param timeUnit The time unit of the pause time.
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;deprecation&quot;)
<b class="nc">&nbsp;                public ForJnaPosixEnvironment(int attempts, long pause, TimeUnit timeUnit) {</b>
<b class="nc">&nbsp;                    this.attempts = attempts;</b>
<b class="nc">&nbsp;                    this.pause = pause;</b>
<b class="nc">&nbsp;                    this.timeUnit = timeUnit;</b>
<b class="nc">&nbsp;                    library = Native.loadLibrary(&quot;c&quot;, PosixLibrary.class);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getTemporaryFolder(String processId) {
<b class="nc">&nbsp;                    if (Platform.isLinux()) {</b>
<b class="nc">&nbsp;                        File file = new File(&quot;/proc/&quot; + processId + &quot;/root/tmp&quot;);</b>
<b class="nc">&nbsp;                        if (file.isDirectory() &amp;&amp; file.canRead()) {</b>
<b class="nc">&nbsp;                            return file.getAbsolutePath();</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    String temporaryFolder = System.getenv(&quot;TMPDIR&quot;);</b>
<b class="nc">&nbsp;                    return temporaryFolder == null ? &quot;/tmp&quot; : temporaryFolder;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int pid() {
<b class="nc">&nbsp;                    return library.getpid();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int userId() {
<b class="nc">&nbsp;                    return library.getuid();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isExistingProcess(int processId) {
<b class="nc">&nbsp;                    return library.kill(processId, PosixLibrary.NULL_SIGNAL) != PosixLibrary.ESRCH;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;OS_OPEN_STREAM&quot;, justification = &quot;The stream life-cycle is bound to its process.&quot;)
&nbsp;                public int getOwnerIdOf(File file) {
&nbsp;                    try {
&nbsp;                        // The binding for &#39;stat&#39; is very platform dependant. To avoid the complexity of binding the correct method,
&nbsp;                        // stat is called as a separate command. This is less efficient but more portable.
<b class="nc">&nbsp;                        Process process = Runtime.getRuntime().exec(new String[]{&quot;stat&quot;,</b>
<b class="nc">&nbsp;                                Platform.isMac() ? &quot;-f&quot; : &quot;-c&quot;,</b>
&nbsp;                                &quot;%u&quot;,
<b class="nc">&nbsp;                                file.getAbsolutePath()});</b>
<b class="nc">&nbsp;                        int attempts = this.attempts;</b>
<b class="nc">&nbsp;                        boolean exited = false;</b>
<b class="nc">&nbsp;                        String line = new BufferedReader(new InputStreamReader(process.getInputStream(), &quot;UTF-8&quot;)).readLine();</b>
&nbsp;                        do {
&nbsp;                            try {
<b class="nc">&nbsp;                                if (process.exitValue() != 0) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Error while executing stat&quot;);</b>
&nbsp;                                }
<b class="nc">&nbsp;                                exited = true;</b>
<b class="nc">&nbsp;                                break;</b>
<b class="nc">&nbsp;                            } catch (IllegalThreadStateException ignored) {</b>
&nbsp;                                try {
<b class="nc">&nbsp;                                    Thread.sleep(timeUnit.toMillis(pause));</b>
<b class="nc">&nbsp;                                } catch (InterruptedException exception) {</b>
<b class="nc">&nbsp;                                    Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } while (--attempts &gt; 0);</b>
<b class="nc">&nbsp;                        if (!exited) {</b>
<b class="nc">&nbsp;                            process.destroy();</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Command for stat did not exit in time&quot;);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return Integer.parseInt(line);</b>
<b class="nc">&nbsp;                    } catch (IOException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Unable to execute stat command&quot;, exception);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void setPermissions(File file, int permissions) {
<b class="nc">&nbsp;                    library.chmod(file.getAbsolutePath(), permissions);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void incrementSemaphore(File directory, String name, boolean global, int count) {
<b class="nc">&nbsp;                    notifySemaphore(directory, name, count, (short) 1, (short) 0, false);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void decrementSemaphore(File directory, String name, boolean global, int count) {
<b class="nc">&nbsp;                    notifySemaphore(directory, name, count, (short) -1, (short) (PosixLibrary.SEM_UNDO | PosixLibrary.IPC_NOWAIT), true);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Notifies a POSIX semaphore.
&nbsp;                 *
&nbsp;                 * @param directory         The semaphore&#39;s directory.
&nbsp;                 * @param name              The semaphore&#39;s name.
&nbsp;                 * @param count             The amount of notifications to send.
&nbsp;                 * @param operation         The operation to apply.
&nbsp;                 * @param flags             The flags to set.
&nbsp;                 * @param acceptUnavailable {@code true} if a {@code EAGAIN} code should be accepted.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = {&quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, &quot;UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD&quot;}, justification = &quot;Modifier is required by JNA.&quot;)
&nbsp;                private void notifySemaphore(File directory, String name, int count, short operation, short flags, boolean acceptUnavailable) {
<b class="nc">&nbsp;                    int semaphore = library.semget(library.ftok(new File(directory, name).getAbsolutePath(), 0xA1), 2, 0666);</b>
<b class="nc">&nbsp;                    PosixLibrary.SemaphoreOperation target = new PosixLibrary.SemaphoreOperation();</b>
<b class="nc">&nbsp;                    target.operation = operation;</b>
<b class="nc">&nbsp;                    target.flags = flags;</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        while (count-- &gt; 0) {</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                library.semop(semaphore, target, 1);</b>
<b class="nc">&nbsp;                            } catch (LastErrorException exception) {</b>
<b class="nc">&nbsp;                                if (acceptUnavailable &amp;&amp; (Native.getLastError() == PosixLibrary.EAGAIN</b>
<b class="nc">&nbsp;                                        || Native.getLastError() == PosixLibrary.EDEADLK)) {</b>
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    throw exception;</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        target = null;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An API for interaction with POSIX systems.
&nbsp;                 */
&nbsp;                protected interface PosixLibrary extends Library {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A null signal.
&nbsp;                     */
&nbsp;                    int NULL_SIGNAL = 0;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates that a process does not exist.
&nbsp;                     */
&nbsp;                    int ESRCH = 3;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates that a request timed out.
&nbsp;                     */
&nbsp;                    int EAGAIN = 11;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates a dead lock on a resource.
&nbsp;                     */
&nbsp;                    int EDEADLK = 35;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates that a semaphore&#39;s operations should be undone at process shutdown.
&nbsp;                     */
&nbsp;                    short SEM_UNDO = 0x1000;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates that one should not wait for the release of a semaphore if it is not currently available.
&nbsp;                     */
&nbsp;                    short IPC_NOWAIT = 04000;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code getpid} command.
&nbsp;                     *
&nbsp;                     * @return The command&#39;s return value.
&nbsp;                     * @throws LastErrorException If an error occurred.
&nbsp;                     */
&nbsp;                    int getpid() throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code getuid} command.
&nbsp;                     *
&nbsp;                     * @return The command&#39;s return value.
&nbsp;                     * @throws LastErrorException If an error occurred.
&nbsp;                     */
&nbsp;                    int getuid() throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code kill} command.
&nbsp;                     *
&nbsp;                     * @param processId The target process id.
&nbsp;                     * @param signal    The signal to send.
&nbsp;                     * @return The command&#39;s return value.
&nbsp;                     * @throws LastErrorException If an error occurred.
&nbsp;                     */
&nbsp;                    int kill(int processId, int signal) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code chmod} command.
&nbsp;                     *
&nbsp;                     * @param path The file path.
&nbsp;                     * @param mode The mode to set.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If an error occurred.
&nbsp;                     */
&nbsp;                    int chmod(String path, int mode) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code ftok} command.
&nbsp;                     *
&nbsp;                     * @param path The file path.
&nbsp;                     * @param id   The id being used for creating the generated key.
&nbsp;                     * @return The generated key.
&nbsp;                     * @throws LastErrorException If an error occurred.
&nbsp;                     */
&nbsp;                    int ftok(String path, int id) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code semget} command.
&nbsp;                     *
&nbsp;                     * @param key   The key of the semaphore.
&nbsp;                     * @param count The initial count of the semaphore.
&nbsp;                     * @param flags The flags to set.
&nbsp;                     * @return The id of the semaphore.
&nbsp;                     * @throws LastErrorException If an error occurred.
&nbsp;                     */
&nbsp;                    int semget(int key, int count, int flags) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Runs the {@code semop} command.
&nbsp;                     *
&nbsp;                     * @param id        The id of the semaphore.
&nbsp;                     * @param operation The initial count of the semaphore.
&nbsp;                     * @param flags     The flags to set.
&nbsp;                     * @return The return code.
&nbsp;                     * @throws LastErrorException If the operation was not successful.
&nbsp;                     */
&nbsp;                    int semop(int id, SemaphoreOperation operation, int flags) throws LastErrorException;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A structure to represent a semaphore operation for {@code semop}.
&nbsp;                     */
<b class="nc">&nbsp;                    class SemaphoreOperation extends Structure {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The semaphore number.
&nbsp;                         */
&nbsp;                        @SuppressWarnings(&quot;unused&quot;)
&nbsp;                        public short number;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The operation to execute.
&nbsp;                         */
&nbsp;                        public short operation;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The flags being set for the operation.
&nbsp;                         */
&nbsp;                        public short flags;
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected List&lt;String&gt; getFieldOrder() {
<b class="nc">&nbsp;                            return Arrays.asList(&quot;number&quot;, &quot;operation&quot;, &quot;flags&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A connector implementation for a Windows environment using JNA.
&nbsp;             */
&nbsp;            class ForJnaWindowsEnvironment implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates a missing user id what is not supported on Windows.
&nbsp;                 */
&nbsp;                private static final int NO_USER_ID = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the creation mutex.
&nbsp;                 */
&nbsp;                private static final String CREATION_MUTEX_NAME = &quot;j9shsemcreationMutex&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * A library to use for interacting with Windows.
&nbsp;                 */
&nbsp;                private final WindowsLibrary library;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new connector for a Windows environment using JNA.
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;deprecation&quot;)
<b class="nc">&nbsp;                public ForJnaWindowsEnvironment() {</b>
<b class="nc">&nbsp;                    library = Native.loadLibrary(&quot;kernel32&quot;, WindowsLibrary.class, W32APIOptions.DEFAULT_OPTIONS);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getTemporaryFolder(String processId) {
<b class="nc">&nbsp;                    WinDef.DWORD length = new WinDef.DWORD(WinDef.MAX_PATH);</b>
<b class="nc">&nbsp;                    char[] path = new char[length.intValue()];</b>
<b class="nc">&nbsp;                    if (Kernel32.INSTANCE.GetTempPath(length, path).intValue() == 0) {</b>
<b class="nc">&nbsp;                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return Native.toString(path);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int pid() {
<b class="nc">&nbsp;                    return Kernel32.INSTANCE.GetCurrentProcessId();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int userId() {
<b class="nc">&nbsp;                    return NO_USER_ID;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isExistingProcess(int processId) {
<b class="nc">&nbsp;                    WinNT.HANDLE handle = Kernel32.INSTANCE.OpenProcess(WinNT.PROCESS_QUERY_INFORMATION, false, processId);</b>
<b class="nc">&nbsp;                    if (handle == null) {</b>
<b class="nc">&nbsp;                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    IntByReference exists = new IntByReference();</b>
<b class="nc">&nbsp;                    if (!Kernel32.INSTANCE.GetExitCodeProcess(handle, exists)) {</b>
<b class="nc">&nbsp;                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return exists.getValue() == WinBase.STILL_ACTIVE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getOwnerIdOf(File file) {
<b class="nc">&nbsp;                    return NO_USER_ID;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void setPermissions(File file, int permissions) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void incrementSemaphore(File directory, String name, boolean global, int count) {
<b class="nc">&nbsp;                    AttachmentHandle handle = openSemaphore(directory, name, global);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        while (count-- &gt; 0) {</b>
<b class="nc">&nbsp;                            if (!library.ReleaseSemaphore(handle.getHandle(), 1, null)) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } finally {
<b class="nc">&nbsp;                        handle.close();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void decrementSemaphore(File directory, String name, boolean global, int count) {
<b class="nc">&nbsp;                    AttachmentHandle handle = openSemaphore(directory, name, global);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        while (count-- &gt; 0) {</b>
<b class="nc">&nbsp;                            int result = Kernel32.INSTANCE.WaitForSingleObject(handle.getHandle(), 0);</b>
<b class="nc">&nbsp;                            switch (result) {</b>
&nbsp;                                case WinBase.WAIT_ABANDONED:
&nbsp;                                case WinBase.WAIT_OBJECT_0:
<b class="nc">&nbsp;                                    break;</b>
&nbsp;                                case WinError.WAIT_TIMEOUT:
&nbsp;                                    return;
&nbsp;                                default:
<b class="nc">&nbsp;                                    throw new Win32Exception(result);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        handle.close();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Opens a semaphore for signaling another process that an attachment is performed.
&nbsp;                 *
&nbsp;                 * @param directory The control directory.
&nbsp;                 * @param name      The semaphore&#39;s name.
&nbsp;                 * @param global    {@code true} if the semaphore is in the global namespace.
&nbsp;                 * @return A handle for signaling an attachment to the target process.
&nbsp;                 */
&nbsp;                private AttachmentHandle openSemaphore(File directory, String name, boolean global) {
<b class="nc">&nbsp;                    WinNT.SECURITY_DESCRIPTOR securityDescriptor = new WinNT.SECURITY_DESCRIPTOR(64 * 1024);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        if (!Advapi32.INSTANCE.InitializeSecurityDescriptor(securityDescriptor, WinNT.SECURITY_DESCRIPTOR_REVISION)) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        if (!Advapi32.INSTANCE.SetSecurityDescriptorDacl(securityDescriptor, true, null, true)) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        WindowsLibrary.SecurityAttributes securityAttributes = new WindowsLibrary.SecurityAttributes();</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            securityAttributes.length = new WinDef.DWORD(securityAttributes.size());</b>
<b class="nc">&nbsp;                            securityAttributes.securityDescriptor = securityDescriptor.getPointer();</b>
<b class="nc">&nbsp;                            WinNT.HANDLE mutex = library.CreateMutex(securityAttributes, false, CREATION_MUTEX_NAME);</b>
<b class="nc">&nbsp;                            if (mutex == null) {</b>
<b class="nc">&nbsp;                                int lastError = Kernel32.INSTANCE.GetLastError();</b>
<b class="nc">&nbsp;                                if (lastError == WinError.ERROR_ALREADY_EXISTS) {</b>
<b class="nc">&nbsp;                                    mutex = library.OpenMutex(WinNT.STANDARD_RIGHTS_REQUIRED | WinNT.SYNCHRONIZE | 0x0001, false, CREATION_MUTEX_NAME);</b>
<b class="nc">&nbsp;                                    if (mutex == null) {</b>
<b class="nc">&nbsp;                                        throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                                    }
&nbsp;                                } else {
<b class="nc">&nbsp;                                    throw new Win32Exception(lastError);</b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            int result = Kernel32.INSTANCE.WaitForSingleObject(mutex, 2000);</b>
<b class="nc">&nbsp;                            switch (result) {</b>
&nbsp;                                case WinBase.WAIT_FAILED:
&nbsp;                                case WinError.WAIT_TIMEOUT:
<b class="nc">&nbsp;                                    throw new Win32Exception(result);</b>
&nbsp;                                default:
&nbsp;                                    try {
<b class="nc">&nbsp;                                        String target = (global ? &quot;Global\\&quot; : &quot;&quot;)</b>
<b class="nc">&nbsp;                                                + (directory.getAbsolutePath() + &#39;_&#39; + name).replaceAll(&quot;[^a-zA-Z0-9_]&quot;, &quot;&quot;)</b>
&nbsp;                                                + &quot;_semaphore&quot;;
<b class="nc">&nbsp;                                        WinNT.HANDLE parent = library.OpenSemaphoreW(WindowsLibrary.SEMAPHORE_ALL_ACCESS, false, target);</b>
<b class="nc">&nbsp;                                        if (parent == null) {</b>
<b class="nc">&nbsp;                                            parent = library.CreateSemaphoreW(null, 0, Integer.MAX_VALUE, target);</b>
<b class="nc">&nbsp;                                            if (parent == null) {</b>
<b class="nc">&nbsp;                                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                                            }
<b class="nc">&nbsp;                                            WinNT.HANDLE child = library.CreateSemaphoreW(null, 0, Integer.MAX_VALUE, target + &quot;_set0&quot;);</b>
<b class="nc">&nbsp;                                            if (child == null) {</b>
<b class="nc">&nbsp;                                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                                            }
<b class="nc">&nbsp;                                            return new AttachmentHandle(parent, child);</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            WinNT.HANDLE child = library.OpenSemaphoreW(WindowsLibrary.SEMAPHORE_ALL_ACCESS, false, target + &quot;_set0&quot;);</b>
<b class="nc">&nbsp;                                            if (child == null) {</b>
<b class="nc">&nbsp;                                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                                            }
<b class="nc">&nbsp;                                            return new AttachmentHandle(parent, child);</b>
&nbsp;                                        }
&nbsp;                                    } finally {
<b class="nc">&nbsp;                                        if (!library.ReleaseMutex(mutex)) {</b>
<b class="nc">&nbsp;                                            throw new Win32Exception(Native.getLastError());</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                    }</b>
&nbsp;                            }
&nbsp;                        } finally {
<b class="nc">&nbsp;                            securityAttributes = null;</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        securityDescriptor = null;</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A library for interacting with Windows.
&nbsp;                 */
&nbsp;                protected interface WindowsLibrary extends StdCallLibrary {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Indicates that a semaphore requires all access rights.
&nbsp;                     */
&nbsp;                    int SEMAPHORE_ALL_ACCESS = 0x1F0003;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Opens an existing semaphore.
&nbsp;                     *
&nbsp;                     * @param access        The access rights.
&nbsp;                     * @param inheritHandle {@code true} if the handle is inherited.
&nbsp;                     * @param name          The semaphore&#39;s name.
&nbsp;                     * @return The handle or {@code null} if the handle could not be created.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinNT.HANDLE OpenSemaphoreW(int access, boolean inheritHandle, String name);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new semaphore.
&nbsp;                     *
&nbsp;                     * @param securityAttributes The security attributes for the created semaphore.
&nbsp;                     * @param count              The initial count for the semaphore.
&nbsp;                     * @param maximumCount       The maximum count for the semaphore.
&nbsp;                     * @param name               The semaphore&#39;s name.
&nbsp;                     * @return The handle or {@code null} if the handle could not be created.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinNT.HANDLE CreateSemaphoreW(@MaybeNull WinBase.SECURITY_ATTRIBUTES securityAttributes,
&nbsp;                                                  long count,
&nbsp;                                                  long maximumCount,
&nbsp;                                                  String name);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Releases the semaphore.
&nbsp;                     *
&nbsp;                     * @param handle        The semaphore&#39;s handle.
&nbsp;                     * @param count         The amount with which to increase the semaphore.
&nbsp;                     * @param previousCount The previous count of the semaphore or {@code null}.
&nbsp;                     * @return {@code true} if the semaphore was successfully released.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    boolean ReleaseSemaphore(WinNT.HANDLE handle, long count, @MaybeNull Long previousCount);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Create or opens a mutex.
&nbsp;                     *
&nbsp;                     * @param attributes The mutex&#39;s security attributes.
&nbsp;                     * @param owner      {@code true} if the caller is supposed to be the initial owner.
&nbsp;                     * @param name       The mutex name.
&nbsp;                     * @return The handle to the mutex or {@code null} if the mutex could not be created.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinNT.HANDLE CreateMutex(SecurityAttributes attributes, boolean owner, String name);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Opens an existing object.
&nbsp;                     *
&nbsp;                     * @param access  The required access privileges.
&nbsp;                     * @param inherit {@code true} if the mutex should be inherited.
&nbsp;                     * @param name    The mutex&#39;s name.
&nbsp;                     * @return The handle or {@code null} if the mutex could not be opened.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    WinNT.HANDLE OpenMutex(int access, boolean inherit, String name);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Releases the supplied mutex.
&nbsp;                     *
&nbsp;                     * @param handle The handle to the mutex.
&nbsp;                     * @return {@code true} if the handle was successfully released.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;checkstyle:methodname&quot;)
&nbsp;                    boolean ReleaseMutex(WinNT.HANDLE handle);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A structure representing a mutex&#39;s security attributes.
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = {&quot;URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD&quot;, &quot;UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD&quot;}, justification = &quot;Field required by native implementation.&quot;)
<b class="nc">&nbsp;                    class SecurityAttributes extends Structure {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The descriptor&#39;s length.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public WinDef.DWORD length;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A pointer to the descriptor.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Pointer securityDescriptor;
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@code true} if the attributes are inherited.
&nbsp;                         */
&nbsp;                        @SuppressWarnings(&quot;unused&quot;)
&nbsp;                        public boolean inherit;
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected List&lt;String&gt; getFieldOrder() {
<b class="nc">&nbsp;                            return Arrays.asList(&quot;length&quot;, &quot;securityDescriptor&quot;, &quot;inherit&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A handle for an attachment which is represented by a pair of handles.
&nbsp;                 */
&nbsp;                protected static class AttachmentHandle implements Closeable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The parent handle.
&nbsp;                     */
&nbsp;                    private final WinNT.HANDLE parent;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The child handle.
&nbsp;                     */
&nbsp;                    private final WinNT.HANDLE child;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new attachment handle.
&nbsp;                     *
&nbsp;                     * @param parent The parent handle.
&nbsp;                     * @param child  The child handle.
&nbsp;                     */
<b class="nc">&nbsp;                    protected AttachmentHandle(WinNT.HANDLE parent, WinNT.HANDLE child) {</b>
<b class="nc">&nbsp;                        this.parent = parent;</b>
<b class="nc">&nbsp;                        this.child = child;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the handle on which signals are to be sent.
&nbsp;                     *
&nbsp;                     * @return The handle on which signals are to be sent.
&nbsp;                     */
&nbsp;                    protected WinNT.HANDLE getHandle() {
<b class="nc">&nbsp;                        return child;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() {
&nbsp;                        boolean closed;
&nbsp;                        try {
<b class="nc">&nbsp;                            if (!Kernel32.INSTANCE.CloseHandle(child)) {</b>
<b class="nc">&nbsp;                                throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                            }
&nbsp;                        } finally {
<b class="nc">&nbsp;                            closed = Kernel32.INSTANCE.CloseHandle(parent);</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        if (!closed) {</b>
<b class="nc">&nbsp;                            throw new Win32Exception(Kernel32.INSTANCE.GetLastError());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
