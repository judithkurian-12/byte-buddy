


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > TypePool</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.pool</a>
</div>

<h1>Coverage Summary for Class: TypePool (net.bytebuddy.pool)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">TypePool$1</td>
  </tr>
  <tr>
    <td class="name">TypePool$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (29/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$AbstractBase$ArrayTypeResolution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$AbstractBase$ComponentTypeReference</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$AbstractBase$Hierarchical</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$Discriminating</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$MockitoMock$2121060436</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$MockitoMock$2121060436$auxiliary$5X8jp1l9</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$MockitoMock$2121060436$auxiliary$YCpKPeMd</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$CacheProvider$Simple$UsingSoftReference</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (12/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$ClassLoading</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81%
  </span>
  <span class="absValue">
    (17/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$AbstractBase$ForTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$AbstractBase$ForTypeVariable$WithIndex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$AbstractBase$ForTypeVariable$WithIndex$DoubleIndexed</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$ForByteCodeElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$ForByteCodeElement$WithIndex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$ForTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$ForTypeVariable$WithIndex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$AnnotationRegistrant$ForTypeVariable$WithIndex$DoubleIndexed</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ComponentTypeLocator</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ComponentTypeLocator$ForAnnotationProperty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ComponentTypeLocator$ForAnnotationProperty$Bound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ComponentTypeLocator$ForArrayType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ComponentTypeLocator$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfMethod$ExceptionTypeRegistrant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfMethod$ParameterTypeRegistrant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfMethod$ReturnTypeTypeRegistrant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfType$InterfaceTypeRegistrant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$ForSignature$OfType$SuperClassRegistrant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken$AbstractBase$ForDirectBound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken$AbstractBase$ForLowerBound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken$AbstractBase$ForUpperBound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken$ForInnerClass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeExtractor$IncompleteToken$ForTopLevelType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeRegistrant</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$GenericTypeRegistrant$RejectingSignatureVisitor</td>
<td class="coverageStat">
  <span class="percent">
    11.8%
  </span>
  <span class="absValue">
    (2/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    11.8%
  </span>
  <span class="absValue">
    (2/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    96.3%
  </span>
  <span class="absValue">
    (26/27)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (76/81)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$AnnotationToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$AnnotationToken$Resolution</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$AnnotationToken$Resolution$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$AnnotationToken$Resolution$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$FieldToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$FieldTokenList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForGenericArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForGenericArray$LazyGenericArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForLowerBoundWildcard</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForLowerBoundWildcard$LazyLowerBoundWildcard</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForParameterizedType$LazyParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForParameterizedType$Nested</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForParameterizedType$Nested$LazyParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForPrimitiveType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (20/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForPrimitiveType$LazyPrimitiveType</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForRawType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForTypeVariable$AnnotatedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForTypeVariable$Formal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForTypeVariable$Formal$LazyTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForTypeVariable$Formal$LazyTypeVariable$LazyBoundTokenList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForTypeVariable$UnresolvedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForUnboundWildcard</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForUnboundWildcard$LazyUnboundWildcard</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForUpperBoundWildcard</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$ForUpperBoundWildcard$LazyUpperBoundWildcard</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$LazyTokenList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$LazyTokenList$ForWildcardBound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$MockitoMock$1685958092</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$MockitoMock$1685958092$auxiliary$a617widj</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$MockitoMock$1685958092$auxiliary$ViOtFE3V</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$OfFormalTypeVariable</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForField</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForField$Tokenized</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForMethod</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForMethod$Tokenized</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForRecordComponent</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForRecordComponent$Tokenized</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForType</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$ForType$Tokenized</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$Malformed</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (5/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$Raw</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$Raw$RawAnnotatedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.7%
  </span>
  <span class="absValue">
    (22/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$GenericTypeToken$Resolution$Raw$RawAnnotatedType$LazyRawAnnotatedTypeList</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (15/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (28/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationDescription$Loadable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationDescription$UnresolvedAnnotationList</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationValue</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationValue$ForAnnotationValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationValue$ForArray</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (38/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationValue$ForEnumerationValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationValue$ForMismatchedType</td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (3/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyAnnotationValue$ForTypeValue</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyFieldDescription</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.7%
  </span>
  <span class="absValue">
    (58/60)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription$LazyNonGenericReceiverType</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription$LazyParameterDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription$LazyParameterizedReceiverType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription$LazyParameterizedReceiverType$TypeArgumentList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription$LazyParameterizedReceiverType$TypeArgumentList$AnnotatedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyMethodDescription$LazyParameterList</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (4/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyNestMemberList</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43.8%
  </span>
  <span class="absValue">
    (7/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyPackageDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyRecordComponentDescription</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$LazyTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$MethodToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (20/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$MethodToken$ParameterToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$MethodTokenList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$RecordComponentToken</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$RecordComponentTokenList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TokenizedGenericType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TokenizedGenericType$Malformed</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TokenizedGenericType$Malformed$TokenList</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TokenizedGenericType$TokenList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TokenizedGenericType$TypeVariableList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TypeContainment</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TypeContainment$SelfContained</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TypeContainment$WithinMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (13/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$LazyTypeDescription$TypeContainment$WithinType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ParameterBag</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$ReaderMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97%
  </span>
  <span class="absValue">
    (64/66)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor$AnnotationExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor$AnnotationExtractor$AnnotationLookup</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor$AnnotationExtractor$ArrayLookup</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor$FieldExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor$MethodExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (54/57)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$TypeExtractor$RecordComponentExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$WithLazyResolution</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$WithLazyResolution$LazyResolution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Default$WithLazyResolution$LazyTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Empty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$LazyFacade</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$LazyFacade$LazyResolution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$LazyFacade$LazyTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$MockitoMock$1085652545</td>
  </tr>
  <tr>
    <td class="name">TypePool$MockitoMock$1085652545$auxiliary$M49h2wJH</td>
  </tr>
  <tr>
    <td class="name">TypePool$MockitoMock$1085652545$auxiliary$WTvvXL2D</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution$MockitoMock$2060228675</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution$MockitoMock$2060228675$auxiliary$FQr8kOIo</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution$MockitoMock$2060228675$auxiliary$s3p71OeM</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution$NoSuchTypeException</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypePool$Resolution$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    90.1%
  </span>
  <span class="absValue">
    (567/629)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.2%
  </span>
  <span class="absValue">
    (1344/1474)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.pool;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.RecordComponentDescription;
&nbsp;import net.bytebuddy.description.type.RecordComponentList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.nullability.UnknownNull;
&nbsp;import org.objectweb.asm.AnnotationVisitor;
&nbsp;import org.objectweb.asm.ClassReader;
&nbsp;import org.objectweb.asm.ClassVisitor;
&nbsp;import org.objectweb.asm.FieldVisitor;
&nbsp;import org.objectweb.asm.Label;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.RecordComponentVisitor;
&nbsp;import org.objectweb.asm.Type;
&nbsp;import org.objectweb.asm.TypePath;
&nbsp;import org.objectweb.asm.TypeReference;
&nbsp;import org.objectweb.asm.signature.SignatureReader;
&nbsp;import org.objectweb.asm.signature.SignatureVisitor;
&nbsp;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import java.io.IOException;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.ref.SoftReference;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.ListIterator;
&nbsp;import java.util.Map;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.atomic.AtomicReference;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.hasDescriptor;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.hasMethodName;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.is;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * A type pool allows the retrieval of {@link TypeDescription} by its name.
&nbsp; */
&nbsp;public interface TypePool {
&nbsp;
&nbsp;    /**
&nbsp;     * Locates and describes the given type by its name.
&nbsp;     *
&nbsp;     * @param name The name of the type to describe. The name is to be written as when calling {@link Class#getName()}.
&nbsp;     * @return A resolution of the type to describe. If the type to be described was found, the returned
&nbsp;     * {@link net.bytebuddy.pool.TypePool.Resolution} represents this type. Otherwise, an illegal resolution is returned.
&nbsp;     */
&nbsp;    Resolution describe(String name);
&nbsp;
&nbsp;    /**
&nbsp;     * Clears this type pool&#39;s cache.
&nbsp;     */
&nbsp;    void clear();
&nbsp;
&nbsp;    /**
&nbsp;     * A resolution of a {@link net.bytebuddy.pool.TypePool} which was queried for a description.
&nbsp;     */
&nbsp;    interface Resolution {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if this resolution represents a fully-resolved {@link TypeDescription}.
&nbsp;         *
&nbsp;         * @return {@code true} if the queried type could be resolved.
&nbsp;         */
&nbsp;        boolean isResolved();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this resolution to a {@link TypeDescription}. If this resolution is unresolved, this
&nbsp;         * method throws an exception either upon invoking this method or upon invoking at least one method
&nbsp;         * of the returned type description.
&nbsp;         *
&nbsp;         * @return The type description that is represented by this resolution.
&nbsp;         * @throws NoSuchTypeException If this resolution is unresolved.
&nbsp;         */
&nbsp;        TypeDescription resolve();
&nbsp;
&nbsp;        /**
&nbsp;         * A simple resolution that represents a given {@link TypeDescription}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented type description.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new successful resolution of a given type description.
&nbsp;             *
&nbsp;             * @param typeDescription The represented type description.
&nbsp;             */
<b class="fc">&nbsp;            public Simple(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription resolve() {
<b class="fc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A canonical representation of a non-successful resolution of a {@link net.bytebuddy.pool.TypePool}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Illegal implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the unresolved type.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new illegal resolution.
&nbsp;             *
&nbsp;             * @param name The name of the unresolved type.
&nbsp;             */
<b class="fc">&nbsp;            public Illegal(String name) {</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription resolve() {
<b class="fc">&nbsp;                throw new NoSuchTypeException(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An exception that indicates that a {@link TypePool} could not resolve a {@link TypeDescription} for a given name.
&nbsp;         */
&nbsp;        class NoSuchTypeException extends IllegalStateException {
&nbsp;
&nbsp;            /**
&nbsp;             * The serial version UID.
&nbsp;             */
&nbsp;            private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type that could not be resolved.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new exception to indicate an unresolved type.
&nbsp;             *
&nbsp;             * @param name The name of the type that could not be resolved.
&nbsp;             */
&nbsp;            public NoSuchTypeException(String name) {
<b class="fc">&nbsp;                super(&quot;Cannot resolve type description for &quot; + name);</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the name of the type that could not be resolved.
&nbsp;             *
&nbsp;             * @return The name of the type that could not be resolved.
&nbsp;             */
&nbsp;            public String getName() {
<b class="fc">&nbsp;                return name;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A cache provider for a {@link net.bytebuddy.pool.TypePool}.
&nbsp;     */
&nbsp;    interface CacheProvider {
&nbsp;
&nbsp;        /**
&nbsp;         * The value that is returned on a cache-miss.
&nbsp;         */
&nbsp;        @MaybeNull
<b class="fc">&nbsp;        Resolution UNRESOLVED = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to find a resolution in this cache.
&nbsp;         *
&nbsp;         * @param name The name of the type to describe.
&nbsp;         * @return A resolution of the type or {@code null} if no such resolution can be found in the cache.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Resolution find(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Registers a resolution in this cache. If a resolution to the given name already exists in the
&nbsp;         * cache, it should be discarded.
&nbsp;         *
&nbsp;         * @param name       The name of the type that is to be registered.
&nbsp;         * @param resolution The resolution to register.
&nbsp;         * @return The oldest version of a resolution that is currently registered in the cache which might
&nbsp;         * be the given resolution or another resolution that was previously registered.
&nbsp;         */
&nbsp;        Resolution register(String name, Resolution resolution);
&nbsp;
&nbsp;        /**
&nbsp;         * Clears this cache.
&nbsp;         */
&nbsp;        void clear();
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational cache that does not store any type descriptions.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements CacheProvider {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Resolution find(String name) {
<b class="fc">&nbsp;                return UNRESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolution register(String name, Resolution resolution) {
<b class="fc">&nbsp;                return resolution;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void clear() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple, thread-safe type cache based on a {@link java.util.concurrent.ConcurrentHashMap}.
&nbsp;         */
&nbsp;        class Simple implements CacheProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * A map containing all cached resolutions by their names.
&nbsp;             */
&nbsp;            private final ConcurrentMap&lt;String, Resolution&gt; storage;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new simple cache.
&nbsp;             */
&nbsp;            public Simple() {
<b class="fc">&nbsp;                this(new ConcurrentHashMap&lt;String, Resolution&gt;());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new simple cache.
&nbsp;             *
&nbsp;             * @param storage A map that is used for locating and storing resolutions.
&nbsp;             */
<b class="fc">&nbsp;            public Simple(ConcurrentMap&lt;String, Resolution&gt; storage) {</b>
<b class="fc">&nbsp;                this.storage = storage;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a simple cache provider that is prepopulated with the {@link Object} type.
&nbsp;             *
&nbsp;             * @return A simple cache provider that is prepopulated with the {@link Object} type.
&nbsp;             */
&nbsp;            public static CacheProvider withObjectType() {
<b class="fc">&nbsp;                CacheProvider cacheProvider = new Simple();</b>
<b class="fc">&nbsp;                cacheProvider.register(Object.class.getName(), new Resolution.Simple(TypeDescription.ForLoadedType.of(Object.class)));</b>
<b class="fc">&nbsp;                return cacheProvider;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Resolution find(String name) {
<b class="fc">&nbsp;                return storage.get(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolution register(String name, Resolution resolution) {
<b class="fc">&nbsp;                Resolution cached = storage.putIfAbsent(name, resolution);</b>
<b class="fc">&nbsp;                return cached == null</b>
<b class="fc">&nbsp;                        ? resolution</b>
<b class="fc">&nbsp;                        : cached;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void clear() {
<b class="fc">&nbsp;                storage.clear();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the underlying storage map of this simple cache provider.
&nbsp;             *
&nbsp;             * @return A map containing all cached resolutions by their names.
&nbsp;             */
&nbsp;            public ConcurrentMap&lt;String, Resolution&gt; getStorage() {
<b class="fc">&nbsp;                return storage;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A {@link Simple} cache provider that clears its storage if the heap is filled, by using a soft reference.
&nbsp;             */
&nbsp;            public static class UsingSoftReference implements CacheProvider {
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference for the actual cache provider.
&nbsp;                 */
&nbsp;                private final AtomicReference&lt;SoftReference&lt;Simple&gt;&gt; delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a softly referenced {@link Simple} cache provider.
&nbsp;                 */
<b class="fc">&nbsp;                public UsingSoftReference() {</b>
<b class="fc">&nbsp;                    delegate = new AtomicReference&lt;SoftReference&lt;Simple&gt;&gt;(new SoftReference&lt;Simple&gt;(new Simple()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Resolution find(String name) {
<b class="fc">&nbsp;                    CacheProvider provider = delegate.get().get();</b>
<b class="fc">&nbsp;                    return provider == null</b>
<b class="nc">&nbsp;                            ? UNRESOLVED</b>
<b class="fc">&nbsp;                            : provider.find(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Resolution register(String name, Resolution resolution) {
<b class="fc">&nbsp;                    SoftReference&lt;Simple&gt; reference = delegate.get();</b>
<b class="fc">&nbsp;                    Simple provider = reference.get();</b>
<b class="fc">&nbsp;                    if (provider == null) {</b>
<b class="nc">&nbsp;                        provider = new Simple();</b>
<b class="nc">&nbsp;                        while (!delegate.compareAndSet(reference, new SoftReference&lt;Simple&gt;(provider))) {</b>
<b class="nc">&nbsp;                            reference = delegate.get();</b>
<b class="nc">&nbsp;                            Simple previous = reference.get();</b>
<b class="nc">&nbsp;                            if (previous != null) {</b>
<b class="nc">&nbsp;                                provider = previous;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return provider.register(name, resolution);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void clear() {
<b class="fc">&nbsp;                    CacheProvider provider = delegate.get().get();</b>
<b class="fc">&nbsp;                    if (provider != null) {</b>
<b class="fc">&nbsp;                        provider.clear();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A discriminating cache provider that delegates a type name to one of two caches.
&nbsp;         */
&nbsp;        class Discriminating implements CacheProvider {
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher that determines which cache to use.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;String&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The cache provider to use for matched types.
&nbsp;             */
&nbsp;            private final CacheProvider matched;
&nbsp;
&nbsp;            /**
&nbsp;             * The cache provider to use for unmatched types.
&nbsp;             */
&nbsp;            private final CacheProvider unmatched;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new discriminating cache provider.
&nbsp;             *
&nbsp;             * @param matcher   The matcher that determines which cache to use.
&nbsp;             * @param matched   The cache provider to use for matched types.
&nbsp;             * @param unmatched The cache provider to use for unmatched types.
&nbsp;             */
<b class="fc">&nbsp;            public Discriminating(ElementMatcher&lt;String&gt; matcher, CacheProvider matched, CacheProvider unmatched) {</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.matched = matched;</b>
<b class="fc">&nbsp;                this.unmatched = unmatched;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Resolution find(String name) {
<b class="nc">&nbsp;                return (matcher.matches(name) ? matched : unmatched).find(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolution register(String name, Resolution resolution) {
<b class="fc">&nbsp;                return (matcher.matches(name) ? matched : unmatched).register(name, resolution);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void clear() {
&nbsp;                try {
<b class="fc">&nbsp;                    unmatched.clear();</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    matched.clear();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An empty type pool that cannot describe any type.
&nbsp;     */
<b class="fc">&nbsp;    enum Empty implements TypePool {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution describe(String name) {
<b class="fc">&nbsp;            return new Resolution.Illegal(name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void clear() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A base implementation of a {@link net.bytebuddy.pool.TypePool} that is managing a cache provider and
&nbsp;     * that handles the description of array and primitive types.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    abstract class AbstractBase implements TypePool {
&nbsp;
&nbsp;        /**
&nbsp;         * A map of primitive types by their name.
&nbsp;         */
&nbsp;        protected static final Map&lt;String, TypeDescription&gt; PRIMITIVE_TYPES;
&nbsp;
&nbsp;        /**
&nbsp;         * A map of primitive types by their descriptor.
&nbsp;         */
&nbsp;        protected static final Map&lt;String, String&gt; PRIMITIVE_DESCRIPTORS;
&nbsp;
&nbsp;        /**
&nbsp;         * The array symbol as used by Java descriptors.
&nbsp;         */
&nbsp;        private static final String ARRAY_SYMBOL = &quot;[&quot;;
&nbsp;
&nbsp;        /*
&nbsp;         * Initializes the maps of primitive type names and descriptors.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            Map&lt;String, TypeDescription&gt; primitiveTypes = new HashMap&lt;String, TypeDescription&gt;();</b>
<b class="fc">&nbsp;            Map&lt;String, String&gt; primitiveDescriptors = new HashMap&lt;String, String&gt;();</b>
<b class="fc">&nbsp;            for (Class&lt;?&gt; type : new Class&lt;?&gt;[]{boolean.class,</b>
&nbsp;                    byte.class,
&nbsp;                    short.class,
&nbsp;                    char.class,
&nbsp;                    int.class,
&nbsp;                    long.class,
&nbsp;                    float.class,
&nbsp;                    double.class,
&nbsp;                    void.class}) {
<b class="fc">&nbsp;                primitiveTypes.put(type.getName(), TypeDescription.ForLoadedType.of(type));</b>
<b class="fc">&nbsp;                primitiveDescriptors.put(Type.getDescriptor(type), type.getName());</b>
&nbsp;            }
<b class="fc">&nbsp;            PRIMITIVE_TYPES = Collections.unmodifiableMap(primitiveTypes);</b>
<b class="fc">&nbsp;            PRIMITIVE_DESCRIPTORS = Collections.unmodifiableMap(primitiveDescriptors);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The cache provider of this instance.
&nbsp;         */
&nbsp;        protected final CacheProvider cacheProvider;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new instance.
&nbsp;         *
&nbsp;         * @param cacheProvider The cache provider to be used.
&nbsp;         */
<b class="fc">&nbsp;        protected AbstractBase(CacheProvider cacheProvider) {</b>
<b class="fc">&nbsp;            this.cacheProvider = cacheProvider;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Resolution describe(String name) {
<b class="fc">&nbsp;            if (name.contains(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(name + &quot; contains the illegal character &#39;/&#39;&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            int arity = 0;</b>
<b class="fc">&nbsp;            while (name.startsWith(ARRAY_SYMBOL)) {</b>
<b class="fc">&nbsp;                arity++;</b>
<b class="fc">&nbsp;                name = name.substring(1);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (arity &gt; 0) {</b>
<b class="fc">&nbsp;                String primitiveName = PRIMITIVE_DESCRIPTORS.get(name);</b>
<b class="fc">&nbsp;                name = primitiveName == null</b>
<b class="fc">&nbsp;                        ? name.substring(1, name.length() - 1)</b>
<b class="fc">&nbsp;                        : primitiveName;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription typeDescription = PRIMITIVE_TYPES.get(name);</b>
<b class="fc">&nbsp;            Resolution resolution = typeDescription == null</b>
<b class="fc">&nbsp;                    ? cacheProvider.find(name)</b>
<b class="fc">&nbsp;                    : new Resolution.Simple(typeDescription);</b>
<b class="fc">&nbsp;            if (resolution == null) {</b>
<b class="fc">&nbsp;                resolution = doCache(name, doDescribe(name));</b>
&nbsp;            }
<b class="fc">&nbsp;            return ArrayTypeResolution.of(resolution, arity);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Writes the resolution to the cache. This method should be overridden if the directly
&nbsp;         * resolved instance should not be added to the cache.
&nbsp;         *
&nbsp;         * @param name       The name of the type.
&nbsp;         * @param resolution The resolution for this type.
&nbsp;         * @return The actual resolution for the type of this name that is stored in the cache.
&nbsp;         */
&nbsp;        protected Resolution doCache(String name, Resolution resolution) {
<b class="fc">&nbsp;            return cacheProvider.register(name, resolution);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void clear() {
<b class="fc">&nbsp;            cacheProvider.clear();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Determines a resolution to a non-primitive, non-array type.
&nbsp;         *
&nbsp;         * @param name The name of the type to describe.
&nbsp;         * @return A resolution to the type to describe.
&nbsp;         */
&nbsp;        protected abstract Resolution doDescribe(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * A lazy representation of the component type of an array.
&nbsp;         */
&nbsp;        protected interface ComponentTypeReference {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that no component type is defined for the property.
&nbsp;             */
&nbsp;            @MaybeNull
<b class="fc">&nbsp;            String NO_ARRAY = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Lazily resolves the binary name of the array component type of an annotation value.
&nbsp;             *
&nbsp;             * @return The binary name of the component type of the array or {@code null} if the referenced type is not an array.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            String resolve();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements a hierarchical view of type pools, similarly to class loader hierarchies. For every lookup, the parent type pool
&nbsp;         * is asked first if it can resolve a type. Only if the parent (and potentially its parents) are unable to resolve a type,
&nbsp;         * this instance is queried for a type description.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public abstract static class Hierarchical extends AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The parent type pool.
&nbsp;             */
&nbsp;            private final TypePool parent;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a hierarchical type pool.
&nbsp;             *
&nbsp;             * @param cacheProvider The cache provider to be used.
&nbsp;             * @param parent        The parent type pool to be used.
&nbsp;             */
&nbsp;            protected Hierarchical(CacheProvider cacheProvider, TypePool parent) {
<b class="fc">&nbsp;                super(cacheProvider);</b>
<b class="fc">&nbsp;                this.parent = parent;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolution describe(String name) {
<b class="fc">&nbsp;                Resolution resolution = parent.describe(name);</b>
<b class="fc">&nbsp;                return resolution.isResolved()</b>
<b class="fc">&nbsp;                        ? resolution</b>
<b class="fc">&nbsp;                        : super.describe(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void clear() {
&nbsp;                try {
<b class="fc">&nbsp;                    parent.clear();</b>
<b class="nc">&nbsp;                } finally {</b>
<b class="fc">&nbsp;                    super.clear();</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resolution for a type that, if resolved, represents an array type.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ArrayTypeResolution implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The underlying resolution that is represented by this instance.
&nbsp;             */
&nbsp;            private final Resolution resolution;
&nbsp;
&nbsp;            /**
&nbsp;             * The arity of the represented array.
&nbsp;             */
&nbsp;            private final int arity;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a wrapper for another resolution that, if resolved, represents an array type.
&nbsp;             *
&nbsp;             * @param resolution The underlying resolution that is represented by this instance.
&nbsp;             * @param arity      The arity of the represented array.
&nbsp;             */
<b class="fc">&nbsp;            protected ArrayTypeResolution(Resolution resolution, int arity) {</b>
<b class="fc">&nbsp;                this.resolution = resolution;</b>
<b class="fc">&nbsp;                this.arity = arity;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a wrapper for another resolution that, if resolved, represents an array type. The wrapper
&nbsp;             * is only created if the arity is not zero. If the arity is zero, the given resolution is simply
&nbsp;             * returned instead.
&nbsp;             *
&nbsp;             * @param resolution The underlying resolution that is represented by this instance.
&nbsp;             * @param arity      The arity of the represented array.
&nbsp;             * @return A wrapper for another resolution that, if resolved, represents an array type or the
&nbsp;             * given resolution if the given arity is zero.
&nbsp;             */
&nbsp;            protected static Resolution of(Resolution resolution, int arity) {
<b class="fc">&nbsp;                return arity == 0</b>
<b class="fc">&nbsp;                        ? resolution</b>
<b class="fc">&nbsp;                        : new ArrayTypeResolution(resolution, arity);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return resolution.isResolved();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription resolve() {
<b class="fc">&nbsp;                return TypeDescription.ArrayProjection.of(resolution.resolve(), arity);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A default implementation of a {@link net.bytebuddy.pool.TypePool} that models binary data in the Java byte code format
&nbsp;     * into a {@link TypeDescription}. The data lookup is delegated to a {@link net.bytebuddy.dynamic.ClassFileLocator}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * {@link Resolution}s that are produced by this type pool are either fully resolved or not resolved at all.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class Default extends AbstractBase.Hierarchical {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a visited method should be ignored.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        private static final MethodVisitor IGNORE_METHOD = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The locator to query for finding binary data of a type.
&nbsp;         */
&nbsp;        protected final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;        /**
&nbsp;         * The reader mode to apply by this default type pool.
&nbsp;         */
&nbsp;        protected final ReaderMode readerMode;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default type pool without a parent pool.
&nbsp;         *
&nbsp;         * @param cacheProvider    The cache provider to be used.
&nbsp;         * @param classFileLocator The class file locator to be used.
&nbsp;         * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;         */
&nbsp;        public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
<b class="fc">&nbsp;            this(cacheProvider, classFileLocator, readerMode, Empty.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default type pool.
&nbsp;         *
&nbsp;         * @param cacheProvider    The cache provider to be used.
&nbsp;         * @param classFileLocator The class file locator to be used.
&nbsp;         * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;         * @param parentPool       The parent type pool.
&nbsp;         */
&nbsp;        public Default(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
<b class="fc">&nbsp;            super(cacheProvider, parentPool);</b>
<b class="fc">&nbsp;            this.classFileLocator = classFileLocator;</b>
<b class="fc">&nbsp;            this.readerMode = readerMode;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the system class
&nbsp;         * loader. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;         *
&nbsp;         * @return A type pool that reads its data from the system class loader.
&nbsp;         */
&nbsp;        public static TypePool ofSystemLoader() {
<b class="fc">&nbsp;            return of(ClassFileLocator.ForClassLoader.ofSystemLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the plaform class
&nbsp;         * loader. The returned instance is configured to use a fast reading mode and a simple cache. If the current
&nbsp;         * VM is of version 8 or older, the extension class loader is represented instead.
&nbsp;         *
&nbsp;         * @return A type pool that reads its data from the platform class path.
&nbsp;         */
&nbsp;        public static TypePool ofPlatformLoader() {
<b class="nc">&nbsp;            return of(ClassFileLocator.ForClassLoader.ofPlatformLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the boot class
&nbsp;         * loader. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;         *
&nbsp;         * @return A type pool that reads its data from the boot class loader.
&nbsp;         */
&nbsp;        public static TypePool ofBootLoader() {
<b class="nc">&nbsp;            return of(ClassFileLocator.ForClassLoader.ofBootLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool for the provided class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader for which this class pool is representing types.
&nbsp;         * @return An appropriate type pool.
&nbsp;         */
&nbsp;        public static TypePool of(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            return of(ClassFileLocator.ForClassLoader.of(classLoader));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a default {@link net.bytebuddy.pool.TypePool} that looks up data by querying the supplied class
&nbsp;         * file locator. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;         *
&nbsp;         * @param classFileLocator The class file locator to use.
&nbsp;         * @return A type pool that reads its data from the system class path.
&nbsp;         */
&nbsp;        public static TypePool of(ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;            return new Default(new CacheProvider.Simple(), classFileLocator, ReaderMode.FAST);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            try {
<b class="fc">&nbsp;                ClassFileLocator.Resolution resolution = classFileLocator.locate(name);</b>
<b class="fc">&nbsp;                return resolution.isResolved()</b>
<b class="fc">&nbsp;                        ? new Resolution.Simple(parse(resolution.resolve()))</b>
<b class="fc">&nbsp;                        : new Resolution.Illegal(name);</b>
<b class="nc">&nbsp;            } catch (IOException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Error while reading class file&quot;, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Parses a binary representation and transforms it into a type description.
&nbsp;         *
&nbsp;         * @param binaryRepresentation The binary data to be parsed.
&nbsp;         * @return A type description of the binary data.
&nbsp;         */
&nbsp;        private TypeDescription parse(byte[] binaryRepresentation) {
<b class="fc">&nbsp;            ClassReader classReader = OpenedClassReader.of(binaryRepresentation);</b>
<b class="fc">&nbsp;            TypeExtractor typeExtractor = new TypeExtractor();</b>
<b class="fc">&nbsp;            classReader.accept(typeExtractor, readerMode.getFlags());</b>
<b class="fc">&nbsp;            return typeExtractor.toTypeDescription();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the granularity of the class file parsing that is conducted by a {@link net.bytebuddy.pool.TypePool.Default}.
&nbsp;         */
<b class="fc">&nbsp;        public enum ReaderMode {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The extended reader mode parses the code segment of each method in order to detect parameter names
&nbsp;             * that are only stored in a method&#39;s debugging information but are not explicitly included.
&nbsp;             */
<b class="fc">&nbsp;            EXTENDED(ClassReader.SKIP_FRAMES),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The fast reader mode skips the code segment of each method and cannot detect parameter names that are
&nbsp;             * only contained within the debugging information. This mode still detects explicitly included method
&nbsp;             * parameter names.
&nbsp;             */
<b class="fc">&nbsp;            FAST(ClassReader.SKIP_CODE);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             */
&nbsp;            private final int flags;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new reader mode constant.
&nbsp;             *
&nbsp;             * @param flags The flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             */
<b class="fc">&nbsp;            ReaderMode(int flags) {</b>
<b class="fc">&nbsp;                this.flags = flags;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             *
&nbsp;             * @return The flags to provide to a {@link ClassReader} for parsing a file.
&nbsp;             */
&nbsp;            protected int getFlags() {
<b class="fc">&nbsp;                return flags;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if this reader mode represents extended reading.
&nbsp;             *
&nbsp;             * @return {@code true} if this reader mode represents extended reading.
&nbsp;             */
&nbsp;            public boolean isExtended() {
<b class="fc">&nbsp;                return this == EXTENDED;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A variant of {@link TypePool.Default} that resolves type descriptions lazily. A lazy resolution respects this type
&nbsp;         * pool&#39;s {@link CacheProvider} but requeries this cache pool for every access of a property of a {@link TypeDescription}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * {@link Resolution}s of this type pool are only fully resolved if a property that is not the type&#39;s name is required.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        public static class WithLazyResolution extends Default {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default type pool with lazy resolution and without a parent pool.
&nbsp;             *
&nbsp;             * @param cacheProvider    The cache provider to be used.
&nbsp;             * @param classFileLocator The class file locator to be used.
&nbsp;             * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;             */
&nbsp;            public WithLazyResolution(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode) {
<b class="fc">&nbsp;                this(cacheProvider, classFileLocator, readerMode, Empty.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default type pool with lazy resolution.
&nbsp;             *
&nbsp;             * @param cacheProvider    The cache provider to be used.
&nbsp;             * @param classFileLocator The class file locator to be used.
&nbsp;             * @param readerMode       The reader mode to apply by this default type pool.
&nbsp;             * @param parentPool       The parent type pool.
&nbsp;             */
&nbsp;            public WithLazyResolution(CacheProvider cacheProvider, ClassFileLocator classFileLocator, ReaderMode readerMode, TypePool parentPool) {
<b class="fc">&nbsp;                super(cacheProvider, classFileLocator, readerMode, parentPool);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default {@link net.bytebuddy.pool.TypePool} with lazy resolution that looks up data by querying the system class
&nbsp;             * loader. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;             *
&nbsp;             * @return A type pool that reads its data from the system class loader.
&nbsp;             */
&nbsp;            public static TypePool ofSystemLoader() {
<b class="nc">&nbsp;                return of(ClassFileLocator.ForClassLoader.ofSystemLoader());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default {@link net.bytebuddy.pool.TypePool} with lazy resolution that looks up data by querying the platform class
&nbsp;             * loader. The returned instance is configured to use a fast reading mode and a simple cache. If the current VM is Java 8 or older,
&nbsp;             * the type pool represents the extension class loader.
&nbsp;             *
&nbsp;             * @return A type pool that reads its data from the boot class loader.
&nbsp;             */
&nbsp;            public static TypePool ofPlatformLoader() {
<b class="nc">&nbsp;                return of(ClassFileLocator.ForClassLoader.ofPlatformLoader());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default {@link net.bytebuddy.pool.TypePool} with lazy resolution that looks up data by querying the boot class
&nbsp;             * loader. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;             *
&nbsp;             * @return A type pool that reads its data from the boot class loader.
&nbsp;             */
&nbsp;            public static TypePool ofBootLoader() {
<b class="nc">&nbsp;                return of(ClassFileLocator.ForClassLoader.ofBootLoader());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a default {@link TypePool} with lazy resolution for the provided class loader.
&nbsp;             *
&nbsp;             * @param classLoader The class loader for which this class pool is representing types.
&nbsp;             * @return An appropriate type pool.
&nbsp;             */
&nbsp;            public static TypePool of(@MaybeNull ClassLoader classLoader) {
<b class="nc">&nbsp;                return of(ClassFileLocator.ForClassLoader.of(classLoader));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default {@link net.bytebuddy.pool.TypePool} with lazy resolution that looks up data by querying the supplied class
&nbsp;             * file locator. The returned instance is configured to use a fast reading mode and a simple cache.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             * @return A type pool that reads its data from the system class path.
&nbsp;             */
&nbsp;            public static TypePool of(ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                return new WithLazyResolution(new CacheProvider.Simple(), classFileLocator, ReaderMode.FAST);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Resolution doDescribe(String name) {
<b class="fc">&nbsp;                return new LazyResolution(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            protected Resolution doCache(String name, Resolution resolution) {
<b class="fc">&nbsp;                return resolution;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Non-lazily resolves a type name.
&nbsp;             *
&nbsp;             * @param name The name of the type to resolve.
&nbsp;             * @return The resolution for the type of this name.
&nbsp;             */
&nbsp;            protected Resolution doResolve(String name) {
<b class="fc">&nbsp;                Resolution resolution = cacheProvider.find(name);</b>
<b class="fc">&nbsp;                if (resolution == null) {</b>
<b class="fc">&nbsp;                    resolution = cacheProvider.register(name, WithLazyResolution.super.doDescribe(name));</b>
&nbsp;                }
<b class="fc">&nbsp;                return resolution;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy resolution of a type that the enclosing type pool attempts to resolve.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class LazyResolution implements Resolution {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy resolution.
&nbsp;                 *
&nbsp;                 * @param name The type&#39;s name.
&nbsp;                 */
<b class="fc">&nbsp;                protected LazyResolution(String name) {</b>
<b class="fc">&nbsp;                    this.name = name;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isResolved() {
<b class="fc">&nbsp;                    return doResolve(name).isResolved();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription resolve() {
<b class="fc">&nbsp;                    return new LazyTypeDescription(name);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy type description that resolves any property that is not the name only when requested.
&nbsp;             */
&nbsp;            protected class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy type description.
&nbsp;                 *
&nbsp;                 * @param name The type&#39;s name.
&nbsp;                 */
<b class="fc">&nbsp;                protected LazyTypeDescription(String name) {</b>
<b class="fc">&nbsp;                    this.name = name;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;delegate&quot;)
&nbsp;                protected TypeDescription delegate() {
<b class="fc">&nbsp;                    return doResolve(name).resolve();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An annotation registrant implements a visitor pattern for reading an unknown amount of values of annotations.
&nbsp;         */
&nbsp;        protected interface AnnotationRegistrant {
&nbsp;
&nbsp;            /**
&nbsp;             * Registers an annotation value.
&nbsp;             *
&nbsp;             * @param name            The name of the annotation value.
&nbsp;             * @param annotationValue The value of the annotation.
&nbsp;             */
&nbsp;            void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue);
&nbsp;
&nbsp;            /**
&nbsp;             * Called once all annotation values are visited.
&nbsp;             */
&nbsp;            void onComplete();
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of an annotation registrant.
&nbsp;             */
&nbsp;            abstract class AbstractBase implements AnnotationRegistrant {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation descriptor.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The values that were collected so far.
&nbsp;                 */
&nbsp;                private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation registrant.
&nbsp;                 *
&nbsp;                 * @param descriptor The annotation descriptor.
&nbsp;                 */
<b class="fc">&nbsp;                protected AbstractBase(String descriptor) {</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    values = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;                    values.put(name, annotationValue);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete() {
<b class="fc">&nbsp;                    getTokens().add(new LazyTypeDescription.AnnotationToken(descriptor, values));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the token list for this collector.
&nbsp;                 *
&nbsp;                 * @return The token list for this collector.
&nbsp;                 */
&nbsp;                protected abstract List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens();
&nbsp;
&nbsp;                /**
&nbsp;                 * A base implementation for a collector for a type variable.
&nbsp;                 */
&nbsp;                protected abstract static class ForTypeVariable extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable&#39;s type path.
&nbsp;                     */
&nbsp;                    private final String typePath;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation collector.
&nbsp;                     *
&nbsp;                     * @param descriptor The annotation descriptor.
&nbsp;                     * @param typePath   The type variable&#39;s type path.
&nbsp;                     */
&nbsp;                    protected ForTypeVariable(String descriptor, @MaybeNull TypePath typePath) {
<b class="fc">&nbsp;                        super(descriptor);</b>
<b class="fc">&nbsp;                        this.typePath = typePath == null</b>
<b class="fc">&nbsp;                                ? LazyTypeDescription.GenericTypeToken.EMPTY_TYPE_PATH</b>
<b class="fc">&nbsp;                                : typePath.toString();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
<b class="fc">&nbsp;                        Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap = getPathMap();</b>
<b class="fc">&nbsp;                        List&lt;LazyTypeDescription.AnnotationToken&gt; tokens = pathMap.get(typePath);</b>
<b class="fc">&nbsp;                        if (tokens == null) {</b>
<b class="fc">&nbsp;                            tokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();</b>
<b class="fc">&nbsp;                            pathMap.put(typePath, tokens);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return tokens;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns this collector&#39;s path map.
&nbsp;                     *
&nbsp;                     * @return This collector&#39;s path map.
&nbsp;                     */
&nbsp;                    protected abstract Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap();
&nbsp;
&nbsp;                    /**
&nbsp;                     * A base implementation for a collector for a type variable with an index.
&nbsp;                     */
&nbsp;                    protected abstract static class WithIndex extends AbstractBase.ForTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable&#39;s index.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation collector.
&nbsp;                         *
&nbsp;                         * @param descriptor The annotation descriptor.
&nbsp;                         * @param typePath   The type variable&#39;s type path.
&nbsp;                         * @param index      The type variable&#39;s index.
&nbsp;                         */
&nbsp;                        protected WithIndex(String descriptor, @MaybeNull TypePath typePath, int index) {
<b class="fc">&nbsp;                            super(descriptor, typePath);</b>
<b class="fc">&nbsp;                            this.index = index;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap() {
<b class="fc">&nbsp;                            Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap = getIndexedPathMap();</b>
<b class="fc">&nbsp;                            Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap = indexedPathMap.get(index);</b>
<b class="fc">&nbsp;                            if (pathMap == null) {</b>
<b class="fc">&nbsp;                                pathMap = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();</b>
<b class="fc">&nbsp;                                indexedPathMap.put(index, pathMap);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return pathMap;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns this collector&#39;s indexed path map.
&nbsp;                         *
&nbsp;                         * @return This collector&#39;s indexed path map.
&nbsp;                         */
&nbsp;                        protected abstract Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap();
&nbsp;
&nbsp;                        /**
&nbsp;                         * A base implementation for a collector for a type variable with two indices.
&nbsp;                         */
&nbsp;                        protected abstract static class DoubleIndexed extends WithIndex {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s first index.
&nbsp;                             */
&nbsp;                            private final int preIndex;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new annotation collector.
&nbsp;                             *
&nbsp;                             * @param descriptor The annotation descriptor.
&nbsp;                             * @param typePath   The type variable&#39;s type path.
&nbsp;                             * @param index      The type variable&#39;s index.
&nbsp;                             * @param preIndex   The type variable&#39;s first index.
&nbsp;                             */
&nbsp;                            protected DoubleIndexed(String descriptor, @MaybeNull TypePath typePath, int index, int preIndex) {
<b class="fc">&nbsp;                                super(descriptor, typePath, index);</b>
<b class="fc">&nbsp;                                this.preIndex = preIndex;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            @Override
&nbsp;                            protected Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap() {
<b class="fc">&nbsp;                                Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexPathMap = getDoubleIndexedPathMap();</b>
<b class="fc">&nbsp;                                Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap = doubleIndexPathMap.get(preIndex);</b>
<b class="fc">&nbsp;                                if (indexedPathMap == null) {</b>
<b class="fc">&nbsp;                                    indexedPathMap = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                                    doubleIndexPathMap.put(preIndex, indexedPathMap);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                return indexedPathMap;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Returns this collector&#39;s double indexed path map.
&nbsp;                             *
&nbsp;                             * @return This collector&#39;s double indexed path map.
&nbsp;                             */
&nbsp;                            protected abstract Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; getDoubleIndexedPathMap();
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An annotation collector for a byte code element.
&nbsp;             */
&nbsp;            class ForByteCodeElement extends AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target collection.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation collector for a byte code element.
&nbsp;                 *
&nbsp;                 * @param descriptor       The annotation descriptor.
&nbsp;                 * @param annotationTokens The target collection.
&nbsp;                 */
&nbsp;                protected ForByteCodeElement(String descriptor, List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens) {
<b class="fc">&nbsp;                    super(descriptor);</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
<b class="fc">&nbsp;                    return annotationTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation collector for a byte code element with an index.
&nbsp;                 */
&nbsp;                public static class WithIndex extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The byte code element&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target collection.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation collector for a byte code element with an index.
&nbsp;                     *
&nbsp;                     * @param descriptor       The annotation descriptor.
&nbsp;                     * @param index            The byte code element&#39;s index.
&nbsp;                     * @param annotationTokens The target collection.
&nbsp;                     */
&nbsp;                    protected WithIndex(String descriptor, int index, Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        super(descriptor);</b>
<b class="fc">&nbsp;                        this.index = index;</b>
<b class="fc">&nbsp;                        this.annotationTokens = annotationTokens;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected List&lt;LazyTypeDescription.AnnotationToken&gt; getTokens() {
<b class="fc">&nbsp;                        List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens = this.annotationTokens.get(index);</b>
<b class="fc">&nbsp;                        if (annotationTokens == null) {</b>
<b class="fc">&nbsp;                            annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();</b>
<b class="fc">&nbsp;                            this.annotationTokens.put(index, annotationTokens);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return annotationTokens;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An annotation collector for a type variable.
&nbsp;             */
&nbsp;            class ForTypeVariable extends AbstractBase.ForTypeVariable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target collection.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation collector.
&nbsp;                 *
&nbsp;                 * @param descriptor The annotation descriptor.
&nbsp;                 * @param typePath   The type variable&#39;s type path.
&nbsp;                 * @param pathMap    The target collection.
&nbsp;                 */
&nbsp;                protected ForTypeVariable(String descriptor, @MaybeNull TypePath typePath, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; pathMap) {
<b class="fc">&nbsp;                    super(descriptor, typePath);</b>
<b class="fc">&nbsp;                    this.pathMap = pathMap;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; getPathMap() {
<b class="fc">&nbsp;                    return pathMap;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation collector for a type variable with an index.
&nbsp;                 */
&nbsp;                public static class WithIndex extends AbstractBase.ForTypeVariable.WithIndex {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target collection.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation collector.
&nbsp;                     *
&nbsp;                     * @param descriptor     The annotation descriptor.
&nbsp;                     * @param typePath       The type variable&#39;s type path.
&nbsp;                     * @param index          The target index.
&nbsp;                     * @param indexedPathMap The target collection.
&nbsp;                     */
&nbsp;                    protected WithIndex(String descriptor,
&nbsp;                                        @MaybeNull TypePath typePath,
&nbsp;                                        int index,
&nbsp;                                        Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; indexedPathMap) {
<b class="fc">&nbsp;                        super(descriptor, typePath, index);</b>
<b class="fc">&nbsp;                        this.indexedPathMap = indexedPathMap;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; getIndexedPathMap() {
<b class="fc">&nbsp;                        return indexedPathMap;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotation collector for a type variable with two indices.
&nbsp;                     */
&nbsp;                    public static class DoubleIndexed extends AbstractBase.ForTypeVariable.WithIndex.DoubleIndexed {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The target collection.
&nbsp;                         */
&nbsp;                        private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexedPathMap;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotation collector.
&nbsp;                         *
&nbsp;                         * @param descriptor           The annotation descriptor.
&nbsp;                         * @param typePath             The type variable&#39;s type path.
&nbsp;                         * @param index                The target index.
&nbsp;                         * @param preIndex             The initial target index.
&nbsp;                         * @param doubleIndexedPathMap The target collection.
&nbsp;                         */
&nbsp;                        protected DoubleIndexed(String descriptor,
&nbsp;                                                @MaybeNull TypePath typePath,
&nbsp;                                                int index,
&nbsp;                                                int preIndex,
&nbsp;                                                Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; doubleIndexedPathMap) {
<b class="fc">&nbsp;                            super(descriptor, typePath, index, preIndex);</b>
<b class="fc">&nbsp;                            this.doubleIndexedPathMap = doubleIndexedPathMap;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; getDoubleIndexedPathMap() {
<b class="fc">&nbsp;                            return doubleIndexedPathMap;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A component type locator allows for the lazy location of an array&#39;s component type.
&nbsp;         */
&nbsp;        protected interface ComponentTypeLocator {
&nbsp;
&nbsp;            /**
&nbsp;             * Binds this component type to a given property name of an annotation.
&nbsp;             *
&nbsp;             * @param name The name of an annotation property which the returned component type reference should
&nbsp;             *             query for resolving an array&#39;s component type.
&nbsp;             * @return A component type reference to an annotation value&#39;s component type.
&nbsp;             */
&nbsp;            ComponentTypeReference bind(String name);
&nbsp;
&nbsp;            /**
&nbsp;             * A component type locator which cannot legally resolve an array&#39;s component type.
&nbsp;             */
<b class="fc">&nbsp;            enum Illegal implements ComponentTypeLocator {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ComponentTypeReference bind(String name) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected lookup of component type for &quot; + name);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A component type locator that lazily analyses an annotation for resolving an annotation property&#39;s
&nbsp;             * array value&#39;s component type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            class ForAnnotationProperty implements ComponentTypeLocator {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to query for type descriptions.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the annotation to analyze.
&nbsp;                 */
&nbsp;                private final String annotationName;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new component type locator for an array value.
&nbsp;                 *
&nbsp;                 * @param typePool             The type pool to be used for looking up linked types.
&nbsp;                 * @param annotationDescriptor A descriptor of the annotation to analyze.
&nbsp;                 */
<b class="fc">&nbsp;                public ForAnnotationProperty(TypePool typePool, String annotationDescriptor) {</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    annotationName = annotationDescriptor.substring(1, annotationDescriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ComponentTypeReference bind(String name) {
<b class="fc">&nbsp;                    return new Bound(name);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound representation of a
&nbsp;                 * {@link net.bytebuddy.pool.TypePool.Default.ComponentTypeLocator.ForAnnotationProperty}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class Bound implements ComponentTypeReference {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the annotation property.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new bound component type locator for an annotation property.
&nbsp;                     *
&nbsp;                     * @param name The name of the annotation property.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Bound(String name) {</b>
<b class="fc">&nbsp;                        this.name = name;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public String resolve() {
<b class="fc">&nbsp;                        TypeDescription componentType = typePool.describe(annotationName)</b>
<b class="fc">&nbsp;                                .resolve()</b>
<b class="fc">&nbsp;                                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(named(name))</b>
<b class="fc">&nbsp;                                .getOnly()</b>
<b class="fc">&nbsp;                                .getReturnType()</b>
<b class="fc">&nbsp;                                .asErasure()</b>
<b class="fc">&nbsp;                                .getComponentType();</b>
<b class="fc">&nbsp;                        return componentType == null</b>
<b class="fc">&nbsp;                                ? NO_ARRAY</b>
<b class="fc">&nbsp;                                : componentType.getName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A component type locator that locates an array type by a method&#39;s return value from its method descriptor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForArrayType implements ComponentTypeLocator, ComponentTypeReference {
&nbsp;
&nbsp;                /**
&nbsp;                 * The resolved component type&#39;s binary name.
&nbsp;                 */
&nbsp;                private final String componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new component type locator for an array type.
&nbsp;                 *
&nbsp;                 * @param methodDescriptor The method descriptor to resolve.
&nbsp;                 */
<b class="fc">&nbsp;                public ForArrayType(String methodDescriptor) {</b>
<b class="fc">&nbsp;                    String arrayType = Type.getMethodType(methodDescriptor).getReturnType().getClassName();</b>
<b class="fc">&nbsp;                    componentType = arrayType.substring(0, arrayType.length() - 2);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ComponentTypeReference bind(String name) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String resolve() {
<b class="fc">&nbsp;                    return componentType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type registrant allows to register a generic type token.
&nbsp;         */
&nbsp;        protected interface GenericTypeRegistrant {
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a discovered generic type token.
&nbsp;             *
&nbsp;             * @param token The token to be registered.
&nbsp;             */
&nbsp;            void register(LazyTypeDescription.GenericTypeToken token);
&nbsp;
&nbsp;            /**
&nbsp;             * A signature visitor that rejects any discovered generic type.
&nbsp;             */
&nbsp;            class RejectingSignatureVisitor extends SignatureVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The message of the error message.
&nbsp;                 */
&nbsp;                private static final String MESSAGE = &quot;Unexpected token in generic signature&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new rejecting signature visitor.
&nbsp;                 */
&nbsp;                public RejectingSignatureVisitor() {
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitFormalTypeParameter(String name) {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitClassBound() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitInterfaceBound() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitSuperclass() {
<b class="fc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitInterface() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitParameterType() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitReturnType() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitExceptionType() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitBaseType(char descriptor) {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitTypeVariable(String name) {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitArrayType() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitClassType(String name) {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitInnerClassType(String name) {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitTypeArgument() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitTypeArgument(char wildcard) {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitEnd() {
<b class="nc">&nbsp;                    throw new IllegalStateException(MESSAGE);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A bag for collecting parameter meta information that is stored as debug information for implemented
&nbsp;         * methods.
&nbsp;         */
&nbsp;        protected static class ParameterBag {
&nbsp;
&nbsp;            /**
&nbsp;             * An array of the method&#39;s parameter types.
&nbsp;             */
&nbsp;            private final Type[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * A map containing the tokens that were collected until now.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, String&gt; parameterRegistry;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new bag.
&nbsp;             *
&nbsp;             * @param parameterType An array of parameter types for the method on which this parameter bag
&nbsp;             *                      is used.
&nbsp;             */
<b class="fc">&nbsp;            protected ParameterBag(Type[] parameterType) {</b>
<b class="fc">&nbsp;                this.parameterType = parameterType;</b>
<b class="fc">&nbsp;                parameterRegistry = new HashMap&lt;Integer, String&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a new parameter.
&nbsp;             *
&nbsp;             * @param offset The offset of the registered entry on the local variable array of the method.
&nbsp;             * @param name   The name of the parameter.
&nbsp;             */
&nbsp;            protected void register(int offset, String name) {
<b class="fc">&nbsp;                parameterRegistry.put(offset, name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the collected parameters as a list of parameter tokens.
&nbsp;             *
&nbsp;             * @param isStatic {@code true} if the analyzed method is static.
&nbsp;             * @return A list of parameter tokens based on the collected information.
&nbsp;             */
&nbsp;            protected List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; resolve(boolean isStatic) {
<b class="fc">&nbsp;                List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; parameterTokens = new ArrayList&lt;LazyTypeDescription.MethodToken.ParameterToken&gt;(parameterType.length);</b>
<b class="fc">&nbsp;                int offset = isStatic</b>
<b class="fc">&nbsp;                        ? StackSize.ZERO.getSize()</b>
<b class="fc">&nbsp;                        : StackSize.SINGLE.getSize();</b>
<b class="fc">&nbsp;                for (Type aParameterType : parameterType) {</b>
<b class="fc">&nbsp;                    String name = this.parameterRegistry.get(offset);</b>
<b class="fc">&nbsp;                    parameterTokens.add(name == null</b>
<b class="fc">&nbsp;                            ? new LazyTypeDescription.MethodToken.ParameterToken()</b>
<b class="fc">&nbsp;                            : new LazyTypeDescription.MethodToken.ParameterToken(name));</b>
<b class="fc">&nbsp;                    offset += aParameterType.getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                return parameterTokens;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A generic type extractor allows for an iterative extraction of generic type information.
&nbsp;         */
&nbsp;        protected static class GenericTypeExtractor extends GenericTypeRegistrant.RejectingSignatureVisitor implements GenericTypeRegistrant {
&nbsp;
&nbsp;            /**
&nbsp;             * A registrant that receives any discovered type.
&nbsp;             */
&nbsp;            private final GenericTypeRegistrant genericTypeRegistrant;
&nbsp;
&nbsp;            /**
&nbsp;             * The current token that is in the process of creation.
&nbsp;             */
&nbsp;            @UnknownNull
&nbsp;            private IncompleteToken incompleteToken;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new generic type extractor.
&nbsp;             *
&nbsp;             * @param genericTypeRegistrant The target to receive the complete type.
&nbsp;             */
<b class="fc">&nbsp;            protected GenericTypeExtractor(GenericTypeRegistrant genericTypeRegistrant) {</b>
<b class="fc">&nbsp;                this.genericTypeRegistrant = genericTypeRegistrant;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void visitBaseType(char descriptor) {
<b class="fc">&nbsp;                genericTypeRegistrant.register(LazyTypeDescription.GenericTypeToken.ForPrimitiveType.of(descriptor));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void visitTypeVariable(String name) {
<b class="fc">&nbsp;                genericTypeRegistrant.register(new LazyTypeDescription.GenericTypeToken.ForTypeVariable(name));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SignatureVisitor visitArrayType() {
<b class="fc">&nbsp;                return new GenericTypeExtractor(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void register(LazyTypeDescription.GenericTypeToken componentTypeToken) {
<b class="fc">&nbsp;                genericTypeRegistrant.register(new LazyTypeDescription.GenericTypeToken.ForGenericArray(componentTypeToken));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void visitClassType(String name) {
<b class="fc">&nbsp;                incompleteToken = new IncompleteToken.ForTopLevelType(name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void visitInnerClassType(String name) {
<b class="fc">&nbsp;                incompleteToken = new IncompleteToken.ForInnerClass(name, incompleteToken);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void visitTypeArgument() {
<b class="fc">&nbsp;                incompleteToken.appendPlaceholder();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public SignatureVisitor visitTypeArgument(char wildcard) {
<b class="fc">&nbsp;                switch (wildcard) {</b>
&nbsp;                    case SignatureVisitor.SUPER:
<b class="fc">&nbsp;                        return incompleteToken.appendLowerBound();</b>
&nbsp;                    case SignatureVisitor.EXTENDS:
<b class="fc">&nbsp;                        return incompleteToken.appendUpperBound();</b>
&nbsp;                    case SignatureVisitor.INSTANCEOF:
<b class="fc">&nbsp;                        return incompleteToken.appendDirectBound();</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Unknown wildcard: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void visitEnd() {
<b class="fc">&nbsp;                genericTypeRegistrant.register(incompleteToken.toToken());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An incomplete {@link LazyTypeDescription.GenericTypeToken}.
&nbsp;             */
&nbsp;            protected interface IncompleteToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends a lower bound to this token.
&nbsp;                 *
&nbsp;                 * @return A signature visitor for visiting the lower bound&#39;s type.
&nbsp;                 */
&nbsp;                SignatureVisitor appendLowerBound();
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends an upper bound to this token.
&nbsp;                 *
&nbsp;                 * @return A signature visitor for visiting the upper bound&#39;s type.
&nbsp;                 */
&nbsp;                SignatureVisitor appendUpperBound();
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends a direct bound to this token.
&nbsp;                 *
&nbsp;                 * @return A signature visitor for visiting the direct bound&#39;s type.
&nbsp;                 */
&nbsp;                SignatureVisitor appendDirectBound();
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends a placeholder to this token.
&nbsp;                 */
&nbsp;                void appendPlaceholder();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if this token describes a type with parameters.
&nbsp;                 *
&nbsp;                 * @return {@code true} if this token describes a type with parameters.
&nbsp;                 */
&nbsp;                boolean isParameterized();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the name of this token.
&nbsp;                 *
&nbsp;                 * @return The name of this token.
&nbsp;                 */
&nbsp;                String getName();
&nbsp;
&nbsp;                /**
&nbsp;                 * Converts this incomplete token to a completed token.
&nbsp;                 *
&nbsp;                 * @return The finalized token.
&nbsp;                 */
&nbsp;                LazyTypeDescription.GenericTypeToken toToken();
&nbsp;
&nbsp;                /**
&nbsp;                 * An abstract base implementation of an incomplete token.
&nbsp;                 */
&nbsp;                abstract class AbstractBase implements IncompleteToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The parameters of this token.
&nbsp;                     */
&nbsp;                    protected final List&lt;LazyTypeDescription.GenericTypeToken&gt; parameters;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new base implementation of an incomplete token.
&nbsp;                     */
<b class="fc">&nbsp;                    public AbstractBase() {</b>
<b class="fc">&nbsp;                        parameters = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor appendDirectBound() {
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new ForDirectBound());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor appendUpperBound() {
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new ForUpperBound());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor appendLowerBound() {
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new ForLowerBound());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void appendPlaceholder() {
<b class="fc">&nbsp;                        parameters.add(LazyTypeDescription.GenericTypeToken.ForUnboundWildcard.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token for registering a direct bound.
&nbsp;                     */
<b class="fc">&nbsp;                    protected class ForDirectBound implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            parameters.add(token);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token for registering a wildcard with an upper bound.
&nbsp;                     */
<b class="fc">&nbsp;                    protected class ForUpperBound implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            parameters.add(new LazyTypeDescription.GenericTypeToken.ForUpperBoundWildcard(token));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token for registering a wildcard with a lower bound.
&nbsp;                     */
<b class="fc">&nbsp;                    protected class ForLowerBound implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            parameters.add(new LazyTypeDescription.GenericTypeToken.ForLowerBoundWildcard(token));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An incomplete token representing a generic type without an outer type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForTopLevelType extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The internal name of the type.
&nbsp;                     */
&nbsp;                    private final String internalName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new incomplete token representing a type without an outer type.
&nbsp;                     *
&nbsp;                     * @param internalName The internal name of the type.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForTopLevelType(String internalName) {</b>
<b class="fc">&nbsp;                        this.internalName = internalName;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public LazyTypeDescription.GenericTypeToken toToken() {
<b class="fc">&nbsp;                        return isParameterized()</b>
<b class="fc">&nbsp;                                ? new LazyTypeDescription.GenericTypeToken.ForParameterizedType(getName(), parameters)</b>
<b class="fc">&nbsp;                                : new LazyTypeDescription.GenericTypeToken.ForRawType(getName());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isParameterized() {
<b class="fc">&nbsp;                        return !parameters.isEmpty();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getName() {
<b class="fc">&nbsp;                        return internalName.replace(&#39;/&#39;, &#39;.&#39;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An incomplete generic type token representing a type with an outer type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForInnerClass extends AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The separator that indicates an inner type.
&nbsp;                     */
&nbsp;                    private static final char INNER_CLASS_SEPARATOR = &#39;$&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The internal name of the type.
&nbsp;                     */
&nbsp;                    private final String internalName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The token representing the outer type.
&nbsp;                     */
&nbsp;                    private final IncompleteToken outerTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new incomplete token representing a type without an outer type.
&nbsp;                     *
&nbsp;                     * @param internalName   The internal name of the type.
&nbsp;                     * @param outerTypeToken The incomplete token representing the outer type.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForInnerClass(String internalName, IncompleteToken outerTypeToken) {</b>
<b class="fc">&nbsp;                        this.internalName = internalName;</b>
<b class="fc">&nbsp;                        this.outerTypeToken = outerTypeToken;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public LazyTypeDescription.GenericTypeToken toToken() {
<b class="fc">&nbsp;                        return isParameterized() || outerTypeToken.isParameterized()</b>
<b class="fc">&nbsp;                                ? new LazyTypeDescription.GenericTypeToken.ForParameterizedType.Nested(getName(), parameters, outerTypeToken.toToken())</b>
<b class="nc">&nbsp;                                : new LazyTypeDescription.GenericTypeToken.ForRawType(getName());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isParameterized() {
<b class="fc">&nbsp;                        return !parameters.isEmpty() || !outerTypeToken.isParameterized();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getName() {
<b class="fc">&nbsp;                        return outerTypeToken.getName() + INNER_CLASS_SEPARATOR + internalName.replace(&#39;/&#39;, &#39;.&#39;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A signature visitor for extracting a generic type resolution.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The type of the resolution this visitor extracts.
&nbsp;             */
&nbsp;            protected abstract static class ForSignature&lt;T extends LazyTypeDescription.GenericTypeToken.Resolution&gt;
&nbsp;                    extends RejectingSignatureVisitor
&nbsp;                    implements GenericTypeRegistrant {
&nbsp;
&nbsp;                /**
&nbsp;                 * The resolved type variable tokens.
&nbsp;                 */
&nbsp;                protected final List&lt;LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the currently constructed type.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                protected String currentTypeParameter;
&nbsp;
&nbsp;                /**
&nbsp;                 * The bounds of the currently constructed type.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                protected List&lt;LazyTypeDescription.GenericTypeToken&gt; currentBounds;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new signature visitor.
&nbsp;                 */
<b class="fc">&nbsp;                public ForSignature() {</b>
<b class="fc">&nbsp;                    typeVariableTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken.OfFormalTypeVariable&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies an extraction of a generic signature given the supplied visitor.
&nbsp;                 *
&nbsp;                 * @param genericSignature The generic signature to interpret.
&nbsp;                 * @param visitor          The visitor to apply.
&nbsp;                 * @param &lt;S&gt;              The type of the generated resolution.
&nbsp;                 * @return The resolution of the supplied signature.
&nbsp;                 */
&nbsp;                protected static &lt;S extends LazyTypeDescription.GenericTypeToken.Resolution&gt; S extract(String genericSignature, ForSignature&lt;S&gt; visitor) {
<b class="fc">&nbsp;                    SignatureReader signatureReader = new SignatureReader(genericSignature);</b>
<b class="fc">&nbsp;                    signatureReader.accept(visitor);</b>
<b class="fc">&nbsp;                    return visitor.resolve();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void visitFormalTypeParameter(String name) {
<b class="fc">&nbsp;                    collectTypeParameter();</b>
<b class="fc">&nbsp;                    currentTypeParameter = name;</b>
<b class="fc">&nbsp;                    currentBounds = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitClassBound() {
<b class="fc">&nbsp;                    return new GenericTypeExtractor(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor visitInterfaceBound() {
<b class="fc">&nbsp;                    return new GenericTypeExtractor(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                    if (currentBounds == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Did not expect &quot; + token + &quot; before finding formal parameter&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    currentBounds.add(token);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Collects the currently constructed type.
&nbsp;                 */
&nbsp;                protected void collectTypeParameter() {
<b class="fc">&nbsp;                    if (currentTypeParameter != null) {</b>
<b class="fc">&nbsp;                        typeVariableTokens.add(new LazyTypeDescription.GenericTypeToken.ForTypeVariable.Formal(currentTypeParameter, currentBounds));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Completes the current resolution.
&nbsp;                 *
&nbsp;                 * @return The resolved generic signature.
&nbsp;                 */
&nbsp;                public abstract T resolve();
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic type signature.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class OfType extends ForSignature&lt;LazyTypeDescription.GenericTypeToken.Resolution.ForType&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The interface type&#39;s generic signatures.
&nbsp;                     */
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; interfaceTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The super type&#39;s generic signature.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private LazyTypeDescription.GenericTypeToken superClassToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new parser for a type signature.
&nbsp;                     */
<b class="fc">&nbsp;                    protected OfType() {</b>
<b class="fc">&nbsp;                        interfaceTypeTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic type resolution of a type signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted type signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForType extract(@MaybeNull String genericSignature) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return genericSignature == null</b>
<b class="fc">&nbsp;                                    ? LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE</b>
<b class="fc">&nbsp;                                    : ForSignature.extract(genericSignature, new OfType());</b>
<b class="fc">&nbsp;                        } catch (RuntimeException ignored) {</b>
<b class="fc">&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor visitSuperclass() {
<b class="fc">&nbsp;                        collectTypeParameter();</b>
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new SuperClassRegistrant());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor visitInterface() {
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new InterfaceTypeRegistrant());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public LazyTypeDescription.GenericTypeToken.Resolution.ForType resolve() {
<b class="fc">&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForType.Tokenized(superClassToken, interfaceTypeTokens, typeVariableTokens);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for the super type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                    protected class SuperClassRegistrant implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            superClassToken = token;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for the interface types.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                    protected class InterfaceTypeRegistrant implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            interfaceTypeTokens.add(token);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic field signature.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class OfField implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic field type.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private LazyTypeDescription.GenericTypeToken fieldTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic field resolution of a field signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted field signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForField extract(@MaybeNull String genericSignature) {
<b class="fc">&nbsp;                        if (genericSignature == null) {</b>
<b class="fc">&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            SignatureReader signatureReader = new SignatureReader(genericSignature);</b>
<b class="fc">&nbsp;                            OfField visitor = new OfField();</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                signatureReader.acceptType(new GenericTypeExtractor(visitor));</b>
<b class="fc">&nbsp;                                return visitor.resolve();</b>
<b class="fc">&nbsp;                            } catch (RuntimeException ignored) {</b>
<b class="fc">&nbsp;                                return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                        fieldTypeToken = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Completes the current resolution.
&nbsp;                     *
&nbsp;                     * @return The resolved generic signature.
&nbsp;                     */
&nbsp;                    protected LazyTypeDescription.GenericTypeToken.Resolution.ForField resolve() {
<b class="fc">&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForField.Tokenized(fieldTypeToken);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic method signature.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class OfMethod extends ForSignature&lt;LazyTypeDescription.GenericTypeToken.Resolution.ForMethod&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic parameter types.
&nbsp;                     */
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic exception types.
&nbsp;                     */
&nbsp;                    private final List&lt;LazyTypeDescription.GenericTypeToken&gt; exceptionTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic return type.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private LazyTypeDescription.GenericTypeToken returnTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parser for a generic method signature.
&nbsp;                     */
<b class="fc">&nbsp;                    public OfMethod() {</b>
<b class="fc">&nbsp;                        parameterTypeTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();</b>
<b class="fc">&nbsp;                        exceptionTypeTokens = new ArrayList&lt;LazyTypeDescription.GenericTypeToken&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic method resolution of a method signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted method signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForMethod extract(@MaybeNull String genericSignature) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return genericSignature == null</b>
<b class="fc">&nbsp;                                    ? LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE</b>
<b class="fc">&nbsp;                                    : ForSignature.extract(genericSignature, new OfMethod());</b>
<b class="fc">&nbsp;                        } catch (RuntimeException ignored) {</b>
<b class="fc">&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor visitParameterType() {
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new ParameterTypeRegistrant());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor visitReturnType() {
<b class="fc">&nbsp;                        collectTypeParameter();</b>
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new ReturnTypeTypeRegistrant());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor visitExceptionType() {
<b class="fc">&nbsp;                        return new GenericTypeExtractor(new ExceptionTypeRegistrant());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public LazyTypeDescription.GenericTypeToken.Resolution.ForMethod resolve() {
<b class="fc">&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForMethod.Tokenized(returnTypeToken,</b>
&nbsp;                                parameterTypeTokens,
&nbsp;                                exceptionTypeTokens,
&nbsp;                                typeVariableTokens);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for a parameter type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                    protected class ParameterTypeRegistrant implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            parameterTypeTokens.add(token);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for a return type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                    protected class ReturnTypeTypeRegistrant implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            returnTypeToken = token;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A registrant for an exception type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
<b class="fc">&nbsp;                    protected class ExceptionTypeRegistrant implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                            exceptionTypeTokens.add(token);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A parser for a generic field signature.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class OfRecordComponent implements GenericTypeRegistrant {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic field type.
&nbsp;                     */
&nbsp;                    @UnknownNull
&nbsp;                    private LazyTypeDescription.GenericTypeToken recordComponentType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Extracts a generic field resolution of a field signature.
&nbsp;                     *
&nbsp;                     * @param genericSignature The signature to interpret.
&nbsp;                     * @return The interpreted field signature.
&nbsp;                     */
&nbsp;                    public static LazyTypeDescription.GenericTypeToken.Resolution.ForRecordComponent extract(@MaybeNull String genericSignature) {
<b class="fc">&nbsp;                        if (genericSignature == null) {</b>
<b class="nc">&nbsp;                            return LazyTypeDescription.GenericTypeToken.Resolution.Raw.INSTANCE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            SignatureReader signatureReader = new SignatureReader(genericSignature);</b>
<b class="fc">&nbsp;                            OfRecordComponent visitor = new OfRecordComponent();</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                signatureReader.acceptType(new GenericTypeExtractor(visitor));</b>
<b class="fc">&nbsp;                                return visitor.resolve();</b>
<b class="nc">&nbsp;                            } catch (RuntimeException ignored) {</b>
<b class="nc">&nbsp;                                return LazyTypeDescription.GenericTypeToken.Resolution.Malformed.INSTANCE;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(LazyTypeDescription.GenericTypeToken token) {
<b class="fc">&nbsp;                        recordComponentType = token;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Completes the current resolution.
&nbsp;                     *
&nbsp;                     * @return The resolved generic signature.
&nbsp;                     */
&nbsp;                    protected LazyTypeDescription.GenericTypeToken.Resolution.ForRecordComponent resolve() {
<b class="fc">&nbsp;                        return new LazyTypeDescription.GenericTypeToken.Resolution.ForRecordComponent.Tokenized(recordComponentType);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type description that looks up any referenced {@link net.bytebuddy.description.ByteCodeElement} or
&nbsp;         * {@link AnnotationDescription} by querying a type pool at lookup time.
&nbsp;         */
<b class="fc">&nbsp;        protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a type does not exist and does therefore not have a name.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final String NO_TYPE = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to be used for looking up linked types.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The actual modifiers of this type.
&nbsp;             */
&nbsp;            private final int actualModifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The modifiers of this type.
&nbsp;             */
&nbsp;            private final int modifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of this type.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s super type&#39;s descriptor or {@code null} if this type does not define a super type.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String superClassDescriptor;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s generic signature as found in the class file or {@code null} if the type is not generic.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String genericSignature;
&nbsp;
&nbsp;            /**
&nbsp;             * The resolution of this type&#39;s generic type.
&nbsp;             */
&nbsp;            private final GenericTypeToken.Resolution.ForType signatureResolution;
&nbsp;
&nbsp;            /**
&nbsp;             * The descriptor of this type&#39;s interfaces.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; interfaceTypeDescriptors;
&nbsp;
&nbsp;            /**
&nbsp;             * A definition of this type&#39;s containment within another type or method.
&nbsp;             */
&nbsp;            private final TypeContainment typeContainment;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of this type&#39;s declaring type or {@code null} if no such type exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String declaringTypeName;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of descriptors representing the types that are declared by this type.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; declaredTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this type is an anonymous type.
&nbsp;             */
&nbsp;            private final boolean anonymousType;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of the nest host or {@code null} if no nest host was specified.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final String nestHost;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of binary names of all specified nest members.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; nestMembers;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the super class&#39;s annotation tokens.
&nbsp;             */
&nbsp;            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; superClassAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of type annotations for this type&#39;s interface types by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; interfaceAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of type annotations of the type variables&#39; type annotations by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of type annotations of the type variables&#39; bounds&#39; type annotations by their indices and each variable&#39;s index.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of tokens that represent the annotations of this type.
&nbsp;             */
&nbsp;            private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of field tokens describing the field&#39;s of this type.
&nbsp;             */
&nbsp;            private final List&lt;FieldToken&gt; fieldTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of method tokens describing the method&#39;s of this type.
&nbsp;             */
&nbsp;            private final List&lt;MethodToken&gt; methodTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of record component tokens describing the record components of this type.
&nbsp;             */
&nbsp;            private final List&lt;RecordComponentToken&gt; recordComponentTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of internal names of permitted subclasses.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; permittedSubclasses;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s class file version.
&nbsp;             */
&nbsp;            private final ClassFileVersion classFileVersion;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new lazy type description.
&nbsp;             *
&nbsp;             * @param typePool                           The type pool to be used for looking up linked types.
&nbsp;             * @param actualModifiers                    The actual modifiers of this type.
&nbsp;             * @param modifiers                          The modifiers of this type.
&nbsp;             * @param name                               The binary name of this type.
&nbsp;             * @param superClassInternalName             The internal name of this type&#39;s super type or {@code null} if no such super type is defined.
&nbsp;             * @param interfaceInternalName              An array of this type&#39;s interfaces or {@code null} if this type does not define any interfaces.
&nbsp;             * @param genericSignature                   The type&#39;s generic signature as found in the class file or {@code null} if the type is not generic.
&nbsp;             * @param typeContainment                    A definition of this type&#39;s containment within another type or method.
&nbsp;             * @param declaringTypeInternalName          The internal name of this type&#39;s declaring type or {@code null} if no such type exists.
&nbsp;             * @param declaredTypes                      A list of descriptors representing the types that are declared by this type.
&nbsp;             * @param anonymousType                      {@code true} if this type is an anonymous type.
&nbsp;             * @param nestHostInternalName               The internal name of the nest host or {@code null} if no nest host was specified.
&nbsp;             * @param nestMemberInternalNames            A list of internal names of the nest members.
&nbsp;             * @param superClassAnnotationTokens         A mapping of the super class&#39;s annotation tokens.
&nbsp;             * @param interfaceAnnotationTokens          A mapping of type annotations for this type&#39;s interface types by their indices.
&nbsp;             * @param typeVariableAnnotationTokens       A mapping of type annotations of the type variables&#39; type annotations by their indices.
&nbsp;             * @param typeVariableBoundsAnnotationTokens A mapping of type annotations of the type variables&#39; bounds&#39; type annotations by their indices
&nbsp;             *                                           and each variable&#39;s index.
&nbsp;             * @param annotationTokens                   A list of tokens that represent the annotations of this type.
&nbsp;             * @param fieldTokens                        A list of field tokens describing the field&#39;s of this type.
&nbsp;             * @param methodTokens                       A list of method tokens describing the method&#39;s of this type.
&nbsp;             * @param recordComponentTokens              A list of record component tokens describing the record components of this type.
&nbsp;             * @param permittedSubclasses                A list of internal names of permitted subclasses.
&nbsp;             * @param classFileVersion                   The type&#39;s class file version.
&nbsp;             */
&nbsp;            protected LazyTypeDescription(TypePool typePool,
&nbsp;                                          int actualModifiers,
&nbsp;                                          int modifiers,
&nbsp;                                          String name,
&nbsp;                                          @MaybeNull String superClassInternalName,
&nbsp;                                          @MaybeNull String[] interfaceInternalName,
&nbsp;                                          @MaybeNull String genericSignature,
&nbsp;                                          TypeContainment typeContainment,
&nbsp;                                          @MaybeNull String declaringTypeInternalName,
&nbsp;                                          List&lt;String&gt; declaredTypes,
&nbsp;                                          boolean anonymousType,
&nbsp;                                          @MaybeNull String nestHostInternalName,
&nbsp;                                          List&lt;String&gt; nestMemberInternalNames,
&nbsp;                                          Map&lt;String, List&lt;AnnotationToken&gt;&gt; superClassAnnotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; interfaceAnnotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens,
&nbsp;                                          List&lt;AnnotationToken&gt; annotationTokens,
&nbsp;                                          List&lt;FieldToken&gt; fieldTokens,
&nbsp;                                          List&lt;MethodToken&gt; methodTokens,
&nbsp;                                          List&lt;RecordComponentToken&gt; recordComponentTokens,
&nbsp;                                          List&lt;String&gt; permittedSubclasses,
<b class="fc">&nbsp;                                          ClassFileVersion classFileVersion) {</b>
<b class="fc">&nbsp;                this.typePool = typePool;</b>
<b class="fc">&nbsp;                this.actualModifiers = actualModifiers &amp; ~Opcodes.ACC_SUPER;</b>
<b class="fc">&nbsp;                this.modifiers = modifiers &amp; ~(Opcodes.ACC_SUPER | Opcodes.ACC_DEPRECATED);</b>
<b class="fc">&nbsp;                this.name = Type.getObjectType(name).getClassName();</b>
<b class="fc">&nbsp;                this.superClassDescriptor = superClassInternalName == null</b>
<b class="fc">&nbsp;                        ? NO_TYPE</b>
<b class="fc">&nbsp;                        : Type.getObjectType(superClassInternalName).getDescriptor();</b>
<b class="fc">&nbsp;                this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                signatureResolution = RAW_TYPES</b>
<b class="nc">&nbsp;                        ? GenericTypeToken.Resolution.Raw.INSTANCE</b>
<b class="fc">&nbsp;                        : GenericTypeExtractor.ForSignature.OfType.extract(genericSignature);</b>
<b class="fc">&nbsp;                if (interfaceInternalName == null) {</b>
<b class="nc">&nbsp;                    interfaceTypeDescriptors = Collections.emptyList();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    interfaceTypeDescriptors = new ArrayList&lt;String&gt;(interfaceInternalName.length);</b>
<b class="fc">&nbsp;                    for (String internalName : interfaceInternalName) {</b>
<b class="fc">&nbsp;                        interfaceTypeDescriptors.add(Type.getObjectType(internalName).getDescriptor());</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                this.typeContainment = typeContainment;</b>
<b class="fc">&nbsp;                declaringTypeName = declaringTypeInternalName == null</b>
<b class="fc">&nbsp;                        ? NO_TYPE</b>
<b class="fc">&nbsp;                        : declaringTypeInternalName.replace(&#39;/&#39;, &#39;.&#39;);</b>
<b class="fc">&nbsp;                this.declaredTypes = declaredTypes;</b>
<b class="fc">&nbsp;                this.anonymousType = anonymousType;</b>
<b class="fc">&nbsp;                nestHost = nestHostInternalName == null</b>
<b class="fc">&nbsp;                        ? NO_TYPE</b>
<b class="fc">&nbsp;                        : Type.getObjectType(nestHostInternalName).getClassName();</b>
<b class="fc">&nbsp;                nestMembers = new ArrayList&lt;String&gt;(nestMemberInternalNames.size());</b>
<b class="fc">&nbsp;                for (String nestMemberInternalName : nestMemberInternalNames) {</b>
<b class="fc">&nbsp;                    nestMembers.add(Type.getObjectType(nestMemberInternalName).getClassName());</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                this.superClassAnnotationTokens = superClassAnnotationTokens;</b>
<b class="fc">&nbsp;                this.interfaceAnnotationTokens = interfaceAnnotationTokens;</b>
<b class="fc">&nbsp;                this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;</b>
<b class="fc">&nbsp;                this.typeVariableBoundsAnnotationTokens = typeVariableBoundsAnnotationTokens;</b>
<b class="fc">&nbsp;                this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                this.fieldTokens = fieldTokens;</b>
<b class="fc">&nbsp;                this.methodTokens = methodTokens;</b>
<b class="fc">&nbsp;                this.recordComponentTokens = recordComponentTokens;</b>
<b class="fc">&nbsp;                this.permittedSubclasses = new ArrayList&lt;String&gt;(permittedSubclasses.size());</b>
<b class="fc">&nbsp;                for (String internalName : permittedSubclasses) {</b>
<b class="fc">&nbsp;                    this.permittedSubclasses.add(Type.getObjectType(internalName).getDescriptor());</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                this.classFileVersion = classFileVersion;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                return superClassDescriptor == null || isInterface()</b>
<b class="fc">&nbsp;                        ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                        : signatureResolution.resolveSuperClass(superClassDescriptor, typePool, superClassAnnotationTokens, this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                return signatureResolution.resolveInterfaceTypes(interfaceTypeDescriptors, typePool, interfaceAnnotationTokens, this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;                return typeContainment.getEnclosingMethod(typePool);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;                return typeContainment.getEnclosingType(typePool);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;                return new LazyTypeList(typePool, declaredTypes);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isAnonymousType() {
<b class="fc">&nbsp;                return anonymousType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isLocalType() {
<b class="fc">&nbsp;                return !anonymousType &amp;&amp; typeContainment.isLocalType();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                return new FieldTokenList();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                return new MethodTokenList();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public PackageDescription getPackage() {
<b class="fc">&nbsp;                String name = getName();</b>
<b class="fc">&nbsp;                int index = name.lastIndexOf(&#39;.&#39;);</b>
<b class="fc">&nbsp;                return new LazyPackageDescription(typePool, index == -1</b>
<b class="fc">&nbsp;                        ? EMPTY_NAME</b>
<b class="fc">&nbsp;                        : name.substring(0, index));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getName() {
<b class="fc">&nbsp;                return name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                return declaringTypeName == null</b>
<b class="fc">&nbsp;                        ? TypeDescription.UNDEFINED</b>
<b class="fc">&nbsp;                        : typePool.describe(declaringTypeName).resolve();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getModifiers() {
<b class="fc">&nbsp;                return modifiers;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getActualModifiers(boolean superFlag) {
<b class="fc">&nbsp;                return superFlag ? (actualModifiers | Opcodes.ACC_SUPER) : actualModifiers;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getNestHost() {
<b class="fc">&nbsp;                return nestHost == null</b>
<b class="fc">&nbsp;                        ? this</b>
<b class="nc">&nbsp;                        : typePool.describe(nestHost).resolve();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList getNestMembers() {
<b class="fc">&nbsp;                return nestHost == null</b>
<b class="fc">&nbsp;                        ? new LazyNestMemberList(this, typePool, nestMembers)</b>
<b class="nc">&nbsp;                        : typePool.describe(nestHost).resolve().getNestMembers();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                return LazyAnnotationDescription.asList(typePool, annotationTokens);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                return signatureResolution.resolveTypeVariables(typePool, this, typeVariableAnnotationTokens, typeVariableBoundsAnnotationTokens);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            public String getGenericSignature() {
<b class="fc">&nbsp;                return genericSignature;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="fc">&nbsp;                return new RecordComponentTokenList();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="fc">&nbsp;                return (actualModifiers &amp; Opcodes.ACC_RECORD) != 0 &amp;&amp; JavaType.RECORD.getTypeStub().getDescriptor().equals(superClassDescriptor);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean isSealed() {
<b class="fc">&nbsp;                return !permittedSubclasses.isEmpty();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList getPermittedSubtypes() {
<b class="fc">&nbsp;                return new LazyTypeList(typePool, permittedSubclasses);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public ClassFileVersion getClassFileVersion() {
<b class="nc">&nbsp;                return classFileVersion;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list of field tokens representing each entry as a field description.
&nbsp;             */
<b class="fc">&nbsp;            protected class FieldTokenList extends FieldList.AbstractBase&lt;FieldDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                    return fieldTokens.get(index).toFieldDescription(LazyTypeDescription.this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int size() {
<b class="fc">&nbsp;                    return fieldTokens.size();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list of method tokens representing each entry as a method description.
&nbsp;             */
<b class="fc">&nbsp;            protected class MethodTokenList extends MethodList.AbstractBase&lt;MethodDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                    return methodTokens.get(index).toMethodDescription(LazyTypeDescription.this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int size() {
<b class="fc">&nbsp;                    return methodTokens.size();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list of record component tokens representing each record component as a description.
&nbsp;             */
<b class="fc">&nbsp;            protected class RecordComponentTokenList extends RecordComponentList.AbstractBase&lt;RecordComponentDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                    return recordComponentTokens.get(index).toRecordComponentDescription(LazyTypeDescription.this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int size() {
<b class="fc">&nbsp;                    return recordComponentTokens.size();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A declaration context encapsulates information about whether a type was declared within another type
&nbsp;             * or within a method of another type.
&nbsp;             */
&nbsp;            protected interface TypeContainment {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the enclosing method or {@code null} if no such method exists.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @return A method description describing the linked type or {@code null}.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the enclosing type or {@code null} if no such type exists.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @return A type description describing the linked type or {@code null}.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                TypeDescription getEnclosingType(TypePool typePool);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if the type is self-contained.
&nbsp;                 *
&nbsp;                 * @return {@code true} if the type is self-contained.
&nbsp;                 */
&nbsp;                boolean isSelfContained();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if the type is a local type unless it is an anonymous type.
&nbsp;                 *
&nbsp;                 * @return {@code true} if the type is a local type unless it is an anonymous type
&nbsp;                 */
&nbsp;                boolean isLocalType();
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a type that is not contained within another type, a method or a constructor.
&nbsp;                 */
<b class="fc">&nbsp;                enum SelfContained implements TypeContainment {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool) {
<b class="fc">&nbsp;                        return MethodDescription.UNDEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
<b class="fc">&nbsp;                        return TypeDescription.UNDEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isSelfContained() {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isLocalType() {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a type that is contained within another type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class WithinType implements TypeContainment {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type&#39;s binary name.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the type is a local type unless it is an anonymous type.
&nbsp;                     */
&nbsp;                    private final boolean localType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type containment for a type that is declared within another type.
&nbsp;                     *
&nbsp;                     * @param internalName The type&#39;s internal name.
&nbsp;                     * @param localType    {@code true} if the type is a local type unless it is an anonymous type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected WithinType(String internalName, boolean localType) {</b>
<b class="fc">&nbsp;                        name = internalName.replace(&#39;/&#39;, &#39;.&#39;);</b>
<b class="fc">&nbsp;                        this.localType = localType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool) {
<b class="fc">&nbsp;                        return MethodDescription.UNDEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
<b class="fc">&nbsp;                        return typePool.describe(name).resolve();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isSelfContained() {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isLocalType() {
<b class="fc">&nbsp;                        return localType;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Describes a type that is contained within a method or constructor.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class WithinMethod implements TypeContainment {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method&#39;s declaring type&#39;s internal name.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method&#39;s internal name.
&nbsp;                     */
&nbsp;                    private final String methodName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method&#39;s descriptor.
&nbsp;                     */
&nbsp;                    private final String methodDescriptor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type containment for a type that is declared within a method.
&nbsp;                     *
&nbsp;                     * @param internalName     The method&#39;s declaring type&#39;s internal name.
&nbsp;                     * @param methodName       The method&#39;s internal name.
&nbsp;                     * @param methodDescriptor The method&#39;s descriptor.
&nbsp;                     */
<b class="fc">&nbsp;                    protected WithinMethod(String internalName, String methodName, String methodDescriptor) {</b>
<b class="fc">&nbsp;                        name = internalName.replace(&#39;/&#39;, &#39;.&#39;);</b>
<b class="fc">&nbsp;                        this.methodName = methodName;</b>
<b class="fc">&nbsp;                        this.methodDescriptor = methodDescriptor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription.InDefinedShape getEnclosingMethod(TypePool typePool) {
<b class="fc">&nbsp;                        TypeDescription enclosingType = getEnclosingType(typePool);</b>
<b class="fc">&nbsp;                        if (enclosingType == null) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Could not resolve enclosing type &quot; + name);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; enclosingMethod = enclosingType.getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(hasMethodName(methodName).and(hasDescriptor(methodDescriptor)));</b>
<b class="fc">&nbsp;                        if (enclosingMethod.isEmpty()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(methodName + methodDescriptor + &quot; not declared by &quot; + enclosingType);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return enclosingMethod.getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription getEnclosingType(TypePool typePool) {
<b class="fc">&nbsp;                        return typePool.describe(name).resolve();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isSelfContained() {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isLocalType() {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token that represents a generic Java type.
&nbsp;             */
&nbsp;            protected interface GenericTypeToken {
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an empty type path.
&nbsp;                 */
&nbsp;                String EMPTY_TYPE_PATH = &quot;&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a step to a component type within a type path.
&nbsp;                 */
&nbsp;                char COMPONENT_TYPE_PATH = &#39;[&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a wildcard type step within a type path.
&nbsp;                 */
&nbsp;                char WILDCARD_TYPE_PATH = &#39;*&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a (reversed) step to an inner class within a type path.
&nbsp;                 */
&nbsp;                char INNER_CLASS_PATH = &#39;.&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an index type delimiter within a type path.
&nbsp;                 */
&nbsp;                char INDEXED_TYPE_DELIMITER = &#39;;&#39;;
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this token into a generic type representation.
&nbsp;                 *
&nbsp;                 * @param typePool           The type pool to be used for locating non-generic type descriptions.
&nbsp;                 * @param typeVariableSource The type variable source.
&nbsp;                 * @param typePath           The type path of the resolved generic type.
&nbsp;                 * @param annotationTokens   A mapping of the type&#39;s annotation tokens by their type path.
&nbsp;                 * @return A description of the represented generic type.
&nbsp;                 */
&nbsp;                Generic toGenericType(TypePool typePool,
&nbsp;                                      TypeVariableSource typeVariableSource,
&nbsp;                                      String typePath,
&nbsp;                                      Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens);
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines if a generic type tokens represents a primary bound of a type variable. This method must only be invoked on types
&nbsp;                 * that represent a {@link Sort#NON_GENERIC},
&nbsp;                 * {@link Sort#PARAMETERIZED} or {@link Sort#VARIABLE}.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to use.
&nbsp;                 * @return {@code true} if this token represents a primary bound.
&nbsp;                 */
&nbsp;                boolean isPrimaryBound(TypePool typePool);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the type path prefix that needs to be appended to the existing type path before any further navigation on the parameterized
&nbsp;                 * type. This method must only be called on type tokens that represent parameterized type
&nbsp;                 *
&nbsp;                 * @return A type path segment that needs to be appended to the base type path before any further navigation on the parameterized type.
&nbsp;                 */
&nbsp;                String getTypePathPrefix();
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a generic type token for a formal type variable.
&nbsp;                 */
&nbsp;                interface OfFormalTypeVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Transforms this token into a generic type representation.
&nbsp;                     *
&nbsp;                     * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                     * @param typeVariableSource       The type variable source.
&nbsp;                     * @param annotationTokens         A mapping of the type variables&#39; type annotations.
&nbsp;                     * @param boundaryAnnotationTokens A mapping of the type variables&#39; bounds&#39; type annotation by their bound index.
&nbsp;                     * @return A generic type representation of this formal type variable.
&nbsp;                     */
&nbsp;                    Generic toGenericType(TypePool typePool,
&nbsp;                                          TypeVariableSource typeVariableSource,
&nbsp;                                          Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a primitive type.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForPrimitiveType implements GenericTypeToken {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code boolean} type.
&nbsp;                     */
<b class="fc">&nbsp;                    BOOLEAN(boolean.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code byte} type.
&nbsp;                     */
<b class="fc">&nbsp;                    BYTE(byte.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code short} type.
&nbsp;                     */
<b class="fc">&nbsp;                    SHORT(short.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code char} type.
&nbsp;                     */
<b class="fc">&nbsp;                    CHAR(char.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code int} type.
&nbsp;                     */
<b class="fc">&nbsp;                    INTEGER(int.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code long} type.
&nbsp;                     */
<b class="fc">&nbsp;                    LONG(long.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code float} type.
&nbsp;                     */
<b class="fc">&nbsp;                    FLOAT(float.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code double} type.
&nbsp;                     */
<b class="fc">&nbsp;                    DOUBLE(double.class),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The generic type token describing the {@code void} type.
&nbsp;                     */
<b class="fc">&nbsp;                    VOID(void.class);</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of this primitive type token.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new primitive type token.
&nbsp;                     *
&nbsp;                     * @param type The loaded type representing this primitive.
&nbsp;                     */
<b class="fc">&nbsp;                    ForPrimitiveType(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                        typeDescription = ForLoadedType.of(type);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a generic type token of a primitive type.
&nbsp;                     *
&nbsp;                     * @param descriptor The descriptor of the primitive type.
&nbsp;                     * @return The corresponding generic type token.
&nbsp;                     */
&nbsp;                    public static GenericTypeToken of(char descriptor) {
<b class="fc">&nbsp;                        switch (descriptor) {</b>
&nbsp;                            case &#39;V&#39;:
<b class="fc">&nbsp;                                return VOID;</b>
&nbsp;                            case &#39;Z&#39;:
<b class="fc">&nbsp;                                return BOOLEAN;</b>
&nbsp;                            case &#39;B&#39;:
<b class="fc">&nbsp;                                return BYTE;</b>
&nbsp;                            case &#39;S&#39;:
<b class="nc">&nbsp;                                return SHORT;</b>
&nbsp;                            case &#39;C&#39;:
<b class="nc">&nbsp;                                return CHAR;</b>
&nbsp;                            case &#39;I&#39;:
<b class="fc">&nbsp;                                return INTEGER;</b>
&nbsp;                            case &#39;J&#39;:
<b class="nc">&nbsp;                                return LONG;</b>
&nbsp;                            case &#39;F&#39;:
<b class="nc">&nbsp;                                return FLOAT;</b>
&nbsp;                            case &#39;D&#39;:
<b class="nc">&nbsp;                                return DOUBLE;</b>
&nbsp;                            default:
<b class="nc">&nbsp;                                throw new IllegalArgumentException(&quot;Not a valid primitive type descriptor: &quot; + descriptor);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new LazyPrimitiveType(typePool,</b>
&nbsp;                                typePath,
&nbsp;                                annotationTokens,
&nbsp;                                typeDescription);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A primitive type cannot be a type variable bound: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A primitive type cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A representation of a lazy primitive type.
&nbsp;                     */
&nbsp;                    protected static class LazyPrimitiveType extends Generic.OfNonGenericType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotation tokens.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type&#39;s description.
&nbsp;                         */
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy primitive type.
&nbsp;                         *
&nbsp;                         * @param typePool         The type pool to use.
&nbsp;                         * @param typePath         This type&#39;s type path.
&nbsp;                         * @param annotationTokens This type&#39;s type annotation tokens.
&nbsp;                         * @param typeDescription  The represented type&#39;s description.
&nbsp;                         */
&nbsp;                        protected LazyPrimitiveType(TypePool typePool,
&nbsp;                                                    String typePath,
&nbsp;                                                    Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                    TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.typeDescription = typeDescription;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription asErasure() {
<b class="nc">&nbsp;                            return typeDescription;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Generic getOwnerType() {
<b class="nc">&nbsp;                            return Generic.UNDEFINED;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Generic getComponentType() {
<b class="nc">&nbsp;                            return Generic.UNDEFINED;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents an unbound wildcard.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForUnboundWildcard implements GenericTypeToken {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 @MaybeNull Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new LazyUnboundWildcard(typePool,</b>
&nbsp;                                typePath,
<b class="fc">&nbsp;                                annotationTokens == null</b>
<b class="nc">&nbsp;                                        ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                        : annotationTokens);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;An unbound wildcard cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a generic unbound wildcard.
&nbsp;                     */
&nbsp;                    protected static class LazyUnboundWildcard extends Generic.OfWildcardType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy unbound wildcard.
&nbsp;                         *
&nbsp;                         * @param typePool         The type pool to use.
&nbsp;                         * @param typePath         This type&#39;s type path.
&nbsp;                         * @param annotationTokens The type&#39;s type annotations.
&nbsp;                         */
<b class="fc">&nbsp;                        protected LazyUnboundWildcard(TypePool typePool, String typePath, Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                            return new TypeList.Generic.Explicit(Generic.OfNonGenericType.ForLoadedType.of(Object.class));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                            return new TypeList.Generic.Empty();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution of a type&#39;s, method&#39;s or field&#39;s generic types.
&nbsp;                 */
&nbsp;                interface Resolution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves the type variables of the represented element.
&nbsp;                     *
&nbsp;                     * @param typePool              The type pool to be used for locating non-generic type descriptions.
&nbsp;                     * @param typeVariableSource    The type variable source to use for resolving type variables.
&nbsp;                     * @param annotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                     * @param boundAnnotationTokens A mapping of the type variables&#39; bounds&#39; type annotation tokens by their indices
&nbsp;                     *                              and each type variable&#39;s index.
&nbsp;                     * @return A list describing the resolved generic types.
&nbsp;                     */
&nbsp;                    TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                          TypeVariableSource typeVariableSource,
&nbsp;                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                          Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of a type&#39;s, method&#39;s or field&#39;s generic types if all of the represented element&#39;s are raw.
&nbsp;                     */
<b class="fc">&nbsp;                    enum Raw implements ForType, ForField, ForMethod, ForRecordComponent {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The singleton instance.
&nbsp;                         */
<b class="fc">&nbsp;                        INSTANCE;</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         TypeDescription definingType) {
<b class="fc">&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, superClassDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      TypeDescription definingType) {
<b class="fc">&nbsp;                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, interfaceTypeDescriptors);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                                     Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                     Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
<b class="fc">&nbsp;                            return new TypeList.Generic.Empty();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                        TypePool typePool,
&nbsp;                                                        Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        FieldDescription.InDefinedShape definingField) {
<b class="fc">&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, fieldTypeDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         MethodDescription.InDefinedShape definingMethod) {
<b class="fc">&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, returnTypeDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
<b class="fc">&nbsp;                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, parameterTypeDescriptors);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
<b class="fc">&nbsp;                            return RawAnnotatedType.LazyRawAnnotatedTypeList.of(typePool, annotationTokens, exceptionTypeDescriptors);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveRecordType(String recordTypeDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         RecordComponentDescription.InDefinedShape definingRecordComponent) {
<b class="nc">&nbsp;                            return RawAnnotatedType.of(typePool, annotationTokens, recordTypeDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Represents a non-generic type that defines type annotations.
&nbsp;                         */
&nbsp;                        protected static class RawAnnotatedType extends Generic.OfNonGenericType {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type pool to use.
&nbsp;                             */
&nbsp;                            private final TypePool typePool;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type&#39;s type path.
&nbsp;                             */
&nbsp;                            private final String typePath;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A mapping of this type&#39;s type annotations.
&nbsp;                             */
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The represented non-generic type.
&nbsp;                             */
&nbsp;                            private final TypeDescription typeDescription;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new raw annotated type.
&nbsp;                             *
&nbsp;                             * @param typePool         The type pool to use.
&nbsp;                             * @param typePath         The type&#39;s type path.
&nbsp;                             * @param annotationTokens A mapping of this type&#39;s type annotations.
&nbsp;                             * @param typeDescription  The represented non-generic type.
&nbsp;                             */
&nbsp;                            protected RawAnnotatedType(TypePool typePool,
&nbsp;                                                       String typePath,
&nbsp;                                                       Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                       TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                                this.typePool = typePool;</b>
<b class="fc">&nbsp;                                this.typePath = typePath;</b>
<b class="fc">&nbsp;                                this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                                this.typeDescription = typeDescription;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new raw annotated type.
&nbsp;                             *
&nbsp;                             * @param typePool         The type pool to use.
&nbsp;                             * @param annotationTokens A mapping of this type&#39;s type annotations.
&nbsp;                             * @param descriptor       The descriptor of the represented non-generic type.
&nbsp;                             * @return An annotated non-generic type.
&nbsp;                             */
&nbsp;                            protected static Generic of(TypePool typePool,
&nbsp;                                                        @MaybeNull Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        String descriptor) {
<b class="fc">&nbsp;                                return new RawAnnotatedType(typePool,</b>
&nbsp;                                        EMPTY_TYPE_PATH,
<b class="fc">&nbsp;                                        annotationTokens == null</b>
<b class="fc">&nbsp;                                                ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                                : annotationTokens,</b>
<b class="fc">&nbsp;                                        TokenizedGenericType.toErasure(typePool, descriptor));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeDescription asErasure() {
<b class="fc">&nbsp;                                return typeDescription;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            public Generic getOwnerType() {
<b class="fc">&nbsp;                                TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="fc">&nbsp;                                return declaringType == null</b>
<b class="fc">&nbsp;                                        ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                                        : new RawAnnotatedType(typePool, typePath, annotationTokens, declaringType);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            public Generic getComponentType() {
<b class="fc">&nbsp;                                TypeDescription componentType = typeDescription.getComponentType();</b>
<b class="fc">&nbsp;                                return componentType == null</b>
<b class="nc">&nbsp;                                        ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                                        : new RawAnnotatedType(typePool, typePath + COMPONENT_TYPE_PATH, annotationTokens, componentType);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                                StringBuilder typePath = new StringBuilder(this.typePath);</b>
<b class="fc">&nbsp;                                for (int index = 0; index &lt; typeDescription.getInnerClassCount(); index++) {</b>
<b class="fc">&nbsp;                                    typePath = typePath.append(INNER_CLASS_PATH);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath.toString()));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A generic type list representing raw types.
&nbsp;                             */
&nbsp;                            protected static class LazyRawAnnotatedTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type pool to use for locating types.
&nbsp;                                 */
&nbsp;                                private final TypePool typePool;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A mapping of the represented types&#39; type annotation tokens by their indices.
&nbsp;                                 */
&nbsp;                                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A list of type descriptors that this list represents.
&nbsp;                                 */
&nbsp;                                private final List&lt;String&gt; descriptors;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a generic type list only representing raw types.
&nbsp;                                 *
&nbsp;                                 * @param typePool         The type pool to use for locating types.
&nbsp;                                 * @param annotationTokens A mapping of the represented types&#39; type annotation tokens by their indices.
&nbsp;                                 * @param descriptors      A list of type descriptors that this list represents.
&nbsp;                                 */
&nbsp;                                protected LazyRawAnnotatedTypeList(TypePool typePool,
&nbsp;                                                                   Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                                   List&lt;String&gt; descriptors) {</b>
<b class="fc">&nbsp;                                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                                    this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                                    this.descriptors = descriptors;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates generic type list only representing raw types.
&nbsp;                                 *
&nbsp;                                 * @param typePool         The type pool to use for locating types.
&nbsp;                                 * @param annotationTokens A mapping of the represented types&#39; type annotation tokens by their indices or
&nbsp;                                 *                         {@code null} if no type annotations are defined for any type.
&nbsp;                                 * @param descriptors      A list of type descriptors that this list represents.
&nbsp;                                 * @return A generic type list representing the raw types this list represents.
&nbsp;                                 */
&nbsp;                                protected static TypeList.Generic of(TypePool typePool,
&nbsp;                                                                     @MaybeNull Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                     List&lt;String&gt; descriptors) {
<b class="fc">&nbsp;                                    return new LazyRawAnnotatedTypeList(typePool,</b>
<b class="fc">&nbsp;                                            annotationTokens == null</b>
<b class="nc">&nbsp;                                                    ? Collections.&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                                    : annotationTokens,</b>
&nbsp;                                            descriptors);
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Generic get(int index) {
<b class="fc">&nbsp;                                    return RawAnnotatedType.of(typePool, annotationTokens.get(index), descriptors.get(index));</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public int size() {
<b class="fc">&nbsp;                                    return descriptors.size();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public TypeList asErasures() {
<b class="fc">&nbsp;                                    return new LazyTypeList(typePool, descriptors);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public TypeList.Generic asRawTypes() {
<b class="nc">&nbsp;                                    return this;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public int getStackSize() {
<b class="fc">&nbsp;                                    int stackSize = 0;</b>
<b class="fc">&nbsp;                                    for (String descriptor : descriptors) {</b>
<b class="fc">&nbsp;                                        stackSize += Type.getType(descriptor).getSize();</b>
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    return stackSize;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of a type&#39;s, method&#39;s or field&#39;s generic types if its generic signature is malformed.
&nbsp;                     */
<b class="fc">&nbsp;                    enum Malformed implements ForType, ForField, ForMethod, ForRecordComponent {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The singleton instance.
&nbsp;                         */
<b class="fc">&nbsp;                        INSTANCE;</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         TypeDescription definingType) {
<b class="nc">&nbsp;                            return new TokenizedGenericType.Malformed(typePool, superClassDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      TypeDescription definingType) {
<b class="fc">&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, interfaceTypeDescriptors);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                                     Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                     Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
<b class="nc">&nbsp;                            throw new GenericSignatureFormatError();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                        TypePool typePool,
&nbsp;                                                        Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        FieldDescription.InDefinedShape definingField) {
<b class="fc">&nbsp;                            return new TokenizedGenericType.Malformed(typePool, fieldTypeDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         MethodDescription.InDefinedShape definingMethod) {
<b class="fc">&nbsp;                            return new TokenizedGenericType.Malformed(typePool, returnTypeDescriptor);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
<b class="nc">&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, parameterTypeDescriptors);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                                      TypePool typePool,
&nbsp;                                                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                      MethodDescription.InDefinedShape definingMethod) {
<b class="nc">&nbsp;                            return new TokenizedGenericType.Malformed.TokenList(typePool, exceptionTypeDescriptors);</b>
&nbsp;                        }
&nbsp;
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic resolveRecordType(String recordTypeDescriptor,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                         RecordComponentDescription.InDefinedShape definingRecordComponent) {
<b class="nc">&nbsp;                            return new TokenizedGenericType.Malformed(typePool, recordTypeDescriptor);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic types of a {@link TypeDescription}.
&nbsp;                     */
&nbsp;                    interface ForType extends Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic super type of the represented type.
&nbsp;                         *
&nbsp;                         * @param superClassDescriptor The descriptor of the raw super type.
&nbsp;                         * @param typePool             The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens     A mapping of the super type&#39;s type annotation tokens.
&nbsp;                         * @param definingType         The type that defines this super type.
&nbsp;                         * @return A description of this type&#39;s generic super type.
&nbsp;                         */
&nbsp;                        Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                  TypePool typePool,
&nbsp;                                                  Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                  TypeDescription definingType);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic interface types of the represented type.
&nbsp;                         *
&nbsp;                         * @param interfaceTypeDescriptors The descriptor of the raw interface types.
&nbsp;                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens         A mapping of the interface types&#39; type annotation tokens by their indices.
&nbsp;                         * @param definingType             The type that defines these interface type.
&nbsp;                         * @return A description of this type&#39;s generic interface types.
&nbsp;                         */
&nbsp;                        TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                               TypePool typePool,
&nbsp;                                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                               TypeDescription definingType);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of generic types of a {@link TypeDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForType {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The super type&#39;s generic type token.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken superClassToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The interface type&#39;s generic type tokens.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; interfaceTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variables generic type tokens.
&nbsp;                             */
&nbsp;                            private final List&lt;OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link TypeDescription}&#39;s generic signatures.
&nbsp;                             *
&nbsp;                             * @param superClassToken     The super class&#39;s generic type token.
&nbsp;                             * @param interfaceTypeTokens The interface type&#39;s generic type tokens.
&nbsp;                             * @param typeVariableTokens  The type variables generic type tokens.
&nbsp;                             */
&nbsp;                            protected Tokenized(GenericTypeToken superClassToken,
&nbsp;                                                List&lt;GenericTypeToken&gt; interfaceTypeTokens,
<b class="fc">&nbsp;                                                List&lt;OfFormalTypeVariable&gt; typeVariableTokens) {</b>
<b class="fc">&nbsp;                                this.superClassToken = superClassToken;</b>
<b class="fc">&nbsp;                                this.interfaceTypeTokens = interfaceTypeTokens;</b>
<b class="fc">&nbsp;                                this.typeVariableTokens = typeVariableTokens;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Generic resolveSuperClass(String superClassDescriptor,
&nbsp;                                                             TypePool typePool,
&nbsp;                                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                             TypeDescription definingType) {
<b class="fc">&nbsp;                                return TokenizedGenericType.of(typePool,</b>
&nbsp;                                        superClassToken,
&nbsp;                                        superClassDescriptor,
&nbsp;                                        annotationTokens,
&nbsp;                                        definingType);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic resolveInterfaceTypes(List&lt;String&gt; interfaceTypeDescriptors,
&nbsp;                                                                          TypePool typePool,
&nbsp;                                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                          TypeDescription definingType) {
<b class="fc">&nbsp;                                return new TokenizedGenericType.TokenList(typePool, interfaceTypeTokens, annotationTokens, interfaceTypeDescriptors, definingType);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                                         Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                         Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
<b class="fc">&nbsp;                                return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic type of a {@link FieldDescription}.
&nbsp;                     */
&nbsp;                    interface ForField {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the field type of the represented field.
&nbsp;                         *
&nbsp;                         * @param fieldTypeDescriptor The descriptor of the raw field type.
&nbsp;                         * @param typePool            The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens    A mapping of the represented types&#39; type annotation tokens.
&nbsp;                         * @param definingField       The field that defines this type.
&nbsp;                         * @return A generic type representation of the field&#39;s type.
&nbsp;                         */
&nbsp;                        Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                 TypePool typePool,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                 FieldDescription.InDefinedShape definingField);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of the generic type of a {@link FieldDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForField {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The token of the represented field&#39;s type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken fieldTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link FieldDescription}&#39;s type.
&nbsp;                             *
&nbsp;                             * @param fieldTypeToken The token of the represented field&#39;s type.
&nbsp;                             */
<b class="fc">&nbsp;                            protected Tokenized(GenericTypeToken fieldTypeToken) {</b>
<b class="fc">&nbsp;                                this.fieldTypeToken = fieldTypeToken;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Generic resolveFieldType(String fieldTypeDescriptor,
&nbsp;                                                            TypePool typePool,
&nbsp;                                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                            FieldDescription.InDefinedShape definingField) {
<b class="fc">&nbsp;                                return TokenizedGenericType.of(typePool,</b>
&nbsp;                                        fieldTypeToken,
&nbsp;                                        fieldTypeDescriptor,
&nbsp;                                        annotationTokens,
<b class="fc">&nbsp;                                        definingField.getDeclaringType());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic types of a {@link MethodDescription}.
&nbsp;                     */
&nbsp;                    interface ForMethod extends Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the return type of the represented method.
&nbsp;                         *
&nbsp;                         * @param returnTypeDescriptor The descriptor of the raw return type.
&nbsp;                         * @param typePool             The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens     A mapping of the return type&#39;s type annotation tokens.
&nbsp;                         * @param definingMethod       The method that defines this return type.
&nbsp;                         * @return A description of this type&#39;s generic return type.
&nbsp;                         */
&nbsp;                        Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                  TypePool typePool,
&nbsp;                                                  Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                  MethodDescription.InDefinedShape definingMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic parameter types of the represented method.
&nbsp;                         *
&nbsp;                         * @param parameterTypeDescriptors The descriptor of the raw parameter types.
&nbsp;                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens         A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                         * @param definingMethod           The method that defines these parameter types.
&nbsp;                         * @return A description of this type&#39;s generic interface types.
&nbsp;                         */
&nbsp;                        TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                               TypePool typePool,
&nbsp;                                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                               MethodDescription.InDefinedShape definingMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the generic parameter types of the represented method.
&nbsp;                         *
&nbsp;                         * @param exceptionTypeDescriptors The descriptor of the raw exception types.
&nbsp;                         * @param typePool                 The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens         A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                         * @param definingMethod           The method that defines these exception types.
&nbsp;                         * @return A description of this type&#39;s generic interface types.
&nbsp;                         */
&nbsp;                        TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                               TypePool typePool,
&nbsp;                                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                               MethodDescription.InDefinedShape definingMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of generic types of a {@link MethodDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForMethod {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s return type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken returnTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s parameter types.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s exception types.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; exceptionTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token describing the represented method&#39;s type variables.
&nbsp;                             */
&nbsp;                            private final List&lt;OfFormalTypeVariable&gt; typeVariableTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link MethodDescription}&#39;s generic signatures.
&nbsp;                             *
&nbsp;                             * @param returnTypeToken     A token describing the represented method&#39;s return type.
&nbsp;                             * @param parameterTypeTokens A token describing the represented method&#39;s parameter types.
&nbsp;                             * @param exceptionTypeTokens A token describing the represented method&#39;s exception types.
&nbsp;                             * @param typeVariableTokens  A token describing the represented method&#39;s type variables.
&nbsp;                             */
&nbsp;                            protected Tokenized(GenericTypeToken returnTypeToken,
&nbsp;                                                List&lt;GenericTypeToken&gt; parameterTypeTokens,
&nbsp;                                                List&lt;GenericTypeToken&gt; exceptionTypeTokens,
<b class="fc">&nbsp;                                                List&lt;OfFormalTypeVariable&gt; typeVariableTokens) {</b>
<b class="fc">&nbsp;                                this.returnTypeToken = returnTypeToken;</b>
<b class="fc">&nbsp;                                this.parameterTypeTokens = parameterTypeTokens;</b>
<b class="fc">&nbsp;                                this.exceptionTypeTokens = exceptionTypeTokens;</b>
<b class="fc">&nbsp;                                this.typeVariableTokens = typeVariableTokens;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Generic resolveReturnType(String returnTypeDescriptor,
&nbsp;                                                             TypePool typePool,
&nbsp;                                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                             MethodDescription.InDefinedShape definingMethod) {
<b class="fc">&nbsp;                                return TokenizedGenericType.of(typePool,</b>
&nbsp;                                        returnTypeToken,
&nbsp;                                        returnTypeDescriptor,
&nbsp;                                        annotationTokens,
&nbsp;                                        definingMethod);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic resolveParameterTypes(List&lt;String&gt; parameterTypeDescriptors,
&nbsp;                                                                          TypePool typePool,
&nbsp;                                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                          MethodDescription.InDefinedShape definingMethod) {
<b class="fc">&nbsp;                                return new TokenizedGenericType.TokenList(typePool, parameterTypeTokens, annotationTokens, parameterTypeDescriptors, definingMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic resolveExceptionTypes(List&lt;String&gt; exceptionTypeDescriptors,
&nbsp;                                                                          TypePool typePool,
&nbsp;                                                                          Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                          MethodDescription.InDefinedShape definingMethod) {
&nbsp;                                // Generic signatures of methods are optional.
<b class="fc">&nbsp;                                return exceptionTypeTokens.isEmpty()</b>
<b class="fc">&nbsp;                                        ? Raw.INSTANCE.resolveExceptionTypes(exceptionTypeDescriptors, typePool, annotationTokens, definingMethod)</b>
<b class="fc">&nbsp;                                        : new TokenizedGenericType.TokenList(typePool, exceptionTypeTokens, annotationTokens, exceptionTypeDescriptors, definingMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic resolveTypeVariables(TypePool typePool,
&nbsp;                                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                                         Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                                                         Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {
<b class="fc">&nbsp;                                return new TokenizedGenericType.TypeVariableList(typePool, typeVariableTokens, typeVariableSource, annotationTokens, boundAnnotationTokens);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolution of the generic type of a {@link RecordComponentDescription}.
&nbsp;                     */
&nbsp;                    interface ForRecordComponent {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves a record component&#39;s type.
&nbsp;                         *
&nbsp;                         * @param recordTypeDescriptor    The record component&#39;s descriptor.
&nbsp;                         * @param typePool                The type pool to be used for locating non-generic type descriptions.
&nbsp;                         * @param annotationTokens        A mapping of the represented types&#39; type annotation tokens.
&nbsp;                         * @param definingRecordComponent The defining record component.
&nbsp;                         * @return A generic type representation of the record component&#39;s type.
&nbsp;                         */
&nbsp;                        Generic resolveRecordType(String recordTypeDescriptor,
&nbsp;                                                  TypePool typePool,
&nbsp;                                                  Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                  RecordComponentDescription.InDefinedShape definingRecordComponent);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation of a tokenized resolution of the generic type of a {@link RecordComponentDescription}.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class Tokenized implements ForRecordComponent {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The token of the represented record component&#39;s type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken recordComponentTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new tokenized resolution of a {@link RecordComponentDescription}&#39;s type.
&nbsp;                             *
&nbsp;                             * @param recordComponentTypeToken The token of the represented record component&#39;s type.
&nbsp;                             */
<b class="fc">&nbsp;                            protected Tokenized(GenericTypeToken recordComponentTypeToken) {</b>
<b class="fc">&nbsp;                                this.recordComponentTypeToken = recordComponentTypeToken;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Generic resolveRecordType(String recordTypeDescriptor,
&nbsp;                                                             TypePool typePool,
&nbsp;                                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                             RecordComponentDescription.InDefinedShape definingRecordComponent) {
<b class="fc">&nbsp;                                return TokenizedGenericType.of(typePool,</b>
&nbsp;                                        recordComponentTypeToken,
&nbsp;                                        recordTypeDescriptor,
&nbsp;                                        annotationTokens,
<b class="fc">&nbsp;                                        definingRecordComponent.getDeclaringType());</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a non-generic type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForRawType implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the represented type.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type token that represents a non-generic type.
&nbsp;                     *
&nbsp;                     * @param name The name of the represented type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForRawType(String name) {</b>
<b class="fc">&nbsp;                        this.name = name;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new Resolution.Raw.RawAnnotatedType(typePool,</b>
&nbsp;                                typePath,
&nbsp;                                annotationTokens,
<b class="fc">&nbsp;                                typePool.describe(name).resolve());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        return !typePool.describe(name).resolve().isInterface();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A non-generic type cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a type variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForTypeVariable implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * This type variable&#39;s nominal symbol.
&nbsp;                     */
&nbsp;                    private final String symbol;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token that represents a type variable.
&nbsp;                     *
&nbsp;                     * @param symbol This type variable&#39;s nominal symbol.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForTypeVariable(String symbol) {</b>
<b class="fc">&nbsp;                        this.symbol = symbol;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        Generic typeVariable = typeVariableSource.findVariable(symbol);</b>
<b class="fc">&nbsp;                        return typeVariable == null</b>
<b class="nc">&nbsp;                                ? new UnresolvedTypeVariable(typeVariableSource, typePool, symbol, annotationTokens.get(typePath))</b>
<b class="fc">&nbsp;                                : new AnnotatedTypeVariable(typePool, annotationTokens.get(typePath), typeVariable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A type variable cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An annotated representation of a formal type variable.
&nbsp;                     */
&nbsp;                    protected static class AnnotatedTypeVariable extends Generic.OfTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented annotation tokens.
&nbsp;                         */
&nbsp;                        private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented type variable.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new annotated type variable.
&nbsp;                         *
&nbsp;                         * @param typePool         The type pool to use.
&nbsp;                         * @param annotationTokens The represented annotation tokens.
&nbsp;                         * @param typeVariable     The represented type variable.
&nbsp;                         */
<b class="fc">&nbsp;                        protected AnnotatedTypeVariable(TypePool typePool, List&lt;AnnotationToken&gt; annotationTokens, Generic typeVariable) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.typeVariable = typeVariable;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                            return typeVariable.getUpperBounds();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                            return typeVariable.getTypeVariableSource();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public String getSymbol() {
<b class="fc">&nbsp;                            return typeVariable.getSymbol();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents a type variable that a type references but that does not exist. Such type variables are only emitted by wrongful
&nbsp;                     * compilation either due to the isolated recompilation of outer classes or due to bugs in compilers.
&nbsp;                     */
&nbsp;                    protected static class UnresolvedTypeVariable extends Generic.OfTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The undeclared type variable&#39;s source.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable&#39;s symbol.
&nbsp;                         */
&nbsp;                        private final String symbol;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable&#39;s annotation tokens.
&nbsp;                         */
&nbsp;                        private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates an unresolved type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariableSource The undeclared type variable&#39;s source.
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param symbol             The type variable&#39;s symbol.
&nbsp;                         * @param annotationTokens   The type variable&#39;s annotation tokens.
&nbsp;                         */
&nbsp;                        protected UnresolvedTypeVariable(TypeVariableSource typeVariableSource,
&nbsp;                                                         TypePool typePool,
&nbsp;                                                         String symbol,
<b class="nc">&nbsp;                                                         List&lt;AnnotationToken&gt; annotationTokens) {</b>
<b class="nc">&nbsp;                            this.typeVariableSource = typeVariableSource;</b>
<b class="nc">&nbsp;                            this.typePool = typePool;</b>
<b class="nc">&nbsp;                            this.symbol = symbol;</b>
<b class="nc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot resolve bounds of unresolved type variable &quot; + this + &quot; by &quot; + typeVariableSource);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                            return typeVariableSource;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public String getSymbol() {
<b class="nc">&nbsp;                            return symbol;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type token that represent a formal type variable, i.e. a type variable including its upper bounds.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Formal implements GenericTypeToken.OfFormalTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type variable&#39;s nominal symbol.
&nbsp;                         */
&nbsp;                        private final String symbol;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of tokens that represent this type variable&#39;s upper bounds.
&nbsp;                         */
&nbsp;                        private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates generic type token that represent a formal type variable.
&nbsp;                         *
&nbsp;                         * @param symbol          This type variable&#39;s nominal symbol.
&nbsp;                         * @param boundTypeTokens A list of tokens that represent this type variable&#39;s upper bounds.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Formal(String symbol, List&lt;GenericTypeToken&gt; boundTypeTokens) {</b>
<b class="fc">&nbsp;                            this.symbol = symbol;</b>
<b class="fc">&nbsp;                            this.boundTypeTokens = boundTypeTokens;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic toGenericType(TypePool typePool,
&nbsp;                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                     @MaybeNull Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                     @MaybeNull Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens) {
<b class="fc">&nbsp;                            return new LazyTypeVariable(typePool,</b>
&nbsp;                                    typeVariableSource,
<b class="fc">&nbsp;                                    annotationTokens == null</b>
<b class="fc">&nbsp;                                            ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                            : annotationTokens,</b>
<b class="fc">&nbsp;                                    boundaryAnnotationTokens == null</b>
<b class="fc">&nbsp;                                            ? Collections.&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                            : boundaryAnnotationTokens,</b>
&nbsp;                                    symbol,
&nbsp;                                    boundTypeTokens);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A type description that represents a type variable with bounds that are resolved lazily.
&nbsp;                         */
&nbsp;                        protected static class LazyTypeVariable extends Generic.OfTypeVariable {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type pool to use for locating type descriptions.
&nbsp;                             */
&nbsp;                            private final TypePool typePool;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable source to use for locating type variables.
&nbsp;                             */
&nbsp;                            private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s type annotation tokens.
&nbsp;                             */
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A mapping of the type variable bounds&#39; type annotation tokens by their indices.
&nbsp;                             */
&nbsp;                            private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s symbol.
&nbsp;                             */
&nbsp;                            private final String symbol;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Tokenized representations of the type variables bound types.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a lazy type description of a type variables.
&nbsp;                             *
&nbsp;                             * @param typePool                 The type pool to use for locating type descriptions.
&nbsp;                             * @param typeVariableSource       The type variable source to use for locating type variables.
&nbsp;                             * @param annotationTokens         The type variable&#39;s type annotation tokens.
&nbsp;                             * @param boundaryAnnotationTokens A mapping of the type variable bounds&#39; type annotation tokens by their indices.
&nbsp;                             * @param symbol                   The type variable&#39;s symbol.
&nbsp;                             * @param boundTypeTokens          Tokenized representations of the type variables bound types.
&nbsp;                             */
&nbsp;                            protected LazyTypeVariable(TypePool typePool,
&nbsp;                                                       TypeVariableSource typeVariableSource,
&nbsp;                                                       Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                       Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; boundaryAnnotationTokens,
&nbsp;                                                       String symbol,
<b class="fc">&nbsp;                                                       List&lt;GenericTypeToken&gt; boundTypeTokens) {</b>
<b class="fc">&nbsp;                                this.typePool = typePool;</b>
<b class="fc">&nbsp;                                this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                                this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                                this.boundaryAnnotationTokens = boundaryAnnotationTokens;</b>
<b class="fc">&nbsp;                                this.symbol = symbol;</b>
<b class="fc">&nbsp;                                this.boundTypeTokens = boundTypeTokens;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                                return new LazyBoundTokenList(typePool, typeVariableSource, boundaryAnnotationTokens, boundTypeTokens);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                                return typeVariableSource;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public String getSymbol() {
<b class="fc">&nbsp;                                return symbol;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(EMPTY_TYPE_PATH));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A list representing a formal type variable&#39;s bounds.
&nbsp;                             */
&nbsp;                            protected static class LazyBoundTokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type pool to use.
&nbsp;                                 */
&nbsp;                                private final TypePool typePool;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type variable source for locating type variables.
&nbsp;                                 */
&nbsp;                                private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A mapping of the bound type&#39;s type annotations by their bound index.
&nbsp;                                 */
&nbsp;                                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The bound types in their tokenized form.
&nbsp;                                 */
&nbsp;                                private final List&lt;GenericTypeToken&gt; boundTypeTokens;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new lazy bound token list for a type variable.
&nbsp;                                 *
&nbsp;                                 * @param typePool           The type pool to use.
&nbsp;                                 * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                                 * @param annotationTokens   A mapping of the bound type&#39;s type annotations by their bound index.
&nbsp;                                 * @param boundTypeTokens    The bound types in their tokenized form.
&nbsp;                                 */
&nbsp;                                protected LazyBoundTokenList(TypePool typePool,
&nbsp;                                                             TypeVariableSource typeVariableSource,
&nbsp;                                                             Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                             List&lt;GenericTypeToken&gt; boundTypeTokens) {</b>
<b class="fc">&nbsp;                                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                                    this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                                    this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                                    this.boundTypeTokens = boundTypeTokens;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Generic get(int index) {
&nbsp;                                    // Avoid resolution of interface bound type unless a type annotation can be possibly resolved.
<b class="fc">&nbsp;                                    Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens = !this.annotationTokens.containsKey(index) &amp;&amp; !this.annotationTokens.containsKey(index + 1)</b>
<b class="fc">&nbsp;                                            ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                            : this.annotationTokens.get(index + (boundTypeTokens.get(0).isPrimaryBound(typePool) ? 0 : 1));</b>
<b class="fc">&nbsp;                                    return boundTypeTokens.get(index).toGenericType(typePool,</b>
&nbsp;                                            typeVariableSource,
&nbsp;                                            EMPTY_TYPE_PATH,
<b class="fc">&nbsp;                                            annotationTokens == null</b>
<b class="fc">&nbsp;                                                    ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                                    : annotationTokens);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public int size() {
<b class="fc">&nbsp;                                    return boundTypeTokens.size();</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a generic array.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForGenericArray implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The array&#39;s component type.
&nbsp;                     */
&nbsp;                    private final GenericTypeToken componentTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token that represents a generic array.
&nbsp;                     *
&nbsp;                     * @param componentTypeToken The array&#39;s component type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForGenericArray(GenericTypeToken componentTypeToken) {</b>
<b class="fc">&nbsp;                        this.componentTypeToken = componentTypeToken;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new LazyGenericArray(typePool, typeVariableSource, typePath, annotationTokens, componentTypeToken);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A generic array type cannot be a type variable bound: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A generic array type cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a generic array.
&nbsp;                     */
&nbsp;                    protected static class LazyGenericArray extends Generic.OfGenericArray {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source for locating type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A tokenized representation of this generic arrays&#39;s component type.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken componentTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy generic array.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                         * @param typePath           This type&#39;s type path.
&nbsp;                         * @param annotationTokens   This type&#39;s type annotations.
&nbsp;                         * @param componentTypeToken A tokenized representation of this generic arrays&#39;s component type.
&nbsp;                         */
&nbsp;                        protected LazyGenericArray(TypePool typePool,
&nbsp;                                                   TypeVariableSource typeVariableSource,
&nbsp;                                                   String typePath,
&nbsp;                                                   Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                   GenericTypeToken componentTypeToken) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.componentTypeToken = componentTypeToken;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic getComponentType() {
<b class="fc">&nbsp;                            return componentTypeToken.toGenericType(typePool, typeVariableSource, typePath + COMPONENT_TYPE_PATH, annotationTokens);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token for a wildcard that is bound below.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForLowerBoundWildcard implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token that represents the wildcard&#39;s lower bound.
&nbsp;                     */
&nbsp;                    private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token for a wildcard that is bound below.
&nbsp;                     *
&nbsp;                     * @param boundTypeToken A token that represents the wildcard&#39;s lower bound.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForLowerBoundWildcard(GenericTypeToken boundTypeToken) {</b>
<b class="fc">&nbsp;                        this.boundTypeToken = boundTypeToken;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new LazyLowerBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A lower bound wildcard cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a lower bound wildcard.
&nbsp;                     */
&nbsp;                    protected static class LazyLowerBoundWildcard extends Generic.OfWildcardType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source for locating type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy lower bound wildcard.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                         * @param typePath           This type&#39;s type path.
&nbsp;                         * @param annotationTokens   This type&#39;s type annotations.
&nbsp;                         * @param boundTypeToken     A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        protected LazyLowerBoundWildcard(TypePool typePool,
&nbsp;                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                         String typePath,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                         GenericTypeToken boundTypeToken) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.boundTypeToken = boundTypeToken;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                            return new TypeList.Generic.Explicit(Generic.OfNonGenericType.ForLoadedType.of(Object.class));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                            return new LazyTokenList.ForWildcardBound(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token for a wildcard that is bound above.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForUpperBoundWildcard implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A token that represents the wildcard&#39;s upper bound.
&nbsp;                     */
&nbsp;                    private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a generic type token for a wildcard that is bound above.
&nbsp;                     *
&nbsp;                     * @param boundTypeToken A token that represents the wildcard&#39;s upper bound.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForUpperBoundWildcard(GenericTypeToken boundTypeToken) {</b>
<b class="fc">&nbsp;                        this.boundTypeToken = boundTypeToken;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new LazyUpperBoundWildcard(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;A wildcard type cannot be a type variable bound: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;An upper bound wildcard cannot be the owner of a nested type: &quot; + this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type representation of a tokenized wildcard with an upper bound.
&nbsp;                     */
&nbsp;                    protected static class LazyUpperBoundWildcard extends Generic.OfWildcardType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source for locating type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type annotations.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken boundTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new lazy upper bound wildcard.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use.
&nbsp;                         * @param typeVariableSource The type variable source for locating type variables.
&nbsp;                         * @param typePath           This type&#39;s type path.
&nbsp;                         * @param annotationTokens   This type&#39;s type annotations.
&nbsp;                         * @param boundTypeToken     A tokenized representation of this wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        protected LazyUpperBoundWildcard(TypePool typePool,
&nbsp;                                                         TypeVariableSource typeVariableSource,
&nbsp;                                                         String typePath,
&nbsp;                                                         Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                         GenericTypeToken boundTypeToken) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.boundTypeToken = boundTypeToken;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                            return new LazyTokenList.ForWildcardBound(typePool, typeVariableSource, typePath, annotationTokens, boundTypeToken);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                            return new TypeList.Generic.Empty();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A generic type token that represents a parameterized type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForParameterizedType implements GenericTypeToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the parameterized type&#39;s erasure.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of tokens that represent the parameters of the represented type.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a type token that represents a parameterized type.
&nbsp;                     *
&nbsp;                     * @param name                The name of the parameterized type&#39;s erasure.
&nbsp;                     * @param parameterTypeTokens A list of tokens that represent the parameters of the represented type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForParameterizedType(String name, List&lt;GenericTypeToken&gt; parameterTypeTokens) {</b>
<b class="fc">&nbsp;                        this.name = name;</b>
<b class="fc">&nbsp;                        this.parameterTypeTokens = parameterTypeTokens;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic toGenericType(TypePool typePool,
&nbsp;                                                 TypeVariableSource typeVariableSource,
&nbsp;                                                 String typePath,
&nbsp;                                                 Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                        return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, name, parameterTypeTokens);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrimaryBound(TypePool typePool) {
<b class="fc">&nbsp;                        return !typePool.describe(name).resolve().isInterface();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getTypePathPrefix() {
<b class="fc">&nbsp;                        return String.valueOf(INNER_CLASS_PATH);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type token to describe a parameterized type description with a generic owner type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Nested implements GenericTypeToken {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The name of the parameterized type&#39;s erasure.
&nbsp;                         */
&nbsp;                        private final String name;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of tokens that represent the parameters of the represented type.
&nbsp;                         */
&nbsp;                        private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A token that describes the described parameterized type&#39;s owner type.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken ownerTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a type token that represents a parameterized type.
&nbsp;                         *
&nbsp;                         * @param name                The name of the parameterized type&#39;s erasure.
&nbsp;                         * @param parameterTypeTokens A list of tokens that represent the parameters of the represented type.
&nbsp;                         * @param ownerTypeToken      A token that describes the described parameterized type&#39;s owner type.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Nested(String name, List&lt;GenericTypeToken&gt; parameterTypeTokens, GenericTypeToken ownerTypeToken) {</b>
<b class="fc">&nbsp;                            this.name = name;</b>
<b class="fc">&nbsp;                            this.parameterTypeTokens = parameterTypeTokens;</b>
<b class="fc">&nbsp;                            this.ownerTypeToken = ownerTypeToken;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic toGenericType(TypePool typePool,
&nbsp;                                                     TypeVariableSource typeVariableSource,
&nbsp;                                                     String typePath,
&nbsp;                                                     Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens) {
<b class="fc">&nbsp;                            return new LazyParameterizedType(typePool, typeVariableSource, typePath, annotationTokens, name, parameterTypeTokens, ownerTypeToken);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public String getTypePathPrefix() {
<b class="nc">&nbsp;                            return ownerTypeToken.getTypePathPrefix() + INNER_CLASS_PATH;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean isPrimaryBound(TypePool typePool) {
<b class="nc">&nbsp;                            return !typePool.describe(name).resolve().isInterface();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A lazy description of a parameterized type with an owner type.
&nbsp;                         */
&nbsp;                        protected static class LazyParameterizedType extends Generic.OfParameterizedType {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type pool that is used for locating a generic type.
&nbsp;                             */
&nbsp;                            private final TypePool typePool;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable source to use for resolving type variables.
&nbsp;                             */
&nbsp;                            private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                            /**
&nbsp;                             * This type&#39;s type path.
&nbsp;                             */
&nbsp;                            private final String typePath;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A mapping of type annotations for this type.
&nbsp;                             */
&nbsp;                            private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The binary name of this parameterized type&#39;s raw type.
&nbsp;                             */
&nbsp;                            private final String name;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Tokens that represent this parameterized type&#39;s parameters.
&nbsp;                             */
&nbsp;                            private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A token that represents this type&#39;s owner type.
&nbsp;                             */
&nbsp;                            private final GenericTypeToken ownerTypeToken;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new lazy parameterized type.
&nbsp;                             *
&nbsp;                             * @param typePool            The type pool that is used for locating a generic type.
&nbsp;                             * @param typeVariableSource  The type variable source to use for resolving type variables.
&nbsp;                             * @param typePath            This type&#39;s type path.
&nbsp;                             * @param annotationTokens    A mapping of type annotations for this type.
&nbsp;                             * @param name                The binary name of this parameterized type&#39;s raw type.
&nbsp;                             * @param parameterTypeTokens Tokens that represent this parameterized type&#39;s parameters.
&nbsp;                             * @param ownerTypeToken      A token that represents this type&#39;s owner type.
&nbsp;                             */
&nbsp;                            protected LazyParameterizedType(TypePool typePool,
&nbsp;                                                            TypeVariableSource typeVariableSource,
&nbsp;                                                            String typePath,
&nbsp;                                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                            String name,
&nbsp;                                                            List&lt;GenericTypeToken&gt; parameterTypeTokens,
<b class="fc">&nbsp;                                                            GenericTypeToken ownerTypeToken) {</b>
<b class="fc">&nbsp;                                this.typePool = typePool;</b>
<b class="fc">&nbsp;                                this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                                this.typePath = typePath;</b>
<b class="fc">&nbsp;                                this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                                this.name = name;</b>
<b class="fc">&nbsp;                                this.parameterTypeTokens = parameterTypeTokens;</b>
<b class="fc">&nbsp;                                this.ownerTypeToken = ownerTypeToken;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeDescription asErasure() {
<b class="fc">&nbsp;                                return typePool.describe(name).resolve();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                                return new LazyTokenList(typePool, typeVariableSource, typePath + ownerTypeToken.getTypePathPrefix(), annotationTokens, parameterTypeTokens);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            public Generic getOwnerType() {
<b class="fc">&nbsp;                                return ownerTypeToken.toGenericType(typePool, typeVariableSource, typePath, annotationTokens);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath + ownerTypeToken.getTypePathPrefix()));</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type description that represents a parameterized type &lt;b&gt;without&lt;/b&gt; an enclosing generic owner type.
&nbsp;                     */
&nbsp;                    protected static class LazyParameterizedType extends Generic.OfParameterizedType {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool that is used for locating a generic type.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source to use for resolving type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * This type&#39;s type path.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of the represent type&#39;s annotation tokens.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The binary name of the raw type.
&nbsp;                         */
&nbsp;                        private final String name;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of type tokens representing this type&#39;s bounds.
&nbsp;                         */
&nbsp;                        private final List&lt;GenericTypeToken&gt; parameterTypeTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new description of a parameterized type.
&nbsp;                         *
&nbsp;                         * @param typePool            The type pool that is used for locating a generic type.
&nbsp;                         * @param typeVariableSource  The type variable source to use for resolving type variables.
&nbsp;                         * @param typePath            This type&#39;s type path.
&nbsp;                         * @param annotationTokens    A mapping of the represent type&#39;s annotation tokens,
&nbsp;                         * @param name                The binary name of the raw type.
&nbsp;                         * @param parameterTypeTokens A list of type tokens representing this type&#39;s bounds.
&nbsp;                         */
&nbsp;                        protected LazyParameterizedType(TypePool typePool,
&nbsp;                                                        TypeVariableSource typeVariableSource,
&nbsp;                                                        String typePath,
&nbsp;                                                        Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                                        String name,
<b class="fc">&nbsp;                                                        List&lt;GenericTypeToken&gt; parameterTypeTokens) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.name = name;</b>
<b class="fc">&nbsp;                            this.parameterTypeTokens = parameterTypeTokens;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription asErasure() {
<b class="fc">&nbsp;                            return typePool.describe(name).resolve();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                            return new LazyTokenList(typePool, typeVariableSource, typePath, annotationTokens, parameterTypeTokens);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Generic getOwnerType() {
<b class="fc">&nbsp;                            TypeDescription ownerType = typePool.describe(name).resolve().getEnclosingType();</b>
<b class="fc">&nbsp;                            return ownerType == null</b>
<b class="fc">&nbsp;                                    ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                                    : ownerType.asGenericType();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens.get(typePath));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy list of type tokens.
&nbsp;                 */
&nbsp;                class LazyTokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool that is used for locating a generic type.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable source to use for resolving type variables.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented types&#39; type path to which an index step is added upon resolution.
&nbsp;                     */
&nbsp;                    private final String typePath;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the represent types&#39; annotation tokens.
&nbsp;                     */
&nbsp;                    private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of type tokens this list represents.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken&gt; genericTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new type list that represents a list of tokenized types.
&nbsp;                     *
&nbsp;                     * @param typePool           The type pool that is used for locating a generic type.
&nbsp;                     * @param typeVariableSource The type variable source to use for resolving type variables.
&nbsp;                     * @param typePath           The represented types&#39; type path to which an index step is added upon resolution.
&nbsp;                     * @param annotationTokens   A mapping of the represent types&#39; annotation tokens,
&nbsp;                     * @param genericTypeTokens  A list of type tokens this list represents.
&nbsp;                     */
&nbsp;                    protected LazyTokenList(TypePool typePool,
&nbsp;                                            TypeVariableSource typeVariableSource,
&nbsp;                                            String typePath,
&nbsp;                                            Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                            List&lt;GenericTypeToken&gt; genericTypeTokens) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                        this.typePath = typePath;</b>
<b class="fc">&nbsp;                        this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                        this.genericTypeTokens = genericTypeTokens;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return genericTypeTokens.get(index).toGenericType(typePool, typeVariableSource, typePath + index + INDEXED_TYPE_DELIMITER, annotationTokens);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return genericTypeTokens.size();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A generic type description representing a tokenized wildcard bound.
&nbsp;                     */
&nbsp;                    protected static class ForWildcardBound extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool that is used for locating a generic type.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variable source to use for resolving type variables.
&nbsp;                         */
&nbsp;                        private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented types&#39; type path to which a wildcard step is added upon resolution.
&nbsp;                         */
&nbsp;                        private final String typePath;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of the represent types&#39; annotation tokens.
&nbsp;                         */
&nbsp;                        private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A token representing the wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        private final GenericTypeToken genericTypeToken;
&nbsp;
&nbsp;                        /**
&nbsp;                         * @param typePool           The type pool that is used for locating a generic type.
&nbsp;                         * @param typeVariableSource The type variable source to use for resolving type variables.
&nbsp;                         * @param typePath           The represented types&#39; type path to which a wildcard step is added upon resolution.
&nbsp;                         * @param annotationTokens   A mapping of the represent types&#39; annotation tokens,
&nbsp;                         * @param genericTypeToken   A token representing the wildcard&#39;s bound.
&nbsp;                         */
&nbsp;                        protected ForWildcardBound(TypePool typePool,
&nbsp;                                                   TypeVariableSource typeVariableSource,
&nbsp;                                                   String typePath,
&nbsp;                                                   Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                                   GenericTypeToken genericTypeToken) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                            this.typePath = typePath;</b>
<b class="fc">&nbsp;                            this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                            this.genericTypeToken = genericTypeToken;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic get(int index) {
<b class="fc">&nbsp;                            if (index == 0) {</b>
<b class="fc">&nbsp;                                return genericTypeToken.toGenericType(typePool, typeVariableSource, typePath + WILDCARD_TYPE_PATH, annotationTokens);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                throw new IndexOutOfBoundsException(&quot;index = &quot; + index);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public int size() {
<b class="fc">&nbsp;                            return 1;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token for representing collected data on an annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class AnnotationToken {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the represented annotation.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * A map of annotation value names to their value representations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation token.
&nbsp;                 *
&nbsp;                 * @param descriptor The descriptor of the represented annotation.
&nbsp;                 * @param values     A map of annotation value names to their value representations.
&nbsp;                 */
<b class="fc">&nbsp;                protected AnnotationToken(String descriptor, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.values = values;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the annotation type&#39;s binary name.
&nbsp;                 *
&nbsp;                 * @return The annotation type&#39;s binary name.
&nbsp;                 */
&nbsp;                protected String getBinaryName() {
<b class="fc">&nbsp;                    return descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this token into an annotation description.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @return An optional description of this annotation&#39;s token.
&nbsp;                 */
&nbsp;                private Resolution toAnnotationDescription(TypePool typePool) {
<b class="fc">&nbsp;                    TypePool.Resolution resolution = typePool.describe(getBinaryName());</b>
<b class="fc">&nbsp;                    return resolution.isResolved()</b>
<b class="fc">&nbsp;                            ? new Resolution.Simple(new LazyAnnotationDescription(typePool, resolution.resolve(), values))</b>
<b class="fc">&nbsp;                            : new Resolution.Illegal(getBinaryName());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution for an annotation tokens. Any annotation is suppressed if its type is not available.
&nbsp;                 * This conforms to the handling of the Java reflection API.
&nbsp;                 */
&nbsp;                protected interface Resolution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the represented annotation could be resolved.
&nbsp;                     *
&nbsp;                     * @return {@code true} if the represented annotation could be resolved.
&nbsp;                     */
&nbsp;                    boolean isResolved();
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the resolved annotation. This method throws an exception if this instance is not resolved.
&nbsp;                     *
&nbsp;                     * @return The resolved annotation. This method throws an exception if this instance is not resolved.
&nbsp;                     */
&nbsp;                    AnnotationDescription resolve();
&nbsp;
&nbsp;                    /**
&nbsp;                     * A simple resolved annotation.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Simple implements Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented annotation description.
&nbsp;                         */
&nbsp;                        private final AnnotationDescription annotationDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new simple resolution.
&nbsp;                         *
&nbsp;                         * @param annotationDescription The represented annotation description.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Simple(AnnotationDescription annotationDescription) {</b>
<b class="fc">&nbsp;                            this.annotationDescription = annotationDescription;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean isResolved() {
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationDescription resolve() {
<b class="fc">&nbsp;                            return annotationDescription;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An illegal resolution.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Illegal implements Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The annotation&#39;s binary type name.
&nbsp;                         */
&nbsp;                        private final String annotationType;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new illegal resolution.
&nbsp;                         *
&nbsp;                         * @param annotationType The annotation&#39;s binary type name.
&nbsp;                         */
<b class="fc">&nbsp;                        public Illegal(String annotationType) {</b>
<b class="fc">&nbsp;                            this.annotationType = annotationType;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean isResolved() {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationDescription resolve() {
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Annotation type is not available: &quot; + annotationType);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token for representing collected data on a field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class FieldToken {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of the represented field.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the field.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The resolution of this field&#39;s generic type.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForField signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens representing the annotations of the represented field.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field token.
&nbsp;                 *
&nbsp;                 * @param name                 The name of the field.
&nbsp;                 * @param modifiers            The modifiers of the represented field.
&nbsp;                 * @param descriptor           The descriptor of the field.
&nbsp;                 * @param genericSignature     The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 * @param typeAnnotationTokens A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 * @param annotationTokens     A list of annotation tokens representing the annotations of the represented field.
&nbsp;                 */
&nbsp;                protected FieldToken(String name,
&nbsp;                                     int modifiers,
&nbsp;                                     String descriptor,
&nbsp;                                     @MaybeNull String genericSignature,
&nbsp;                                     Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens,
<b class="fc">&nbsp;                                     List&lt;AnnotationToken&gt; annotationTokens) {</b>
<b class="fc">&nbsp;                    this.modifiers = modifiers &amp; ~Opcodes.ACC_DEPRECATED;</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    signatureResolution = RAW_TYPES</b>
<b class="nc">&nbsp;                            ? GenericTypeToken.Resolution.Raw.INSTANCE</b>
<b class="fc">&nbsp;                            : GenericTypeExtractor.ForSignature.OfField.extract(genericSignature);</b>
<b class="fc">&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this token into a lazy field description.
&nbsp;                 *
&nbsp;                 * @param lazyTypeDescription The lazy type description to attach this field description to.
&nbsp;                 * @return A field description resembling this field token.
&nbsp;                 */
&nbsp;                private LazyFieldDescription toFieldDescription(LazyTypeDescription lazyTypeDescription) {
<b class="fc">&nbsp;                    return lazyTypeDescription.new LazyFieldDescription(name,</b>
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            signatureResolution,
&nbsp;                            typeAnnotationTokens,
&nbsp;                            annotationTokens);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token for representing collected data on a method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class MethodToken {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name of the represented method.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of the represented method.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the represented method.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The methods&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic type resolution of this method.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of internal names of the exceptions of the represented method or {@code null} if there
&nbsp;                 * are no such exceptions.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String[] exceptionName;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their indices and each variable&#39;s index.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the return type&#39;s type variable tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the receiver type&#39;s annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens that are present on the represented method.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A map of parameter indices to tokens that represent their annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of tokens describing meta data of the method&#39;s parameters.
&nbsp;                 */
&nbsp;                private final List&lt;ParameterToken&gt; parameterTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value of this method or {@code null} if there is no such value.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new method token.
&nbsp;                 *
&nbsp;                 * @param name                              The name of the method.
&nbsp;                 * @param modifiers                         The modifiers of the represented method.
&nbsp;                 * @param descriptor                        The descriptor of the represented method.
&nbsp;                 * @param genericSignature                  The methods&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 * @param exceptionName                     An array of internal names of the exceptions of the represented method or {@code null} if
&nbsp;                 *                                          there are no such exceptions.
&nbsp;                 * @param typeVariableAnnotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 * @param typeVariableBoundAnnotationTokens A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their
&nbsp;                 *                                          index and each variable&#39;s index.
&nbsp;                 * @param returnTypeAnnotationTokens        A mapping of the return type&#39;s type variable tokens.
&nbsp;                 * @param parameterTypeAnnotationTokens     A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 * @param exceptionTypeAnnotationTokens     A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 * @param receiverTypeAnnotationTokens      A mapping of the receiver type&#39;s annotation tokens.
&nbsp;                 * @param annotationTokens                  A list of annotation tokens that are present on the represented method.
&nbsp;                 * @param parameterAnnotationTokens         A map of parameter indices to tokens that represent their annotations.
&nbsp;                 * @param parameterTokens                   A list of tokens describing meta data of the method&#39;s parameters.
&nbsp;                 * @param defaultValue                      The default value of this method or {@code null} if there is no such value.
&nbsp;                 */
&nbsp;                protected MethodToken(String name,
&nbsp;                                      int modifiers,
&nbsp;                                      String descriptor,
&nbsp;                                      @MaybeNull String genericSignature,
&nbsp;                                      @MaybeNull String[] exceptionName,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens,
&nbsp;                                      Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens,
&nbsp;                                      Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens,
&nbsp;                                      List&lt;AnnotationToken&gt; annotationTokens,
&nbsp;                                      Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens,
&nbsp;                                      List&lt;ParameterToken&gt; parameterTokens,
<b class="fc">&nbsp;                                      @MaybeNull AnnotationValue&lt;?, ?&gt; defaultValue) {</b>
<b class="fc">&nbsp;                    this.modifiers = modifiers &amp; ~Opcodes.ACC_DEPRECATED;</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    signatureResolution = RAW_TYPES</b>
<b class="nc">&nbsp;                            ? GenericTypeToken.Resolution.Raw.INSTANCE</b>
<b class="fc">&nbsp;                            : GenericTypeExtractor.ForSignature.OfMethod.extract(genericSignature);</b>
<b class="fc">&nbsp;                    this.exceptionName = exceptionName;</b>
<b class="fc">&nbsp;                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.receiverTypeAnnotationTokens = receiverTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                    this.parameterAnnotationTokens = parameterAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.parameterTokens = parameterTokens;</b>
<b class="fc">&nbsp;                    this.defaultValue = defaultValue;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this method token to a method description that is attached to a lazy type description.
&nbsp;                 *
&nbsp;                 * @param lazyTypeDescription The lazy type description to attach this method description to.
&nbsp;                 * @return A method description representing this method token.
&nbsp;                 */
&nbsp;                private MethodDescription.InDefinedShape toMethodDescription(LazyTypeDescription lazyTypeDescription) {
<b class="fc">&nbsp;                    return lazyTypeDescription.new LazyMethodDescription(name,</b>
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            signatureResolution,
&nbsp;                            exceptionName,
&nbsp;                            typeVariableAnnotationTokens,
&nbsp;                            typeVariableBoundAnnotationTokens,
&nbsp;                            returnTypeAnnotationTokens,
&nbsp;                            parameterTypeAnnotationTokens,
&nbsp;                            exceptionTypeAnnotationTokens,
&nbsp;                            receiverTypeAnnotationTokens,
&nbsp;                            annotationTokens,
&nbsp;                            parameterAnnotationTokens,
&nbsp;                            parameterTokens,
&nbsp;                            defaultValue);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A token representing a method&#39;s parameter.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ParameterToken {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Donates an unknown name of a parameter.
&nbsp;                     */
&nbsp;                    @AlwaysNull
<b class="fc">&nbsp;                    protected static final String NO_NAME = null;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Donates an unknown modifier of a parameter.
&nbsp;                     */
&nbsp;                    @AlwaysNull
<b class="fc">&nbsp;                    protected static final Integer NO_MODIFIERS = null;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the parameter or {@code null} if no explicit name for this parameter is known.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The modifiers of the parameter or {@code null} if no modifiers are known for this parameter.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                    private final Integer modifiers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parameter token for a parameter without an explicit name and without specific modifiers.
&nbsp;                     */
&nbsp;                    protected ParameterToken() {
<b class="fc">&nbsp;                        this(NO_NAME);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parameter token for a parameter with an explicit name and without specific modifiers.
&nbsp;                     *
&nbsp;                     * @param name The name of the parameter.
&nbsp;                     */
&nbsp;                    protected ParameterToken(@MaybeNull String name) {
<b class="fc">&nbsp;                        this(name, NO_MODIFIERS);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a parameter token for a parameter with an explicit name and with specific modifiers.
&nbsp;                     *
&nbsp;                     * @param name      The name of the parameter.
&nbsp;                     * @param modifiers The modifiers of the parameter.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ParameterToken(@MaybeNull String name, @MaybeNull Integer modifiers) {</b>
<b class="fc">&nbsp;                        this.name = name;</b>
<b class="fc">&nbsp;                        this.modifiers = modifiers;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the name of the parameter or {@code null} if there is no such name.
&nbsp;                     *
&nbsp;                     * @return The name of the parameter or {@code null} if there is no such name.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    protected String getName() {
<b class="fc">&nbsp;                        return name;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the modifiers of the parameter or {@code null} if no modifiers are known.
&nbsp;                     *
&nbsp;                     * @return The modifiers of the parameter or {@code null} if no modifiers are known.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    protected Integer getModifiers() {
<b class="fc">&nbsp;                        return modifiers;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A token representing a record component.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class RecordComponentToken {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s descriptor.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s generic signature or {@code null} if it is non-generic.
&nbsp;                 */
&nbsp;                @UnknownNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s signature resolution.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForRecordComponent signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the record component&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of the record component&#39;s annotations.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new record component token.
&nbsp;                 *
&nbsp;                 * @param name                 The record component&#39;s name.
&nbsp;                 * @param descriptor           The record component&#39;s descriptor.
&nbsp;                 * @param genericSignature     The record component&#39;s generic signature or {@code null} if it is non-generic.
&nbsp;                 * @param typeAnnotationTokens A mapping of the record component&#39;s type annotations.
&nbsp;                 * @param annotationTokens     A list of the record component&#39;s annotations.
&nbsp;                 */
&nbsp;                protected RecordComponentToken(String name,
&nbsp;                                               String descriptor,
&nbsp;                                               @MaybeNull String genericSignature,
&nbsp;                                               Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens,
<b class="fc">&nbsp;                                               List&lt;AnnotationToken&gt; annotationTokens) {</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    signatureResolution = RAW_TYPES</b>
<b class="nc">&nbsp;                            ? GenericTypeToken.Resolution.Raw.INSTANCE</b>
<b class="fc">&nbsp;                            : GenericTypeExtractor.ForSignature.OfRecordComponent.extract(genericSignature);</b>
<b class="fc">&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Transforms this record component token to a record component description that is attached to a lazy type description.
&nbsp;                 *
&nbsp;                 * @param lazyTypeDescription The lazy type description to attach this record component description to.
&nbsp;                 * @return A record component description representing this record component token.
&nbsp;                 */
&nbsp;                private RecordComponentDescription.InDefinedShape toRecordComponentDescription(LazyTypeDescription lazyTypeDescription) {
<b class="fc">&nbsp;                    return lazyTypeDescription.new LazyRecordComponentDescription(name,</b>
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            signatureResolution,
&nbsp;                            typeAnnotationTokens,
&nbsp;                            annotationTokens);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy description of an annotation that looks up types from a type pool when required.
&nbsp;             */
<b class="fc">&nbsp;            private static class LazyAnnotationDescription extends AnnotationDescription.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool for looking up type references.
&nbsp;                 */
&nbsp;                protected final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of this annotation.
&nbsp;                 */
&nbsp;                private final TypeDescription annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * A map of annotation values by their property name.
&nbsp;                 */
&nbsp;                protected final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy annotation description.
&nbsp;                 *
&nbsp;                 * @param typePool       The type pool to be used for looking up linked types.
&nbsp;                 * @param annotationType The annotation&#39;s type.
&nbsp;                 * @param values         A map of annotation value names to their value representations.
&nbsp;                 */
<b class="fc">&nbsp;                private LazyAnnotationDescription(TypePool typePool, TypeDescription annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                    this.values = values;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
&nbsp;                 * a type that cannot be loaded from the type pool is ignored and not included in the list. If the provided
&nbsp;                 * {@code tokens} are {@code null}, an empty list is returned.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @param tokens   The tokens to represent in the list.
&nbsp;                 * @return A list of the loadable annotations.
&nbsp;                 */
&nbsp;                protected static AnnotationList asListOfNullable(TypePool typePool, @MaybeNull List&lt;? extends AnnotationToken&gt; tokens) {
<b class="fc">&nbsp;                    return tokens == null</b>
<b class="fc">&nbsp;                            ? new AnnotationList.Empty()</b>
<b class="fc">&nbsp;                            : asList(typePool, tokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a list of annotation tokens in form of a list of lazy type annotations. Any annotation with
&nbsp;                 * a type that cannot be loaded from the type pool is ignored and not included in the list.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to be used for looking up linked types.
&nbsp;                 * @param tokens   The tokens to represent in the list.
&nbsp;                 * @return A list of the represented annotations.
&nbsp;                 */
&nbsp;                protected static AnnotationList asList(TypePool typePool, List&lt;? extends AnnotationToken&gt; tokens) {
<b class="fc">&nbsp;                    List&lt;AnnotationDescription&gt; annotationDescriptions = new ArrayList&lt;AnnotationDescription&gt;(tokens.size());</b>
<b class="fc">&nbsp;                    for (AnnotationToken token : tokens) {</b>
<b class="fc">&nbsp;                        AnnotationToken.Resolution resolution = token.toAnnotationDescription(typePool);</b>
<b class="fc">&nbsp;                        if (resolution.isResolved() &amp;&amp; resolution.resolve().getAnnotationType().isAnnotation()) {</b>
<b class="fc">&nbsp;                            annotationDescriptions.add(resolution.resolve());</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new UnresolvedAnnotationList(annotationDescriptions, tokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
<b class="fc">&nbsp;                    if (!property.getDeclaringType().asErasure().equals(annotationType)) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(property + &quot; is not declared by &quot; + getAnnotationType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    AnnotationValue&lt;?, ?&gt; annotationValue = values.get(property.getName());</b>
<b class="fc">&nbsp;                    if (annotationValue != null) {</b>
<b class="fc">&nbsp;                        return annotationValue.filter(property);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        annotationValue = getAnnotationType().getDeclaredMethods().filter(is(property)).getOnly().getDefaultValue();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return annotationValue == null</b>
<b class="fc">&nbsp;                            ? new AnnotationValue.ForMissingValue&lt;Void, Void&gt;(annotationType, property.getName())</b>
<b class="fc">&nbsp;                            : annotationValue;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
<b class="fc">&nbsp;                    if (!this.annotationType.represents(annotationType)) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotationType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Loadable&lt;T&gt;(typePool, annotationType, values);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A loadable version of a lazy annotation description.
&nbsp;                 *
&nbsp;                 * @param &lt;S&gt; The annotation type.
&nbsp;                 */
<b class="fc">&nbsp;                private static class Loadable&lt;S extends Annotation&gt; extends LazyAnnotationDescription implements AnnotationDescription.Loadable&lt;S&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The loaded annotation type.
&nbsp;                     */
&nbsp;                    private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new loadable version of a lazy annotation.
&nbsp;                     *
&nbsp;                     * @param typePool       The type pool to be used for looking up linked types.
&nbsp;                     * @param annotationType The annotation&#39;s loaded type.
&nbsp;                     * @param values         A map of annotation value names to their value representations.
&nbsp;                     */
&nbsp;                    private Loadable(TypePool typePool, Class&lt;S&gt; annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values) {
<b class="fc">&nbsp;                        super(typePool, ForLoadedType.of(annotationType), values);</b>
<b class="fc">&nbsp;                        this.annotationType = annotationType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public S load() {
<b class="fc">&nbsp;                        return AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, values);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotations which allows for resolving the names of the annotations even if the annotations cannot be resolved.
&nbsp;                 */
<b class="fc">&nbsp;                private static class UnresolvedAnnotationList extends AnnotationList.Explicit {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The list of represented annotation tokens.
&nbsp;                     */
&nbsp;                    private final List&lt;? extends AnnotationToken&gt; tokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list of unresolved annotations.
&nbsp;                     *
&nbsp;                     * @param annotationDescriptions The list of represented annotation descriptions.
&nbsp;                     * @param tokens                 The list of represented annotation tokens.
&nbsp;                     */
&nbsp;                    private UnresolvedAnnotationList(List&lt;? extends AnnotationDescription&gt; annotationDescriptions, List&lt;? extends AnnotationToken&gt; tokens) {
<b class="fc">&nbsp;                        super(annotationDescriptions);</b>
<b class="fc">&nbsp;                        this.tokens = tokens;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public List&lt;String&gt; asTypeNames() {
<b class="nc">&nbsp;                        List&lt;String&gt; typeNames = new ArrayList&lt;String&gt;(tokens.size());</b>
<b class="nc">&nbsp;                        for (AnnotationToken token : tokens) {</b>
<b class="nc">&nbsp;                            typeNames.add(token.getBinaryName());</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        return typeNames;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A proxy for a lazy annotation value.
&nbsp;             *
&nbsp;             * @param &lt;U&gt; The represented unloaded type.
&nbsp;             * @param &lt;V&gt; The represented loaded type.
&nbsp;             */
<b class="fc">&nbsp;            private abstract static class LazyAnnotationValue&lt;U, V&gt; extends AnnotationValue.AbstractBase&lt;U, V&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the actual annotation value.
&nbsp;                 *
&nbsp;                 * @return The actual annotation value.
&nbsp;                 */
&nbsp;                protected abstract AnnotationValue&lt;U, V&gt; doResolve();
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public State getState() {
<b class="nc">&nbsp;                    return doResolve().getState();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                    return doResolve().filter(property, typeDefinition);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public U resolve() {
<b class="fc">&nbsp;                    return doResolve().resolve();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Loaded&lt;V&gt; load(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                    return doResolve().load(classLoader);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    return doResolve().hashCode();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;                    return doResolve().equals(other);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString() {
<b class="fc">&nbsp;                    return doResolve().toString();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy for a mismatched type for which the property is not yet know.
&nbsp;                 *
&nbsp;                 * @param &lt;W&gt; The represented unloaded type.
&nbsp;                 * @param &lt;X&gt; The represented loaded type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                private static class ForMismatchedType&lt;W, X&gt; extends AbstractBase&lt;W, X&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The mismatched value.
&nbsp;                     */
&nbsp;                    private final String value;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The mismatched array type.
&nbsp;                     */
&nbsp;                    private final Sort sort;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new mismatched type proxy.
&nbsp;                     *
&nbsp;                     * @param value The mismatched value.
&nbsp;                     * @param sort  The mismatched array type.
&nbsp;                     */
<b class="fc">&nbsp;                    private ForMismatchedType(String value, Sort sort) {</b>
<b class="fc">&nbsp;                        this.value = value;</b>
<b class="fc">&nbsp;                        this.sort = sort;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public State getState() {
<b class="nc">&nbsp;                        return State.UNRESOLVED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="nc">&nbsp;                        return Sort.NONE;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationValue&lt;W, X&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                        return new ForMismatchedType&lt;W, X&gt;(property, property.getReturnType().isArray()</b>
<b class="fc">&nbsp;                                ? RenderingDispatcher.CURRENT.toArrayErrorString(sort)</b>
<b class="fc">&nbsp;                                : value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public W resolve() {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Expected filtering of this unresolved property&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Loaded&lt;X&gt; load(@MaybeNull ClassLoader classLoader) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Expected filtering of this unresolved property&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy annotation value description for a type value.
&nbsp;                 */
<b class="fc">&nbsp;                private static class ForTypeValue extends LazyAnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to query for the type.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type&#39;s binary name.
&nbsp;                     */
&nbsp;                    private final String typeName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy description of an annotation type constant.
&nbsp;                     *
&nbsp;                     * @param typePool The type pool to query for the type.
&nbsp;                     * @param typeName The type&#39;s binary name.
&nbsp;                     */
<b class="fc">&nbsp;                    private ForTypeValue(TypePool typePool, String typeName) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.typeName = typeName;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="nc">&nbsp;                        return Sort.TYPE;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;                    protected AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt; doResolve() {
<b class="fc">&nbsp;                        Resolution resolution = typePool.describe(typeName);</b>
<b class="fc">&nbsp;                        return resolution.isResolved()</b>
<b class="fc">&nbsp;                                ? new AnnotationValue.ForTypeDescription(resolution.resolve())</b>
<b class="fc">&nbsp;                                : new AnnotationValue.ForMissingType&lt;TypeDescription, Class&lt;?&gt;&gt;(typeName);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy annotation value description for an annotation value.
&nbsp;                 */
<b class="fc">&nbsp;                private static class ForAnnotationValue extends LazyAnnotationValue&lt;AnnotationDescription, Annotation&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for resolving the annotation type.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation token.
&nbsp;                     */
&nbsp;                    private final AnnotationToken annotationToken;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy annotation value.
&nbsp;                     *
&nbsp;                     * @param typePool        The type pool to use for resolving the annotation type.
&nbsp;                     * @param annotationToken The annotation token.
&nbsp;                     */
<b class="fc">&nbsp;                    private ForAnnotationValue(TypePool typePool, AnnotationToken annotationToken) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.annotationToken = annotationToken;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="fc">&nbsp;                        return Sort.ANNOTATION;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected AnnotationValue&lt;AnnotationDescription, Annotation&gt; doResolve() {
<b class="fc">&nbsp;                        AnnotationToken.Resolution resolution = annotationToken.toAnnotationDescription(typePool);</b>
<b class="fc">&nbsp;                        if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                            return new AnnotationValue.ForMissingType&lt;AnnotationDescription, Annotation&gt;(annotationToken.getBinaryName());</b>
<b class="fc">&nbsp;                        } else if (!resolution.resolve().getAnnotationType().isAnnotation()) {</b>
<b class="fc">&nbsp;                            return new ForMismatchedType&lt;AnnotationDescription, Annotation&gt;(resolution.resolve().getAnnotationType().getName(), Sort.ANNOTATION);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return new AnnotationValue.ForAnnotationDescription&lt;Annotation&gt;(resolution.resolve());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy annotation value description for an enumeration value.
&nbsp;                 */
<b class="fc">&nbsp;                private static class ForEnumerationValue extends LazyAnnotationValue&lt;EnumerationDescription, Enum&lt;?&gt;&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for looking up types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The binary name of the enumeration type.
&nbsp;                     */
&nbsp;                    private final String typeName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the enumeration.
&nbsp;                     */
&nbsp;                    private final String value;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a lazy annotation value description for an enumeration.
&nbsp;                     *
&nbsp;                     * @param typePool The type pool to use for looking up types.
&nbsp;                     * @param typeName The binary name of the enumeration type.
&nbsp;                     * @param value    The name of the enumeration.
&nbsp;                     */
<b class="fc">&nbsp;                    private ForEnumerationValue(TypePool typePool, String typeName, String value) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.typeName = typeName;</b>
<b class="fc">&nbsp;                        this.value = value;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="fc">&nbsp;                        return Sort.ENUMERATION;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;                    protected AnnotationValue&lt;EnumerationDescription, Enum&lt;?&gt;&gt; doResolve() {
<b class="fc">&nbsp;                        Resolution resolution = typePool.describe(typeName);</b>
<b class="fc">&nbsp;                        if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                            return new AnnotationValue.ForMissingType&lt;EnumerationDescription, Enum&lt;?&gt;&gt;(typeName);</b>
<b class="fc">&nbsp;                        } else if (!resolution.resolve().isEnum()) {</b>
<b class="fc">&nbsp;                            return new ForMismatchedType&lt;EnumerationDescription, Enum&lt;?&gt;&gt;(typeName + &quot;.&quot; + value, Sort.ENUMERATION);</b>
<b class="fc">&nbsp;                        } else if (resolution.resolve().getDeclaredFields().filter(named(value)).isEmpty()) {</b>
<b class="fc">&nbsp;                            return new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(resolution.resolve(), value);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return new AnnotationValue.ForEnumerationDescription(new EnumerationDescription.Latent(resolution.resolve(), value));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy projection of an annotation value that contains an array of values.
&nbsp;                 */
<b class="fc">&nbsp;                private static class ForArray extends LazyAnnotationValue&lt;Object, Object&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for looking up types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A reference to the component type.
&nbsp;                     */
&nbsp;                    private final ComponentTypeReference componentTypeReference;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of all values of this array value in their order.
&nbsp;                     */
&nbsp;                    private final List&lt;AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a lazy projection for a non-primitive array.
&nbsp;                     *
&nbsp;                     * @param typePool               The type pool to use for looking up types.
&nbsp;                     * @param componentTypeReference A reference to the component type.
&nbsp;                     * @param values                 A list of all values of this array value in their order.
&nbsp;                     */
<b class="fc">&nbsp;                    private ForArray(TypePool typePool, ComponentTypeReference componentTypeReference, List&lt;AnnotationValue&lt;?, ?&gt;&gt; values) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.componentTypeReference = componentTypeReference;</b>
<b class="fc">&nbsp;                        this.values = values;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Sort getSort() {
<b class="nc">&nbsp;                        return Sort.ARRAY;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected AnnotationValue&lt;Object, Object&gt; doResolve() {
<b class="fc">&nbsp;                        String typeName = componentTypeReference.resolve();</b>
<b class="fc">&nbsp;                        if (typeName != null) {</b>
<b class="fc">&nbsp;                            Resolution resolution = typePool.describe(typeName);</b>
<b class="fc">&nbsp;                            if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                                return new ForMissingType&lt;Object, Object&gt;(typeName);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().isEnum()) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(EnumerationDescription.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().isAnnotation()) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(AnnotationDescription.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(Class.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(TypeDescription.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(String.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(String.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(boolean.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(boolean.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(byte.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(byte.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(short.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(short.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(char.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(char.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(int.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(int.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(long.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(long.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(float.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(float.class, resolution.resolve(), values);</b>
<b class="fc">&nbsp;                            } else if (resolution.resolve().represents(double.class)) {</b>
<b class="fc">&nbsp;                                return new AnnotationValue.ForDescriptionArray&lt;Object, Object&gt;(double.class, resolution.resolve(), values);</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        Sort sort = Sort.NONE;</b>
<b class="fc">&nbsp;                        ListIterator&lt;AnnotationValue&lt;?, ?&gt;&gt; iterator = values.listIterator(values.size());</b>
<b class="fc">&nbsp;                        while (iterator.hasPrevious() &amp;&amp; !sort.isDefined()) {</b>
<b class="fc">&nbsp;                            sort = iterator.previous().getSort();</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new ForMismatchedType&lt;Object, Object&gt;(RenderingDispatcher.CURRENT.toArrayErrorString(sort), sort);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a {@link PackageDescription} that only
&nbsp;             * loads its annotations on requirement.
&nbsp;             */
<b class="fc">&nbsp;            private static class LazyPackageDescription extends PackageDescription.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for look-ups.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the package.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy package description.
&nbsp;                 *
&nbsp;                 * @param typePool The type pool to use for look-ups.
&nbsp;                 * @param name     The name of the package.
&nbsp;                 */
<b class="fc">&nbsp;                private LazyPackageDescription(TypePool typePool, String name) {</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    this.name = name;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    Resolution resolution = typePool.describe(name + &quot;.&quot; + PackageDescription.PACKAGE_CLASS_NAME);</b>
<b class="fc">&nbsp;                    return resolution.isResolved()</b>
<b class="fc">&nbsp;                            ? resolution.resolve().getDeclaredAnnotations()</b>
<b class="fc">&nbsp;                            : new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A list that is constructing {@link LazyTypeDescription}s.
&nbsp;             */
&nbsp;            protected static class LazyTypeList extends TypeList.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for locating types.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type descriptors that this list represents.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; descriptors;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a list of lazy type descriptions.
&nbsp;                 *
&nbsp;                 * @param typePool    The type pool to use for locating types.
&nbsp;                 * @param descriptors A list of type descriptors that this list represents.
&nbsp;                 */
<b class="fc">&nbsp;                protected LazyTypeList(TypePool typePool, List&lt;String&gt; descriptors) {</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    this.descriptors = descriptors;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription get(int index) {
<b class="fc">&nbsp;                    return TokenizedGenericType.toErasure(typePool, descriptors.get(index));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int size() {
<b class="fc">&nbsp;                    return descriptors.size();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public String[] toInternalNames() {
<b class="fc">&nbsp;                    String[] internalName = new String[descriptors.size()];</b>
<b class="fc">&nbsp;                    int index = 0;</b>
<b class="fc">&nbsp;                    for (String descriptor : descriptors) {</b>
<b class="fc">&nbsp;                        internalName[index++] = Type.getType(descriptor).getInternalName();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return internalName.length == 0</b>
<b class="fc">&nbsp;                            ? NO_INTERFACES</b>
<b class="fc">&nbsp;                            : internalName;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getStackSize() {
<b class="fc">&nbsp;                    int stackSize = 0;</b>
<b class="fc">&nbsp;                    for (String descriptor : descriptors) {</b>
<b class="fc">&nbsp;                        stackSize += Type.getType(descriptor).getSize();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return stackSize;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy list that represents all nest members of the represented type.
&nbsp;             */
&nbsp;            protected static class LazyNestMemberList extends TypeList.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type for which the nest members are represented.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for looking up types.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The binary names of all nest members of this nest mate group excluding the represented type.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; nestMembers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy type list of all nest members of this group.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type for which the nest members are represented.
&nbsp;                 * @param typePool        The type pool to use for looking up types.
&nbsp;                 * @param nestMembers     The binary names of all nest members of this nest mate group excluding the represented type.
&nbsp;                 */
<b class="fc">&nbsp;                protected LazyNestMemberList(TypeDescription typeDescription, TypePool typePool, List&lt;String&gt; nestMembers) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    this.nestMembers = nestMembers;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription get(int index) {
<b class="fc">&nbsp;                    return index == 0</b>
<b class="fc">&nbsp;                            ? typeDescription</b>
<b class="nc">&nbsp;                            : typePool.describe(nestMembers.get(index - 1)).resolve();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int size() {
<b class="fc">&nbsp;                    return nestMembers.size() + 1;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String[] toInternalNames() {
<b class="nc">&nbsp;                    String[] internalName = new String[nestMembers.size() + 1];</b>
<b class="nc">&nbsp;                    internalName[0] = typeDescription.getInternalName();</b>
<b class="nc">&nbsp;                    int index = 1;</b>
<b class="nc">&nbsp;                    for (String name : nestMembers) {</b>
<b class="nc">&nbsp;                        internalName[index++] = name.replace(&#39;.&#39;, &#39;/&#39;);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return internalName;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getStackSize() {
<b class="nc">&nbsp;                    return nestMembers.size() + 1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A representation of a generic type that is described by a {@link GenericTypeToken}.
&nbsp;             */
&nbsp;            protected static class TokenizedGenericType extends Generic.LazyProjection.WithEagerNavigation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use for locating referenced types.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The token that describes the represented generic type.
&nbsp;                 */
&nbsp;                private final GenericTypeToken genericTypeToken;
&nbsp;
&nbsp;                /**
&nbsp;                 * A descriptor of the generic type&#39;s raw type.
&nbsp;                 */
&nbsp;                private final String rawTypeDescriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The tokenized type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                 */
&nbsp;                private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new tokenized generic type.
&nbsp;                 *
&nbsp;                 * @param typePool           The type pool to use for locating referenced types.
&nbsp;                 * @param genericTypeToken   The token that describes the represented generic type.
&nbsp;                 * @param rawTypeDescriptor  A descriptor of the generic type&#39;s erasure.
&nbsp;                 * @param annotationTokens   The tokenized type&#39;s type annotation tokens.
&nbsp;                 * @param typeVariableSource The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                 */
&nbsp;                protected TokenizedGenericType(TypePool typePool,
&nbsp;                                               GenericTypeToken genericTypeToken,
&nbsp;                                               String rawTypeDescriptor,
&nbsp;                                               Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                               TypeVariableSource typeVariableSource) {</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    this.genericTypeToken = genericTypeToken;</b>
<b class="fc">&nbsp;                    this.rawTypeDescriptor = rawTypeDescriptor;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                    this.typeVariableSource = typeVariableSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new generic type description for a tokenized generic type.
&nbsp;                 *
&nbsp;                 * @param typePool           The type pool to use for locating referenced types.
&nbsp;                 * @param genericTypeToken   The token that describes the represented generic type.
&nbsp;                 * @param rawTypeDescriptor  A descriptor of the generic type&#39;s erasure.
&nbsp;                 * @param annotationTokens   The tokenized type&#39;s type annotation tokens or {@code null} if no such annotations are defined.
&nbsp;                 * @param typeVariableSource The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                 * @return A suitable generic type.
&nbsp;                 */
&nbsp;                protected static Generic of(TypePool typePool,
&nbsp;                                            GenericTypeToken genericTypeToken,
&nbsp;                                            String rawTypeDescriptor,
&nbsp;                                            @MaybeNull Map&lt;String, List&lt;AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                            TypeVariableSource typeVariableSource) {
<b class="fc">&nbsp;                    return new TokenizedGenericType(typePool,</b>
&nbsp;                            genericTypeToken,
&nbsp;                            rawTypeDescriptor,
<b class="fc">&nbsp;                            annotationTokens == null</b>
<b class="fc">&nbsp;                                    ? Collections.&lt;String, List&lt;AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                    : annotationTokens,</b>
&nbsp;                            typeVariableSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type description from a descriptor by looking up the corresponding type.
&nbsp;                 *
&nbsp;                 * @param typePool   The type pool to use for locating a type.
&nbsp;                 * @param descriptor The descriptor to interpret.
&nbsp;                 * @return A description of the type represented by the descriptor.
&nbsp;                 */
&nbsp;                protected static TypeDescription toErasure(TypePool typePool, String descriptor) {
<b class="fc">&nbsp;                    Type type = Type.getType(descriptor);</b>
<b class="fc">&nbsp;                    return typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="fc">&nbsp;                            ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="fc">&nbsp;                            : type.getClassName()).resolve();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return genericTypeToken.toGenericType(typePool, typeVariableSource, GenericTypeToken.EMPTY_TYPE_PATH, annotationTokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @CachedReturnPlugin.Enhance(&quot;erasure&quot;)
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return toErasure(typePool, rawTypeDescriptor);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return resolve().getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A tokenized list of generic types.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class TokenList extends TypeList.Generic.AbstractBase {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for locating types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Type tokens that describe the represented generic types.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken&gt; genericTypeTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of the generic types&#39; erasures.
&nbsp;                     */
&nbsp;                    private final List&lt;String&gt; rawTypeDescriptors;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of each type&#39;s type annotation tokens by its index.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list of tokenized generic types.
&nbsp;                     *
&nbsp;                     * @param typePool           The type pool to use for locating type descriptions.
&nbsp;                     * @param genericTypeTokens  A list of tokens describing the represented generic types.
&nbsp;                     * @param annotationTokens   A mapping of each type&#39;s type annotation tokens by its index.
&nbsp;                     * @param rawTypeDescriptors A list of the generic types&#39; erasures.
&nbsp;                     * @param typeVariableSource The closest type variable source of this generic type&#39;s declaration context.
&nbsp;                     */
&nbsp;                    private TokenList(TypePool typePool,
&nbsp;                                      List&lt;GenericTypeToken&gt; genericTypeTokens,
&nbsp;                                      Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
&nbsp;                                      List&lt;String&gt; rawTypeDescriptors,
<b class="fc">&nbsp;                                      TypeVariableSource typeVariableSource) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.genericTypeTokens = genericTypeTokens;</b>
<b class="fc">&nbsp;                        this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                        this.rawTypeDescriptors = rawTypeDescriptors;</b>
<b class="fc">&nbsp;                        this.typeVariableSource = typeVariableSource;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return rawTypeDescriptors.size() == genericTypeTokens.size()</b>
<b class="fc">&nbsp;                                ? TokenizedGenericType.of(typePool, genericTypeTokens.get(index), rawTypeDescriptors.get(index), annotationTokens.get(index), typeVariableSource)</b>
<b class="fc">&nbsp;                                : TokenizedGenericType.toErasure(typePool, rawTypeDescriptors.get(index)).asGenericType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return rawTypeDescriptors.size();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList asErasures() {
<b class="fc">&nbsp;                        return new LazyTypeList(typePool, rawTypeDescriptors);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of tokenized type variables.
&nbsp;                 */
&nbsp;                protected static class TypeVariableList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for locating types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Type tokens that describe the represented type variables.
&nbsp;                     */
&nbsp;                    private final List&lt;GenericTypeToken.OfFormalTypeVariable&gt; typeVariables;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable source of the represented type variables.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of the type variables&#39; bound types&#39; annotation tokens by their indices and each type variable&#39;s index..
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list of type variables.
&nbsp;                     *
&nbsp;                     * @param typePool              The type pool to use for locating types.
&nbsp;                     * @param typeVariables         Type tokens that describe the represented generic types.
&nbsp;                     * @param typeVariableSource    The type variable source of the represented type variables.
&nbsp;                     * @param annotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                     * @param boundAnnotationTokens A mapping of the type variables&#39; bound types&#39; annotation tokens by their indices
&nbsp;                     *                              and each type variable&#39;s index.
&nbsp;                     */
&nbsp;                    protected TypeVariableList(TypePool typePool,
&nbsp;                                               List&lt;GenericTypeToken.OfFormalTypeVariable&gt; typeVariables,
&nbsp;                                               TypeVariableSource typeVariableSource,
&nbsp;                                               Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; annotationTokens,
<b class="fc">&nbsp;                                               Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; boundAnnotationTokens) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.typeVariables = typeVariables;</b>
<b class="fc">&nbsp;                        this.typeVariableSource = typeVariableSource;</b>
<b class="fc">&nbsp;                        this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                        this.boundAnnotationTokens = boundAnnotationTokens;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return typeVariables.get(index).toGenericType(typePool, typeVariableSource, annotationTokens.get(index), boundAnnotationTokens.get(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return typeVariables.size();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a non-well-defined described generic type.
&nbsp;                 */
&nbsp;                protected static class Malformed extends LazyProjection.WithEagerNavigation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type pool to use for locating types.
&nbsp;                     */
&nbsp;                    private final TypePool typePool;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The descriptor of the type erasure.
&nbsp;                     */
&nbsp;                    private final String rawTypeDescriptor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a lazy description of a non-well-defined described generic type.
&nbsp;                     *
&nbsp;                     * @param typePool          The type pool to use for locating types.
&nbsp;                     * @param rawTypeDescriptor The descriptor of the type erasure.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Malformed(TypePool typePool, String rawTypeDescriptor) {</b>
<b class="fc">&nbsp;                        this.typePool = typePool;</b>
<b class="fc">&nbsp;                        this.rawTypeDescriptor = rawTypeDescriptor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic resolve() {
<b class="fc">&nbsp;                        throw new GenericSignatureFormatError();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription asErasure() {
<b class="nc">&nbsp;                        return toErasure(typePool, rawTypeDescriptor);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        throw new GenericSignatureFormatError();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A tokenized list of non-well-defined generic types.
&nbsp;                     */
&nbsp;                    protected static class TokenList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type pool to use for locating types.
&nbsp;                         */
&nbsp;                        private final TypePool typePool;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A list of descriptors of the list&#39;s types&#39; erasures.
&nbsp;                         */
&nbsp;                        private final List&lt;String&gt; rawTypeDescriptors;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new tokenized list of generic types.
&nbsp;                         *
&nbsp;                         * @param typePool           The type pool to use for locating types.
&nbsp;                         * @param rawTypeDescriptors A list of descriptors of the list&#39;s types&#39; erasures.
&nbsp;                         */
<b class="fc">&nbsp;                        protected TokenList(TypePool typePool, List&lt;String&gt; rawTypeDescriptors) {</b>
<b class="fc">&nbsp;                            this.typePool = typePool;</b>
<b class="fc">&nbsp;                            this.rawTypeDescriptors = rawTypeDescriptors;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic get(int index) {
<b class="fc">&nbsp;                            return new Malformed(typePool, rawTypeDescriptors.get(index));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public int size() {
<b class="fc">&nbsp;                            return rawTypeDescriptors.size();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList asErasures() {
<b class="nc">&nbsp;                            return new LazyTypeList(typePool, rawTypeDescriptors);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy field description that only resolved type references when required.
&nbsp;             */
<b class="fc">&nbsp;            private class LazyFieldDescription extends FieldDescription.InDefinedShape.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of the field.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of this field&#39;s type.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution of this field&#39;s generic type.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForField signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation descriptions of this field.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy field description.
&nbsp;                 *
&nbsp;                 * @param name                 The name of the field.
&nbsp;                 * @param modifiers            The modifiers of the field.
&nbsp;                 * @param descriptor           The descriptor of this field&#39;s type.
&nbsp;                 * @param genericSignature     The field&#39;s generic signature as found in the class file or {@code null} if the field is not generic.
&nbsp;                 * @param signatureResolution  A resolution of this field&#39;s generic type.
&nbsp;                 * @param typeAnnotationTokens A mapping of the field type&#39;s type annotation tokens.
&nbsp;                 * @param annotationTokens     A list of annotation descriptions of this field.
&nbsp;                 */
&nbsp;                private LazyFieldDescription(String name,
&nbsp;                                             int modifiers,
&nbsp;                                             String descriptor,
&nbsp;                                             @MaybeNull String genericSignature,
&nbsp;                                             GenericTypeToken.Resolution.ForField signatureResolution,
&nbsp;                                             Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens,
<b class="fc">&nbsp;                                             List&lt;AnnotationToken&gt; annotationTokens) {</b>
<b class="fc">&nbsp;                    this.modifiers = modifiers;</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    this.signatureResolution = signatureResolution;</b>
<b class="fc">&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getType() {
<b class="fc">&nbsp;                    return signatureResolution.resolveFieldType(descriptor, typePool, typeAnnotationTokens, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return LazyAnnotationDescription.asListOfNullable(typePool, annotationTokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return LazyTypeDescription.this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getModifiers() {
<b class="fc">&nbsp;                    return modifiers;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public String getGenericSignature() {
<b class="nc">&nbsp;                    return genericSignature;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy representation of a method that resolves references to types only on demand.
&nbsp;             */
<b class="fc">&nbsp;            private class LazyMethodDescription extends MethodDescription.InDefinedShape.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name of this method.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers of this method.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the return type.
&nbsp;                 */
&nbsp;                private final String returnTypeDescriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic type token of this method.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForMethod signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type descriptions of this method&#39;s parameters.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; parameterTypeDescriptors;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type descriptions of this method&#39;s exception types.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; exceptionTypeDescriptors;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their indices and each variable&#39;s index.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the return type&#39;s type variable tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the receiver type&#39;s type annotation tokens.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation tokens representing the method&#39;s annotations.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation tokens representing the parameter&#39;s annotation. Every index can
&nbsp;                 * contain {@code null} if a parameter does not define any annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of parameter names which may be {@code null} if no explicit name is known for a parameter.
&nbsp;                 */
&nbsp;                private final String[] parameterNames;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of parameter modifiers which may be {@code null} if no modifiers is known.
&nbsp;                 */
&nbsp;                private final Integer[] parameterModifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value of this method or {@code null} if no such value exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy method description.
&nbsp;                 *
&nbsp;                 * @param internalName                      The internal name of this method.
&nbsp;                 * @param modifiers                         The modifiers of the represented method.
&nbsp;                 * @param descriptor                        The method descriptor of this method.
&nbsp;                 * @param genericSignature                  The method&#39;s generic signature as found in the class file or {@code null} if the method is not generic.
&nbsp;                 * @param signatureResolution               The generic type token of this method.
&nbsp;                 * @param exceptionTypeInternalName         The internal names of the exceptions that are declared by this
&nbsp;                 *                                          method or {@code null} if no exceptions are declared by this
&nbsp;                 *                                          method.
&nbsp;                 * @param typeVariableAnnotationTokens      A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;                 * @param typeVariableBoundAnnotationTokens A mapping of the type variables&#39; type bounds&#39; type annotation tokens by their
&nbsp;                 *                                          index and each variable&#39;s index.
&nbsp;                 * @param returnTypeAnnotationTokens        A mapping of the return type&#39;s type variable tokens.
&nbsp;                 * @param parameterTypeAnnotationTokens     A mapping of the parameter types&#39; type annotation tokens by their indices.
&nbsp;                 * @param exceptionTypeAnnotationTokens     A mapping of the exception types&#39; type annotation tokens by their indices.
&nbsp;                 * @param receiverTypeAnnotationTokens      A mapping of the receiver type&#39;s type annotation tokens.
&nbsp;                 * @param annotationTokens                  The annotation tokens representing the method&#39;s annotations.
&nbsp;                 * @param parameterAnnotationTokens         The annotation tokens representing the parameter&#39;s annotation. Every
&nbsp;                 *                                          index can contain {@code null} if a parameter does not define any annotations.
&nbsp;                 * @param parameterTokens                   A list of parameter tokens which might be empty or even out of sync
&nbsp;                 *                                          with the actual parameters if the debugging information found in a
&nbsp;                 *                                          class was corrupt.
&nbsp;                 * @param defaultValue                      The default value of this method or {@code null} if there is no
&nbsp;                 */
&nbsp;                private LazyMethodDescription(String internalName,
&nbsp;                                              int modifiers,
&nbsp;                                              String descriptor,
&nbsp;                                              @MaybeNull String genericSignature,
&nbsp;                                              GenericTypeToken.Resolution.ForMethod signatureResolution,
&nbsp;                                              @MaybeNull String[] exceptionTypeInternalName,
&nbsp;                                              Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens,
&nbsp;                                              Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens,
&nbsp;                                              Map&lt;String, List&lt;AnnotationToken&gt;&gt; returnTypeAnnotationTokens,
&nbsp;                                              Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens,
&nbsp;                                              Map&lt;Integer, Map&lt;String, List&lt;AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens,
&nbsp;                                              Map&lt;String, List&lt;AnnotationToken&gt;&gt; receiverTypeAnnotationTokens,
&nbsp;                                              List&lt;AnnotationToken&gt; annotationTokens,
&nbsp;                                              Map&lt;Integer, List&lt;AnnotationToken&gt;&gt; parameterAnnotationTokens,
&nbsp;                                              List&lt;MethodToken.ParameterToken&gt; parameterTokens,
<b class="fc">&nbsp;                                              @MaybeNull AnnotationValue&lt;?, ?&gt; defaultValue) {</b>
<b class="fc">&nbsp;                    this.modifiers = modifiers;</b>
<b class="fc">&nbsp;                    this.internalName = internalName;</b>
<b class="fc">&nbsp;                    Type methodType = Type.getMethodType(descriptor);</b>
<b class="fc">&nbsp;                    Type returnType = methodType.getReturnType();</b>
<b class="fc">&nbsp;                    Type[] parameterType = methodType.getArgumentTypes();</b>
<b class="fc">&nbsp;                    returnTypeDescriptor = returnType.getDescriptor();</b>
<b class="fc">&nbsp;                    parameterTypeDescriptors = new ArrayList&lt;String&gt;(parameterType.length);</b>
<b class="fc">&nbsp;                    for (Type type : parameterType) {</b>
<b class="fc">&nbsp;                        parameterTypeDescriptors.add(type.getDescriptor());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    this.signatureResolution = signatureResolution;</b>
<b class="fc">&nbsp;                    if (exceptionTypeInternalName == null) {</b>
<b class="fc">&nbsp;                        exceptionTypeDescriptors = Collections.emptyList();</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        exceptionTypeDescriptors = new ArrayList&lt;String&gt;(exceptionTypeInternalName.length);</b>
<b class="fc">&nbsp;                        for (String anExceptionTypeInternalName : exceptionTypeInternalName) {</b>
<b class="fc">&nbsp;                            exceptionTypeDescriptors.add(Type.getObjectType(anExceptionTypeInternalName).getDescriptor());</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    this.typeVariableAnnotationTokens = typeVariableAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.typeVariableBoundAnnotationTokens = typeVariableBoundAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.returnTypeAnnotationTokens = returnTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.parameterTypeAnnotationTokens = parameterTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.exceptionTypeAnnotationTokens = exceptionTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.receiverTypeAnnotationTokens = receiverTypeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
<b class="fc">&nbsp;                    this.parameterAnnotationTokens = parameterAnnotationTokens;</b>
<b class="fc">&nbsp;                    parameterNames = new String[parameterType.length];</b>
<b class="fc">&nbsp;                    parameterModifiers = new Integer[parameterType.length];</b>
<b class="fc">&nbsp;                    if (parameterTokens.size() == parameterType.length) {</b>
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        for (MethodToken.ParameterToken parameterToken : parameterTokens) {</b>
<b class="fc">&nbsp;                            parameterNames[index] = parameterToken.getName();</b>
<b class="fc">&nbsp;                            parameterModifiers[index] = parameterToken.getModifiers();</b>
<b class="fc">&nbsp;                            index++;</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;                    this.defaultValue = defaultValue;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getReturnType() {
<b class="fc">&nbsp;                    return signatureResolution.resolveReturnType(returnTypeDescriptor, typePool, returnTypeAnnotationTokens, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                    return signatureResolution.resolveExceptionTypes(exceptionTypeDescriptors, typePool, exceptionTypeAnnotationTokens, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                    return new LazyParameterList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return LazyAnnotationDescription.asList(typePool, annotationTokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getInternalName() {
<b class="fc">&nbsp;                    return internalName;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return LazyTypeDescription.this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getModifiers() {
<b class="fc">&nbsp;                    return modifiers;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                    return signatureResolution.resolveTypeVariables(typePool, this, typeVariableAnnotationTokens, typeVariableBoundAnnotationTokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;                    return defaultValue;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getReceiverType() {
<b class="fc">&nbsp;                    if (isStatic()) {</b>
<b class="fc">&nbsp;                        return Generic.UNDEFINED;</b>
<b class="fc">&nbsp;                    } else if (isConstructor()) {</b>
<b class="fc">&nbsp;                        TypeDescription declaringType = getDeclaringType(), enclosingDeclaringType = declaringType.getEnclosingType();</b>
<b class="fc">&nbsp;                        if (enclosingDeclaringType == null) {</b>
<b class="fc">&nbsp;                            return declaringType.isGenerified()</b>
<b class="nc">&nbsp;                                    ? new LazyParameterizedReceiverType(declaringType)</b>
<b class="fc">&nbsp;                                    : new LazyNonGenericReceiverType(declaringType);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return !declaringType.isStatic() &amp;&amp; declaringType.isGenerified()</b>
<b class="fc">&nbsp;                                    ? new LazyParameterizedReceiverType(enclosingDeclaringType)</b>
<b class="fc">&nbsp;                                    : new LazyNonGenericReceiverType(enclosingDeclaringType);</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="fc">&nbsp;                        return LazyTypeDescription.this.isGenerified()</b>
<b class="fc">&nbsp;                                ? new LazyParameterizedReceiverType()</b>
<b class="fc">&nbsp;                                : new LazyNonGenericReceiverType();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public String getGenericSignature() {
<b class="nc">&nbsp;                    return genericSignature;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy list of parameter descriptions for the enclosing method description.
&nbsp;                 */
<b class="fc">&nbsp;                private class LazyParameterList extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                        return new LazyParameterDescription(index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean hasExplicitMetaData() {
<b class="nc">&nbsp;                        for (int i = 0; i &lt; size(); i++) {</b>
<b class="nc">&nbsp;                            if (parameterNames[i] == null || parameterModifiers[i] == null) {</b>
<b class="nc">&nbsp;                                return false;</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return parameterTypeDescriptors.size();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic asTypeList() {
<b class="fc">&nbsp;                        return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, parameterTypeAnnotationTokens, LazyMethodDescription.this);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a parameters of the enclosing method.
&nbsp;                 */
&nbsp;                private class LazyParameterDescription extends ParameterDescription.InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the described parameter.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new description for a given parameter of the enclosing method.
&nbsp;                     *
&nbsp;                     * @param index The index of the described parameter.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LazyParameterDescription(int index) {</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="fc">&nbsp;                        return LazyMethodDescription.this;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getIndex() {
<b class="fc">&nbsp;                        return index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isNamed() {
<b class="fc">&nbsp;                        return parameterNames[index] != null;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean hasModifiers() {
<b class="fc">&nbsp;                        return parameterModifiers[index] != null;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getName() {
<b class="fc">&nbsp;                        return isNamed()</b>
<b class="fc">&nbsp;                                ? parameterNames[index]</b>
<b class="fc">&nbsp;                                : super.getName();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getModifiers() {
<b class="fc">&nbsp;                        return hasModifiers()</b>
<b class="fc">&nbsp;                                ? parameterModifiers[index]</b>
<b class="fc">&nbsp;                                : super.getModifiers();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic getType() {
<b class="fc">&nbsp;                        return signatureResolution.resolveParameterTypes(parameterTypeDescriptors, typePool, parameterTypeAnnotationTokens, LazyMethodDescription.this).get(index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                        return LazyAnnotationDescription.asListOfNullable(typePool, parameterAnnotationTokens.get(index));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a parameterized receiver type.
&nbsp;                 */
<b class="fc">&nbsp;                private class LazyParameterizedReceiverType extends Generic.OfParameterizedType {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The erasure of the type to be represented as a parameterized receiver type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy parameterized receiver type of the method&#39;s declaring type.
&nbsp;                     */
&nbsp;                    protected LazyParameterizedReceiverType() {
<b class="fc">&nbsp;                        this(LazyTypeDescription.this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy parameterized receiver type of the supplied receiver type.
&nbsp;                     *
&nbsp;                     * @param typeDescription The erasure of the type to be represented as a parameterized receiver type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LazyParameterizedReceiverType(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                        return new TypeArgumentList(typeDescription.getTypeVariables());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public Generic getOwnerType() {
<b class="fc">&nbsp;                        TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="fc">&nbsp;                        if (declaringType == null) {</b>
<b class="nc">&nbsp;                            return Generic.UNDEFINED;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return !typeDescription.isStatic() &amp;&amp; declaringType.isGenerified()</b>
<b class="fc">&nbsp;                                    ? new LazyParameterizedReceiverType(declaringType)</b>
<b class="fc">&nbsp;                                    : new LazyNonGenericReceiverType(declaringType);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                        return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(getTypePath()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the type path for this type.
&nbsp;                     *
&nbsp;                     * @return This type&#39;s type path.
&nbsp;                     */
&nbsp;                    private String getTypePath() {
<b class="fc">&nbsp;                        StringBuilder typePath = new StringBuilder();</b>
<b class="fc">&nbsp;                        for (int index = 0; index &lt; typeDescription.getInnerClassCount(); index++) {</b>
<b class="fc">&nbsp;                            typePath = typePath.append(GenericTypeToken.INNER_CLASS_PATH);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return typePath.toString();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription asErasure() {
<b class="fc">&nbsp;                        return typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of generic types representing the receiver type&#39;s type arguments.
&nbsp;                     */
&nbsp;                    protected class TypeArgumentList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type variables of the represented receiver type.
&nbsp;                         */
&nbsp;                        private final List&lt;? extends Generic&gt; typeVariables;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type argument list.
&nbsp;                         *
&nbsp;                         * @param typeVariables The type variables of the represented receiver type.
&nbsp;                         */
<b class="fc">&nbsp;                        protected TypeArgumentList(List&lt;? extends Generic&gt; typeVariables) {</b>
<b class="fc">&nbsp;                            this.typeVariables = typeVariables;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic get(int index) {
<b class="fc">&nbsp;                            return new AnnotatedTypeVariable(typeVariables.get(index), index);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public int size() {
<b class="fc">&nbsp;                            return typeVariables.size();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Represents a type variable as a type argument with type annotations.
&nbsp;                         */
&nbsp;                        protected class AnnotatedTypeVariable extends OfTypeVariable {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s description.
&nbsp;                             */
&nbsp;                            private final Generic typeVariable;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type variable&#39;s index.
&nbsp;                             */
&nbsp;                            private final int index;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new description of an annotated type variable as a type argument.
&nbsp;                             *
&nbsp;                             * @param typeVariable The type variable&#39;s description.
&nbsp;                             * @param index        The type variable&#39;s index.
&nbsp;                             */
<b class="fc">&nbsp;                            protected AnnotatedTypeVariable(Generic typeVariable, int index) {</b>
<b class="fc">&nbsp;                                this.typeVariable = typeVariable;</b>
<b class="fc">&nbsp;                                this.index = index;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                                return typeVariable.getUpperBounds();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                                return typeVariable.getTypeVariableSource();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public String getSymbol() {
<b class="fc">&nbsp;                                return typeVariable.getSymbol();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                                return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(getTypePath()</b>
&nbsp;                                        + index
&nbsp;                                        + GenericTypeToken.INDEXED_TYPE_DELIMITER));
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy description of a non-generic receiver type.
&nbsp;                 */
&nbsp;                protected class LazyNonGenericReceiverType extends Generic.OfNonGenericType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type description of the non-generic receiver type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new non-generic receiver type of the method&#39;s declaring type.
&nbsp;                     */
&nbsp;                    protected LazyNonGenericReceiverType() {
<b class="fc">&nbsp;                        this(LazyTypeDescription.this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new non-generic receiver type of the supplied type.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type to represent as a non-generic receiver type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LazyNonGenericReceiverType(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public Generic getOwnerType() {
<b class="fc">&nbsp;                        TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="fc">&nbsp;                        return declaringType == null</b>
<b class="fc">&nbsp;                                ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                                : new LazyNonGenericReceiverType(declaringType);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public Generic getComponentType() {
<b class="nc">&nbsp;                        return Generic.UNDEFINED;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                        StringBuilder typePath = new StringBuilder();</b>
<b class="fc">&nbsp;                        for (int index = 0; index &lt; typeDescription.getInnerClassCount(); index++) {</b>
<b class="fc">&nbsp;                            typePath = typePath.append(GenericTypeToken.INNER_CLASS_PATH);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return LazyAnnotationDescription.asListOfNullable(typePool, receiverTypeAnnotationTokens.get(typePath.toString()));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription asErasure() {
<b class="fc">&nbsp;                        return typeDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy description of a record component.
&nbsp;             */
<b class="fc">&nbsp;            private class LazyRecordComponentDescription extends RecordComponentDescription.InDefinedShape.AbstractBase {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s descriptor.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s generic signature or {@code null} if the record component is non-generic.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s signature resolution.
&nbsp;                 */
&nbsp;                private final GenericTypeToken.Resolution.ForRecordComponent signatureResolution;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the record component&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of the record components annotations.
&nbsp;                 */
&nbsp;                private final List&lt;AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy description of a record component.
&nbsp;                 *
&nbsp;                 * @param name                 The record component&#39;s name.
&nbsp;                 * @param descriptor           The record component&#39;s descriptor.
&nbsp;                 * @param genericSignature     The record component&#39;s generic signature or {@code null} if the record component is non-generic.
&nbsp;                 * @param signatureResolution  The record component&#39;s signature resolution.
&nbsp;                 * @param typeAnnotationTokens A mapping of the record component&#39;s type annotations.
&nbsp;                 * @param annotationTokens     A list of the record components annotations.
&nbsp;                 */
&nbsp;                private LazyRecordComponentDescription(String name,
&nbsp;                                                       String descriptor,
&nbsp;                                                       @MaybeNull String genericSignature,
&nbsp;                                                       GenericTypeToken.Resolution.ForRecordComponent signatureResolution,
&nbsp;                                                       Map&lt;String, List&lt;AnnotationToken&gt;&gt; typeAnnotationTokens,
<b class="fc">&nbsp;                                                       List&lt;AnnotationToken&gt; annotationTokens) {</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    this.signatureResolution = signatureResolution;</b>
<b class="fc">&nbsp;                    this.typeAnnotationTokens = typeAnnotationTokens;</b>
<b class="fc">&nbsp;                    this.annotationTokens = annotationTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getType() {
<b class="fc">&nbsp;                    return signatureResolution.resolveRecordType(descriptor, typePool, typeAnnotationTokens, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @Nonnull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return LazyTypeDescription.this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getActualName() {
<b class="fc">&nbsp;                    return name;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return LazyAnnotationDescription.asList(typePool, annotationTokens);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public String getGenericSignature() {
<b class="nc">&nbsp;                    return genericSignature;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type extractor reads a class file and collects data that is relevant to create a type description.
&nbsp;         */
<b class="fc">&nbsp;        protected class TypeExtractor extends ClassVisitor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The index of a super class&#39;s type annotations.
&nbsp;             */
&nbsp;            private static final int SUPER_CLASS_INDEX = -1;
&nbsp;
&nbsp;            /**
&nbsp;             * A mask that cuts off pseudo flags beyond the second byte that are inserted by ASM.
&nbsp;             */
&nbsp;            private static final int REAL_MODIFIER_MASK = 0xFFFF;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the super types&#39; type annotation tokens by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; superTypeAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the type variables&#39; type annotation tokens by their indices.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the type variables&#39; bounds&#39; type annotation tokens by their indices and each variables index.
&nbsp;             */
&nbsp;            private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundsAnnotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of annotation tokens describing annotations that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of field tokens describing fields that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.FieldToken&gt; fieldTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of method tokens describing annotations that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.MethodToken&gt; methodTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of record component tokens that are found on the visited type.
&nbsp;             */
&nbsp;            private final List&lt;LazyTypeDescription.RecordComponentToken&gt; recordComponentTokens;
&nbsp;
&nbsp;            /**
&nbsp;             * The actual modifiers found for this type.
&nbsp;             */
&nbsp;            private int actualModifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The modifiers found for this type.
&nbsp;             */
&nbsp;            private int modifiers;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name found for this type.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private String internalName;
&nbsp;
&nbsp;            /**
&nbsp;             * The internal name of the super type found for this type or {@code null} if no such type exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private String superClassName;
&nbsp;
&nbsp;            /**
&nbsp;             * The generic signature of the type or {@code null} if it is not generic.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private String genericSignature;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of internal names of interfaces implemented by this type or {@code null} if no interfaces
&nbsp;             * are implemented.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private String[] interfaceName;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this type was found to represent an anonymous type.
&nbsp;             */
&nbsp;            private boolean anonymousType;
&nbsp;
&nbsp;            /**
&nbsp;             * The nest host that was found in the class file or {@code null} if no nest host was specified.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private String nestHost;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of nest members that were found in the class file.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; nestMembers;
&nbsp;
&nbsp;            /**
&nbsp;             * The declaration context found for this type.
&nbsp;             */
&nbsp;            private LazyTypeDescription.TypeContainment typeContainment;
&nbsp;
&nbsp;            /**
&nbsp;             * The binary name of this type&#39;s declaring type or {@code null} if no such type exists.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private String declaringTypeName;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of descriptors representing the types that are declared by the parsed type.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; declaredTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of internal names of permitted subclasses.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; permittedSubclasses;
&nbsp;
&nbsp;            /**
&nbsp;             * The discovered class file version or {@code null} if no version was yet discovered.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private ClassFileVersion classFileVersion;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type extractor.
&nbsp;             */
<b class="fc">&nbsp;            protected TypeExtractor() {</b>
<b class="fc">&nbsp;                super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                superTypeAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                typeVariableAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                typeVariableBoundsAnnotationTokens = new HashMap&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();</b>
<b class="fc">&nbsp;                fieldTokens = new ArrayList&lt;LazyTypeDescription.FieldToken&gt;();</b>
<b class="fc">&nbsp;                methodTokens = new ArrayList&lt;LazyTypeDescription.MethodToken&gt;();</b>
<b class="fc">&nbsp;                recordComponentTokens = new ArrayList&lt;LazyTypeDescription.RecordComponentToken&gt;();</b>
<b class="fc">&nbsp;                anonymousType = false;</b>
<b class="fc">&nbsp;                typeContainment = LazyTypeDescription.TypeContainment.SelfContained.INSTANCE;</b>
<b class="fc">&nbsp;                nestMembers = new ArrayList&lt;String&gt;();</b>
<b class="fc">&nbsp;                declaredTypes = new ArrayList&lt;String&gt;();</b>
<b class="fc">&nbsp;                permittedSubclasses = new ArrayList&lt;String&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not modified by class contract.&quot;)
&nbsp;            public void visit(int classFileVersion,
&nbsp;                              int modifiers,
&nbsp;                              String internalName,
&nbsp;                              @MaybeNull String genericSignature,
&nbsp;                              @MaybeNull String superClassName,
&nbsp;                              @MaybeNull String[] interfaceName) {
<b class="fc">&nbsp;                this.modifiers = modifiers &amp; REAL_MODIFIER_MASK;</b>
<b class="fc">&nbsp;                actualModifiers = modifiers;</b>
<b class="fc">&nbsp;                this.internalName = internalName;</b>
<b class="fc">&nbsp;                this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                this.superClassName = superClassName;</b>
<b class="fc">&nbsp;                this.interfaceName = interfaceName;</b>
<b class="fc">&nbsp;                this.classFileVersion = ClassFileVersion.ofMinorMajor(classFileVersion);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitOuterClass(@MaybeNull String typeName, @MaybeNull String methodName, String methodDescriptor) {
<b class="fc">&nbsp;                if (methodName != null &amp;&amp; !methodName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)) {</b>
<b class="fc">&nbsp;                    typeContainment = new LazyTypeDescription.TypeContainment.WithinMethod(typeName, methodName, methodDescriptor);</b>
<b class="fc">&nbsp;                } else if (typeName != null) {</b>
<b class="fc">&nbsp;                    typeContainment = new LazyTypeDescription.TypeContainment.WithinType(typeName, true);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitInnerClass(String internalName, @MaybeNull String outerName, @MaybeNull String innerName, int modifiers) {
<b class="fc">&nbsp;                if (internalName.equals(this.internalName)) {</b>
<b class="fc">&nbsp;                    if (outerName != null) {</b>
<b class="fc">&nbsp;                        declaringTypeName = outerName;</b>
<b class="fc">&nbsp;                        if (typeContainment.isSelfContained()) {</b>
<b class="fc">&nbsp;                            typeContainment = new LazyTypeDescription.TypeContainment.WithinType(outerName, false);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    if (innerName == null &amp;&amp; !typeContainment.isSelfContained()) { // Some compilers define this property inconsistently.</b>
<b class="fc">&nbsp;                        anonymousType = true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    this.modifiers = modifiers &amp; REAL_MODIFIER_MASK;</b>
<b class="fc">&nbsp;                } else if (outerName != null &amp;&amp; innerName != null &amp;&amp; outerName.equals(this.internalName)) {</b>
<b class="fc">&nbsp;                    declaredTypes.add(&quot;L&quot; + internalName + &quot;;&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
&nbsp;                AnnotationRegistrant annotationRegistrant;
<b class="fc">&nbsp;                TypeReference typeReference = new TypeReference(rawTypeReference);</b>
<b class="fc">&nbsp;                switch (typeReference.getSort()) {</b>
&nbsp;                    case TypeReference.CLASS_EXTENDS:
<b class="fc">&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor,</b>
&nbsp;                                typePath,
<b class="fc">&nbsp;                                typeReference.getSuperTypeIndex(),</b>
&nbsp;                                superTypeAnnotationTokens);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case TypeReference.CLASS_TYPE_PARAMETER:
<b class="fc">&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex(descriptor,</b>
&nbsp;                                typePath,
<b class="fc">&nbsp;                                typeReference.getTypeParameterIndex(),</b>
&nbsp;                                typeVariableAnnotationTokens);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case TypeReference.CLASS_TYPE_PARAMETER_BOUND:
<b class="fc">&nbsp;                        annotationRegistrant = new AnnotationRegistrant.ForTypeVariable.WithIndex.DoubleIndexed(descriptor,</b>
&nbsp;                                typePath,
<b class="fc">&nbsp;                                typeReference.getTypeParameterBoundIndex(),</b>
<b class="fc">&nbsp;                                typeReference.getTypeParameterIndex(),</b>
&nbsp;                                typeVariableBoundsAnnotationTokens);
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Unexpected type reference: &quot; + typeReference.getSort());</b>
&nbsp;                }
<b class="fc">&nbsp;                return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="fc">&nbsp;                return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public FieldVisitor visitField(int modifiers, String internalName, String descriptor, @MaybeNull String genericSignature, @MaybeNull Object value) {
<b class="fc">&nbsp;                return new FieldExtractor(modifiers &amp; REAL_MODIFIER_MASK, internalName, descriptor, genericSignature);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String genericSignature, @MaybeNull String[] exceptionName) {
<b class="fc">&nbsp;                return internalName.equals(MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME)</b>
<b class="fc">&nbsp;                        ? IGNORE_METHOD</b>
<b class="fc">&nbsp;                        : new MethodExtractor(modifiers &amp; REAL_MODIFIER_MASK, internalName, descriptor, genericSignature, exceptionName);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitNestHost(String nestHost) {
<b class="fc">&nbsp;                this.nestHost = nestHost;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitNestMember(String nestMember) {
<b class="fc">&nbsp;                nestMembers.add(nestMember);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public RecordComponentVisitor visitRecordComponent(String name, String descriptor, @MaybeNull String signature) {
<b class="fc">&nbsp;                return new RecordComponentExtractor(name, descriptor, signature);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitPermittedSubclass(String permittedSubclass) {
<b class="fc">&nbsp;                permittedSubclasses.add(permittedSubclass);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a type description from all data that is currently collected. This method should only be invoked
&nbsp;             * after a class file was parsed fully.
&nbsp;             *
&nbsp;             * @return A type description reflecting the data that was collected by this instance.
&nbsp;             */
&nbsp;            protected TypeDescription toTypeDescription() {
<b class="fc">&nbsp;                if (internalName == null || classFileVersion == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Internal name or class file version were not set&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; superClassAnnotationTokens = superTypeAnnotationTokens.remove(SUPER_CLASS_INDEX);</b>
<b class="fc">&nbsp;                return new LazyTypeDescription(Default.this,</b>
&nbsp;                        actualModifiers,
&nbsp;                        modifiers,
&nbsp;                        internalName,
&nbsp;                        superClassName,
&nbsp;                        interfaceName,
&nbsp;                        genericSignature,
&nbsp;                        typeContainment,
&nbsp;                        declaringTypeName,
&nbsp;                        declaredTypes,
&nbsp;                        anonymousType,
&nbsp;                        nestHost,
&nbsp;                        nestMembers,
<b class="fc">&nbsp;                        superClassAnnotationTokens == null</b>
<b class="fc">&nbsp;                                ? Collections.&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;emptyMap()</b>
<b class="fc">&nbsp;                                : superClassAnnotationTokens,</b>
&nbsp;                        superTypeAnnotationTokens,
&nbsp;                        typeVariableAnnotationTokens,
&nbsp;                        typeVariableBoundsAnnotationTokens,
&nbsp;                        annotationTokens,
&nbsp;                        fieldTokens,
&nbsp;                        methodTokens,
&nbsp;                        recordComponentTokens,
&nbsp;                        permittedSubclasses,
&nbsp;                        classFileVersion);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An annotation extractor reads an annotation found in a class field an collects data that
&nbsp;             * is relevant to creating a related annotation description.
&nbsp;             */
<b class="fc">&nbsp;            protected class AnnotationExtractor extends AnnotationVisitor {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation registrant to register found annotation values on.
&nbsp;                 */
&nbsp;                private final AnnotationRegistrant annotationRegistrant;
&nbsp;
&nbsp;                /**
&nbsp;                 * A locator for the component type of any found annotation value.
&nbsp;                 */
&nbsp;                private final ComponentTypeLocator componentTypeLocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation extractor for a byte code element without an index.
&nbsp;                 *
&nbsp;                 * @param descriptor           The annotation descriptor.
&nbsp;                 * @param annotationTokens     The collection for storing any discovered annotation tokens.
&nbsp;                 * @param componentTypeLocator The component type locator to use.
&nbsp;                 */
&nbsp;                protected AnnotationExtractor(String descriptor, List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens, ComponentTypeLocator componentTypeLocator) {
<b class="fc">&nbsp;                    this(new AnnotationRegistrant.ForByteCodeElement(descriptor, annotationTokens), componentTypeLocator);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation extractor for a byte code element with an index.
&nbsp;                 *
&nbsp;                 * @param descriptor           The annotation descriptor.
&nbsp;                 * @param index                The index of the element for which the annotations are collected.
&nbsp;                 * @param annotationTokens     The collection for storing any discovered annotation tokens.
&nbsp;                 * @param componentTypeLocator The component type locator to use.
&nbsp;                 */
&nbsp;                protected AnnotationExtractor(String descriptor,
&nbsp;                                              int index,
&nbsp;                                              Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; annotationTokens,
&nbsp;                                              ComponentTypeLocator componentTypeLocator) {
<b class="fc">&nbsp;                    this(new AnnotationRegistrant.ForByteCodeElement.WithIndex(descriptor, index, annotationTokens), componentTypeLocator);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new annotation extractor.
&nbsp;                 *
&nbsp;                 * @param annotationRegistrant The annotation registrant to register found annotation values on.
&nbsp;                 * @param componentTypeLocator A locator for the component type of any found annotation value.
&nbsp;                 */
<b class="fc">&nbsp;                protected AnnotationExtractor(AnnotationRegistrant annotationRegistrant, ComponentTypeLocator componentTypeLocator) {</b>
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                    this.annotationRegistrant = annotationRegistrant;</b>
<b class="fc">&nbsp;                    this.componentTypeLocator = componentTypeLocator;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visit(String name, Object value) {
<b class="fc">&nbsp;                    if (value instanceof Type) {</b>
<b class="fc">&nbsp;                        Type type = (Type) value;</b>
<b class="fc">&nbsp;                        annotationRegistrant.register(name, new LazyTypeDescription.LazyAnnotationValue.ForTypeValue(Default.this, type.getSort() == Type.ARRAY</b>
<b class="fc">&nbsp;                                ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="fc">&nbsp;                                : type.getClassName()));</b>
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        annotationRegistrant.register(name, AnnotationValue.ForConstant.of(value));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnum(String name, String descriptor, String value) {
<b class="fc">&nbsp;                    annotationRegistrant.register(name, new LazyTypeDescription.LazyAnnotationValue.ForEnumerationValue(Default.this,</b>
<b class="fc">&nbsp;                            descriptor.substring(1, descriptor.length() - 1).replace(&#39;/&#39;, &#39;.&#39;),</b>
&nbsp;                            value));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String name, String descriptor) {
<b class="fc">&nbsp;                    return new AnnotationExtractor(new AnnotationLookup(descriptor, name), new ComponentTypeLocator.ForAnnotationProperty(TypePool.Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitArray(String name) {
<b class="fc">&nbsp;                    return new AnnotationExtractor(new ArrayLookup(name, componentTypeLocator.bind(name)), ComponentTypeLocator.Illegal.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
<b class="fc">&nbsp;                    annotationRegistrant.onComplete();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation registrant for registering values of an array.
&nbsp;                 */
<b class="fc">&nbsp;                protected class ArrayLookup implements AnnotationRegistrant {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the annotation property the collected array is representing.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A lazy reference to resolve the component type of the collected array.
&nbsp;                     */
&nbsp;                    private final ComponentTypeReference componentTypeReference;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of all annotation values that are found on this array.
&nbsp;                     */
&nbsp;                    private final List&lt;AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation registrant for an array lookup.
&nbsp;                     *
&nbsp;                     * @param name                   The name of the annotation property the collected array is representing.
&nbsp;                     * @param componentTypeReference A lazy reference to resolve the component type of the collected array.
&nbsp;                     */
<b class="fc">&nbsp;                    private ArrayLookup(String name, ComponentTypeReference componentTypeReference) {</b>
<b class="fc">&nbsp;                        this.name = name;</b>
<b class="fc">&nbsp;                        this.componentTypeReference = componentTypeReference;</b>
<b class="fc">&nbsp;                        values = new ArrayList&lt;AnnotationValue&lt;?, ?&gt;&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(String ignored, AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;                        values.add(annotationValue);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onComplete() {
<b class="fc">&nbsp;                        annotationRegistrant.register(name, new LazyTypeDescription.LazyAnnotationValue.ForArray(Default.this,</b>
&nbsp;                                componentTypeReference,
&nbsp;                                values));
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation registrant for registering the values on an array that is itself an annotation property.
&nbsp;                 */
&nbsp;                protected class AnnotationLookup implements AnnotationRegistrant {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The descriptor of the original annotation for which the annotation values are looked up.
&nbsp;                     */
&nbsp;                    private final String descriptor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the original annotation for which the annotation values are looked up.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * This annotation&#39;s values mapped by their attribute name.
&nbsp;                     */
&nbsp;                    private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation registrant for a recursive annotation lookup.
&nbsp;                     *
&nbsp;                     * @param descriptor The descriptor of the original annotation for which the annotation values are looked up.
&nbsp;                     * @param name       The name of the original annotation for which the annotation values are looked up.
&nbsp;                     */
<b class="fc">&nbsp;                    protected AnnotationLookup(String descriptor, String name) {</b>
<b class="fc">&nbsp;                        this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                        this.name = name;</b>
<b class="fc">&nbsp;                        values = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(String name, AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;                        values.put(name, annotationValue);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onComplete() {
<b class="fc">&nbsp;                        annotationRegistrant.register(name, new LazyTypeDescription.LazyAnnotationValue.ForAnnotationValue(Default.this,</b>
&nbsp;                                new LazyTypeDescription.AnnotationToken(descriptor, values)));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A field extractor reads a field within a class file and collects data that is relevant
&nbsp;             * to creating a related field description.
&nbsp;             */
&nbsp;            protected class FieldExtractor extends FieldVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers found on the field.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor of the field type.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic signature of the field or {@code null} if it is not generic.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the field type&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens found for this field.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new field extractor.
&nbsp;                 *
&nbsp;                 * @param modifiers        The modifiers found for this field.
&nbsp;                 * @param internalName     The name of the field.
&nbsp;                 * @param descriptor       The descriptor of the field type.
&nbsp;                 * @param genericSignature The generic signature of the field or {@code null} if it is not generic.
&nbsp;                 */
&nbsp;                protected FieldExtractor(int modifiers,
&nbsp;                                         String internalName,
&nbsp;                                         String descriptor,
<b class="fc">&nbsp;                                         @MaybeNull String genericSignature) {</b>
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                    this.modifiers = modifiers;</b>
<b class="fc">&nbsp;                    this.internalName = internalName;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    typeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();</b>
<b class="fc">&nbsp;                    annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    AnnotationRegistrant annotationRegistrant;
<b class="fc">&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);</b>
<b class="fc">&nbsp;                    switch (typeReference.getSort()) {</b>
&nbsp;                        case TypeReference.FIELD:
<b class="fc">&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, typeAnnotationTokens);</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on field: &quot; + typeReference.getSort());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="fc">&nbsp;                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
<b class="fc">&nbsp;                    fieldTokens.add(new LazyTypeDescription.FieldToken(internalName,</b>
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            typeAnnotationTokens,
&nbsp;                            annotationTokens));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method extractor reads a method within a class file and collects data that is relevant
&nbsp;             * to creating a related method description.
&nbsp;             */
&nbsp;            protected class MethodExtractor extends MethodVisitor implements AnnotationRegistrant {
&nbsp;
&nbsp;                /**
&nbsp;                 * The modifiers found for this method.
&nbsp;                 */
&nbsp;                private final int modifiers;
&nbsp;
&nbsp;                /**
&nbsp;                 * The internal name found for this method.
&nbsp;                 */
&nbsp;                private final String internalName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The descriptor found for this method.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic signature of the method or {@code null} if it is not generic.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * An array of internal names of the exceptions of the found method
&nbsp;                 * or {@code null} if there are no such exceptions.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String[] exceptionName;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the method&#39;s type variables&#39; type annotations by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; typeVariableAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the method&#39;s type variables&#39; bounds&#39; type annotations by their indices and each variable&#39;s index.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt; typeVariableBoundAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the method&#39;s return type&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; returnTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the parameters&#39; type annotations by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; parameterTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the exception types&#39; type annotations by their indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt; exceptionTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the receiver type&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; receiverTypeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of annotation tokens declared on the found method.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of parameter indices to annotation tokens found for the parameters at these indices.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; parameterAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of tokens representing meta information of a parameter as it is available for method&#39;s
&nbsp;                 * that are compiled in the Java 8 version format.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.MethodToken.ParameterToken&gt; parameterTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A bag of parameter meta information representing debugging information which allows to extract
&nbsp;                 * a method&#39;s parameter names.
&nbsp;                 */
&nbsp;                private final ParameterBag legacyParameterBag;
&nbsp;
&nbsp;                /**
&nbsp;                 * The first label that is found in the method&#39;s body, if any, denoting the start of the method.
&nbsp;                 * This label can be used to identify names of local variables that describe the method&#39;s parameters.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private Label firstLabel;
&nbsp;
&nbsp;                /**
&nbsp;                 * A shift index for visible parameters that indicates a deviation of the actual parameter index.
&nbsp;                 */
&nbsp;                private int visibleParameterShift;
&nbsp;
&nbsp;                /**
&nbsp;                 * A shift index for invisible parameters that indicates a deviation of the actual parameter index.
&nbsp;                 */
&nbsp;                private int invisibleParameterShift;
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value of the found method or {@code null} if no such value exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a method extractor.
&nbsp;                 *
&nbsp;                 * @param modifiers        The modifiers found for this method.
&nbsp;                 * @param internalName     The internal name found for this method.
&nbsp;                 * @param descriptor       The descriptor found for this method.
&nbsp;                 * @param genericSignature The generic signature of the method or {@code null} if it is not generic.
&nbsp;                 * @param exceptionName    An array of internal names of the exceptions of the found method
&nbsp;                 *                         or {@code null} if there are no such exceptions.
&nbsp;                 */
&nbsp;                protected MethodExtractor(int modifiers,
&nbsp;                                          String internalName,
&nbsp;                                          String descriptor,
&nbsp;                                          @MaybeNull String genericSignature,
<b class="fc">&nbsp;                                          @MaybeNull String[] exceptionName) {</b>
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                    this.modifiers = modifiers;</b>
<b class="fc">&nbsp;                    this.internalName = internalName;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    this.exceptionName = exceptionName;</b>
<b class="fc">&nbsp;                    typeVariableAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    typeVariableBoundAnnotationTokens = new HashMap&lt;Integer, Map&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    returnTypeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();</b>
<b class="fc">&nbsp;                    parameterTypeAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    exceptionTypeAnnotationTokens = new HashMap&lt;Integer, Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    receiverTypeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();</b>
<b class="fc">&nbsp;                    annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();</b>
<b class="fc">&nbsp;                    parameterAnnotationTokens = new HashMap&lt;Integer, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();</b>
<b class="fc">&nbsp;                    parameterTokens = new ArrayList&lt;LazyTypeDescription.MethodToken.ParameterToken&gt;();</b>
<b class="fc">&nbsp;                    legacyParameterBag = new ParameterBag(Type.getMethodType(descriptor).getArgumentTypes());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    AnnotationRegistrant annotationRegistrant;
<b class="fc">&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);</b>
<b class="fc">&nbsp;                    switch (typeReference.getSort()) {</b>
&nbsp;                        case TypeReference.METHOD_TYPE_PARAMETER:
<b class="fc">&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,</b>
&nbsp;                                    typePath,
<b class="fc">&nbsp;                                    typeReference.getTypeParameterIndex(),</b>
&nbsp;                                    typeVariableAnnotationTokens);
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case TypeReference.METHOD_TYPE_PARAMETER_BOUND:
<b class="fc">&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex.DoubleIndexed(descriptor,</b>
&nbsp;                                    typePath,
<b class="fc">&nbsp;                                    typeReference.getTypeParameterBoundIndex(),</b>
<b class="fc">&nbsp;                                    typeReference.getTypeParameterIndex(),</b>
&nbsp;                                    typeVariableBoundAnnotationTokens);
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case TypeReference.METHOD_RETURN:
<b class="fc">&nbsp;                            annotationRegistrant = new ForTypeVariable(descriptor,</b>
&nbsp;                                    typePath,
&nbsp;                                    returnTypeAnnotationTokens);
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case TypeReference.METHOD_FORMAL_PARAMETER:
<b class="fc">&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,</b>
&nbsp;                                    typePath,
<b class="fc">&nbsp;                                    typeReference.getFormalParameterIndex(),</b>
&nbsp;                                    parameterTypeAnnotationTokens);
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case TypeReference.THROWS:
<b class="fc">&nbsp;                            annotationRegistrant = new ForTypeVariable.WithIndex(descriptor,</b>
&nbsp;                                    typePath,
<b class="fc">&nbsp;                                    typeReference.getExceptionIndex(),</b>
&nbsp;                                    exceptionTypeAnnotationTokens);
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case TypeReference.METHOD_RECEIVER:
<b class="fc">&nbsp;                            annotationRegistrant = new ForTypeVariable(descriptor,</b>
&nbsp;                                    typePath,
&nbsp;                                    receiverTypeAnnotationTokens);
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case TypeReference.FIELD: // Emitted by mistake by javac for records in Java 14.
<b class="nc">&nbsp;                            return null;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on method: &quot; + typeReference.getSort());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="fc">&nbsp;                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitAnnotableParameterCount(int count, boolean visible) {
<b class="fc">&nbsp;                    if (visible) {</b>
<b class="fc">&nbsp;                        visibleParameterShift = Type.getMethodType(descriptor).getArgumentTypes().length - count;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        invisibleParameterShift = Type.getMethodType(descriptor).getArgumentTypes().length - count;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
<b class="fc">&nbsp;                    return new AnnotationExtractor(descriptor,</b>
<b class="fc">&nbsp;                            index + (visible ? visibleParameterShift : invisibleParameterShift),</b>
&nbsp;                            parameterAnnotationTokens,
&nbsp;                            new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitLabel(Label label) {
<b class="fc">&nbsp;                    if (readerMode.isExtended() &amp;&amp; firstLabel == null) {</b>
<b class="fc">&nbsp;                        firstLabel = label;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int offset) {
<b class="fc">&nbsp;                    if (readerMode.isExtended() &amp;&amp; start == firstLabel) {</b>
<b class="fc">&nbsp;                        legacyParameterBag.register(offset, name);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitParameter(String name, int modifiers) {
<b class="fc">&nbsp;                    parameterTokens.add(new LazyTypeDescription.MethodToken.ParameterToken(name, modifiers));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
<b class="fc">&nbsp;                    return new AnnotationExtractor(this, new ComponentTypeLocator.ForArrayType(descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void register(String ignored, AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;                    defaultValue = annotationValue;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete() {
&nbsp;                    /* do nothing, as the register method is called at most once for default values */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
<b class="fc">&nbsp;                    methodTokens.add(new LazyTypeDescription.MethodToken(internalName,</b>
&nbsp;                            modifiers,
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            exceptionName,
&nbsp;                            typeVariableAnnotationTokens,
&nbsp;                            typeVariableBoundAnnotationTokens,
&nbsp;                            returnTypeAnnotationTokens,
&nbsp;                            parameterTypeAnnotationTokens,
&nbsp;                            exceptionTypeAnnotationTokens,
&nbsp;                            receiverTypeAnnotationTokens,
&nbsp;                            annotationTokens,
&nbsp;                            parameterAnnotationTokens,
<b class="fc">&nbsp;                            parameterTokens.isEmpty()</b>
<b class="fc">&nbsp;                                    ? legacyParameterBag.resolve((modifiers &amp; Opcodes.ACC_STATIC) != 0)</b>
<b class="fc">&nbsp;                                    : parameterTokens,</b>
&nbsp;                            defaultValue));
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A record component extractor reads a record component&#39;s information within a class file.
&nbsp;             */
&nbsp;            protected class RecordComponentExtractor extends RecordComponentVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s descriptor.
&nbsp;                 */
&nbsp;                private final String descriptor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The record component&#39;s generic signature.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final String genericSignature;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of the record component&#39;s type annotations.
&nbsp;                 */
&nbsp;                private final Map&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt; typeAnnotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of the record component&#39;s annotations.
&nbsp;                 */
&nbsp;                private final List&lt;LazyTypeDescription.AnnotationToken&gt; annotationTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new record component extractor.
&nbsp;                 *
&nbsp;                 * @param name             The record component&#39;s name.
&nbsp;                 * @param descriptor       The record component&#39;s descriptor.
&nbsp;                 * @param genericSignature The record component&#39;s generic signature.
&nbsp;                 */
<b class="fc">&nbsp;                protected RecordComponentExtractor(String name, String descriptor, @MaybeNull String genericSignature) {</b>
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.descriptor = descriptor;</b>
<b class="fc">&nbsp;                    this.genericSignature = genericSignature;</b>
<b class="fc">&nbsp;                    typeAnnotationTokens = new HashMap&lt;String, List&lt;LazyTypeDescription.AnnotationToken&gt;&gt;();</b>
<b class="fc">&nbsp;                    annotationTokens = new ArrayList&lt;LazyTypeDescription.AnnotationToken&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int rawTypeReference, TypePath typePath, String descriptor, boolean visible) {
&nbsp;                    AnnotationRegistrant annotationRegistrant;
<b class="fc">&nbsp;                    TypeReference typeReference = new TypeReference(rawTypeReference);</b>
<b class="fc">&nbsp;                    switch (typeReference.getSort()) {</b>
&nbsp;                        case TypeReference.FIELD:
<b class="fc">&nbsp;                            annotationRegistrant = new AnnotationRegistrant.ForTypeVariable(descriptor, typePath, typeAnnotationTokens);</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Unexpected type reference on record component: &quot; + typeReference.getSort());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new AnnotationExtractor(annotationRegistrant, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="fc">&nbsp;                    return new AnnotationExtractor(descriptor, annotationTokens, new ComponentTypeLocator.ForAnnotationProperty(Default.this, descriptor));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
<b class="fc">&nbsp;                    recordComponentTokens.add(new LazyTypeDescription.RecordComponentToken(name,</b>
&nbsp;                            descriptor,
&nbsp;                            genericSignature,
&nbsp;                            typeAnnotationTokens,
&nbsp;                            annotationTokens));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A lazy facade of a type pool that delegates any lookups to another type pool only if another value than the type&#39;s name is looked up.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class LazyFacade extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type pool to delegate to.
&nbsp;         */
&nbsp;        private final TypePool typePool;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a lazy facade for a type pool.
&nbsp;         *
&nbsp;         * @param typePool The type pool to delegate to.
&nbsp;         */
&nbsp;        public LazyFacade(TypePool typePool) {
<b class="fc">&nbsp;            super(CacheProvider.NoOp.INSTANCE);</b>
<b class="fc">&nbsp;            this.typePool = typePool;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
<b class="fc">&nbsp;            return new LazyResolution(typePool, name);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void clear() {
<b class="fc">&nbsp;            typePool.clear();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The lazy resolution for a lazy facade for a type pool.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class LazyResolution implements Resolution {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to delegate to.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type that is represented by this resolution.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a lazy resolution for a lazy facade for a type pool.
&nbsp;             *
&nbsp;             * @param typePool The type pool to delegate to.
&nbsp;             * @param name     The name of the type that is represented by this resolution.
&nbsp;             */
<b class="fc">&nbsp;            protected LazyResolution(TypePool typePool, String name) {</b>
<b class="fc">&nbsp;                this.typePool = typePool;</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isResolved() {
<b class="fc">&nbsp;                return typePool.describe(name).isResolved();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription resolve() {
<b class="fc">&nbsp;                return new LazyTypeDescription(typePool, name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of a type that delegates to another type pool once a property that is not the name is resolved.
&nbsp;         */
&nbsp;        protected static class LazyTypeDescription extends TypeDescription.AbstractBase.OfSimpleType.WithDelegation {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to delegate to.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the type that is represented by this resolution.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new lazy type resolution.
&nbsp;             *
&nbsp;             * @param typePool The type pool to delegate to.
&nbsp;             * @param name     The name of the type.
&nbsp;             */
<b class="fc">&nbsp;            protected LazyTypeDescription(TypePool typePool, String name) {</b>
<b class="fc">&nbsp;                this.typePool = typePool;</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getName() {
<b class="fc">&nbsp;                return name;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;delegate&quot;)
&nbsp;            protected TypeDescription delegate() {
<b class="fc">&nbsp;                return typePool.describe(name).resolve();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type pool that attempts to load a class.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class ClassLoading extends AbstractBase.Hierarchical {
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to query.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class loadings type pool.
&nbsp;         *
&nbsp;         * @param cacheProvider The cache provider to use.
&nbsp;         * @param parent        The parent type pool.
&nbsp;         * @param classLoader   The class loader to use for locating files.
&nbsp;         */
&nbsp;        public ClassLoading(CacheProvider cacheProvider, TypePool parent, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            super(cacheProvider, parent);</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the given class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to use.
&nbsp;         * @return An class loading type pool.
&nbsp;         */
&nbsp;        public static TypePool of(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            return of(classLoader, Empty.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the given class loader.
&nbsp;         *
&nbsp;         * @param classLoader The class loader to use.
&nbsp;         * @param parent      The parent type pool to use.
&nbsp;         * @return An class loading type pool.
&nbsp;         */
&nbsp;        public static TypePool of(@MaybeNull ClassLoader classLoader, TypePool parent) {
<b class="fc">&nbsp;            return new ClassLoading(new CacheProvider.Simple(), parent, classLoader);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the system class loader.
&nbsp;         *
&nbsp;         * @return An class loading type pool for the system class loader.
&nbsp;         */
&nbsp;        public static TypePool ofSystemLoader() {
<b class="fc">&nbsp;            return of(ClassLoader.getSystemClassLoader());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the platform class loader.
&nbsp;         * If the current VM is Java 8 or older, the extension class loader is represented instead.
&nbsp;         *
&nbsp;         * @return An class loading type pool for the system class loader.
&nbsp;         */
&nbsp;        public static TypePool ofPlatformLoader() {
<b class="fc">&nbsp;            return of(ClassLoader.getSystemClassLoader().getParent());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a type pool that attempts type descriptions by loadings types from the bootstrap class loader.
&nbsp;         *
&nbsp;         * @return An class loading type pool for the bootstrap class loader.
&nbsp;         */
&nbsp;        public static TypePool ofBootLoader() {
<b class="fc">&nbsp;            return of(ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
&nbsp;            try {
<b class="fc">&nbsp;                return new Resolution.Simple(TypeDescription.ForLoadedType.of(Class.forName(name, false, classLoader)));</b>
<b class="fc">&nbsp;            } catch (ClassNotFoundException ignored) {</b>
<b class="fc">&nbsp;                return new Resolution.Illegal(name);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type pool that supplies explicitly known type descriptions.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Explicit extends AbstractBase.Hierarchical {
&nbsp;
&nbsp;        /**
&nbsp;         * A mapping from type names to type descriptions of that name.
&nbsp;         */
&nbsp;        private final Map&lt;String, TypeDescription&gt; types;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new explicit type pool without a parent.
&nbsp;         *
&nbsp;         * @param types A mapping from type names to type descriptions of that name.
&nbsp;         */
&nbsp;        public Explicit(Map&lt;String, TypeDescription&gt; types) {
<b class="nc">&nbsp;            this(Empty.INSTANCE, types);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new explicit type pool.
&nbsp;         *
&nbsp;         * @param parent The parent type pool.
&nbsp;         * @param types  A mapping from type names to type descriptions of that name.
&nbsp;         */
&nbsp;        public Explicit(TypePool parent, Map&lt;String, TypeDescription&gt; types) {
<b class="fc">&nbsp;            super(CacheProvider.NoOp.INSTANCE, parent);</b>
<b class="fc">&nbsp;            this.types = types;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps another type pool for an instrumented type and its auxiliary types.
&nbsp;         *
&nbsp;         * @param instrumentedType The instrumented type.
&nbsp;         * @param auxiliaryTypes   The auxiliary types.
&nbsp;         * @param typePool         The type pool to wrap.
&nbsp;         * @return A type pool that also represents the instrumented type and its auxiliary types.
&nbsp;         */
&nbsp;        public static TypePool wrap(TypeDescription instrumentedType, List&lt;? extends DynamicType&gt; auxiliaryTypes, TypePool typePool) {
<b class="fc">&nbsp;            Map&lt;String, TypeDescription&gt; typeDescriptions = new HashMap&lt;String, TypeDescription&gt;();</b>
<b class="fc">&nbsp;            typeDescriptions.put(instrumentedType.getName(), instrumentedType);</b>
<b class="fc">&nbsp;            for (DynamicType auxiliaryType : auxiliaryTypes) {</b>
<b class="fc">&nbsp;                for (TypeDescription typeDescription : auxiliaryType.getAllTypes().keySet()) {</b>
<b class="fc">&nbsp;                    typeDescriptions.put(typeDescription.getName(), typeDescription);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Explicit(typePool, typeDescriptions);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected Resolution doDescribe(String name) {
<b class="fc">&nbsp;            TypeDescription typeDescription = types.get(name);</b>
<b class="fc">&nbsp;            return typeDescription == null</b>
<b class="fc">&nbsp;                    ? new Resolution.Illegal(name)</b>
<b class="fc">&nbsp;                    : new Resolution.Simple(typeDescription);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
