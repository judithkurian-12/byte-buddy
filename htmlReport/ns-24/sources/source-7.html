


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > JavaConstant</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.utility</a>
</div>

<h1>Coverage Summary for Class: JavaConstant (net.bytebuddy.utility)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">JavaConstant$1</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Dynamic</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/36)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/178)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/105)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodHandle$HandleType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/41)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodHandle$MethodHandleInfo</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodHandle$MethodHandles</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodHandle$MethodHandles$Lookup</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodHandle$MethodType</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/64)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$MethodType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/119)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfClassDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfDirectMethodHandleDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfDirectMethodHandleDesc$ForKind</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfDynamicConstantDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfMethodHandleDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$Dispatcher$OfMethodTypeDesc</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue$ForDouble</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue$ForFloat</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue$ForInteger</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue$ForLong</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTrivialValue$ForString</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Simple$OfTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Visitor</td>
  </tr>
  <tr>
    <td class="name">JavaConstant$Visitor$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/145)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/532)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.utility;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * Represents a constant-pool constant within a Java class file.
&nbsp; */
&nbsp;public interface JavaConstant extends ConstantValue {
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this constant as a Java {@code java.lang.constant.ConstantDesc} if the current VM is of at least version 12.
&nbsp;     * If the current VM is of an older version and does not support the type, an exception is thrown.
&nbsp;     *
&nbsp;     * @return This constant as a Java {@code java.lang.constant.ConstantDesc}.
&nbsp;     */
&nbsp;    Object toDescription();
&nbsp;
&nbsp;    /**
&nbsp;     * Applies the supplied visitor to this constant type with its respective callback.
&nbsp;     *
&nbsp;     * @param visitor The visitor to dispatch.
&nbsp;     * @param &lt;T&gt;     The type of the value that is returned by the visitor.
&nbsp;     * @return The value that is returned by the supplied visitor.
&nbsp;     */
&nbsp;    &lt;T&gt; T accept(Visitor&lt;T&gt; visitor);
&nbsp;
&nbsp;    /**
&nbsp;     * A visitor to resolve a {@link JavaConstant} based on its implementation.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the value that is returned by this visitor.
&nbsp;     */
&nbsp;    interface Visitor&lt;T&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked on a {@link Simple} constant that represents itself. Such values are of type
&nbsp;         * {@link Integer}, {@link Long}, {@link Float}, {@link Double} or {@link String}.
&nbsp;         *
&nbsp;         * @param constant The simple constant.
&nbsp;         * @return The returned value.
&nbsp;         */
&nbsp;        T onValue(Simple&lt;?&gt; constant);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked on a {@link Simple} constant that represents a {@link TypeDescription}.
&nbsp;         *
&nbsp;         * @param constant The simple constant.
&nbsp;         * @return The returned value.
&nbsp;         */
&nbsp;        T onType(Simple&lt;TypeDescription&gt; constant);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked on a constant that represents a {@link MethodType}.
&nbsp;         *
&nbsp;         * @param constant The method type constant.
&nbsp;         * @return The returned value.
&nbsp;         */
&nbsp;        T onMethodType(MethodType constant);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked on a constant that represents a {@link MethodHandle}.
&nbsp;         *
&nbsp;         * @param constant The method handle constant.
&nbsp;         * @return The returned value.
&nbsp;         */
&nbsp;        T onMethodHandle(MethodHandle constant);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked on a {@link Dynamic} constant.
&nbsp;         *
&nbsp;         * @param constant The dynamic constant.
&nbsp;         * @return The returned value.
&nbsp;         */
&nbsp;        T onDynamic(Dynamic constant);
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational implementation of a {@link Visitor} for a {@link JavaConstant}.
&nbsp;         */
<b class="nc">&nbsp;        enum NoOp implements Visitor&lt;JavaConstant&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public JavaConstant onValue(Simple&lt;?&gt; constant) {
<b class="nc">&nbsp;                return constant;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public JavaConstant onType(Simple&lt;TypeDescription&gt; constant) {
<b class="nc">&nbsp;                return constant;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public JavaConstant onMethodType(MethodType constant) {
<b class="nc">&nbsp;                return constant;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public JavaConstant onMethodHandle(MethodHandle constant) {
<b class="nc">&nbsp;                return constant;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public JavaConstant onDynamic(Dynamic constant) {
<b class="nc">&nbsp;                return constant;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a simple Java constant, either a primitive constant, a {@link String} or a {@link Class}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The represented type.
&nbsp;     */
&nbsp;    abstract class Simple&lt;T&gt; implements JavaConstant {
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.ClassDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher CONSTANT_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.ClassDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher.OfClassDesc CLASS_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfClassDesc.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.MethodTypeDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher.OfMethodTypeDesc METHOD_TYPE_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfMethodTypeDesc.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.MethodHandleDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher.OfMethodHandleDesc METHOD_HANDLE_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfMethodHandleDesc.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.DirectMethodHandleDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher.OfDirectMethodHandleDesc DIRECT_METHOD_HANDLE_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfDirectMethodHandleDesc.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.DirectMethodHandleDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher.OfDirectMethodHandleDesc.ForKind DIRECT_METHOD_HANDLE_DESC_KIND = doPrivileged(JavaDispatcher.of(Dispatcher.OfDirectMethodHandleDesc.ForKind.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interaction with {@code java.lang.constant.DirectMethodHandleDesc}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final Dispatcher.OfDynamicConstantDesc DYNAMIC_CONSTANT_DESC = doPrivileged(JavaDispatcher.of(Dispatcher.OfDynamicConstantDesc.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The represented constant pool value.
&nbsp;         */
&nbsp;        protected final T value;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the type of the constant.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a simple Java constant.
&nbsp;         *
&nbsp;         * @param value           The represented constant pool value.
&nbsp;         * @param typeDescription A description of the type of the constant.
&nbsp;         */
<b class="nc">&nbsp;        protected Simple(T value, TypeDescription typeDescription) {</b>
<b class="nc">&nbsp;            this.value = value;</b>
<b class="nc">&nbsp;            this.typeDescription = typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="nc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a loaded Java value to a Java constant representation.
&nbsp;         *
&nbsp;         * @param value The value to represent.
&nbsp;         * @return An appropriate Java constant representation.
&nbsp;         */
&nbsp;        public static JavaConstant ofLoaded(Object value) {
<b class="nc">&nbsp;            JavaConstant constant = ofLoadedOrNull(value);</b>
<b class="nc">&nbsp;            if (constant == null) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a constant: &quot; + value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return constant;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a loaded Java value to a Java constant representation.
&nbsp;         *
&nbsp;         * @param value The value to represent.
&nbsp;         * @return An appropriate Java constant representation or {@code null} if the supplied argument is not a compile-time constant.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected static JavaConstant ofLoadedOrNull(Object value) {
<b class="nc">&nbsp;            if (value instanceof Integer) {</b>
<b class="nc">&nbsp;                return new OfTrivialValue.ForInteger((Integer) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Long) {</b>
<b class="nc">&nbsp;                return new OfTrivialValue.ForLong((Long) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Float) {</b>
<b class="nc">&nbsp;                return new OfTrivialValue.ForFloat((Float) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Double) {</b>
<b class="nc">&nbsp;                return new OfTrivialValue.ForDouble((Double) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof String) {</b>
<b class="nc">&nbsp;                return new OfTrivialValue.ForString((String) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Class&lt;?&gt;) {</b>
<b class="nc">&nbsp;                return JavaConstant.Simple.of(TypeDescription.ForLoadedType.of((Class&lt;?&gt;) value));</b>
<b class="nc">&nbsp;            } else if (JavaType.METHOD_HANDLE.isInstance(value)) {</b>
<b class="nc">&nbsp;                return MethodHandle.ofLoaded(value);</b>
<b class="nc">&nbsp;            } else if (JavaType.METHOD_TYPE.isInstance(value)) {</b>
<b class="nc">&nbsp;                return MethodType.ofLoaded(value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a Java constant value from a {@code java.lang.constant.ConstantDesc}.
&nbsp;         *
&nbsp;         * @param value       The  {@code java.lang.constant.ConstantDesc} to represent.
&nbsp;         * @param classLoader The class loader to use for resolving type information from the supplied value.
&nbsp;         * @return An appropriate Java constant representation.
&nbsp;         */
&nbsp;        public static JavaConstant ofDescription(Object value, @MaybeNull ClassLoader classLoader) {
<b class="nc">&nbsp;            return ofDescription(value, ClassFileLocator.ForClassLoader.of(classLoader));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a Java constant value from a {@code java.lang.constant.ConstantDesc}.
&nbsp;         *
&nbsp;         * @param value            The  {@code java.lang.constant.ConstantDesc} to represent.
&nbsp;         * @param classFileLocator The class file locator to use for resolving type information from the supplied value.
&nbsp;         * @return An appropriate Java constant representation.
&nbsp;         */
&nbsp;        public static JavaConstant ofDescription(Object value, ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;            return ofDescription(value, TypePool.Default.WithLazyResolution.of(classFileLocator));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a Java constant value from a {@code java.lang.constant.ConstantDesc}.
&nbsp;         *
&nbsp;         * @param value    The  {@code java.lang.constant.ConstantDesc} to represent.
&nbsp;         * @param typePool The type pool to use for resolving type information from the supplied value.
&nbsp;         * @return An appropriate Java constant representation.
&nbsp;         */
&nbsp;        public static JavaConstant ofDescription(Object value, TypePool typePool) {
<b class="nc">&nbsp;            if (value instanceof Integer) {</b>
<b class="nc">&nbsp;                return new JavaConstant.Simple.OfTrivialValue.ForInteger((Integer) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Long) {</b>
<b class="nc">&nbsp;                return new JavaConstant.Simple.OfTrivialValue.ForLong((Long) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Float) {</b>
<b class="nc">&nbsp;                return new JavaConstant.Simple.OfTrivialValue.ForFloat((Float) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof Double) {</b>
<b class="nc">&nbsp;                return new JavaConstant.Simple.OfTrivialValue.ForDouble((Double) value);</b>
<b class="nc">&nbsp;            } else if (value instanceof String) {</b>
<b class="nc">&nbsp;                return new JavaConstant.Simple.OfTrivialValue.ForString((String) value);</b>
<b class="nc">&nbsp;            } else if (CLASS_DESC.isInstance(value)) {</b>
<b class="nc">&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(value));</b>
<b class="nc">&nbsp;                return JavaConstant.Simple.OfTypeDescription.of(typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                        ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                        : type.getClassName()).resolve());</b>
<b class="nc">&nbsp;            } else if (METHOD_TYPE_DESC.isInstance(value)) {</b>
<b class="nc">&nbsp;                Object[] parameterTypes = METHOD_TYPE_DESC.parameterArray(value);</b>
<b class="nc">&nbsp;                List&lt;TypeDescription&gt; typeDescriptions = new ArrayList&lt;TypeDescription&gt;(parameterTypes.length);</b>
<b class="nc">&nbsp;                for (Object parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                    Type type = Type.getType(CLASS_DESC.descriptorString(parameterType));</b>
<b class="nc">&nbsp;                    typeDescriptions.add(typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                            ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                            : type.getClassName()).resolve());</b>
&nbsp;                }
<b class="nc">&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(METHOD_TYPE_DESC.returnType(value)));</b>
<b class="nc">&nbsp;                return MethodType.of(typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                        ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                        : type.getClassName()).resolve(), typeDescriptions);</b>
<b class="nc">&nbsp;            } else if (DIRECT_METHOD_HANDLE_DESC.isInstance(value)) {</b>
<b class="nc">&nbsp;                Object[] parameterTypes = METHOD_TYPE_DESC.parameterArray(METHOD_HANDLE_DESC.invocationType(value));</b>
<b class="nc">&nbsp;                List&lt;TypeDescription&gt; typeDescriptions = new ArrayList&lt;TypeDescription&gt;(parameterTypes.length);</b>
<b class="nc">&nbsp;                for (Object parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                    Type type = Type.getType(CLASS_DESC.descriptorString(parameterType));</b>
<b class="nc">&nbsp;                    typeDescriptions.add(typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                            ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                            : type.getClassName()).resolve());</b>
&nbsp;                }
<b class="nc">&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(METHOD_TYPE_DESC.returnType(METHOD_HANDLE_DESC.invocationType(value))));</b>
<b class="nc">&nbsp;                return new MethodHandle(MethodHandle.HandleType.of(DIRECT_METHOD_HANDLE_DESC.refKind(value)),</b>
<b class="nc">&nbsp;                        typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(value))).getClassName()).resolve(),</b>
<b class="nc">&nbsp;                        DIRECT_METHOD_HANDLE_DESC.methodName(value),</b>
<b class="nc">&nbsp;                        DIRECT_METHOD_HANDLE_DESC.refKind(value) == Opcodes.H_NEWINVOKESPECIAL</b>
<b class="nc">&nbsp;                                ? TypeDescription.ForLoadedType.of(void.class)</b>
<b class="nc">&nbsp;                                : typePool.describe(type.getSort() == Type.ARRAY ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;) : type.getClassName()).resolve(),</b>
&nbsp;                        typeDescriptions);
<b class="nc">&nbsp;            } else if (DYNAMIC_CONSTANT_DESC.isInstance(value)) {</b>
<b class="nc">&nbsp;                Type methodType = Type.getMethodType(DIRECT_METHOD_HANDLE_DESC.lookupDescriptor(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)));</b>
<b class="nc">&nbsp;                List&lt;TypeDescription&gt; parameterTypes = new ArrayList&lt;TypeDescription&gt;(methodType.getArgumentTypes().length);</b>
<b class="nc">&nbsp;                for (Type type : methodType.getArgumentTypes()) {</b>
<b class="nc">&nbsp;                    parameterTypes.add(typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                            ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                            : type.getClassName()).resolve());</b>
&nbsp;                }
<b class="nc">&nbsp;                Object[] constant = DYNAMIC_CONSTANT_DESC.bootstrapArgs(value);</b>
<b class="nc">&nbsp;                List&lt;JavaConstant&gt; arguments = new ArrayList&lt;JavaConstant&gt;(constant.length);</b>
<b class="nc">&nbsp;                for (Object aConstant : constant) {</b>
<b class="nc">&nbsp;                    arguments.add(ofDescription(aConstant, typePool));</b>
&nbsp;                }
<b class="nc">&nbsp;                Type type = Type.getType(CLASS_DESC.descriptorString(DYNAMIC_CONSTANT_DESC.constantType(value)));</b>
<b class="nc">&nbsp;                return new Dynamic(DYNAMIC_CONSTANT_DESC.constantName(value),</b>
<b class="nc">&nbsp;                        typePool.describe(type.getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                                ? type.getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                                : type.getClassName()).resolve(),</b>
<b class="nc">&nbsp;                        new MethodHandle(MethodHandle.HandleType.of(DIRECT_METHOD_HANDLE_DESC.refKind(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value))),</b>
<b class="nc">&nbsp;                                typePool.describe(Type.getType(CLASS_DESC.descriptorString(DIRECT_METHOD_HANDLE_DESC.owner(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)))).getClassName()).resolve(),</b>
<b class="nc">&nbsp;                                DIRECT_METHOD_HANDLE_DESC.methodName(DYNAMIC_CONSTANT_DESC.bootstrapMethod(value)),</b>
<b class="nc">&nbsp;                                typePool.describe(methodType.getReturnType().getSort() == Type.ARRAY</b>
<b class="nc">&nbsp;                                        ? methodType.getReturnType().getInternalName().replace(&#39;/&#39;, &#39;.&#39;)</b>
<b class="nc">&nbsp;                                        : methodType.getReturnType().getClassName()).resolve(),</b>
&nbsp;                                parameterTypes),
&nbsp;                        arguments);
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a resolvable constant description or not expressible as a constant pool value: &quot; + value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a Java constant representation for a {@link TypeDescription}.
&nbsp;         *
&nbsp;         * @param typeDescription The type to represent as a constant.
&nbsp;         * @return An appropriate Java constant representation.
&nbsp;         */
&nbsp;        public static JavaConstant of(TypeDescription typeDescription) {
<b class="nc">&nbsp;            if (typeDescription.isPrimitive()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;A primitive type cannot be represented as a type constant: &quot; + typeDescription);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new JavaConstant.Simple.OfTypeDescription(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a value representing a loaded or unloaded constant as {@link JavaConstant} instance.
&nbsp;         *
&nbsp;         * @param value The value to wrap.
&nbsp;         * @return A wrapped Java constant.
&nbsp;         */
&nbsp;        public static JavaConstant wrap(Object value) {
<b class="nc">&nbsp;            if (value instanceof JavaConstant) {</b>
<b class="nc">&nbsp;                return (JavaConstant) value;</b>
<b class="nc">&nbsp;            } else if (value instanceof TypeDescription) {</b>
<b class="nc">&nbsp;                return of((TypeDescription) value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return ofLoaded(value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a list of either loaded or unloaded constant representations as {@link JavaConstant} instances.
&nbsp;         *
&nbsp;         * @param values The values to wrap.
&nbsp;         * @return A list of wrapped Java constants.
&nbsp;         */
&nbsp;        public static List&lt;JavaConstant&gt; wrap(List&lt;?&gt; values) {
<b class="nc">&nbsp;            List&lt;JavaConstant&gt; constants = new ArrayList&lt;JavaConstant&gt;(values.size());</b>
<b class="nc">&nbsp;            for (Object value : values) {</b>
<b class="nc">&nbsp;                constants.add(wrap(value));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return constants;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the represented value.
&nbsp;         *
&nbsp;         * @return The represented value.
&nbsp;         */
&nbsp;        public T getValue() {
<b class="nc">&nbsp;            return value;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;            return typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return value.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object object) {
<b class="nc">&nbsp;            if (this == object) return true;</b>
<b class="nc">&nbsp;            if (object == null || getClass() != object.getClass()) return false;</b>
<b class="nc">&nbsp;            return value.equals(((JavaConstant.Simple&lt;?&gt;) object).value);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return value.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a trivial constant value that represents itself.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; The represented type.
&nbsp;         */
&nbsp;        protected abstract static class OfTrivialValue&lt;S&gt; extends JavaConstant.Simple&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a representation of a trivial constant that represents itself.
&nbsp;             *
&nbsp;             * @param value           The represented value.
&nbsp;             * @param typeDescription The represented value&#39;s type.
&nbsp;             */
&nbsp;            protected OfTrivialValue(S value, TypeDescription typeDescription) {
<b class="nc">&nbsp;                super(value, typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object toDescription() {
<b class="nc">&nbsp;                return value;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;                return visitor.onValue(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForInteger extends OfTrivialValue&lt;Integer&gt; {
&nbsp;
&nbsp;                public ForInteger(Integer value) {
<b class="nc">&nbsp;                    super(value, TypeDescription.ForLoadedType.of(int.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;                    return IntegerConstant.forValue(value);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForLong extends OfTrivialValue&lt;Long&gt; {
&nbsp;
&nbsp;                public ForLong(Long value) {
<b class="nc">&nbsp;                    super(value, TypeDescription.ForLoadedType.of(long.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;                    return LongConstant.forValue(value);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForFloat extends OfTrivialValue&lt;Float&gt; {
&nbsp;
&nbsp;                public ForFloat(Float value) {
<b class="nc">&nbsp;                    super(value, TypeDescription.ForLoadedType.of(float.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;                    return FloatConstant.forValue(value);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForDouble extends OfTrivialValue&lt;Double&gt; {
&nbsp;
&nbsp;                public ForDouble(Double value) {
<b class="nc">&nbsp;                    super(value, TypeDescription.ForLoadedType.of(double.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;                    return DoubleConstant.forValue(value);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            protected static class ForString extends OfTrivialValue&lt;String&gt; {
&nbsp;
&nbsp;                public ForString(String value) {
<b class="nc">&nbsp;                    super(value, TypeDescription.ForLoadedType.of(String.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;                    return new TextConstant(value);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a type constant.
&nbsp;         */
&nbsp;        protected static class OfTypeDescription extends JavaConstant.Simple&lt;TypeDescription&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a type constant.
&nbsp;             *
&nbsp;             * @param value The represented type.
&nbsp;             */
&nbsp;            protected OfTypeDescription(TypeDescription value) {
<b class="nc">&nbsp;                super(value, TypeDescription.ForLoadedType.of(Class.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object toDescription() {
<b class="nc">&nbsp;                return CLASS_DESC.ofDescriptor(value.getDescriptor());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;                return ClassConstant.of(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;                return visitor.onType(this);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to represent {@code java.lang.constant.ConstantDesc}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.constant.ConstantDesc&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the supplied instance is of the type of this dispatcher.
&nbsp;             *
&nbsp;             * @param instance The instance to verify.
&nbsp;             * @return {@code true} if the instance is of the supplied type.
&nbsp;             */
&nbsp;            @JavaDispatcher.Instance
&nbsp;            boolean isInstance(Object instance);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns an array of the dispatcher type.
&nbsp;             *
&nbsp;             * @param length The length of the array.
&nbsp;             * @return An array of the type that is represented by this dispatcher with the given length.
&nbsp;             */
&nbsp;            @JavaDispatcher.Container
&nbsp;            Object[] toArray(int length);
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher to represent {@code java.lang.constant.ClassDesc}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.constant.ClassDesc&quot;)
&nbsp;            interface OfClassDesc extends Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.ClassDesc} of a descriptor.
&nbsp;                 *
&nbsp;                 * @param descriptor The descriptor to resolve.
&nbsp;                 * @return An appropriate {@code java.lang.constant.ClassDesc}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.IsStatic
&nbsp;                Object ofDescriptor(String descriptor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the descriptor of the supplied class description.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.ClassDesc} to resolve.
&nbsp;                 * @return The class&#39;s descriptor.
&nbsp;                 */
&nbsp;                String descriptorString(Object value);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher to represent {@code java.lang.constant.MethodTypeDesc}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.constant.MethodTypeDesc&quot;)
&nbsp;            interface OfMethodTypeDesc extends Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.MethodTypeDesc} from descriptions of the return type descriptor and parameter types.
&nbsp;                 *
&nbsp;                 * @param returnType    A {@code java.lang.constant.ClassDesc} representing the return type.
&nbsp;                 * @param parameterType An array of {@code java.lang.constant.ClassDesc}s representing the parameter types.
&nbsp;                 * @return An appropriate {@code java.lang.constant.MethodTypeDesc}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.IsStatic
&nbsp;                Object of(@JavaDispatcher.Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object returnType,
&nbsp;                          @JavaDispatcher.Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object[] parameterType);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a {@code java.lang.constant.MethodTypeDesc} for a given descriptor.
&nbsp;                 *
&nbsp;                 * @param descriptor The method type&#39;s descriptor.
&nbsp;                 * @return A {@code java.lang.constant.MethodTypeDesc} of the supplied descriptor
&nbsp;                 */
&nbsp;                @JavaDispatcher.IsStatic
&nbsp;                Object ofDescriptor(String descriptor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the return type of a {@code java.lang.constant.MethodTypeDesc}.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.MethodTypeDesc} to resolve.
&nbsp;                 * @return A {@code java.lang.constant.ClassDesc} of the supplied {@code java.lang.constant.MethodTypeDesc}&#39;s return type.
&nbsp;                 */
&nbsp;                Object returnType(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the parameter types of a {@code java.lang.constant.MethodTypeDesc}.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.MethodTypeDesc} to resolve.
&nbsp;                 * @return An array of {@code java.lang.constant.ClassDesc} of the supplied {@code java.lang.constant.MethodTypeDesc}&#39;s parameter types.
&nbsp;                 */
&nbsp;                Object[] parameterArray(Object value);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher to represent {@code java.lang.constant.MethodHandleDesc}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.constant.MethodHandleDesc&quot;)
&nbsp;            interface OfMethodHandleDesc extends Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.MethodHandleDesc}.
&nbsp;                 *
&nbsp;                 * @param kind       The {@code java.lang.constant.DirectMethodHandleDesc$Kind} of the resolved method handle description.
&nbsp;                 * @param owner      The {@code java.lang.constant.ClassDesc} of the resolved method handle description&#39;s owner type.
&nbsp;                 * @param name       The name of the method handle to resolve.
&nbsp;                 * @param descriptor A descriptor of the lookup type.
&nbsp;                 * @return An {@code java.lang.constant.MethodTypeDesc} representing the invocation type.
&nbsp;                 */
&nbsp;                @JavaDispatcher.IsStatic
&nbsp;                Object of(@JavaDispatcher.Proxied(&quot;java.lang.constant.DirectMethodHandleDesc$Kind&quot;) Object kind,
&nbsp;                          @JavaDispatcher.Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object owner,
&nbsp;                          String name,
&nbsp;                          String descriptor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.MethodTypeDesc} representing the invocation type of
&nbsp;                 * the supplied {@code java.lang.constant.DirectMethodHandleDesc}.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DirectMethodHandleDesc} to resolve.
&nbsp;                 * @return An {@code java.lang.constant.MethodTypeDesc} representing the invocation type.
&nbsp;                 */
&nbsp;                Object invocationType(Object value);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher to represent {@code java.lang.constant.DirectMethodHandleDesc}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.constant.DirectMethodHandleDesc&quot;)
&nbsp;            interface OfDirectMethodHandleDesc extends Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the type of method handle for the supplied method handle description.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DirectMethodHandleDesc} to resolve.
&nbsp;                 * @return The type of the handle.
&nbsp;                 */
&nbsp;                int refKind(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the method name of the supplied direct method handle.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DirectMethodHandleDesc} to resolve.
&nbsp;                 * @return The handle&#39;s method name.
&nbsp;                 */
&nbsp;                String methodName(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.ClassDesc} representing the owner of a direct method handle description.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DirectMethodHandleDesc} to resolve.
&nbsp;                 * @return A {@code java.lang.constant.ClassDesc} describing the handle&#39;s owner.
&nbsp;                 */
&nbsp;                Object owner(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the lookup descriptor of the supplied direct method handle description.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DirectMethodHandleDesc} to resolve.
&nbsp;                 * @return A descriptor of the supplied direct method handle&#39;s lookup.
&nbsp;                 */
&nbsp;                String lookupDescriptor(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher to represent {@code java.lang.constant.DirectMethodHandleDesc$Kind}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.constant.DirectMethodHandleDesc$Kind&quot;)
&nbsp;                interface ForKind {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a {@code java.lang.constant.DirectMethodHandleDesc$Kind} from an identifier.
&nbsp;                     *
&nbsp;                     * @param identifier  The identifier to resolve.
&nbsp;                     * @param isInterface {@code true} if the handle invokes an interface type.
&nbsp;                     * @return The identifier&#39;s {@code java.lang.constant.DirectMethodHandleDesc$Kind}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.IsStatic
&nbsp;                    Object valueOf(int identifier, boolean isInterface);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher to represent {@code java.lang.constant.DynamicConstantDesc}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.constant.DynamicConstantDesc&quot;)
&nbsp;            interface OfDynamicConstantDesc extends Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.DynamicConstantDesc} for a canonical description of the constant.
&nbsp;                 *
&nbsp;                 * @param bootstrap    A {@code java.lang.constant.DirectMethodHandleDesc} describing the boostrap method of the dynamic constant.
&nbsp;                 * @param constantName The constant&#39;s name.
&nbsp;                 * @param type         A {@code java.lang.constant.ClassDesc} describing the constant&#39;s type.
&nbsp;                 * @param argument     Descriptions of the dynamic constant&#39;s arguments.
&nbsp;                 * @return A {@code java.lang.constant.DynamicConstantDesc} for the supplied arguments.
&nbsp;                 */
&nbsp;                @JavaDispatcher.IsStatic
&nbsp;                Object ofCanonical(@JavaDispatcher.Proxied(&quot;java.lang.constant.DirectMethodHandleDesc&quot;) Object bootstrap,
&nbsp;                                   String constantName,
&nbsp;                                   @JavaDispatcher.Proxied(&quot;java.lang.constant.ClassDesc&quot;) Object type,
&nbsp;                                   @JavaDispatcher.Proxied(&quot;java.lang.constant.ConstantDesc&quot;) Object[] argument);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.DynamicConstantDesc}&#39;s arguments.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DynamicConstantDesc} to resolve.
&nbsp;                 * @return An array of {@code java.lang.constant.ConstantDesc} describing the arguments of the supplied dynamic constant description.
&nbsp;                 */
&nbsp;                Object[] bootstrapArgs(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the dynamic constant description&#39;s name.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DynamicConstantDesc} to resolve.
&nbsp;                 * @return The dynamic constant description&#39;s name.
&nbsp;                 */
&nbsp;                String constantName(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.ClassDesc} for the dynamic constant&#39;s type.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DynamicConstantDesc} to resolve.
&nbsp;                 * @return A {@code java.lang.constant.ClassDesc} describing the constant&#39;s type.
&nbsp;                 */
&nbsp;                Object constantType(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a {@code java.lang.constant.DirectMethodHandleDesc} representing the dynamic constant&#39;s bootstrap method.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.constant.DynamicConstantDesc} to resolve.
&nbsp;                 * @return A {@code java.lang.constant.DirectMethodHandleDesc} representing the dynamic constant&#39;s bootstrap method.
&nbsp;                 */
&nbsp;                Object bootstrapMethod(Object value);
&nbsp;
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a {@code java.lang.invoke.MethodType} object.
&nbsp;     */
&nbsp;    class MethodType implements JavaConstant {
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for extracting information from a {@code java.lang.invoke.MethodType} instance.
&nbsp;         */
<b class="nc">&nbsp;        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The return type of this method type.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter types of this method type.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method type for the given types.
&nbsp;         *
&nbsp;         * @param returnType     The return type of the method type.
&nbsp;         * @param parameterTypes The parameter types of the method type.
&nbsp;         */
<b class="nc">&nbsp;        protected MethodType(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
<b class="nc">&nbsp;            this.returnType = returnType;</b>
<b class="nc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="nc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type representation of a loaded {@code MethodType} object.
&nbsp;         *
&nbsp;         * @param methodType A method type object to represent as a {@link JavaConstant}.
&nbsp;         * @return The method type represented as a {@link MethodType}.
&nbsp;         */
&nbsp;        public static MethodType ofLoaded(Object methodType) {
<b class="nc">&nbsp;            if (!JavaType.METHOD_TYPE.isInstance(methodType)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Expected method type object: &quot; + methodType);</b>
&nbsp;            }
<b class="nc">&nbsp;            return of(DISPATCHER.returnType(methodType), DISPATCHER.parameterArray(methodType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given return type and parameter types.
&nbsp;         *
&nbsp;         * @param returnType    The return type to represent.
&nbsp;         * @param parameterType The parameter types to represent.
&nbsp;         * @return A method type of the given return type and parameter types.
&nbsp;         */
&nbsp;        public static MethodType of(Class&lt;?&gt; returnType, Class&lt;?&gt;... parameterType) {
<b class="nc">&nbsp;            return of(TypeDescription.ForLoadedType.of(returnType), new TypeList.ForLoadedTypes(parameterType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given return type and parameter types.
&nbsp;         *
&nbsp;         * @param returnType    The return type to represent.
&nbsp;         * @param parameterType The parameter types to represent.
&nbsp;         * @return A method type of the given return type and parameter types.
&nbsp;         */
&nbsp;        public static MethodType of(TypeDescription returnType, TypeDescription... parameterType) {
<b class="nc">&nbsp;            return new MethodType(returnType, Arrays.asList(parameterType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given return type and parameter types.
&nbsp;         *
&nbsp;         * @param returnType     The return type to represent.
&nbsp;         * @param parameterTypes The parameter types to represent.
&nbsp;         * @return A method type of the given return type and parameter types.
&nbsp;         */
&nbsp;        public static MethodType of(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {
<b class="nc">&nbsp;            return new MethodType(returnType, parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given method.
&nbsp;         *
&nbsp;         * @param method The method to extract the method type from.
&nbsp;         * @return The method type of the given method.
&nbsp;         */
&nbsp;        public static MethodType of(Method method) {
<b class="nc">&nbsp;            return of(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given constructor.
&nbsp;         *
&nbsp;         * @param constructor The constructor to extract the method type from.
&nbsp;         * @return The method type of the given constructor.
&nbsp;         */
&nbsp;        public static MethodType of(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return of(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given method.
&nbsp;         *
&nbsp;         * @param methodDescription The method to extract the method type from.
&nbsp;         * @return The method type of the given method.
&nbsp;         */
&nbsp;        public static MethodType of(MethodDescription methodDescription) {
<b class="nc">&nbsp;            return new MethodType(</b>
<b class="nc">&nbsp;                    (methodDescription.isConstructor() ? methodDescription.getDeclaringType() : methodDescription.getReturnType()).asErasure(),</b>
<b class="nc">&nbsp;                    methodDescription.isStatic() || methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                            ? methodDescription.getParameters().asTypeList().asErasures()</b>
<b class="nc">&nbsp;                            : CompoundList.of(methodDescription.getDeclaringType().asErasure(), methodDescription.getParameters().asTypeList().asErasures()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given method&#39;s signature without considering the method&#39;s actual stack consumption
&nbsp;         * and production.
&nbsp;         *
&nbsp;         * @param method The method to extract the method type from.
&nbsp;         * @return The method type of the given method&#39;s signature.
&nbsp;         */
&nbsp;        public static MethodType ofSignature(Method method) {
<b class="nc">&nbsp;            return ofSignature(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given constructor&#39;s signature without considering the constructor&#39;s
&nbsp;         * actual stack consumption and production.
&nbsp;         *
&nbsp;         * @param constructor The constructor to extract the method type from.
&nbsp;         * @return The method type of the given method&#39;s signature.
&nbsp;         */
&nbsp;        public static MethodType ofSignature(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return ofSignature(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type description of the given method&#39;s signature without considering the method&#39;s actual stack consumption
&nbsp;         * and production.
&nbsp;         *
&nbsp;         * @param methodDescription The method to extract the method type from.
&nbsp;         * @return The method type of the given method&#39;s signature.
&nbsp;         */
&nbsp;        public static MethodType ofSignature(MethodDescription methodDescription) {
<b class="nc">&nbsp;            return new MethodType(methodDescription.getReturnType().asErasure(), methodDescription.getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for a setter of the given field.
&nbsp;         *
&nbsp;         * @param field The field to extract a setter type for.
&nbsp;         * @return The type of a setter for the given field.
&nbsp;         */
&nbsp;        public static MethodType ofSetter(Field field) {
<b class="nc">&nbsp;            return ofSetter(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for a setter of the given field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field to extract a setter type for.
&nbsp;         * @return The type of a setter for the given field.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public static MethodType ofSetter(FieldDescription fieldDescription) {
<b class="nc">&nbsp;            return new MethodType(TypeDescription.ForLoadedType.of(void.class), fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                    ? Collections.singletonList(fieldDescription.getType().asErasure())</b>
<b class="nc">&nbsp;                    : Arrays.asList(fieldDescription.getDeclaringType().asErasure(), fieldDescription.getType().asErasure()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for a getter of the given field.
&nbsp;         *
&nbsp;         * @param field The field to extract a getter type for.
&nbsp;         * @return The type of a getter for the given field.
&nbsp;         */
&nbsp;        public static MethodType ofGetter(Field field) {
<b class="nc">&nbsp;            return ofGetter(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for a getter of the given field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field to extract a getter type for.
&nbsp;         * @return The type of a getter for the given field.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public static MethodType ofGetter(FieldDescription fieldDescription) {
<b class="nc">&nbsp;            return new MethodType(fieldDescription.getType().asErasure(), fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                    ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="nc">&nbsp;                    : Collections.singletonList(fieldDescription.getDeclaringType().asErasure()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for the given constant.
&nbsp;         *
&nbsp;         * @param instance The constant for which a constant method type should be created.
&nbsp;         * @return A method type for the given constant.
&nbsp;         */
&nbsp;        public static MethodType ofConstant(Object instance) {
<b class="nc">&nbsp;            return ofConstant(instance.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for the given constant type.
&nbsp;         *
&nbsp;         * @param type The constant type for which a constant method type should be created.
&nbsp;         * @return A method type for the given constant type.
&nbsp;         */
&nbsp;        public static MethodType ofConstant(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return ofConstant(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method type for the given constant type.
&nbsp;         *
&nbsp;         * @param typeDescription The constant type for which a constant method type should be created.
&nbsp;         * @return A method type for the given constant type.
&nbsp;         */
&nbsp;        public static MethodType ofConstant(TypeDescription typeDescription) {
<b class="nc">&nbsp;            return new MethodType(typeDescription, Collections.&lt;TypeDescription&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the return type of this method type.
&nbsp;         *
&nbsp;         * @return The return type of this method type.
&nbsp;         */
&nbsp;        public TypeDescription getReturnType() {
<b class="nc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the parameter types of this method type.
&nbsp;         *
&nbsp;         * @return The parameter types of this method type.
&nbsp;         */
&nbsp;        public TypeList getParameterTypes() {
<b class="nc">&nbsp;            return new TypeList.Explicit(parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the method descriptor of this method type representation.
&nbsp;         *
&nbsp;         * @return The method descriptor of this method type representation.
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(&quot;(&quot;);</b>
<b class="nc">&nbsp;            for (TypeDescription parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                stringBuilder.append(parameterType.getDescriptor());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(returnType.getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object toDescription() {
<b class="nc">&nbsp;            Object[] parameterType = JavaConstant.Simple.CLASS_DESC.toArray(parameterTypes.size());</b>
<b class="nc">&nbsp;            for (int index = 0; index &lt; parameterTypes.size(); index++) {</b>
<b class="nc">&nbsp;                parameterType[index] = JavaConstant.Simple.CLASS_DESC.ofDescriptor(parameterTypes.get(index).getDescriptor());</b>
&nbsp;            }
<b class="nc">&nbsp;            return JavaConstant.Simple.METHOD_TYPE_DESC.of(JavaConstant.Simple.CLASS_DESC.ofDescriptor(returnType.getDescriptor()), parameterType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;            return visitor.onMethodType(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;            return JavaType.METHOD_TYPE.getTypeStub();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;            return new JavaConstantValue(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = returnType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + parameterTypes.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!(other instanceof MethodType)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            MethodType methodType = (MethodType) other;</b>
<b class="nc">&nbsp;            return parameterTypes.equals(methodType.parameterTypes) &amp;&amp; returnType.equals(methodType.returnType);</b>
&nbsp;
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (TypeDescription typeDescription : parameterTypes) {</b>
<b class="nc">&nbsp;                if (first) {</b>
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(typeDescription.getSimpleName());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(returnType.getSimpleName()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for extracting information from a {@code java.lang.invoke.MethodType} instance.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodType&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts the return type of the supplied method type.
&nbsp;             *
&nbsp;             * @param methodType An instance of {@code java.lang.invoke.MethodType}.
&nbsp;             * @return The return type that is described by the supplied instance.
&nbsp;             */
&nbsp;            Class&lt;?&gt; returnType(Object methodType);
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts the parameter types of the supplied method type.
&nbsp;             *
&nbsp;             * @param methodType An instance of {@code java.lang.invoke.MethodType}.
&nbsp;             * @return The parameter types that are described by the supplied instance.
&nbsp;             */
&nbsp;            Class&lt;?&gt;[] parameterArray(Object methodType);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a {@code java.lang.invoke.MethodHandle} object. Note that constant {@code MethodHandle}s cannot
&nbsp;     * be represented within the constant pool of a Java class and can therefore not be represented as an instance of
&nbsp;     * this representation order.
&nbsp;     */
&nbsp;    class MethodHandle implements JavaConstant {
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodHandleInfo}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final MethodHandleInfo METHOD_HANDLE_INFO = doPrivileged(JavaDispatcher.of(MethodHandleInfo.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodType}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final MethodType METHOD_TYPE = doPrivileged(JavaDispatcher.of(MethodType.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodHandles}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final MethodHandles METHOD_HANDLES = doPrivileged(JavaDispatcher.of(MethodHandles.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;         */
<b class="nc">&nbsp;        protected static final MethodHandles.Lookup METHOD_HANDLES_LOOKUP = doPrivileged(JavaDispatcher.of(MethodHandles.Lookup.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The handle type that is represented by this instance.
&nbsp;         */
&nbsp;        private final HandleType handleType;
&nbsp;
&nbsp;        /**
&nbsp;         * The owner type that is represented by this instance.
&nbsp;         */
&nbsp;        private final TypeDescription ownerType;
&nbsp;
&nbsp;        /**
&nbsp;         * The name that is represented by this instance.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The return type that is represented by this instance.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter types that is represented by this instance.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handle representation.
&nbsp;         *
&nbsp;         * @param handleType     The handle type that is represented by this instance.
&nbsp;         * @param ownerType      The owner type that is represented by this instance.
&nbsp;         * @param name           The name that is represented by this instance.
&nbsp;         * @param returnType     The return type that is represented by this instance.
&nbsp;         * @param parameterTypes The parameter types that is represented by this instance.
&nbsp;         */
&nbsp;        public MethodHandle(HandleType handleType,
&nbsp;                            TypeDescription ownerType,
&nbsp;                            String name,
&nbsp;                            TypeDescription returnType,
<b class="nc">&nbsp;                            List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
<b class="nc">&nbsp;            this.handleType = handleType;</b>
<b class="nc">&nbsp;            this.ownerType = ownerType;</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.returnType = returnType;</b>
<b class="nc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="nc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handles representation of a loaded method handle which is analyzed using a public {@code MethodHandles.Lookup} object.
&nbsp;         * A method handle can only be analyzed on virtual machines that support the corresponding API (Java 7+). For virtual machines before Java 8+,
&nbsp;         * a method handle instance can only be analyzed by taking advantage of private APIs what might require a access context.
&nbsp;         *
&nbsp;         * @param methodHandle The loaded method handle to represent.
&nbsp;         * @return A representation of the loaded method handle
&nbsp;         */
&nbsp;        public static MethodHandle ofLoaded(Object methodHandle) {
<b class="nc">&nbsp;            return ofLoaded(methodHandle, METHOD_HANDLES.publicLookup());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handles representation of a loaded method handle which is analyzed using the given lookup context.
&nbsp;         * A method handle can only be analyzed on virtual machines that support the corresponding API (Java 7+). For virtual machines before Java 8+,
&nbsp;         * a method handle instance can only be analyzed by taking advantage of private APIs what might require a access context.
&nbsp;         *
&nbsp;         * @param methodHandle The loaded method handle to represent.
&nbsp;         * @param lookup       The lookup object to use for analyzing the method handle.
&nbsp;         * @return A representation of the loaded method handle
&nbsp;         */
&nbsp;        public static MethodHandle ofLoaded(Object methodHandle, Object lookup) {
<b class="nc">&nbsp;            if (!JavaType.METHOD_HANDLE.isInstance(methodHandle)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Expected method handle object: &quot; + methodHandle);</b>
<b class="nc">&nbsp;            } else if (!JavaType.METHOD_HANDLES_LOOKUP.isInstance(lookup)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Expected method handle lookup object: &quot; + lookup);</b>
&nbsp;            }
<b class="nc">&nbsp;            Object methodHandleInfo = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V8).isAtMost(ClassFileVersion.JAVA_V7)</b>
<b class="nc">&nbsp;                    ? METHOD_HANDLE_INFO.revealDirect(methodHandle)</b>
<b class="nc">&nbsp;                    : METHOD_HANDLES_LOOKUP.revealDirect(lookup, methodHandle);</b>
<b class="nc">&nbsp;            Object methodType = METHOD_HANDLE_INFO.getMethodType(methodHandleInfo);</b>
<b class="nc">&nbsp;            return new MethodHandle(HandleType.of(METHOD_HANDLE_INFO.getReferenceKind(methodHandleInfo)),</b>
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(METHOD_HANDLE_INFO.getDeclaringClass(methodHandleInfo)),</b>
<b class="nc">&nbsp;                    METHOD_HANDLE_INFO.getName(methodHandleInfo),</b>
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(METHOD_TYPE.returnType(methodType)),</b>
<b class="nc">&nbsp;                    new TypeList.ForLoadedTypes(METHOD_TYPE.parameterArray(methodType)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handle representation of the given method.
&nbsp;         *
&nbsp;         * @param method The method ro represent.
&nbsp;         * @return A method handle representing the given method.
&nbsp;         */
&nbsp;        public static MethodHandle of(Method method) {
<b class="nc">&nbsp;            return of(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handle representation of the given constructor.
&nbsp;         *
&nbsp;         * @param constructor The constructor ro represent.
&nbsp;         * @return A method handle representing the given constructor.
&nbsp;         */
&nbsp;        public static MethodHandle of(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return of(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handle representation of the given method.
&nbsp;         *
&nbsp;         * @param methodDescription The method ro represent.
&nbsp;         * @return A method handle representing the given method.
&nbsp;         */
&nbsp;        public static MethodHandle of(MethodDescription.InDefinedShape methodDescription) {
<b class="nc">&nbsp;            return new MethodHandle(HandleType.of(methodDescription),</b>
<b class="nc">&nbsp;                    methodDescription.getDeclaringType().asErasure(),</b>
<b class="nc">&nbsp;                    methodDescription.getInternalName(),</b>
<b class="nc">&nbsp;                    methodDescription.getReturnType().asErasure(),</b>
<b class="nc">&nbsp;                    methodDescription.getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handle representation of the given method for an explicit special method invocation of an otherwise virtual method.
&nbsp;         *
&nbsp;         * @param method The method ro represent.
&nbsp;         * @param type   The type on which the method is to be invoked on as a special method invocation.
&nbsp;         * @return A method handle representing the given method as special method invocation.
&nbsp;         */
&nbsp;        public static MethodHandle ofSpecial(Method method, Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return ofSpecial(new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method handle representation of the given method for an explicit special method invocation of an otherwise virtual method.
&nbsp;         *
&nbsp;         * @param methodDescription The method ro represent.
&nbsp;         * @param typeDescription   The type on which the method is to be invoked on as a special method invocation.
&nbsp;         * @return A method handle representing the given method as special method invocation.
&nbsp;         */
&nbsp;        public static MethodHandle ofSpecial(MethodDescription.InDefinedShape methodDescription, TypeDescription typeDescription) {
<b class="nc">&nbsp;            if (!methodDescription.isSpecializableFor(typeDescription)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot specialize &quot; + methodDescription + &quot; for &quot; + typeDescription);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new MethodHandle(HandleType.ofSpecial(methodDescription),</b>
&nbsp;                    typeDescription,
<b class="nc">&nbsp;                    methodDescription.getInternalName(),</b>
<b class="nc">&nbsp;                    methodDescription.getReturnType().asErasure(),</b>
<b class="nc">&nbsp;                    methodDescription.getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method handle for a setter of the given field.
&nbsp;         *
&nbsp;         * @param field The field to represent.
&nbsp;         * @return A method handle for a setter of the given field.
&nbsp;         */
&nbsp;        public static MethodHandle ofGetter(Field field) {
<b class="nc">&nbsp;            return ofGetter(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method handle for a setter of the given field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field to represent.
&nbsp;         * @return A method handle for a setter of the given field.
&nbsp;         */
&nbsp;        public static MethodHandle ofGetter(FieldDescription.InDefinedShape fieldDescription) {
<b class="nc">&nbsp;            return new MethodHandle(HandleType.ofGetter(fieldDescription),</b>
<b class="nc">&nbsp;                    fieldDescription.getDeclaringType().asErasure(),</b>
<b class="nc">&nbsp;                    fieldDescription.getInternalName(),</b>
<b class="nc">&nbsp;                    fieldDescription.getType().asErasure(),</b>
<b class="nc">&nbsp;                    Collections.&lt;TypeDescription&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method handle for a getter of the given field.
&nbsp;         *
&nbsp;         * @param field The field to represent.
&nbsp;         * @return A method handle for a getter of the given field.
&nbsp;         */
&nbsp;        public static MethodHandle ofSetter(Field field) {
<b class="nc">&nbsp;            return ofSetter(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method handle for a getter of the given field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field to represent.
&nbsp;         * @return A method handle for a getter of the given field.
&nbsp;         */
&nbsp;        public static MethodHandle ofSetter(FieldDescription.InDefinedShape fieldDescription) {
<b class="nc">&nbsp;            return new MethodHandle(HandleType.ofSetter(fieldDescription),</b>
<b class="nc">&nbsp;                    fieldDescription.getDeclaringType().asErasure(),</b>
<b class="nc">&nbsp;                    fieldDescription.getInternalName(),</b>
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(void.class),</b>
<b class="nc">&nbsp;                    Collections.singletonList(fieldDescription.getType().asErasure()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the lookup type of the provided {@code java.lang.invoke.MethodHandles$Lookup} instance.
&nbsp;         *
&nbsp;         * @param callerClassLookup An instance of {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;         * @return The instance&#39;s lookup type.
&nbsp;         */
&nbsp;        public static Class&lt;?&gt; lookupType(Object callerClassLookup) {
<b class="nc">&nbsp;            return METHOD_HANDLES_LOOKUP.lookupClass(callerClassLookup);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object toDescription() {
<b class="nc">&nbsp;            return JavaConstant.Simple.METHOD_HANDLE_DESC.of(JavaConstant.Simple.DIRECT_METHOD_HANDLE_DESC_KIND.valueOf(handleType.getIdentifier(), ownerType.isInterface()),</b>
<b class="nc">&nbsp;                    JavaConstant.Simple.CLASS_DESC.ofDescriptor(ownerType.getDescriptor()),</b>
&nbsp;                    name,
<b class="nc">&nbsp;                    getDescriptor());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;            return visitor.onMethodHandle(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;            return JavaType.METHOD_HANDLE.getTypeStub();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;            return new JavaConstantValue(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the handle type represented by this instance.
&nbsp;         *
&nbsp;         * @return The handle type represented by this instance.
&nbsp;         */
&nbsp;        public HandleType getHandleType() {
<b class="nc">&nbsp;            return handleType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the owner type of this instance.
&nbsp;         *
&nbsp;         * @return The owner type of this instance.
&nbsp;         */
&nbsp;        public TypeDescription getOwnerType() {
<b class="nc">&nbsp;            return ownerType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name represented by this instance.
&nbsp;         *
&nbsp;         * @return The name represented by this instance.
&nbsp;         */
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the return type represented by this instance.
&nbsp;         *
&nbsp;         * @return The return type represented by this instance.
&nbsp;         */
&nbsp;        public TypeDescription getReturnType() {
<b class="nc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the parameter types represented by this instance.
&nbsp;         *
&nbsp;         * @return The parameter types represented by this instance.
&nbsp;         */
&nbsp;        public TypeList getParameterTypes() {
<b class="nc">&nbsp;            return new TypeList.Explicit(parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the method descriptor of this method handle representation.
&nbsp;         *
&nbsp;         * @return The method descriptor of this method handle representation.
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="nc">&nbsp;            switch (handleType) {</b>
&nbsp;                case GET_FIELD:
&nbsp;                case GET_STATIC_FIELD:
<b class="nc">&nbsp;                    return returnType.getDescriptor();</b>
&nbsp;                case PUT_FIELD:
&nbsp;                case PUT_STATIC_FIELD:
<b class="nc">&nbsp;                    return parameterTypes.get(0).getDescriptor();</b>
&nbsp;                default:
<b class="nc">&nbsp;                    StringBuilder stringBuilder = new StringBuilder().append(&#39;(&#39;);</b>
<b class="nc">&nbsp;                    for (TypeDescription parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                        stringBuilder.append(parameterType.getDescriptor());</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return stringBuilder.append(&#39;)&#39;).append(returnType.getDescriptor()).toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = handleType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + ownerType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + returnType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + parameterTypes.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof MethodHandle)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            MethodHandle methodHandle = (MethodHandle) other;</b>
<b class="nc">&nbsp;            return handleType == methodHandle.handleType</b>
<b class="nc">&nbsp;                    &amp;&amp; name.equals(methodHandle.name)</b>
<b class="nc">&nbsp;                    &amp;&amp; ownerType.equals(methodHandle.ownerType)</b>
<b class="nc">&nbsp;                    &amp;&amp; parameterTypes.equals(methodHandle.parameterTypes)</b>
<b class="nc">&nbsp;                    &amp;&amp; returnType.equals(methodHandle.returnType);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder()</b>
<b class="nc">&nbsp;                    .append(handleType.name())</b>
<b class="nc">&nbsp;                    .append(ownerType.isInterface() &amp;&amp; !handleType.isField() &amp;&amp; handleType != HandleType.INVOKE_INTERFACE</b>
<b class="nc">&nbsp;                            ? &quot;@interface&quot;</b>
<b class="nc">&nbsp;                            : &quot;&quot;)</b>
<b class="nc">&nbsp;                    .append(&#39;/&#39;)</b>
<b class="nc">&nbsp;                    .append(ownerType.getSimpleName())</b>
<b class="nc">&nbsp;                    .append(&quot;::&quot;)</b>
<b class="nc">&nbsp;                    .append(name)</b>
<b class="nc">&nbsp;                    .append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (TypeDescription typeDescription : parameterTypes) {</b>
<b class="nc">&nbsp;                if (first) {</b>
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(typeDescription.getSimpleName());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(returnType.getSimpleName()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of a method handle&#39;s type.
&nbsp;         */
<b class="nc">&nbsp;        public enum HandleType {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing an invokevirtual invocation.
&nbsp;             */
<b class="nc">&nbsp;            INVOKE_VIRTUAL(Opcodes.H_INVOKEVIRTUAL, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing an invokestatic invocation.
&nbsp;             */
<b class="nc">&nbsp;            INVOKE_STATIC(Opcodes.H_INVOKESTATIC, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing an invokespecial invocation for a non-constructor.
&nbsp;             */
<b class="nc">&nbsp;            INVOKE_SPECIAL(Opcodes.H_INVOKESPECIAL, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing an invokeinterface invocation.
&nbsp;             */
<b class="nc">&nbsp;            INVOKE_INTERFACE(Opcodes.H_INVOKEINTERFACE, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing an invokespecial invocation for a constructor.
&nbsp;             */
<b class="nc">&nbsp;            INVOKE_SPECIAL_CONSTRUCTOR(Opcodes.H_NEWINVOKESPECIAL, false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing a write of a non-static field invocation.
&nbsp;             */
<b class="nc">&nbsp;            PUT_FIELD(Opcodes.H_PUTFIELD, true),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing a read of a non-static field invocation.
&nbsp;             */
<b class="nc">&nbsp;            GET_FIELD(Opcodes.H_GETFIELD, true),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing a write of a static field invocation.
&nbsp;             */
<b class="nc">&nbsp;            PUT_STATIC_FIELD(Opcodes.H_PUTSTATIC, true),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A handle representing a read of a static field invocation.
&nbsp;             */
<b class="nc">&nbsp;            GET_STATIC_FIELD(Opcodes.H_GETSTATIC, true);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The represented identifier.
&nbsp;             */
&nbsp;            private final int identifier;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code} true if this handle type represents a field handle.
&nbsp;             */
&nbsp;            private final boolean field;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new handle type.
&nbsp;             *
&nbsp;             * @param identifier The represented identifier.
&nbsp;             * @param field      {@code} true if this handle type represents a field handle.
&nbsp;             */
<b class="nc">&nbsp;            HandleType(int identifier, boolean field) {</b>
<b class="nc">&nbsp;                this.identifier = identifier;</b>
<b class="nc">&nbsp;                this.field = field;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts a handle type for invoking the given method.
&nbsp;             *
&nbsp;             * @param methodDescription The method for which a handle type should be found.
&nbsp;             * @return The handle type for the given method.
&nbsp;             */
&nbsp;            protected static HandleType of(MethodDescription.InDefinedShape methodDescription) {
<b class="nc">&nbsp;                if (methodDescription.isTypeInitializer()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot create handle of type initializer &quot; + methodDescription);</b>
<b class="nc">&nbsp;                } else if (methodDescription.isStatic()) {</b>
<b class="nc">&nbsp;                    return INVOKE_STATIC;</b>
<b class="nc">&nbsp;                } else if (methodDescription.isConstructor()) { // Private constructors must use this handle type.</b>
<b class="nc">&nbsp;                    return INVOKE_SPECIAL_CONSTRUCTOR;</b>
<b class="nc">&nbsp;                } else if (methodDescription.isPrivate()) {</b>
<b class="nc">&nbsp;                    return INVOKE_SPECIAL;</b>
<b class="nc">&nbsp;                } else if (methodDescription.getDeclaringType().isInterface()) {</b>
<b class="nc">&nbsp;                    return INVOKE_INTERFACE;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return INVOKE_VIRTUAL;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts a handle type for the given identifier.
&nbsp;             *
&nbsp;             * @param identifier The identifier to extract a handle type for.
&nbsp;             * @return The representing handle type.
&nbsp;             */
&nbsp;            protected static HandleType of(int identifier) {
<b class="nc">&nbsp;                for (HandleType handleType : HandleType.values()) {</b>
<b class="nc">&nbsp;                    if (handleType.getIdentifier() == identifier) {</b>
<b class="nc">&nbsp;                        return handleType;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Unknown handle type: &quot; + identifier);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts a handle type for invoking the given method via invokespecial.
&nbsp;             *
&nbsp;             * @param methodDescription The method for which a handle type should be found.
&nbsp;             * @return The handle type for the given method.
&nbsp;             */
&nbsp;            protected static HandleType ofSpecial(MethodDescription.InDefinedShape methodDescription) {
<b class="nc">&nbsp;                if (methodDescription.isStatic() || methodDescription.isAbstract()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot invoke &quot; + methodDescription + &quot; via invokespecial&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                        ? INVOKE_SPECIAL_CONSTRUCTOR</b>
<b class="nc">&nbsp;                        : INVOKE_SPECIAL;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts a handle type for a getter of the given field.
&nbsp;             *
&nbsp;             * @param fieldDescription The field for which to create a getter handle.
&nbsp;             * @return The corresponding handle type.
&nbsp;             */
&nbsp;            protected static HandleType ofGetter(FieldDescription.InDefinedShape fieldDescription) {
<b class="nc">&nbsp;                return fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                        ? GET_STATIC_FIELD</b>
<b class="nc">&nbsp;                        : GET_FIELD;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Extracts a handle type for a setter of the given field.
&nbsp;             *
&nbsp;             * @param fieldDescription The field for which to create a setter handle.
&nbsp;             * @return The corresponding handle type.
&nbsp;             */
&nbsp;            protected static HandleType ofSetter(FieldDescription.InDefinedShape fieldDescription) {
<b class="nc">&nbsp;                return fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                        ? PUT_STATIC_FIELD</b>
<b class="nc">&nbsp;                        : PUT_FIELD;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the represented identifier.
&nbsp;             *
&nbsp;             * @return The represented identifier.
&nbsp;             */
&nbsp;            public int getIdentifier() {
<b class="nc">&nbsp;                return identifier;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code} true if this handle type represents a field handle.
&nbsp;             *
&nbsp;             * @return {@code} true if this handle type represents a field handle.
&nbsp;             */
&nbsp;            public boolean isField() {
<b class="nc">&nbsp;                return field;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodHandleInfo}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandleInfo&quot;)
&nbsp;        protected interface MethodHandleInfo {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the name of the method handle info.
&nbsp;             *
&nbsp;             * @param value The {@code java.lang.invoke.MethodHandleInfo} to resolve.
&nbsp;             * @return The name of the method handle info.
&nbsp;             */
&nbsp;            String getName(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the declaring type of the method handle info.
&nbsp;             *
&nbsp;             * @param value The {@code java.lang.invoke.MethodHandleInfo} to resolve.
&nbsp;             * @return The declaring type of the method handle info.
&nbsp;             */
&nbsp;            Class&lt;?&gt; getDeclaringClass(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the reference kind of the method handle info.
&nbsp;             *
&nbsp;             * @param value The {@code java.lang.invoke.MethodHandleInfo} to resolve.
&nbsp;             * @return The reference kind of the method handle info.
&nbsp;             */
&nbsp;            int getReferenceKind(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the {@code java.lang.invoke.MethodType} of the method handle info.
&nbsp;             *
&nbsp;             * @param value The {@code java.lang.invoke.MethodHandleInfo} to resolve.
&nbsp;             * @return The {@code java.lang.invoke.MethodType} of the method handle info.
&nbsp;             */
&nbsp;            Object getMethodType(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the {@code java.lang.invoke.MethodHandleInfo} of the provided method handle. This method
&nbsp;             * was available on Java 7 but replaced by a lookup-based method in Java 8 and later.
&nbsp;             *
&nbsp;             * @param handle The {@code java.lang.invoke.MethodHandle} to resolve.
&nbsp;             * @return A {@code java.lang.invoke.MethodHandleInfo} to describe the supplied method handle.
&nbsp;             */
&nbsp;            @JavaDispatcher.IsConstructor
&nbsp;            Object revealDirect(@JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandle&quot;) Object handle);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodType}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodType&quot;)
&nbsp;        protected interface MethodType {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a method type&#39;s return type.
&nbsp;             *
&nbsp;             * @param value The {@code java.lang.invoke.MethodType} to resolve.
&nbsp;             * @return The method type&#39;s return type.
&nbsp;             */
&nbsp;            Class&lt;?&gt; returnType(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a method type&#39;s parameter type.
&nbsp;             *
&nbsp;             * @param value The {@code java.lang.invoke.MethodType} to resolve.
&nbsp;             * @return The method type&#39;s parameter types.
&nbsp;             */
&nbsp;            Class&lt;?&gt;[] parameterArray(Object value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to interact with {@code java.lang.invoke.MethodHandles}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandles&quot;)
&nbsp;        protected interface MethodHandles {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the public {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;             *
&nbsp;             * @return The public {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;             */
&nbsp;            @JavaDispatcher.IsStatic
&nbsp;            Object publicLookup();
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher to interact with {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandles$Lookup&quot;)
&nbsp;            interface Lookup {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the lookup type for a given lookup instance.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.invoke.MethodHandles$Lookup} to resolve.
&nbsp;                 * @return The lookup&#39;s lookup class.
&nbsp;                 */
&nbsp;                Class&lt;?&gt; lookupClass(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * Reveals the {@code java.lang.invoke.MethodHandleInfo} for the supplied method handle.
&nbsp;                 *
&nbsp;                 * @param value  The {@code java.lang.invoke.MethodHandles$Lookup} to use for resolving the supplied handle
&nbsp;                 * @param handle The {@code java.lang.invoke.MethodHandle} to resolve.
&nbsp;                 * @return A {@code java.lang.invoke.MethodHandleInfo} representing the supplied method handle.
&nbsp;                 */
&nbsp;                Object revealDirect(Object value, @JavaDispatcher.Proxied(&quot;java.lang.invoke.MethodHandle&quot;) Object handle);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a dynamically resolved constant pool entry of a class file. This feature is supported for class files in version 11 and newer.
&nbsp;     */
&nbsp;    class Dynamic implements JavaConstant {
&nbsp;
&nbsp;        /**
&nbsp;         * The default name of a dynamic constant.
&nbsp;         */
&nbsp;        public static final String DEFAULT_NAME = &quot;_&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the dynamic constant.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the represented value&#39;s type.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A handle representation of the bootstrap method.
&nbsp;         */
&nbsp;        private final MethodHandle bootstrap;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of the arguments to the dynamic constant.
&nbsp;         */
&nbsp;        private final List&lt;JavaConstant&gt; arguments;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a dynamic resolved constant.
&nbsp;         *
&nbsp;         * @param name            The name of the dynamic constant.
&nbsp;         * @param typeDescription A description of the represented value&#39;s type.
&nbsp;         * @param bootstrap       A handle representation of the bootstrap method.
&nbsp;         * @param arguments       A list of the arguments to the dynamic constant.
&nbsp;         */
<b class="nc">&nbsp;        protected Dynamic(String name, TypeDescription typeDescription, MethodHandle bootstrap, List&lt;JavaConstant&gt; arguments) {</b>
<b class="nc">&nbsp;            this.name = name;</b>
<b class="nc">&nbsp;            this.typeDescription = typeDescription;</b>
<b class="nc">&nbsp;            this.bootstrap = bootstrap;</b>
<b class="nc">&nbsp;            this.arguments = arguments;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a constant {@code null} value of type {@link Object}.
&nbsp;         *
&nbsp;         * @return A dynamically resolved null constant.
&nbsp;         */
&nbsp;        public static Dynamic ofNullConstant() {
<b class="nc">&nbsp;            return new Dynamic(DEFAULT_NAME,</b>
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(Object.class),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
&nbsp;                            &quot;nullConstant&quot;,
<b class="nc">&nbsp;                            TypeDescription.ForLoadedType.of(Object.class),</b>
<b class="nc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))),</b>
<b class="nc">&nbsp;                    Collections.&lt;JavaConstant&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@link Class} constant for a primitive type.
&nbsp;         *
&nbsp;         * @param type The primitive type to represent.
&nbsp;         * @return A dynamically resolved primitive type constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofPrimitiveType(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return ofPrimitiveType(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@link Class} constant for a primitive type.
&nbsp;         *
&nbsp;         * @param typeDescription The primitive type to represent.
&nbsp;         * @return A dynamically resolved primitive type constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofPrimitiveType(TypeDescription typeDescription) {
<b class="nc">&nbsp;            if (!typeDescription.isPrimitive()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a primitive type: &quot; + typeDescription);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new Dynamic(typeDescription.getDescriptor(),</b>
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(Class.class),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
&nbsp;                            &quot;primitiveClass&quot;,
<b class="nc">&nbsp;                            TypeDescription.ForLoadedType.of(Class.class),</b>
<b class="nc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))),</b>
<b class="nc">&nbsp;                    Collections.&lt;JavaConstant&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@link Enum} value constant.
&nbsp;         *
&nbsp;         * @param enumeration The enumeration value to represent.
&nbsp;         * @return A dynamically resolved enumeration constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofEnumeration(Enum&lt;?&gt; enumeration) {
<b class="nc">&nbsp;            return ofEnumeration(new EnumerationDescription.ForLoadedEnumeration(enumeration));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@link Enum} value constant.
&nbsp;         *
&nbsp;         * @param enumerationDescription The enumeration value to represent.
&nbsp;         * @return A dynamically resolved enumeration constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofEnumeration(EnumerationDescription enumerationDescription) {
<b class="nc">&nbsp;            return new Dynamic(enumerationDescription.getValue(),</b>
<b class="nc">&nbsp;                    enumerationDescription.getEnumerationType(),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
&nbsp;                            &quot;enumConstant&quot;,
<b class="nc">&nbsp;                            TypeDescription.ForLoadedType.of(Enum.class),</b>
<b class="nc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))),</b>
<b class="nc">&nbsp;                    Collections.&lt;JavaConstant&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@code static}, {@code final} field constant.
&nbsp;         *
&nbsp;         * @param field The field to represent a value of.
&nbsp;         * @return A dynamically resolved field value constant.
&nbsp;         */
&nbsp;        public static Dynamic ofField(Field field) {
<b class="nc">&nbsp;            return ofField(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a {@code static}, {@code final} field constant.
&nbsp;         *
&nbsp;         * @param fieldDescription The field to represent a value of.
&nbsp;         * @return A dynamically resolved field value constant.
&nbsp;         */
&nbsp;        public static Dynamic ofField(FieldDescription.InDefinedShape fieldDescription) {
<b class="nc">&nbsp;            if (!fieldDescription.isStatic() || !fieldDescription.isFinal()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Field must be static and final: &quot; + fieldDescription);</b>
&nbsp;            }
<b class="nc">&nbsp;            boolean selfDeclared = fieldDescription.getType().isPrimitive()</b>
<b class="nc">&nbsp;                    ? fieldDescription.getType().asErasure().asBoxed().equals(fieldDescription.getType().asErasure())</b>
<b class="nc">&nbsp;                    : fieldDescription.getDeclaringType().equals(fieldDescription.getType().asErasure());</b>
<b class="nc">&nbsp;            return new Dynamic(fieldDescription.getInternalName(),</b>
<b class="nc">&nbsp;                    fieldDescription.getType().asErasure(),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
&nbsp;                            &quot;getStaticFinal&quot;,
<b class="nc">&nbsp;                            TypeDescription.ForLoadedType.of(Object.class),</b>
<b class="nc">&nbsp;                            selfDeclared</b>
<b class="nc">&nbsp;                                    ? Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class))</b>
<b class="nc">&nbsp;                                    : Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(), TypeDescription.ForLoadedType.of(String.class), TypeDescription.ForLoadedType.of(Class.class), TypeDescription.ForLoadedType.of(Class.class))),</b>
<b class="nc">&nbsp;                    selfDeclared</b>
<b class="nc">&nbsp;                            ? Collections.&lt;JavaConstant&gt;emptyList()</b>
<b class="nc">&nbsp;                            : Collections.singletonList(JavaConstant.Simple.of(fieldDescription.getDeclaringType())));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a constant that is resolved by invoking a {@code static} factory method.
&nbsp;         *
&nbsp;         * @param method   The method to invoke to create the represented constant value.
&nbsp;         * @param constant The method&#39;s constant arguments.
&nbsp;         * @return A dynamic constant that is resolved by the supplied factory method.
&nbsp;         */
&nbsp;        public static Dynamic ofInvocation(Method method, Object... constant) {
<b class="nc">&nbsp;            return ofInvocation(method, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a constant that is resolved by invoking a {@code static} factory method.
&nbsp;         *
&nbsp;         * @param method    The method to invoke to create the represented constant value.
&nbsp;         * @param constants The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                  as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                  {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that is resolved by the supplied factory method.
&nbsp;         */
&nbsp;        public static Dynamic ofInvocation(Method method, List&lt;?&gt; constants) {
<b class="nc">&nbsp;            return ofInvocation(new MethodDescription.ForLoadedMethod(method), constants);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a constant that is resolved by invoking a constructor.
&nbsp;         *
&nbsp;         * @param constructor The constructor to invoke to create the represented constant value.
&nbsp;         * @param constant    The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                    as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                    {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that is resolved by the supplied constuctor.
&nbsp;         */
&nbsp;        public static Dynamic ofInvocation(Constructor&lt;?&gt; constructor, Object... constant) {
<b class="nc">&nbsp;            return ofInvocation(constructor, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a constant that is resolved by invoking a constructor.
&nbsp;         *
&nbsp;         * @param constructor The constructor to invoke to create the represented constant value.
&nbsp;         * @param constants   The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                    as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                    {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that is resolved by the supplied constuctor.
&nbsp;         */
&nbsp;        public static Dynamic ofInvocation(Constructor&lt;?&gt; constructor, List&lt;?&gt; constants) {
<b class="nc">&nbsp;            return ofInvocation(new MethodDescription.ForLoadedConstructor(constructor), constants);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a constant that is resolved by invoking a {@code static} factory method or a constructor.
&nbsp;         *
&nbsp;         * @param methodDescription The method or constructor to invoke to create the represented constant value.
&nbsp;         * @param constant          The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                          as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                          {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that is resolved by the supplied factory method or constructor.
&nbsp;         */
&nbsp;        public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescription, Object... constant) {
<b class="nc">&nbsp;            return ofInvocation(methodDescription, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a constant that is resolved by invoking a {@code static} factory method or a constructor.
&nbsp;         *
&nbsp;         * @param methodDescription The method or constructor to invoke to create the represented constant value.
&nbsp;         * @param constants         The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                          as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                          {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that is resolved by the supplied factory method or constructor.
&nbsp;         */
&nbsp;        public static Dynamic ofInvocation(MethodDescription.InDefinedShape methodDescription, List&lt;?&gt; constants) {
<b class="nc">&nbsp;            if (!methodDescription.isConstructor() &amp;&amp; methodDescription.getReturnType().represents(void.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Bootstrap method is no constructor or non-void static factory: &quot; + methodDescription);</b>
<b class="nc">&nbsp;            } else if (methodDescription.isVarArgs()</b>
<b class="nc">&nbsp;                    ? methodDescription.getParameters().size() + (methodDescription.isStatic() || methodDescription.isConstructor() ? 0 : 1) &gt; constants.size() + 1</b>
<b class="nc">&nbsp;                    : methodDescription.getParameters().size() + (methodDescription.isStatic() || methodDescription.isConstructor() ? 0 : 1) != constants.size()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot assign &quot; + constants + &quot; to &quot; + methodDescription);</b>
&nbsp;            }
<b class="nc">&nbsp;            List&lt;TypeDescription&gt; parameters = (methodDescription.isStatic() || methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                    ? methodDescription.getParameters().asTypeList().asErasures()</b>
<b class="nc">&nbsp;                    : CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList().asErasures()));</b>
&nbsp;            Iterator&lt;TypeDescription&gt; iterator;
<b class="nc">&nbsp;            if (methodDescription.isVarArgs()) {</b>
<b class="nc">&nbsp;                iterator = CompoundList.of(parameters.subList(0, parameters.size() - 1), Collections.nCopies(</b>
<b class="nc">&nbsp;                        constants.size() - parameters.size() + 1,</b>
<b class="nc">&nbsp;                        parameters.get(parameters.size() - 1).getComponentType())).iterator();</b>
&nbsp;            } else {
<b class="nc">&nbsp;                iterator = parameters.iterator();</b>
&nbsp;            }
<b class="nc">&nbsp;            List&lt;JavaConstant&gt; arguments = new ArrayList&lt;JavaConstant&gt;(constants.size() + 1);</b>
<b class="nc">&nbsp;            arguments.add(MethodHandle.of(methodDescription));</b>
<b class="nc">&nbsp;            for (Object constant : constants) {</b>
<b class="nc">&nbsp;                JavaConstant argument = JavaConstant.Simple.wrap(constant);</b>
<b class="nc">&nbsp;                if (!argument.getTypeDescription().isAssignableTo(iterator.next())) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot assign &quot; + constants + &quot; to &quot; + methodDescription);</b>
&nbsp;                }
<b class="nc">&nbsp;                arguments.add(argument);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return new Dynamic(DEFAULT_NAME,</b>
<b class="nc">&nbsp;                    methodDescription.isConstructor()</b>
<b class="nc">&nbsp;                            ? methodDescription.getDeclaringType()</b>
<b class="nc">&nbsp;                            : methodDescription.getReturnType().asErasure(),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
&nbsp;                            &quot;invoke&quot;,
<b class="nc">&nbsp;                            TypeDescription.ForLoadedType.of(Object.class),</b>
<b class="nc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(String.class),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class),</b>
<b class="nc">&nbsp;                                    JavaType.METHOD_HANDLE.getTypeStub(),</b>
<b class="nc">&nbsp;                                    TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(Object.class)))),</b>
&nbsp;                    arguments);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a var handle constant for a field.
&nbsp;         *
&nbsp;         * @param field The field to represent a var handle for.
&nbsp;         * @return A dynamic constant that represents the created var handle constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofVarHandle(Field field) {
<b class="nc">&nbsp;            return ofVarHandle(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a var handle constant for a field.
&nbsp;         *
&nbsp;         * @param fieldDescription The field to represent a var handle for.
&nbsp;         * @return A dynamic constant that represents the created var handle constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofVarHandle(FieldDescription.InDefinedShape fieldDescription) {
<b class="nc">&nbsp;            return new Dynamic(fieldDescription.getInternalName(),</b>
<b class="nc">&nbsp;                    JavaType.VAR_HANDLE.getTypeStub(),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
<b class="nc">&nbsp;                            fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                                    ? &quot;staticFieldVarHandle&quot;</b>
<b class="nc">&nbsp;                                    : &quot;fieldVarHandle&quot;,</b>
<b class="nc">&nbsp;                            JavaType.VAR_HANDLE.getTypeStub(),</b>
<b class="nc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(String.class),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class))),</b>
<b class="nc">&nbsp;                    Arrays.asList(JavaConstant.Simple.of(fieldDescription.getDeclaringType()), JavaConstant.Simple.of(fieldDescription.getType().asErasure())));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a var handle constant for an array.
&nbsp;         *
&nbsp;         * @param type The array type for which the var handle is resolved.
&nbsp;         * @return A dynamic constant that represents the created var handle constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofArrayVarHandle(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return ofArrayVarHandle(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a var handle constant for an array.
&nbsp;         *
&nbsp;         * @param typeDescription The array type for which the var handle is resolved.
&nbsp;         * @return A dynamic constant that represents the created var handle constant.
&nbsp;         */
&nbsp;        public static JavaConstant ofArrayVarHandle(TypeDescription typeDescription) {
<b class="nc">&nbsp;            if (!typeDescription.isArray()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not an array type: &quot; + typeDescription);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new Dynamic(DEFAULT_NAME,</b>
<b class="nc">&nbsp;                    JavaType.VAR_HANDLE.getTypeStub(),</b>
&nbsp;                    new MethodHandle(MethodHandle.HandleType.INVOKE_STATIC,
<b class="nc">&nbsp;                            JavaType.CONSTANT_BOOTSTRAPS.getTypeStub(),</b>
&nbsp;                            &quot;arrayVarHandle&quot;,
<b class="nc">&nbsp;                            JavaType.VAR_HANDLE.getTypeStub(),</b>
<b class="nc">&nbsp;                            Arrays.asList(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub(),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(String.class),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class),</b>
<b class="nc">&nbsp;                                    TypeDescription.ForLoadedType.of(Class.class))),</b>
<b class="nc">&nbsp;                    Collections.singletonList(JavaConstant.Simple.of(typeDescription)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied bootstrap method for the resolution of a dynamic constant.
&nbsp;         *
&nbsp;         * @param name     The name of the bootstrap constant that is provided to the bootstrap method or constructor.
&nbsp;         * @param method   The bootstrap method to invoke.
&nbsp;         * @param constant The arguments for the bootstrap method represented as primitive wrapper types,
&nbsp;         *                 {@link String}, {@link TypeDescription} or {@link JavaConstant} values or their loaded forms.
&nbsp;         * @return A dynamic constant that represents the bootstrapped method&#39;s result.
&nbsp;         */
&nbsp;        public static Dynamic bootstrap(String name, Method method, Object... constant) {
<b class="nc">&nbsp;            return bootstrap(name, method, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied bootstrap method for the resolution of a dynamic constant.
&nbsp;         *
&nbsp;         * @param name      The name of the bootstrap constant that is provided to the bootstrap method or constructor.
&nbsp;         * @param method    The bootstrap method to invoke.
&nbsp;         * @param constants The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                  as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                  {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that represents the bootstrapped method&#39;s result.
&nbsp;         */
&nbsp;        public static Dynamic bootstrap(String name, Method method, List&lt;?&gt; constants) {
<b class="nc">&nbsp;            return bootstrap(name, new MethodDescription.ForLoadedMethod(method), constants);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied bootstrap constructor for the resolution of a dynamic constant.
&nbsp;         *
&nbsp;         * @param name        The name of the bootstrap constant that is provided to the bootstrap method or constructor.
&nbsp;         * @param constructor The bootstrap constructor to invoke.
&nbsp;         * @param constant    The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                    as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                    {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that represents the bootstrapped constructor&#39;s result.
&nbsp;         */
&nbsp;        public static Dynamic bootstrap(String name, Constructor&lt;?&gt; constructor, Object... constant) {
<b class="nc">&nbsp;            return bootstrap(name, constructor, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied bootstrap constructor for the resolution of a dynamic constant.
&nbsp;         *
&nbsp;         * @param name        The name of the bootstrap constant that is provided to the bootstrap method or constructor.
&nbsp;         * @param constructor The bootstrap constructor to invoke.
&nbsp;         * @param constants   The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                    as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                    {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that represents the bootstrapped constructor&#39;s result.
&nbsp;         */
&nbsp;        public static Dynamic bootstrap(String name, Constructor&lt;?&gt; constructor, List&lt;?&gt; constants) {
<b class="nc">&nbsp;            return bootstrap(name, new MethodDescription.ForLoadedConstructor(constructor), constants);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied bootstrap method or constructor for the resolution of a dynamic constant.
&nbsp;         *
&nbsp;         * @param name            The name of the bootstrap constant that is provided to the bootstrap method or constructor.
&nbsp;         * @param bootstrapMethod The bootstrap method or constructor to invoke.
&nbsp;         * @param constant        The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                        as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                        {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that represents the bootstrapped method&#39;s or constructor&#39;s result.
&nbsp;         */
&nbsp;        public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
<b class="nc">&nbsp;            return bootstrap(name, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied bootstrap method or constructor for the resolution of a dynamic constant.
&nbsp;         *
&nbsp;         * @param name      The name of the bootstrap constant that is provided to the bootstrap method or constructor.
&nbsp;         * @param bootstrap The bootstrap method or constructor to invoke.
&nbsp;         * @param arguments The constant values passed to the bootstrap method. Values can be represented either
&nbsp;         *                  as {@link TypeDescription}, as {@link JavaConstant}, as {@link String} or a primitive
&nbsp;         *                  {@code int}, {@code long}, {@code float} or {@code double} represented as wrapper type.
&nbsp;         * @return A dynamic constant that represents the bootstrapped method&#39;s or constructor&#39;s result.
&nbsp;         */
&nbsp;        public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrap, List&lt;?&gt; arguments) {
<b class="nc">&nbsp;            if (name.length() == 0 || name.contains(&quot;.&quot;)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a valid field name: &quot; + name);</b>
&nbsp;            }
<b class="nc">&nbsp;            List&lt;JavaConstant&gt; constants = new ArrayList&lt;JavaConstant&gt;(arguments.size());</b>
<b class="nc">&nbsp;            for (Object argument : arguments) {</b>
<b class="nc">&nbsp;                constants.add(JavaConstant.Simple.wrap(argument));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!bootstrap.isConstantBootstrap(TypeList.Explicit.of(constants))) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a valid bootstrap method &quot; + bootstrap + &quot; for &quot; + arguments);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new Dynamic(name,</b>
<b class="nc">&nbsp;                    bootstrap.isConstructor()</b>
<b class="nc">&nbsp;                            ? bootstrap.getDeclaringType()</b>
<b class="nc">&nbsp;                            : bootstrap.getReturnType().asErasure(),</b>
<b class="nc">&nbsp;                    new MethodHandle(bootstrap.isConstructor() ? MethodHandle.HandleType.INVOKE_SPECIAL_CONSTRUCTOR : MethodHandle.HandleType.INVOKE_STATIC,</b>
<b class="nc">&nbsp;                            bootstrap.getDeclaringType(),</b>
<b class="nc">&nbsp;                            bootstrap.getInternalName(),</b>
<b class="nc">&nbsp;                            bootstrap.getReturnType().asErasure(),</b>
<b class="nc">&nbsp;                            bootstrap.getParameters().asTypeList().asErasures()),</b>
&nbsp;                    constants);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the dynamic constant.
&nbsp;         *
&nbsp;         * @return The name of the dynamic constant.
&nbsp;         */
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a handle representation of the bootstrap method.
&nbsp;         *
&nbsp;         * @return A handle representation of the bootstrap method.
&nbsp;         */
&nbsp;        public MethodHandle getBootstrap() {
<b class="nc">&nbsp;            return bootstrap;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a list of the arguments to the dynamic constant.
&nbsp;         *
&nbsp;         * @return A list of the arguments to the dynamic constant.
&nbsp;         */
&nbsp;        public List&lt;JavaConstant&gt; getArguments() {
<b class="nc">&nbsp;            return arguments;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this {@link Dynamic} constant to resolve the returned instance to the supplied type. The type must be a subtype of the
&nbsp;         * bootstrap method&#39;s return type. Constructors cannot be resolved to a different type.
&nbsp;         *
&nbsp;         * @param type The type to resolve the bootstrapped value to.
&nbsp;         * @return This dynamic constant but resolved to the supplied type.
&nbsp;         */
&nbsp;        public JavaConstant withType(Class&lt;?&gt; type) {
<b class="nc">&nbsp;            return withType(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this {@link Dynamic} constant to resolve the returned instance to the supplied type. The type must be a subtype of the
&nbsp;         * bootstrap method&#39;s return type. Constructors cannot be resolved to a different type.
&nbsp;         *
&nbsp;         * @param typeDescription The type to resolve the bootstrapped value to.
&nbsp;         * @return This dynamic constant but resolved to the supplied type.
&nbsp;         */
&nbsp;        public JavaConstant withType(TypeDescription typeDescription) {
<b class="nc">&nbsp;            if (typeDescription.represents(void.class)) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Constant value cannot represent void&quot;);</b>
<b class="nc">&nbsp;            } else if (getBootstrap().getName().equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)</b>
<b class="nc">&nbsp;                    ? !getTypeDescription().isAssignableTo(typeDescription)</b>
<b class="nc">&nbsp;                    : (!typeDescription.asBoxed().isInHierarchyWith(getTypeDescription().asBoxed()))) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(typeDescription + &quot; is not compatible with bootstrapped type &quot; + getTypeDescription());</b>
&nbsp;            }
<b class="nc">&nbsp;            return new Dynamic(getName(), typeDescription, getBootstrap(), getArguments());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object toDescription() {
<b class="nc">&nbsp;            Object[] argument = JavaConstant.Simple.CONSTANT_DESC.toArray(arguments.size());</b>
<b class="nc">&nbsp;            for (int index = 0; index &lt; argument.length; index++) {</b>
<b class="nc">&nbsp;                argument[index] = arguments.get(index).toDescription();</b>
&nbsp;            }
<b class="nc">&nbsp;            return JavaConstant.Simple.DYNAMIC_CONSTANT_DESC.ofCanonical(JavaConstant.Simple.METHOD_HANDLE_DESC.of(</b>
<b class="nc">&nbsp;                    JavaConstant.Simple.DIRECT_METHOD_HANDLE_DESC_KIND.valueOf(bootstrap.getHandleType().getIdentifier(), bootstrap.getOwnerType().isInterface()),</b>
<b class="nc">&nbsp;                    JavaConstant.Simple.CLASS_DESC.ofDescriptor(bootstrap.getOwnerType().getDescriptor()),</b>
<b class="nc">&nbsp;                    bootstrap.getName(),</b>
<b class="nc">&nbsp;                    bootstrap.getDescriptor()), getName(), JavaConstant.Simple.CLASS_DESC.ofDescriptor(typeDescription.getDescriptor()), argument);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="nc">&nbsp;            return visitor.onDynamic(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getTypeDescription() {
<b class="nc">&nbsp;            return typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackManipulation toStackManipulation() {
<b class="nc">&nbsp;            return new JavaConstantValue(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + typeDescription.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + bootstrap.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + arguments.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object object) {
<b class="nc">&nbsp;            if (this == object) return true;</b>
<b class="nc">&nbsp;            if (object == null || getClass() != object.getClass()) return false;</b>
<b class="nc">&nbsp;            Dynamic dynamic = (Dynamic) object;</b>
<b class="nc">&nbsp;            if (!name.equals(dynamic.name)) return false;</b>
<b class="nc">&nbsp;            if (!typeDescription.equals(dynamic.typeDescription)) return false;</b>
<b class="nc">&nbsp;            if (!bootstrap.equals(dynamic.bootstrap)) return false;</b>
<b class="nc">&nbsp;            return arguments.equals(dynamic.arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder()</b>
<b class="nc">&nbsp;                    .append(bootstrap.getOwnerType().getSimpleName())</b>
<b class="nc">&nbsp;                    .append(&quot;::&quot;)</b>
<b class="nc">&nbsp;                    .append(bootstrap.getName())</b>
<b class="nc">&nbsp;                    .append(&#39;(&#39;)</b>
<b class="nc">&nbsp;                    .append(name.equals(DEFAULT_NAME) ? &quot;&quot; : name)</b>
<b class="nc">&nbsp;                    .append(&#39;/&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (JavaConstant constant : arguments) {</b>
<b class="nc">&nbsp;                if (first) {</b>
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(constant.toString());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(typeDescription.getSimpleName()).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 10:47</div>
</div>
</body>
</html>
