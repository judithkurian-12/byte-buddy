


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > JavaDispatcher</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.utility.dispatcher</a>
</div>

<h1>Coverage Summary for Class: JavaDispatcher (net.bytebuddy.utility.dispatcher)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">JavaDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (123/160)
  </span>
</td>
</tr>
  <tr>
    <td class="name">JavaDispatcher$1</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Container</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Defaults</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DirectInvoker</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.2%
  </span>
  <span class="absValue">
    (13/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForContainerCreation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (59/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForDefaultValue$OfNonPrimitiveArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForDefaultValue$OfPrimitiveArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForInstanceCheck</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForNonStaticMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForStaticMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Dispatcher$ForUnresolvedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.7%
  </span>
  <span class="absValue">
    (94/115)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader$Resolver</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader$Resolver$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (7/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader$Resolver$ForModuleSystem</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (10/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$DynamicClassLoader$Resolver$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Instance</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$InvokerCreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$IsConstructor</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$IsStatic</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$Proxied</td>
  </tr>
  <tr>
    <td class="name">JavaDispatcher$ProxiedInvocationHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.1%
  </span>
  <span class="absValue">
    (18/31)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (56/62)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.8%
  </span>
  <span class="absValue">
    (420/507)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.utility.dispatcher;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeWriter;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.Invoker;
&nbsp;import net.bytebuddy.utility.MethodComparator;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;import org.objectweb.asm.ClassWriter;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.security.Permission;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * A dispatcher for creating a proxy that invokes methods of a type that is possibly unknown on the current VM. Dispatchers do not
&nbsp; * use any of Byte Buddy&#39;s regular infrastructure, to avoid bootstrapping issues as these dispatchers are used by Byte Buddy itself.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * By default, this dispatcher uses the Java {@link Proxy} for creating dispatchers. By setting {@code net.bytebuddy.generate} to
&nbsp; * {@code true}, Byte Buddy can generate proxies manually as byte code to mostly avoid reflection and boxing of arguments as arrays.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * If a security manager is active, the &lt;i&gt;net.bytebuddy.createJavaDispatcher&lt;/i&gt; runtime permission is required. Any dispatching
&nbsp; * will be executed from a separate class loader and an unnamed module but with the {@link java.security.ProtectionDomain} of
&nbsp; * the {@link JavaDispatcher} class. It is not permitted to invoke methods of the {@code java.security.AccessController} class or
&nbsp; * to resolve a {@code java.lang.invoke.MethodHandle$Lookup}.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @param &lt;T&gt; The resolved type.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public class JavaDispatcher&lt;T&gt; implements PrivilegedAction&lt;T&gt; {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A property to determine, that if {@code true}, dispatcher classes will be generated natively and not by using a {@link Proxy}.
&nbsp;     */
&nbsp;    public static final String GENERATE_PROPERTY = &quot;net.bytebuddy.generate&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * If {@code true}, dispatcher classes will be generated natively and not by using a {@link Proxy}.
&nbsp;     */
<b class="fc">&nbsp;    private static final boolean GENERATE = Boolean.parseBoolean(doPrivileged(new GetSystemPropertyAction(GENERATE_PROPERTY)));</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A resolver to assure that a type&#39;s package and module are exported to the created class loader.
&nbsp;     * This should normally always be the case, but if another library is shading Byte Buddy or otherwise
&nbsp;     * manipulates the module graph, this might become necessary.
&nbsp;     */
<b class="fc">&nbsp;    private static final DynamicClassLoader.Resolver RESOLVER = doPrivileged(DynamicClassLoader.Resolver.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Contains an invoker that makes sure that reflective dispatchers make invocations from an isolated {@link ClassLoader} and
&nbsp;     * not from within Byte Buddy&#39;s context. This way, no privilege context can be leaked by accident.
&nbsp;     */
<b class="fc">&nbsp;    private static final Invoker INVOKER = doPrivileged(new InvokerCreationAction());</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The proxy type.
&nbsp;     */
&nbsp;    private final Class&lt;T&gt; proxy;
&nbsp;
&nbsp;    /**
&nbsp;     * The class loader to resolve the proxied type from or {@code null} if the bootstrap loader should be used.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;    private final ClassLoader classLoader;
&nbsp;
&nbsp;    /**
&nbsp;     * {@code true} if a proxy class should be manually generated.
&nbsp;     */
&nbsp;    private final boolean generate;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new dispatcher.
&nbsp;     *
&nbsp;     * @param proxy       The proxy type.
&nbsp;     * @param classLoader The class loader to resolve the proxied type from or {@code null} if the bootstrap loader should be used.
&nbsp;     * @param generate    {@code true} if a proxy class should be manually generated.
&nbsp;     */
<b class="fc">&nbsp;    protected JavaDispatcher(Class&lt;T&gt; proxy, @MaybeNull ClassLoader classLoader, boolean generate) {</b>
<b class="fc">&nbsp;        this.proxy = proxy;</b>
<b class="fc">&nbsp;        this.classLoader = classLoader;</b>
<b class="fc">&nbsp;        this.generate = generate;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;     *
&nbsp;     * @param action The action to execute from a privileged context.
&nbsp;     * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;     * @return The action&#39;s resolved value.
&nbsp;     */
&nbsp;    @AccessControllerPlugin.Enhance
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;        return action.run();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves an action for creating a dispatcher for the provided type where the proxied type is resolved from the bootstrap loader.
&nbsp;     *
&nbsp;     * @param type The type for which a dispatcher should be resolved.
&nbsp;     * @param &lt;T&gt;  The resolved type.
&nbsp;     * @return An action for creating an appropriate dispatcher.
&nbsp;     */
&nbsp;    public static &lt;T&gt; PrivilegedAction&lt;T&gt; of(Class&lt;T&gt; type) {
<b class="fc">&nbsp;        return of(type, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves an action for creating a dispatcher for the provided type.
&nbsp;     *
&nbsp;     * @param type        The type for which a dispatcher should be resolved.
&nbsp;     * @param classLoader The class loader to resolve the proxied type from.
&nbsp;     * @param &lt;T&gt;         The resolved type.
&nbsp;     * @return An action for creating an appropriate dispatcher.
&nbsp;     */
&nbsp;    protected static &lt;T&gt; PrivilegedAction&lt;T&gt; of(Class&lt;T&gt; type, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;        return of(type, classLoader, GENERATE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves an action for creating a dispatcher for the provided type.
&nbsp;     *
&nbsp;     * @param type        The type for which a dispatcher should be resolved.
&nbsp;     * @param classLoader The class loader to resolve the proxied type from.
&nbsp;     * @param generate    {@code true} if a proxy class should be manually generated.
&nbsp;     * @param &lt;T&gt;         The resolved type.
&nbsp;     * @return An action for creating an appropriate dispatcher.
&nbsp;     */
&nbsp;    protected static &lt;T&gt; PrivilegedAction&lt;T&gt; of(Class&lt;T&gt; type, @MaybeNull ClassLoader classLoader, boolean generate) {
<b class="fc">&nbsp;        if (!type.isInterface()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Expected an interface instead of &quot; + type);</b>
<b class="fc">&nbsp;        } else if (!type.isAnnotationPresent(Proxied.class)) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Expected &quot; + type.getName() + &quot; to be annotated with &quot; + Proxied.class.getName());</b>
<b class="fc">&nbsp;        } else if (type.getAnnotation(Proxied.class).value().startsWith(&quot;java.security.&quot;)) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(&quot;Classes related to Java security cannot be proxied: &quot; + type.getName());</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return new JavaDispatcher&lt;T&gt;(type, classLoader, generate);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    public T run() {
&nbsp;        try {
<b class="fc">&nbsp;            Object securityManager = System.class.getMethod(&quot;getSecurityManager&quot;).invoke(null);</b>
<b class="fc">&nbsp;            if (securityManager != null) {</b>
<b class="nc">&nbsp;                Class.forName(&quot;java.lang.SecurityManager&quot;)</b>
<b class="nc">&nbsp;                        .getMethod(&quot;checkPermission&quot;, Permission.class)</b>
<b class="nc">&nbsp;                        .invoke(securityManager, new RuntimePermission(&quot;net.bytebuddy.createJavaDispatcher&quot;));</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (NoSuchMethodException ignored) {</b>
&nbsp;            /* security manager not available on current VM */
<b class="nc">&nbsp;        } catch (ClassNotFoundException ignored) {</b>
&nbsp;            /* security manager not available on current VM */
<b class="nc">&nbsp;        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;            Throwable cause = exception.getTargetException();</b>
<b class="nc">&nbsp;            if (cause instanceof RuntimeException) {</b>
<b class="nc">&nbsp;                throw (RuntimeException) cause;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Failed to assert access rights using security manager&quot;, cause);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Failed to access security manager&quot;, exception);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        Map&lt;Method, Dispatcher&gt; dispatchers = generate</b>
<b class="fc">&nbsp;                ? new LinkedHashMap&lt;Method, Dispatcher&gt;()</b>
<b class="fc">&nbsp;                : new HashMap&lt;Method, Dispatcher&gt;();</b>
<b class="fc">&nbsp;        boolean defaults = proxy.isAnnotationPresent(Defaults.class);</b>
<b class="fc">&nbsp;        String name = proxy.getAnnotation(Proxied.class).value();</b>
&nbsp;        Class&lt;?&gt; target;
&nbsp;        try {
<b class="fc">&nbsp;            target = Class.forName(name, false, classLoader);</b>
<b class="fc">&nbsp;        } catch (ClassNotFoundException exception) {</b>
<b class="fc">&nbsp;            for (Method method : generate</b>
<b class="fc">&nbsp;                    ? GraalImageCode.getCurrent().sorted(proxy.getMethods(), MethodComparator.INSTANCE)</b>
<b class="fc">&nbsp;                    : proxy.getMethods()) {</b>
<b class="fc">&nbsp;                if (method.getDeclaringClass() == Object.class) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (method.isAnnotationPresent(Instance.class)) {</b>
<b class="nc">&nbsp;                    if (method.getParameterTypes().length != 1 || method.getParameterTypes()[0].isPrimitive() || method.getParameterTypes()[0].isArray()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Instance check requires a single regular-typed argument: &quot; + method);</b>
<b class="nc">&nbsp;                    } else if (method.getReturnType() != boolean.class) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Instance check requires a boolean return type: &quot; + method);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        dispatchers.put(method, Dispatcher.ForDefaultValue.BOOLEAN);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    dispatchers.put(method, defaults || method.isAnnotationPresent(Defaults.class)</b>
<b class="fc">&nbsp;                            ? Dispatcher.ForDefaultValue.of(method.getReturnType())</b>
<b class="fc">&nbsp;                            : new Dispatcher.ForUnresolvedMethod(&quot;Type not available on current VM: &quot; + exception.getMessage()));</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            if (generate) {</b>
<b class="fc">&nbsp;                return (T) DynamicClassLoader.proxy(proxy, dispatchers);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return (T) Proxy.newProxyInstance(proxy.getClassLoader(),</b>
&nbsp;                        new Class&lt;?&gt;[]{proxy},
&nbsp;                        new ProxiedInvocationHandler(name, dispatchers));
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        boolean generate = this.generate;</b>
<b class="fc">&nbsp;        for (Method method : generate</b>
<b class="fc">&nbsp;                ? GraalImageCode.getCurrent().sorted(proxy.getMethods(), MethodComparator.INSTANCE)</b>
<b class="fc">&nbsp;                : proxy.getMethods()) {</b>
<b class="fc">&nbsp;            if (method.getDeclaringClass() == Object.class) {</b>
<b class="nc">&nbsp;                continue;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (method.isAnnotationPresent(Instance.class)) {</b>
<b class="fc">&nbsp;                if (method.getParameterTypes().length != 1 || !method.getParameterTypes()[0].isAssignableFrom(target)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Instance check requires a single regular-typed argument: &quot; + method);</b>
<b class="fc">&nbsp;                } else if (method.getReturnType() != boolean.class) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Instance check requires a boolean return type: &quot; + method);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    dispatchers.put(method, new Dispatcher.ForInstanceCheck(target));</b>
&nbsp;                }
<b class="fc">&nbsp;            } else if (method.isAnnotationPresent(Container.class)) {</b>
<b class="fc">&nbsp;                if (method.getParameterTypes().length != 1 || method.getParameterTypes()[0] != int.class) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Container creation requires a single int-typed argument: &quot; + method);</b>
<b class="fc">&nbsp;                } else if (!method.getReturnType().isArray() || !method.getReturnType().getComponentType().isAssignableFrom(target)) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Container creation requires an assignable array as return value: &quot; + method);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    dispatchers.put(method, new Dispatcher.ForContainerCreation(target));</b>
&nbsp;                }
<b class="fc">&nbsp;            } else if (target.getName().equals(&quot;java.lang.invoke.MethodHandles&quot;) &amp;&amp; method.getName().equals(&quot;lookup&quot;)) {</b>
<b class="fc">&nbsp;                throw new UnsupportedOperationException(&quot;Cannot resolve Byte Buddy lookup via dispatcher&quot;);</b>
&nbsp;            } else {
&nbsp;                try {
<b class="fc">&nbsp;                    Class&lt;?&gt;[] parameterType = method.getParameterTypes();</b>
&nbsp;                    int offset;
<b class="fc">&nbsp;                    if (method.isAnnotationPresent(IsStatic.class) || method.isAnnotationPresent(IsConstructor.class)) {</b>
<b class="fc">&nbsp;                        offset = 0;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        offset = 1;</b>
<b class="fc">&nbsp;                        if (parameterType.length == 0) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Expected self type: &quot; + method);</b>
<b class="fc">&nbsp;                        } else if (!parameterType[0].isAssignableFrom(target)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign self type: &quot; + target + &quot; on &quot; + method);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        Class&lt;?&gt;[] adjusted = new Class&lt;?&gt;[parameterType.length - 1];</b>
<b class="fc">&nbsp;                        System.arraycopy(parameterType, 1, adjusted, 0, adjusted.length);</b>
<b class="fc">&nbsp;                        parameterType = adjusted;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Annotation[][] parameterAnnotation = method.getParameterAnnotations();</b>
<b class="fc">&nbsp;                    for (int index = 0; index &lt; parameterType.length; index++) {</b>
<b class="fc">&nbsp;                        for (Annotation annotation : parameterAnnotation[index + offset]) {</b>
<b class="fc">&nbsp;                            if (annotation instanceof Proxied) {</b>
<b class="fc">&nbsp;                                int arity = 0;</b>
<b class="fc">&nbsp;                                while (parameterType[index].isArray()) {</b>
<b class="fc">&nbsp;                                    arity += 1;</b>
<b class="fc">&nbsp;                                    parameterType[index] = parameterType[index].getComponentType();</b>
&nbsp;                                }
<b class="fc">&nbsp;                                if (arity &gt; 0) {</b>
<b class="fc">&nbsp;                                    if (parameterType[index].isPrimitive()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Primitive values are not supposed to be proxied: &quot; + index + &quot; of &quot; + method);</b>
<b class="fc">&nbsp;                                    } else if (!parameterType[index].isAssignableFrom(Class.forName(((Proxied) annotation).value(), false, classLoader))) {</b>
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot resolve to component type: &quot; + ((Proxied) annotation).value() + &quot; at &quot; + index + &quot; of &quot; + method);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;                                    while (arity-- &gt; 0) {</b>
<b class="fc">&nbsp;                                        stringBuilder.append(&#39;[&#39;);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    parameterType[index] = Class.forName(stringBuilder.append(&#39;L&#39;)</b>
<b class="fc">&nbsp;                                            .append(((Proxied) annotation).value())</b>
<b class="fc">&nbsp;                                            .append(&#39;;&#39;)</b>
<b class="fc">&nbsp;                                            .toString(), false, classLoader);</b>
<b class="fc">&nbsp;                                } else {</b>
<b class="fc">&nbsp;                                    Class&lt;?&gt; resolved = Class.forName(((Proxied) annotation).value(), false, classLoader);</b>
<b class="fc">&nbsp;                                    if (!parameterType[index].isAssignableFrom(resolved)) {</b>
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot resolve to type: &quot; + resolved.getName() + &quot; at &quot; + index + &quot; of &quot; + method);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    parameterType[index] = resolved;</b>
&nbsp;                                }
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    if (method.isAnnotationPresent(IsConstructor.class)) {</b>
<b class="fc">&nbsp;                        Constructor&lt;?&gt; resolved = target.getConstructor(parameterType);</b>
<b class="fc">&nbsp;                        if (!method.getReturnType().isAssignableFrom(target)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + resolved.getDeclaringClass().getName() + &quot; to &quot; + method);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if ((resolved.getModifiers() &amp; Opcodes.ACC_PUBLIC) == 0 || (target.getModifiers() &amp; Opcodes.ACC_PUBLIC) == 0) {</b>
<b class="nc">&nbsp;                            resolved.setAccessible(true);</b>
<b class="nc">&nbsp;                            generate = false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        dispatchers.put(method, new Dispatcher.ForConstructor(resolved));</b>
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        Proxied proxied = method.getAnnotation(Proxied.class);</b>
<b class="fc">&nbsp;                        Method resolved = target.getMethod(proxied == null ? method.getName() : proxied.value(), parameterType);</b>
<b class="fc">&nbsp;                        if (!method.getReturnType().isAssignableFrom(resolved.getReturnType())) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + resolved.getReturnType().getName() + &quot; to &quot; + method);</b>
&nbsp;                        }
&nbsp;                        exceptions:
<b class="fc">&nbsp;                        for (Class&lt;?&gt; type : resolved.getExceptionTypes()) {</b>
<b class="fc">&nbsp;                            if (RuntimeException.class.isAssignableFrom(type) || Error.class.isAssignableFrom(type)) {</b>
<b class="nc">&nbsp;                                continue;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (Class&lt;?&gt; exception : method.getExceptionTypes()) {</b>
<b class="fc">&nbsp;                                if (exception.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                                    continue exceptions;</b>
&nbsp;                                }
&nbsp;                            }
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Resolved method for &quot; + method + &quot; throws undeclared checked exception &quot; + type.getName());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if ((resolved.getModifiers() &amp; Opcodes.ACC_PUBLIC) == 0 || (resolved.getDeclaringClass().getModifiers() &amp; Opcodes.ACC_PUBLIC) == 0) {</b>
<b class="nc">&nbsp;                            resolved.setAccessible(true);</b>
<b class="nc">&nbsp;                            generate = false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if (Modifier.isStatic(resolved.getModifiers())) {</b>
<b class="fc">&nbsp;                            if (!method.isAnnotationPresent(IsStatic.class)) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Resolved method for &quot; + method + &quot; was expected to be static: &quot; + resolved);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            dispatchers.put(method, new Dispatcher.ForStaticMethod(resolved));</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            if (method.isAnnotationPresent(IsStatic.class)) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Resolved method for &quot; + method + &quot; was expected to be virtual: &quot; + resolved);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            dispatchers.put(method, new Dispatcher.ForNonStaticMethod(resolved));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                    dispatchers.put(method, defaults || method.isAnnotationPresent(Defaults.class)</b>
<b class="nc">&nbsp;                            ? Dispatcher.ForDefaultValue.of(method.getReturnType())</b>
<b class="nc">&nbsp;                            : new Dispatcher.ForUnresolvedMethod(&quot;Class not available on current VM: &quot; + exception.getMessage()));</b>
<b class="fc">&nbsp;                } catch (NoSuchMethodException exception) {</b>
<b class="fc">&nbsp;                    dispatchers.put(method, defaults || method.isAnnotationPresent(Defaults.class)</b>
<b class="fc">&nbsp;                            ? Dispatcher.ForDefaultValue.of(method.getReturnType())</b>
<b class="fc">&nbsp;                            : new Dispatcher.ForUnresolvedMethod(&quot;Method not available on current VM: &quot; + exception.getMessage()));</b>
<b class="fc">&nbsp;                } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                    dispatchers.put(method, new Dispatcher.ForUnresolvedMethod(&quot;Unexpected error: &quot; + throwable.getMessage()));</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        if (generate) {</b>
<b class="fc">&nbsp;            return (T) DynamicClassLoader.proxy(proxy, dispatchers);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return (T) Proxy.newProxyInstance(proxy.getClassLoader(),</b>
&nbsp;                    new Class&lt;?&gt;[]{proxy},
<b class="fc">&nbsp;                    new ProxiedInvocationHandler(target.getName(), dispatchers));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates a proxied type&#39;s name. This annotation is mandatory for proxied types but can also be used on method&#39;s
&nbsp;     * to describe the actual name of the proxied method or on parameters to indicate the parameter&#39;s (component) type.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target({ElementType.TYPE, ElementType.METHOD, ElementType.PARAMETER})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Proxied {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the binary name of the proxied type.
&nbsp;         *
&nbsp;         * @return The binary name of the proxied type.
&nbsp;         */
&nbsp;        String value();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that a proxied method is static.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.METHOD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface IsStatic {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that a proxied method is a constructor.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.METHOD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface IsConstructor {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that a method is supposed to perform an instance check. The annotated method must declare a single argument
&nbsp;     * with a type that is assignable from the proxied type.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.METHOD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Instance {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that the method is supposed to return an array of the proxied type. The annotated method must declare a single,
&nbsp;     * {@code int}-typed argument that represents the array&#39;s dimension.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.METHOD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Container {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that a method is supposed to return a default value if a method or type could not be resolved.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target({ElementType.TYPE, ElementType.METHOD})
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Defaults {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A privileged action for creating an {@link Invoker}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    private static class InvokerCreationAction implements PrivilegedAction&lt;Invoker&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Invoker run() {
<b class="fc">&nbsp;            return DynamicClassLoader.invoker();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An {@link Invoker} that uses Byte Buddy&#39;s invocation context to use if dynamic class loading is not supported, for example on Android,
&nbsp;     * and that do not use secured contexts, where this security measure is obsolete to begin with.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="nc">&nbsp;    private static class DirectInvoker implements Invoker {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object newInstance(Constructor&lt;?&gt; constructor, Object[] argument) throws InstantiationException, IllegalAccessException, InvocationTargetException {
<b class="nc">&nbsp;            return constructor.newInstance(argument);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object invoke(Method method, @MaybeNull Object instance, @MaybeNull Object[] argument) throws IllegalAccessException, InvocationTargetException {
<b class="nc">&nbsp;            return method.invoke(instance, argument);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dispatcher for handling a proxied method.
&nbsp;     */
&nbsp;    protected interface Dispatcher {
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes the proxied action.
&nbsp;         *
&nbsp;         * @param argument The arguments provided.
&nbsp;         * @return The return value.
&nbsp;         * @throws Throwable If any error occurs.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Object invoke(Object[] argument) throws Throwable;
&nbsp;
&nbsp;        /**
&nbsp;         * Implements this dispatcher in a generated proxy.
&nbsp;         *
&nbsp;         * @param methodVisitor The method visitor to implement the method with.
&nbsp;         * @param method        The method being implemented.
&nbsp;         * @return The maximal size of the operand stack.
&nbsp;         */
&nbsp;        int apply(MethodVisitor methodVisitor, Method method);
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher that performs an instance check.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForInstanceCheck implements Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The checked type.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt; target;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for an instance check.
&nbsp;             *
&nbsp;             * @param target The checked type.
&nbsp;             */
<b class="fc">&nbsp;            protected ForInstanceCheck(Class&lt;?&gt; target) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object invoke(Object[] argument) {
<b class="fc">&nbsp;                return target.isInstance(argument[0]);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(target));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.IRETURN);</b>
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher that creates an array.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForContainerCreation implements Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The component type.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt; target;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for an array creation.
&nbsp;             *
&nbsp;             * @param target The component type.
&nbsp;             */
<b class="fc">&nbsp;            protected ForContainerCreation(Class&lt;?&gt; target) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object invoke(Object[] argument) {
<b class="fc">&nbsp;                return Array.newInstance(target, (Integer) argument[0]);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ILOAD, 1);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(target));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher that returns a fixed value.
&nbsp;         */
<b class="fc">&nbsp;        enum ForDefaultValue implements Dispatcher {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code void} type.
&nbsp;             */
<b class="fc">&nbsp;            VOID(null, Opcodes.NOP, Opcodes.RETURN, 0),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code boolean} type.
&nbsp;             */
<b class="fc">&nbsp;            BOOLEAN(false, Opcodes.ICONST_0, Opcodes.IRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code boolean} type that returns {@code true}.
&nbsp;             */
<b class="fc">&nbsp;            BOOLEAN_REVERSE(true, Opcodes.ICONST_1, Opcodes.IRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code byte} type.
&nbsp;             */
<b class="fc">&nbsp;            BYTE((byte) 0, Opcodes.ICONST_0, Opcodes.IRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code short} type.
&nbsp;             */
<b class="fc">&nbsp;            SHORT((short) 0, Opcodes.ICONST_0, Opcodes.IRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code char} type.
&nbsp;             */
<b class="fc">&nbsp;            CHARACTER((char) 0, Opcodes.ICONST_0, Opcodes.IRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for an {@code int} type.
&nbsp;             */
<b class="fc">&nbsp;            INTEGER(0, Opcodes.ICONST_0, Opcodes.IRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code long} type.
&nbsp;             */
<b class="fc">&nbsp;            LONG(0L, Opcodes.LCONST_0, Opcodes.LRETURN, 2),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code float} type.
&nbsp;             */
<b class="fc">&nbsp;            FLOAT(0f, Opcodes.FCONST_0, Opcodes.FRETURN, 1),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a {@code double} type.
&nbsp;             */
<b class="fc">&nbsp;            DOUBLE(0d, Opcodes.DCONST_0, Opcodes.DRETURN, 2),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a reference type.
&nbsp;             */
<b class="fc">&nbsp;            REFERENCE(null, Opcodes.ACONST_NULL, Opcodes.ARETURN, 1);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The default value.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final Object value;
&nbsp;
&nbsp;            /**
&nbsp;             * The opcode to load the default value.
&nbsp;             */
&nbsp;            private final int load;
&nbsp;
&nbsp;            /**
&nbsp;             * The opcode to return the default value.
&nbsp;             */
&nbsp;            private final int returned;
&nbsp;
&nbsp;            /**
&nbsp;             * The operand stack size of default value.
&nbsp;             */
&nbsp;            private final int size;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default value dispatcher.
&nbsp;             *
&nbsp;             * @param value    The default value.
&nbsp;             * @param load     The opcode to load the default value.
&nbsp;             * @param returned The opcode to return the default value.
&nbsp;             * @param size     The operand stack size of default value.
&nbsp;             */
<b class="fc">&nbsp;            ForDefaultValue(@MaybeNull Object value, int load, int returned, int size) {</b>
<b class="fc">&nbsp;                this.value = value;</b>
<b class="fc">&nbsp;                this.load = load;</b>
<b class="fc">&nbsp;                this.returned = returned;</b>
<b class="fc">&nbsp;                this.size = size;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a fixed value for a given type.
&nbsp;             *
&nbsp;             * @param type The type to resolve.
&nbsp;             * @return An appropriate dispatcher.
&nbsp;             */
&nbsp;            protected static Dispatcher of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                if (type == void.class) {</b>
<b class="fc">&nbsp;                    return VOID;</b>
<b class="fc">&nbsp;                } else if (type == boolean.class) {</b>
<b class="fc">&nbsp;                    return BOOLEAN;</b>
<b class="fc">&nbsp;                } else if (type == byte.class) {</b>
<b class="fc">&nbsp;                    return BYTE;</b>
<b class="fc">&nbsp;                } else if (type == short.class) {</b>
<b class="fc">&nbsp;                    return SHORT;</b>
<b class="fc">&nbsp;                } else if (type == char.class) {</b>
<b class="fc">&nbsp;                    return CHARACTER;</b>
<b class="fc">&nbsp;                } else if (type == int.class) {</b>
<b class="fc">&nbsp;                    return INTEGER;</b>
<b class="fc">&nbsp;                } else if (type == long.class) {</b>
<b class="fc">&nbsp;                    return LONG;</b>
<b class="fc">&nbsp;                } else if (type == float.class) {</b>
<b class="fc">&nbsp;                    return FLOAT;</b>
<b class="fc">&nbsp;                } else if (type == double.class) {</b>
<b class="fc">&nbsp;                    return DOUBLE;</b>
<b class="fc">&nbsp;                } else if (type.isArray()) {</b>
<b class="fc">&nbsp;                    if (type.getComponentType() == boolean.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.BOOLEAN;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == byte.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.BYTE;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == short.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.SHORT;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == char.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.CHARACTER;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == int.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.INTEGER;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == long.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.LONG;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == float.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.FLOAT;</b>
<b class="fc">&nbsp;                    } else if (type.getComponentType() == double.class) {</b>
<b class="fc">&nbsp;                        return OfPrimitiveArray.DOUBLE;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return OfNonPrimitiveArray.of(type.getComponentType());</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    return REFERENCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Object invoke(Object[] argument) {
<b class="fc">&nbsp;                return value;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                if (load != Opcodes.NOP) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(load);</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitInsn(returned);</b>
<b class="fc">&nbsp;                return size;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for returning a default value for a primitive array.
&nbsp;             */
<b class="fc">&nbsp;            protected enum OfPrimitiveArray implements Dispatcher {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code boolean} array.
&nbsp;                 */
<b class="fc">&nbsp;                BOOLEAN(new boolean[0], Opcodes.T_BOOLEAN),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code byte} array.
&nbsp;                 */
<b class="fc">&nbsp;                BYTE(new byte[0], Opcodes.T_BYTE),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code short} array.
&nbsp;                 */
<b class="fc">&nbsp;                SHORT(new short[0], Opcodes.T_SHORT),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code char} array.
&nbsp;                 */
<b class="fc">&nbsp;                CHARACTER(new char[0], Opcodes.T_CHAR),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code int} array.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER(new int[0], Opcodes.T_INT),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code long} array.
&nbsp;                 */
<b class="fc">&nbsp;                LONG(new long[0], Opcodes.T_LONG),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code float} array.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT(new float[0], Opcodes.T_FLOAT),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a {@code double} array.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE(new double[0], Opcodes.T_DOUBLE);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value.
&nbsp;                 */
&nbsp;                private final Object value;
&nbsp;
&nbsp;                /**
&nbsp;                 * The operand for creating an array of the represented type.
&nbsp;                 */
&nbsp;                private final int operand;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher for a primitive array.
&nbsp;                 *
&nbsp;                 * @param value   The default value.
&nbsp;                 * @param operand The operand for creating an array of the represented type.
&nbsp;                 */
<b class="fc">&nbsp;                OfPrimitiveArray(Object value, int operand) {</b>
<b class="fc">&nbsp;                    this.value = value;</b>
<b class="fc">&nbsp;                    this.operand = operand;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Object invoke(Object[] argument) {
<b class="fc">&nbsp;                    return value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitIntInsn(Opcodes.NEWARRAY, operand);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                    return 1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a non-primitive array type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfNonPrimitiveArray implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The default value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;                private final Object value;
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented component type.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher for the default value of a non-primitive array.
&nbsp;                 *
&nbsp;                 * @param value         The default value.
&nbsp;                 * @param componentType The represented component type.
&nbsp;                 */
<b class="fc">&nbsp;                protected OfNonPrimitiveArray(Object value, Class&lt;?&gt; componentType) {</b>
<b class="fc">&nbsp;                    this.value = value;</b>
<b class="fc">&nbsp;                    this.componentType = componentType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher.
&nbsp;                 *
&nbsp;                 * @param componentType The represented component type.
&nbsp;                 * @return A dispatcher for the supplied component type.
&nbsp;                 */
&nbsp;                protected static Dispatcher of(Class&lt;?&gt; componentType) {
<b class="fc">&nbsp;                    return new OfNonPrimitiveArray(Array.newInstance(componentType, 0), componentType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Object invoke(Object[] argument) {
<b class="fc">&nbsp;                    return value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(componentType));</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                    return 1;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for invoking a constructor.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForConstructor implements Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The proxied constructor.
&nbsp;             */
&nbsp;            private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for invoking a constructor.
&nbsp;             *
&nbsp;             * @param constructor The proxied constructor.
&nbsp;             */
<b class="fc">&nbsp;            protected ForConstructor(Constructor&lt;?&gt; constructor) {</b>
<b class="fc">&nbsp;                this.constructor = constructor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
<b class="fc">&nbsp;                return INVOKER.newInstance(constructor, argument);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                Class&lt;?&gt;[] source = method.getParameterTypes(), target = constructor.getParameterTypes();</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(constructor.getDeclaringClass()));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                int offset = 1;</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; source.length; index++) {</b>
<b class="nc">&nbsp;                    Type type = Type.getType(source[index]);</b>
<b class="nc">&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), offset);</b>
<b class="nc">&nbsp;                    if (source[index] != target[index]) {</b>
<b class="nc">&nbsp;                        methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(target[index]));</b>
&nbsp;                    }
<b class="nc">&nbsp;                    offset += type.getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                        Type.getInternalName(constructor.getDeclaringClass()),</b>
&nbsp;                        MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                        Type.getConstructorDescriptor(constructor),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                return offset + 1;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for invoking a static proxied method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForStaticMethod implements Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The proxied method.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for invoking a static method.
&nbsp;             *
&nbsp;             * @param method The proxied method.
&nbsp;             */
<b class="fc">&nbsp;            protected ForStaticMethod(Method method) {</b>
<b class="fc">&nbsp;                this.method = method;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
<b class="fc">&nbsp;                return INVOKER.invoke(method, null, argument);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                Class&lt;?&gt;[] source = method.getParameterTypes(), target = this.method.getParameterTypes();</b>
<b class="fc">&nbsp;                int offset = 1;</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; source.length; index++) {</b>
<b class="fc">&nbsp;                    Type type = Type.getType(source[index]);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), offset);</b>
<b class="fc">&nbsp;                    if (source[index] != target[index]) {</b>
<b class="fc">&nbsp;                        methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(target[index]));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    offset += type.getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                        Type.getInternalName(this.method.getDeclaringClass()),</b>
<b class="fc">&nbsp;                        this.method.getName(),</b>
<b class="fc">&nbsp;                        Type.getMethodDescriptor(this.method),</b>
<b class="fc">&nbsp;                        this.method.getDeclaringClass().isInterface());</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Type.getReturnType(this.method).getOpcode(Opcodes.IRETURN));</b>
<b class="fc">&nbsp;                return Math.max(offset - 1, Type.getReturnType(this.method).getSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for invoking a non-static proxied method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForNonStaticMethod implements Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates a call without arguments.
&nbsp;             */
<b class="fc">&nbsp;            private static final Object[] NO_ARGUMENTS = new Object[0];</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The proxied method.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for invoking a non-static method.
&nbsp;             *
&nbsp;             * @param method The proxied method.
&nbsp;             */
<b class="fc">&nbsp;            protected ForNonStaticMethod(Method method) {</b>
<b class="fc">&nbsp;                this.method = method;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
&nbsp;                Object[] reduced;
<b class="fc">&nbsp;                if (argument.length == 1) {</b>
<b class="fc">&nbsp;                    reduced = NO_ARGUMENTS;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    reduced = new Object[argument.length - 1];</b>
<b class="fc">&nbsp;                    System.arraycopy(argument, 1, reduced, 0, reduced.length);</b>
&nbsp;                }
<b class="fc">&nbsp;                return INVOKER.invoke(method, argument[0], reduced);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                Class&lt;?&gt;[] source = method.getParameterTypes(), target = this.method.getParameterTypes();</b>
<b class="fc">&nbsp;                int offset = 1;</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; source.length; index++) {</b>
<b class="fc">&nbsp;                    Type type = Type.getType(source[index]);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), offset);</b>
<b class="fc">&nbsp;                    if (source[index] != (index == 0 ? this.method.getDeclaringClass() : target[index - 1])) {</b>
<b class="fc">&nbsp;                        methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(index == 0</b>
<b class="fc">&nbsp;                                ? this.method.getDeclaringClass()</b>
<b class="fc">&nbsp;                                : target[index - 1]));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    offset += type.getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(this.method.getDeclaringClass().isInterface() ? Opcodes.INVOKEINTERFACE : Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                        Type.getInternalName(this.method.getDeclaringClass()),</b>
<b class="fc">&nbsp;                        this.method.getName(),</b>
<b class="fc">&nbsp;                        Type.getMethodDescriptor(this.method),</b>
<b class="fc">&nbsp;                        this.method.getDeclaringClass().isInterface());</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Type.getReturnType(this.method).getOpcode(Opcodes.IRETURN));</b>
<b class="fc">&nbsp;                return Math.max(offset - 1, Type.getReturnType(this.method).getSize());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for an unresolved method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForUnresolvedMethod implements Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The message for describing the reason why the method could not be resolved.
&nbsp;             */
&nbsp;            private final String message;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for an unresolved method.
&nbsp;             *
&nbsp;             * @param message The message for describing the reason why the method could not be resolved.
&nbsp;             */
<b class="fc">&nbsp;            protected ForUnresolvedMethod(String message) {</b>
<b class="fc">&nbsp;                this.message = message;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object invoke(Object[] argument) throws Throwable {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Could not invoke proxy: &quot; + message);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int apply(MethodVisitor methodVisitor, Method method) {
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(IllegalStateException.class));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(message);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                        Type.getInternalName(IllegalStateException.class),</b>
&nbsp;                        MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                        Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(String.class)),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ATHROW);</b>
<b class="fc">&nbsp;                return 3;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An invocation handler that invokes given dispatchers.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ProxiedInvocationHandler implements InvocationHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that an invocation handler does not provide any arguments.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object[] NO_ARGUMENTS = new Object[0];</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The proxied type&#39;s name.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * A mapping of proxy type methods to their proxied dispatchers.
&nbsp;         */
&nbsp;        private final Map&lt;Method, Dispatcher&gt; targets;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new invocation handler for proxying a type.
&nbsp;         *
&nbsp;         * @param name    The proxied type&#39;s name.
&nbsp;         * @param targets A mapping of proxy type methods to their proxied dispatchers.
&nbsp;         */
<b class="fc">&nbsp;        protected ProxiedInvocationHandler(String name, Map&lt;Method, Dispatcher&gt; targets) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.targets = targets;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) throws Throwable {
<b class="fc">&nbsp;            if (method.getDeclaringClass() == Object.class) {</b>
<b class="nc">&nbsp;                if (method.getName().equals(&quot;hashCode&quot;)) {</b>
<b class="nc">&nbsp;                    return hashCode();</b>
<b class="nc">&nbsp;                } else if (method.getName().equals(&quot;equals&quot;)) {</b>
<b class="nc">&nbsp;                    return argument[0] != null</b>
<b class="nc">&nbsp;                            &amp;&amp; Proxy.isProxyClass(argument[0].getClass())</b>
<b class="nc">&nbsp;                            &amp;&amp; Proxy.getInvocationHandler(argument[0]).equals(this);</b>
<b class="nc">&nbsp;                } else if (method.getName().equals(&quot;toString&quot;)) {</b>
<b class="nc">&nbsp;                    return &quot;Call proxy for &quot; + name;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected object method: &quot; + method);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            Dispatcher dispatcher = targets.get(method);</b>
&nbsp;            try {
&nbsp;                try {
<b class="fc">&nbsp;                    if (dispatcher == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;No proxy target found for &quot; + method);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return dispatcher.invoke(argument == null</b>
<b class="fc">&nbsp;                                ? NO_ARGUMENTS</b>
<b class="fc">&nbsp;                                : argument);</b>
&nbsp;                    }
<b class="fc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                    throw exception.getTargetException();</b>
&nbsp;                }
<b class="fc">&nbsp;            } catch (RuntimeException exception) {</b>
<b class="fc">&nbsp;                throw exception;</b>
<b class="nc">&nbsp;            } catch (Error error) {</b>
<b class="nc">&nbsp;                throw error;</b>
<b class="fc">&nbsp;            } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                for (Class&lt;?&gt; type : method.getExceptionTypes()) {</b>
<b class="fc">&nbsp;                    if (type.isInstance(throwable)) {</b>
<b class="fc">&nbsp;                        throw throwable;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Failed to invoke proxy for &quot; + method, throwable);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A class loader for loading synthetic classes for implementing a {@link JavaDispatcher}.
&nbsp;     */
&nbsp;    protected static class DynamicClassLoader extends ClassLoader {
&nbsp;
&nbsp;        /**
&nbsp;         * The dump folder that is defined by the {@link TypeWriter#DUMP_PROPERTY} property or {@code null} if not set.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private static final String DUMP_FOLDER;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a constructor does not declare any parameters.
&nbsp;         */
<b class="fc">&nbsp;        private static final Class&lt;?&gt;[] NO_PARAMETER = new Class&lt;?&gt;[0];</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a constructor does not require any arguments.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object[] NO_ARGUMENT = new Object[0];</b>
&nbsp;
&nbsp;        /*
&nbsp;         * Resolves the currently set dump folder.
&nbsp;         */
&nbsp;        static {
&nbsp;            String dumpFolder;
&nbsp;            try {
<b class="fc">&nbsp;                dumpFolder = doPrivileged(new GetSystemPropertyAction(TypeWriter.DUMP_PROPERTY));</b>
<b class="nc">&nbsp;            } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;                dumpFolder = null;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            DUMP_FOLDER = dumpFolder;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new dynamic class loader.
&nbsp;         *
&nbsp;         * @param target The proxied type.
&nbsp;         */
&nbsp;        protected DynamicClassLoader(Class&lt;?&gt; target) {
<b class="fc">&nbsp;            super(target.getClassLoader());</b>
<b class="fc">&nbsp;            RESOLVER.accept(this, target);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new proxied type.
&nbsp;         *
&nbsp;         * @param proxy       The proxy type interface.
&nbsp;         * @param dispatchers The dispatchers to implement.
&nbsp;         * @return An instance of the proxied type.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = {&quot;REC_CATCH_EXCEPTION&quot;, &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;}, justification = &quot;Expected internal invocation.&quot;)
&nbsp;        protected static Object proxy(Class&lt;?&gt; proxy, Map&lt;Method, Dispatcher&gt; dispatchers) {
<b class="fc">&nbsp;            ClassWriter classWriter = new ClassWriter(0);</b>
<b class="fc">&nbsp;            classWriter.visit(ClassFileVersion.JAVA_V5.getMinorMajorVersion(),</b>
&nbsp;                    Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                    Type.getInternalName(proxy) + &quot;$Proxy&quot;,</b>
&nbsp;                    null,
<b class="fc">&nbsp;                    Type.getInternalName(Object.class),</b>
<b class="fc">&nbsp;                    new String[]{Type.getInternalName(proxy)});</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;Method, Dispatcher&gt; entry : dispatchers.entrySet()) {</b>
<b class="fc">&nbsp;                Class&lt;?&gt;[] exceptionType = entry.getKey().getExceptionTypes();</b>
<b class="fc">&nbsp;                String[] exceptionTypeName = new String[exceptionType.length];</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; exceptionType.length; index++) {</b>
<b class="fc">&nbsp;                    exceptionTypeName[index] = Type.getInternalName(exceptionType[index]);</b>
&nbsp;                }
<b class="fc">&nbsp;                MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC,</b>
<b class="fc">&nbsp;                        entry.getKey().getName(),</b>
<b class="fc">&nbsp;                        Type.getMethodDescriptor(entry.getKey()),</b>
&nbsp;                        null,
&nbsp;                        exceptionTypeName);
<b class="fc">&nbsp;                methodVisitor.visitCode();</b>
<b class="fc">&nbsp;                int offset = (entry.getKey().getModifiers() &amp; Opcodes.ACC_STATIC) == 0 ? 1 : 0;</b>
<b class="fc">&nbsp;                for (Class&lt;?&gt; type : entry.getKey().getParameterTypes()) {</b>
<b class="fc">&nbsp;                    offset += Type.getType(type).getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitMaxs(entry.getValue().apply(methodVisitor, entry.getKey()), offset);</b>
<b class="fc">&nbsp;                methodVisitor.visitEnd();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC,</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE),</b>
&nbsp;                    null,
&nbsp;                    null);
<b class="fc">&nbsp;            methodVisitor.visitCode();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(Object.class),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.RETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitMaxs(1, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitEnd();</b>
<b class="fc">&nbsp;            classWriter.visitEnd();</b>
<b class="fc">&nbsp;            byte[] binaryRepresentation = classWriter.toByteArray();</b>
<b class="fc">&nbsp;            if (DUMP_FOLDER != null) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    OutputStream outputStream = new FileOutputStream(new File(DUMP_FOLDER, proxy.getName() + &quot;$Proxy.class&quot;));</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        outputStream.write(binaryRepresentation);</b>
<b class="nc">&nbsp;                    } finally {</b>
<b class="nc">&nbsp;                        outputStream.close();</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (Throwable ignored) {</b>
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                return new DynamicClassLoader(proxy)</b>
<b class="fc">&nbsp;                        .defineClass(proxy.getName() + &quot;$Proxy&quot;,</b>
&nbsp;                                binaryRepresentation,
&nbsp;                                0,
&nbsp;                                binaryRepresentation.length,
<b class="fc">&nbsp;                                JavaDispatcher.class.getProtectionDomain())</b>
<b class="fc">&nbsp;                        .getConstructor(NO_PARAMETER)</b>
<b class="fc">&nbsp;                        .newInstance(NO_ARGUMENT);</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Failed to create proxy for &quot; + proxy.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a {@link Invoker} for a separate class loader.
&nbsp;         *
&nbsp;         * @return The created {@link Invoker}.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = {&quot;REC_CATCH_EXCEPTION&quot;, &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;}, justification = &quot;Expected internal invocation.&quot;)
&nbsp;        protected static Invoker invoker() {
<b class="fc">&nbsp;            ClassWriter classWriter = new ClassWriter(0);</b>
<b class="fc">&nbsp;            classWriter.visit(ClassFileVersion.JAVA_V5.getMinorMajorVersion(),</b>
&nbsp;                    Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                    Type.getInternalName(Invoker.class) + &quot;$Dispatcher&quot;,</b>
&nbsp;                    null,
<b class="fc">&nbsp;                    Type.getInternalName(Object.class),</b>
<b class="fc">&nbsp;                    new String[]{Type.getInternalName(Invoker.class)});</b>
<b class="fc">&nbsp;            for (Method method : GraalImageCode.getCurrent().sorted(Invoker.class.getMethods(), MethodComparator.INSTANCE)) {</b>
<b class="fc">&nbsp;                Class&lt;?&gt;[] exceptionType = method.getExceptionTypes();</b>
<b class="fc">&nbsp;                String[] exceptionTypeName = new String[exceptionType.length];</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; exceptionType.length; index++) {</b>
<b class="fc">&nbsp;                    exceptionTypeName[index] = Type.getInternalName(exceptionType[index]);</b>
&nbsp;                }
<b class="fc">&nbsp;                MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC,</b>
<b class="fc">&nbsp;                        method.getName(),</b>
<b class="fc">&nbsp;                        Type.getMethodDescriptor(method),</b>
&nbsp;                        null,
&nbsp;                        exceptionTypeName);
<b class="fc">&nbsp;                methodVisitor.visitCode();</b>
<b class="fc">&nbsp;                int offset = 1;</b>
<b class="fc">&nbsp;                Type[] parameter = new Type[method.getParameterTypes().length - 1];</b>
<b class="fc">&nbsp;                for (int index = 0; index &lt; method.getParameterTypes().length; index++) {</b>
<b class="fc">&nbsp;                    Type type = Type.getType(method.getParameterTypes()[index]);</b>
<b class="fc">&nbsp;                    if (index &gt; 0) {</b>
<b class="fc">&nbsp;                        parameter[index - 1] = type;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), offset);</b>
<b class="fc">&nbsp;                    offset += type.getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                        Type.getInternalName(method.getParameterTypes()[0]),</b>
<b class="fc">&nbsp;                        method.getName(),</b>
<b class="fc">&nbsp;                        Type.getMethodDescriptor(Type.getReturnType(method), parameter),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Type.getReturnType(method).getOpcode(Opcodes.IRETURN));</b>
<b class="fc">&nbsp;                methodVisitor.visitMaxs(Math.max(offset - 1, Type.getReturnType(method).getSize()), offset);</b>
<b class="fc">&nbsp;                methodVisitor.visitEnd();</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodVisitor methodVisitor = classWriter.visitMethod(Opcodes.ACC_PUBLIC,</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE),</b>
&nbsp;                    null,
&nbsp;                    null);
<b class="fc">&nbsp;            methodVisitor.visitCode();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(Object.class),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.RETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitMaxs(1, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitEnd();</b>
<b class="fc">&nbsp;            classWriter.visitEnd();</b>
<b class="fc">&nbsp;            byte[] binaryRepresentation = classWriter.toByteArray();</b>
&nbsp;            try {
<b class="fc">&nbsp;                String dumpFolder = System.getProperty(TypeWriter.DUMP_PROPERTY);</b>
<b class="fc">&nbsp;                if (dumpFolder != null) {</b>
<b class="nc">&nbsp;                    OutputStream outputStream = new FileOutputStream(new File(dumpFolder, Invoker.class.getName() + &quot;$Dispatcher.class&quot;));</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        outputStream.write(binaryRepresentation);</b>
<b class="nc">&nbsp;                    } finally {</b>
<b class="nc">&nbsp;                        outputStream.close();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Throwable ignored) {</b>
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;            try {
<b class="fc">&nbsp;                return (Invoker) new DynamicClassLoader(Invoker.class)</b>
<b class="fc">&nbsp;                        .defineClass(Invoker.class.getName() + &quot;$Dispatcher&quot;,</b>
&nbsp;                                binaryRepresentation,
&nbsp;                                0,
&nbsp;                                binaryRepresentation.length,
<b class="fc">&nbsp;                                JavaDispatcher.class.getProtectionDomain())</b>
<b class="fc">&nbsp;                        .getConstructor(NO_PARAMETER)</b>
<b class="fc">&nbsp;                        .newInstance(NO_ARGUMENT);</b>
<b class="nc">&nbsp;            } catch (UnsupportedOperationException ignored) {</b>
<b class="nc">&nbsp;                return new DirectInvoker();</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Failed to create invoker for &quot; + Invoker.class.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resolver to make adjustments that are possibly necessary to withhold module graph guarantees.
&nbsp;         */
&nbsp;        protected interface Resolver {
&nbsp;
&nbsp;            /**
&nbsp;             * Adjusts a module graph if necessary.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to adjust.
&nbsp;             * @param target      The targeted class for which a proxy is created.
&nbsp;             */
&nbsp;            void accept(@MaybeNull ClassLoader classLoader, Class&lt;?&gt; target);
&nbsp;
&nbsp;            /**
&nbsp;             * An action to create a resolver.
&nbsp;             */
<b class="fc">&nbsp;            enum CreationAction implements PrivilegedAction&lt;Resolver&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                public Resolver run() {
&nbsp;                    try {
<b class="fc">&nbsp;                        Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;, false, null);</b>
<b class="fc">&nbsp;                        return new ForModuleSystem(Class.class.getMethod(&quot;getModule&quot;),</b>
<b class="fc">&nbsp;                                module.getMethod(&quot;isExported&quot;, String.class),</b>
<b class="fc">&nbsp;                                module.getMethod(&quot;addExports&quot;, String.class, module),</b>
<b class="fc">&nbsp;                                ClassLoader.class.getMethod(&quot;getUnnamedModule&quot;));</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational resolver for VMs that do not support the module system.
&nbsp;             */
<b class="nc">&nbsp;            enum NoOp implements Resolver {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void accept(@MaybeNull ClassLoader classLoader, Class&lt;?&gt; target) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resolver for VMs that do support the module system.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForModuleSystem implements Resolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.Class#getModule} method.
&nbsp;                 */
&nbsp;                private final Method getModule;
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.Module#isExported} method.
&nbsp;                 */
&nbsp;                private final Method isExported;
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.Module#addExports} method.
&nbsp;                 */
&nbsp;                private final Method addExports;
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code java.lang.ClassLoader#getUnnamedModule} method.
&nbsp;                 */
&nbsp;                private final Method getUnnamedModule;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resolver for a VM that supports the module system.
&nbsp;                 *
&nbsp;                 * @param getModule        The {@code java.lang.Class#getModule} method.
&nbsp;                 * @param isExported       The {@code java.lang.Module#isExported} method.
&nbsp;                 * @param addExports       The {@code java.lang.Module#addExports} method.
&nbsp;                 * @param getUnnamedModule The {@code java.lang.ClassLoader#getUnnamedModule} method.
&nbsp;                 */
&nbsp;                protected ForModuleSystem(Method getModule,
&nbsp;                                          Method isExported,
&nbsp;                                          Method addExports,
<b class="fc">&nbsp;                                          Method getUnnamedModule) {</b>
<b class="fc">&nbsp;                    this.getModule = getModule;</b>
<b class="fc">&nbsp;                    this.isExported = isExported;</b>
<b class="fc">&nbsp;                    this.addExports = addExports;</b>
<b class="fc">&nbsp;                    this.getUnnamedModule = getUnnamedModule;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should always be wrapped for clarity.&quot;)
&nbsp;                public void accept(@MaybeNull ClassLoader classLoader, Class&lt;?&gt; target) {
<b class="fc">&nbsp;                    Package location = target.getPackage();</b>
<b class="fc">&nbsp;                    if (location != null) {</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            Object module = getModule.invoke(target);</b>
<b class="fc">&nbsp;                            if (!(Boolean) isExported.invoke(module, location.getName())) {</b>
<b class="nc">&nbsp;                                addExports.invoke(module, location.getName(), getUnnamedModule.invoke(classLoader));</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Failed to adjust module graph for dispatcher&quot;, exception);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
