


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AgentBuilder</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.agent.builder</a>
</div>

<h1>Coverage Summary for Class: AgentBuilder (net.bytebuddy.agent.builder)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">AgentBuilder$1</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock$Global</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock$Inactive</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock$MockitoMock$2118434360</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock$MockitoMock$2118434360$auxiliary$YBGuQWYd</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$CircularityLock$MockitoMock$2118434360$auxiliary$YJzzlgYs</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy$MockitoMock$1161278207</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy$MockitoMock$1161278207$auxiliary$r11Umw83</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$ClassFileBufferStrategy$MockitoMock$1161278207$auxiliary$T2EU5xX4</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default</td>
<td class="coverageStat">
  <span class="percent">
    65.6%
  </span>
  <span class="absValue">
    (40/61)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.4%
  </span>
  <span class="absValue">
    (120/153)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    17.8%
  </span>
  <span class="absValue">
    (8/45)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    17.8%
  </span>
  <span class="absValue">
    (8/45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Delegator$Matchable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.5%
  </span>
  <span class="absValue">
    (77/89)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$ByteBuddy$ModuleSupport</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$Factory</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$Factory$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (14/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$Factory$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$Factory$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$Java9CapableVmDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$ExecutingTransformer$LegacyVmDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Ignoring</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$NativeMethodStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$NativeMethodStrategy$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$NativeMethodStrategy$ForPrefix</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$NativeMethodStrategy$MockitoMock$555881687</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$NativeMethodStrategy$MockitoMock$555881687$auxiliary$GXPqv1o5</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$NativeMethodStrategy$MockitoMock$555881687$auxiliary$SIV4Zxaz</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Redefining</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Redefining$WithResubmission</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Transformation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Transformation$DifferentialMatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Transformation$SimpleMatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Transformation$TransformerIterator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$Transforming</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$WarmupStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$WarmupStrategy$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.6%
  </span>
  <span class="absValue">
    (39/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$WarmupStrategy$Enabled$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Default$WarmupStrategy$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    20%
  </span>
  <span class="absValue">
    (1/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$MockitoMock$1092884140</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$MockitoMock$1092884140$auxiliary$cQtSZl8W</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$MockitoMock$1092884140$auxiliary$KBWcLO0B</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$SuperTypeLoading</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    28.6%
  </span>
  <span class="absValue">
    (2/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$SuperTypeLoading$Asynchronous</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    37.5%
  </span>
  <span class="absValue">
    (3/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$SuperTypeLoading$Asynchronous$ThreadSwitchingClassLoadingDelegate</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$SuperTypeLoading$Asynchronous$ThreadSwitchingClassLoadingDelegate$NotifyingClassLoadingAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$SuperTypeLoading$Asynchronous$ThreadSwitchingClassLoadingDelegate$SimpleClassLoadingAction</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$DescriptionStrategy$SuperTypeLoading$UnlockingClassLoadingDelegate</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$FallbackStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$FallbackStrategy$ByThrowableType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$FallbackStrategy$MockitoMock$288753730</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$FallbackStrategy$MockitoMock$288753730$auxiliary$6BQGLKSO</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$FallbackStrategy$MockitoMock$288753730$auxiliary$PzP7HCtA</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$FallbackStrategy$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Identified</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Identified$Extendable</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Identified$Narrowable</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Ignored</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$Dispatcher$MockitoMock$1047329608</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$Dispatcher$MockitoMock$1047329608$auxiliary$DxIiZ7ma</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$Dispatcher$MockitoMock$1047329608$auxiliary$n6lhurWk</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$Minimal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$MockitoMock$529683841</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$MockitoMock$529683841$auxiliary$WdcThI8p</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$MockitoMock$529683841$auxiliary$WtfvSUTR</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Dispatcher$InjectingInitializer</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Eager</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Eager$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Lazy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Lazy$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Split</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InitializationStrategy$SelfInjection$Split$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92%
  </span>
  <span class="absValue">
    (23/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$MockitoMock$1161370193</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$MockitoMock$1161370193$auxiliary$2M6cYOBS</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$MockitoMock$1161370193$auxiliary$sRnAdsOd</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$UsingInstrumentation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$UsingJna</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$UsingReflection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$UsingUnsafe</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InjectionStrategy$UsingUnsafe$OfFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97%
  </span>
  <span class="absValue">
    (32/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$ErrorSuppressing</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$MockitoMock$1969354729</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$MockitoMock$1969354729$auxiliary$jV9NUjgN</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$MockitoMock$1969354729$auxiliary$T1Z2tGVN</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$InstallationListener$StreamWriting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    21.4%
  </span>
  <span class="absValue">
    (3/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    6.2%
  </span>
  <span class="absValue">
    (4/64)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$BridgeMethodImplementation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$BridgeMethodImplementation$Appender</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$ConstructorImplementation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$ConstructorImplementation$Appender</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$FactoryImplementation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$FactoryImplementation$Appender</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$LambdaMethodImplementation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$LambdaMethodImplementation$Appender</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/39)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$LambdaMethodImplementation$Appender$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$LambdaMethodImplementation$Appender$Dispatcher$UsingDirectInvocation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$LambdaMethodImplementation$Appender$Dispatcher$UsingMethodHandle</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$MockitoMock$1126031366</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$MockitoMock$1126031366$auxiliary$5nUMyiBP</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$MockitoMock$1126031366$auxiliary$6mxtZHEE</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$MockitoMock$1126031366$auxiliary$wHkOjYN9</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaInstanceFactory$SerializationImplementation</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (134/141)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (121/121)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory$Loader</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory$Loader$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory$Loader$UsingMethodHandleLookup</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (84/84)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LambdaInstrumentationStrategy$LambdaMetafactoryFactory$Loader$UsingUnsafe</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (19/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$Filtering</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$MockitoMock$945115301</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$MockitoMock$945115301$auxiliary$OIPKSUNq</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$MockitoMock$945115301$auxiliary$yFx76MpG</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$ModuleReadEdgeCompleting</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.7%
  </span>
  <span class="absValue">
    (23/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$StreamWriting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$WithErrorsOnly</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Listener$WithTransformationsOnly</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$ForClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$ForClassLoader$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$ForClassLoader$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$MockitoMock$950504943</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$MockitoMock$950504943$auxiliary$78SCidoK</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$MockitoMock$950504943$auxiliary$K8W1AnjS</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$LocationStrategy$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Matchable</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$Handler</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$Handler$ForPatchWithGap</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$Handler$ForPatchWithOverlap</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$Handler$ForPatchWithSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PatchMode$Handler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$ClassLoading</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$Eager</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$MockitoMock$2004901119</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$MockitoMock$2004901119$auxiliary$aAvaTYgF</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$MockitoMock$2004901119$auxiliary$QHOQjuiW</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$WithTypePoolCache</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$WithTypePoolCache$Simple</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (13/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$PoolStrategy$WithTypePoolCache$Simple$BootstrapMarkerAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$Conjunction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$Disjunction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$ForElementMatchers</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$ForLoadState</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$ForResolvableTypes</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$Inversion</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$MockitoMock$1856826334</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$MockitoMock$1856826334$auxiliary$CciAQ30H</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$MockitoMock$1856826334$auxiliary$sPO1AjtX</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RawMatcher$Trivial</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$Conjunction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$Disjunction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$ForElementMatchers</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$MockitoMock$2099772858</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$MockitoMock$2099772858$auxiliary$6kYT7gfA</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$MockitoMock$2099772858$auxiliary$xyatDWtg</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionImmediateMatcher$Trivial</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$Conjunction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$Disjunction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$ForElementMatchers</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$MockitoMock$663593358</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$MockitoMock$663593358$auxiliary$LpEjgjAU</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$MockitoMock$663593358$auxiliary$u8Cvxm3k</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$ResubmissionOnErrorMatcher$Trivial</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$WithImplicitDiscoveryStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$WithoutBatchStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$WithoutResubmissionSpecification</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionListenable$WithResubmissionSpecification</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$1</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$ForFixedSize</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$ForMatchedGrouping</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (27/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$ForTotal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$MockitoMock$828408414</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$MockitoMock$828408414$auxiliary$6ShEtXen</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$MockitoMock$828408414$auxiliary$koxSw7i5</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$Partitioning</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$Slicing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$Slicing$SlicingIterable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$BatchAllocator$Slicing$SlicingIterable$SlicingIterator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (16/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Collector</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.1%
  </span>
  <span class="absValue">
    (52/53)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Collector$ForRedefinition</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60.9%
  </span>
  <span class="absValue">
    (14/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Collector$ForRetransformation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Collector$PrependableIterator</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Reiterating</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Reiterating$ReiteratingIterable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Reiterating$ReiteratingIterator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Reiterating$WithSortOrderAssumption</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Reiterating$WithSortOrderAssumption$OrderedReiteratingIterable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$Reiterating$WithSortOrderAssumption$OrderedReiteratingIterator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$DiscoveryStrategy$SinglePass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$BatchReallocator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (19/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$Compound$CompoundIterable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$Compound$CompoundIterable$CompoundIterator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$ErrorEscalating</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$ErrorEscalating$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$ErrorEscalating$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$MockitoMock$10710895</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$MockitoMock$10710895$auxiliary$42bVF7Fp</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$MockitoMock$10710895$auxiliary$eK7fvazW</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$Pausing</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    38.5%
  </span>
  <span class="absValue">
    (5/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$StreamWriting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$Listener$Yielding</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionEnforcer</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionEnforcer$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionEnforcer$MockitoMock$113274119</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionEnforcer$MockitoMock$113274119$auxiliary$LVu78aqA</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionEnforcer$MockitoMock$113274119$auxiliary$wSlhpfhH</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$AtFixedRate</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$Cancelable</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$Cancelable$ForFuture</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$Cancelable$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$MockitoMock$1047631086</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$MockitoMock$1047631086$auxiliary$9qykg3ek</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$MockitoMock$1047631086$auxiliary$xV5sDg6J</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionScheduler$WithFixedDelay</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Enabled$LookupKey</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Enabled$ResubmissionInstallationListener</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.1%
  </span>
  <span class="absValue">
    (37/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Enabled$Resubmitter</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (11/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Enabled$Resubmitter$ConcurrentHashSet</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Enabled$StorageKey</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$RedefinitionStrategy$ResubmissionStrategy$Installation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$ForAdvice</td>
<td class="coverageStat">
  <span class="percent">
    76.5%
  </span>
  <span class="absValue">
    (13/17)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.8%
  </span>
  <span class="absValue">
    (33/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$ForAdvice$Entry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$ForAdvice$Entry$ForSplitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$ForAdvice$Entry$ForUnifiedAdvice</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$ForBuildPlugin</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$MockitoMock$1205708131</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$MockitoMock$1205708131$auxiliary$b9u7MsGP</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$Transformer$MockitoMock$1205708131$auxiliary$qg9Ig6kg</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator$ForSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator$MockitoMock$409213977</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator$MockitoMock$409213977$auxiliary$69V1hmT2</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator$MockitoMock$409213977$auxiliary$isSn0u2e</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TransformerDecorator$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$Default$4</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$ForBuildEntryPoint</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$MockitoMock$1343018440</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$MockitoMock$1343018440$auxiliary$sLPmkvtD</td>
  </tr>
  <tr>
    <td class="name">AgentBuilder$TypeStrategy$MockitoMock$1343018440$auxiliary$y95zN6Dw</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    79.7%
  </span>
  <span class="absValue">
    (639/802)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.9%
  </span>
  <span class="absValue">
    (1851/2376)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.agent.builder;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.NamingStrategy;
&nbsp;import net.bytebuddy.asm.Advice;
&nbsp;import net.bytebuddy.asm.AsmVisitorWrapper;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.EntryPoint;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.build.Plugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.modifier.FieldManifestation;
&nbsp;import net.bytebuddy.description.modifier.MethodManifestation;
&nbsp;import net.bytebuddy.description.modifier.Ownership;
&nbsp;import net.bytebuddy.description.modifier.TypeManifestation;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.PackageDescription;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.NexusAccessor;
&nbsp;import net.bytebuddy.dynamic.TypeResolutionStrategy;
&nbsp;import net.bytebuddy.dynamic.VisibilityBridgeStrategy;
&nbsp;import net.bytebuddy.dynamic.loading.ClassInjector;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.dynamic.loading.ClassReloadingStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.ExceptionMethod;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.implementation.MethodCall;
&nbsp;import net.bytebuddy.implementation.auxiliary.AuxiliaryType;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.TypeCasting;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.TextConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.matcher.LatentMatcher;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.ConstantDynamic;
&nbsp;import org.objectweb.asm.Handle;
&nbsp;import org.objectweb.asm.Label;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.NotSerializableException;
&nbsp;import java.io.ObjectInputStream;
&nbsp;import java.io.ObjectOutputStream;
&nbsp;import java.io.PrintStream;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.instrument.ClassDefinition;
&nbsp;import java.lang.instrument.ClassFileTransformer;
&nbsp;import java.lang.instrument.IllegalClassFormatException;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.instrument.UnmodifiableClassException;
&nbsp;import java.lang.ref.WeakReference;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.AbstractSet;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.Iterator;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.LinkedHashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Random;
&nbsp;import java.util.Set;
&nbsp;import java.util.concurrent.Callable;
&nbsp;import java.util.concurrent.ConcurrentHashMap;
&nbsp;import java.util.concurrent.ConcurrentMap;
&nbsp;import java.util.concurrent.ExecutionException;
&nbsp;import java.util.concurrent.ExecutorService;
&nbsp;import java.util.concurrent.Executors;
&nbsp;import java.util.concurrent.Future;
&nbsp;import java.util.concurrent.ScheduledExecutorService;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.concurrent.atomic.AtomicBoolean;
&nbsp;import java.util.concurrent.atomic.AtomicInteger;
&nbsp;import java.util.concurrent.locks.Lock;
&nbsp;import java.util.concurrent.locks.ReentrantLock;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.any;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.hasMethodName;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isConstructor;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isExtensionClassLoader;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isSynthetic;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.not;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.returns;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.supportsModules;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.takesArgument;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.takesArguments;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * An agent builder provides a convenience API for defining a
&nbsp; * &lt;a href=&quot;http://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html&quot;&gt;Java agent&lt;/a&gt;. By default,
&nbsp; * this transformation is applied by rebasing the type if not specified otherwise by setting a
&nbsp; * {@link TypeStrategy}.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * When defining several {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s, the agent builder always
&nbsp; * applies the transformers that were supplied with the last applicable matcher. Therefore, more general transformers
&nbsp; * should be defined first.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: Any transformation is performed using the {@code java.security.AccessControlContext} of an agent&#39;s creator.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Important&lt;/b&gt;: Types that implement lambda expressions (functional interfaces) are not instrumented by default but
&nbsp; * only when enabling the builder&#39;s {@link LambdaInstrumentationStrategy}.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;@SuppressWarnings(&quot;overloads&quot;)
&nbsp;public interface AgentBuilder {
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given {@link net.bytebuddy.ByteBuddy} instance to be used by the created agent.
&nbsp;     *
&nbsp;     * @param byteBuddy The Byte Buddy instance to be used.
&nbsp;     * @return A new instance of this agent builder which makes use of the given {@code byteBuddy} instance.
&nbsp;     */
&nbsp;    AgentBuilder with(ByteBuddy byteBuddy);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the given {@link net.bytebuddy.agent.builder.AgentBuilder.Listener} to be notified by the created agent.
&nbsp;     * The given listener is notified after any other listener that is already registered. If a listener is registered
&nbsp;     * twice, it is also notified twice.
&nbsp;     *
&nbsp;     * @param listener The listener to be notified.
&nbsp;     * @return A new instance of this agent builder which creates an agent that informs the given listener about
&nbsp;     * events.
&nbsp;     */
&nbsp;    AgentBuilder with(Listener listener);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a circularity lock that is acquired upon executing code that potentially loads new classes. While the
&nbsp;     * lock is acquired, any class file transformer refrains from transforming any classes. By default, all created
&nbsp;     * agents use a shared {@link CircularityLock} to avoid that any classes that are required to execute an agent
&nbsp;     * causes a {@link ClassCircularityError}.
&nbsp;     *
&nbsp;     * @param circularityLock The circularity lock to use.
&nbsp;     * @return A new instance of this agent builder which creates an agent that uses the supplied circularity lock.
&nbsp;     */
&nbsp;    AgentBuilder with(CircularityLock circularityLock);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the use of the given type locator for locating a {@link TypeDescription} for an instrumented type.
&nbsp;     *
&nbsp;     * @param poolStrategy The type locator to use.
&nbsp;     * @return A new instance of this agent builder which uses the given type locator for looking up class files.
&nbsp;     */
&nbsp;    AgentBuilder with(PoolStrategy poolStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the use of the given location strategy for locating binary data to given class names.
&nbsp;     *
&nbsp;     * @param locationStrategy The location strategy to use.
&nbsp;     * @return A new instance of this agent builder which uses the given location strategy for looking up class files.
&nbsp;     */
&nbsp;    AgentBuilder with(LocationStrategy locationStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Registers an additional class file locator for types that are globally available but cannot be located
&nbsp;     * otherwise. Typically, those types are injected classes into the boot loader.
&nbsp;     *
&nbsp;     * @param classFileLocator The class file locator to add.
&nbsp;     * @return A new instance of this agent builder which uses the given class file locator for global type lookup.
&nbsp;     */
&nbsp;    AgentBuilder with(ClassFileLocator classFileLocator);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines how types should be transformed, e.g. if they should be rebased or redefined by the created agent.
&nbsp;     *
&nbsp;     * @param typeStrategy The type strategy to use.
&nbsp;     * @return A new instance of this agent builder which uses the given type strategy.
&nbsp;     */
&nbsp;    AgentBuilder with(TypeStrategy typeStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a given initialization strategy to be applied to generated types. An initialization strategy is responsible
&nbsp;     * for setting up a type after it was loaded. This initialization must be performed after the transformation because
&nbsp;     * a Java agent is only invoked before loading a type. By default, the initialization logic is added to a class&#39;s type
&nbsp;     * initializer which queries a global object for any objects that are to be injected into the generated type.
&nbsp;     *
&nbsp;     * @param initializationStrategy The initialization strategy to use.
&nbsp;     * @return A new instance of this agent builder that applies the given initialization strategy.
&nbsp;     */
&nbsp;    AgentBuilder with(InitializationStrategy initializationStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Specifies a strategy for modifying types that were already loaded prior to the installation of this transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: Defining a redefinition strategy resets any refinements of a previously set redefinition strategy.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param redefinitionStrategy The redefinition strategy to apply.
&nbsp;     * @return A new instance of this agent builder that applies the given redefinition strategy.
&nbsp;     */
&nbsp;    RedefinitionListenable.WithoutBatchStrategy with(RedefinitionStrategy redefinitionStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Enables or disables management of the JVM&#39;s {@code LambdaMetafactory} which is responsible for creating classes that
&nbsp;     * implement lambda expressions. Without this feature enabled, classes that are represented by lambda expressions are
&nbsp;     * not instrumented by the JVM such that Java agents have no effect on them when a lambda expression&#39;s class is loaded
&nbsp;     * for the first time.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When activating this feature, Byte Buddy instruments the {@code LambdaMetafactory} and takes over the responsibility
&nbsp;     * of creating classes that represent lambda expressions. In doing so, Byte Buddy has the opportunity to apply the built
&nbsp;     * class file transformer. If the current VM does not support lambda expressions, activating this feature has no effect.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: If this feature is active, it is important to release the built class file transformer when
&nbsp;     * deactivating it. Normally, it is sufficient to call {@link Instrumentation#removeTransformer(ClassFileTransformer)}.
&nbsp;     * When this feature is enabled, it is however also required to invoke
&nbsp;     * {@link LambdaInstrumentationStrategy#release(ClassFileTransformer, Instrumentation)}. Otherwise, the executing VMs class
&nbsp;     * loader retains a reference to the class file transformer what can cause a memory leak.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param lambdaInstrumentationStrategy {@code true} if this feature should be enabled.
&nbsp;     * @return A new instance of this agent builder where this feature is explicitly enabled or disabled.
&nbsp;     */
&nbsp;    AgentBuilder with(LambdaInstrumentationStrategy lambdaInstrumentationStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies a strategy to be used for resolving {@link TypeDescription} for any type handled by the created transformer.
&nbsp;     *
&nbsp;     * @param descriptionStrategy The description strategy to use.
&nbsp;     * @return A new instance of this agent builder that applies the given description strategy.
&nbsp;     */
&nbsp;    AgentBuilder with(DescriptionStrategy descriptionStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies a fallback strategy to that this agent builder applies upon installing an agent and during class file transformation.
&nbsp;     *
&nbsp;     * @param fallbackStrategy The fallback strategy to be used.
&nbsp;     * @return A new agent builder that applies the supplied fallback strategy.
&nbsp;     */
&nbsp;    AgentBuilder with(FallbackStrategy fallbackStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies a class file buffer strategy that determines the use of the buffer supplied to a class file transformer.
&nbsp;     *
&nbsp;     * @param classFileBufferStrategy The class file buffer strategy to use.
&nbsp;     * @return A new agent builder that applies the supplied class file buffer strategy.
&nbsp;     */
&nbsp;    AgentBuilder with(ClassFileBufferStrategy classFileBufferStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds an installation listener that is notified during installation events. Installation listeners are only invoked if
&nbsp;     * a class file transformer is installed using this agent builder&#39;s installation methods and uninstalled via the created
&nbsp;     * {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     *
&nbsp;     * @param installationListener The installation listener to register.
&nbsp;     * @return A new agent builder that applies the supplied installation listener.
&nbsp;     */
&nbsp;    AgentBuilder with(InstallationListener installationListener);
&nbsp;
&nbsp;    /**
&nbsp;     * Defines a strategy for injecting auxiliary types into the target class loader.
&nbsp;     *
&nbsp;     * @param injectionStrategy The injection strategy to use.
&nbsp;     * @return A new agent builder with the supplied injection strategy configured.
&nbsp;     */
&nbsp;    AgentBuilder with(InjectionStrategy injectionStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a decorator for the created class file transformer.
&nbsp;     *
&nbsp;     * @param transformerDecorator A decorator to wrap the created class file transformer.
&nbsp;     * @return A new agent builder that applies the supplied transformer decorator.
&nbsp;     */
&nbsp;    AgentBuilder with(TransformerDecorator transformerDecorator);
&nbsp;
&nbsp;    /**
&nbsp;     * Enables the use of the given native method prefix for instrumented methods. Note that this prefix is also
&nbsp;     * applied when preserving non-native methods. The use of this prefix is also registered when installing the
&nbsp;     * final agent with an {@link java.lang.instrument.Instrumentation}.
&nbsp;     *
&nbsp;     * @param prefix The prefix to be used.
&nbsp;     * @return A new instance of this agent builder which uses the given native method prefix.
&nbsp;     */
&nbsp;    AgentBuilder enableNativeMethodPrefix(String prefix);
&nbsp;
&nbsp;    /**
&nbsp;     * Disables the use of a native method prefix for instrumented methods.
&nbsp;     *
&nbsp;     * @return A new instance of this agent builder which does not use a native method prefix.
&nbsp;     */
&nbsp;    AgentBuilder disableNativeMethodPrefix();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Disables all implicit changes on a class file that Byte Buddy would apply for certain instrumentations. When
&nbsp;     * using this option, it is no longer possible to rebase a method, i.e. intercepted methods are fully replaced. Furthermore,
&nbsp;     * it is no longer possible to implicitly apply loaded type initializers for explicitly initializing the generated type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * This is equivalent to setting {@link InitializationStrategy.NoOp} and {@link TypeStrategy.Default#REDEFINE_FROZEN}
&nbsp;     * (unless it is configured as {@link TypeStrategy.Default#DECORATE} where this strategy is retained)
&nbsp;     * as well as configuring the underlying {@link ByteBuddy} instance to use a {@link net.bytebuddy.implementation.Implementation.Context.Disabled}.
&nbsp;     * Using this strategy also configures Byte Buddy to create frozen instrumented types and discards any explicit configuration.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return A new instance of this agent builder that does not apply any implicit changes to the received class file.
&nbsp;     */
&nbsp;    AgentBuilder disableClassFormatChanges();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Warms up the generated {@link ClassFileTransformer} to trigger class loading of classes used by the transformer
&nbsp;     * prior to its actual use. Ideally, warmup should include classes that cause a transformation and classes that
&nbsp;     * are ignored. Warming up can be especially useful when transforming classes on the boot path, where circularity
&nbsp;     * errors are more likely. At the same time, warming up might load classes that are expected to be unloaded
&nbsp;     * when this agent is installed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Warming up is applied just as a regular transformation and will also invoke the {@link Listener}.
&nbsp;     * This is done to avoid that listener classes can cause circularities. It is the users responsibility to suppress
&nbsp;     * such log output, if necessary.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param type The types to include in the warmup.
&nbsp;     * @return A new agent builder that considers the supplied classes in its warmup.
&nbsp;     */
&nbsp;    AgentBuilder warmUp(Class&lt;?&gt;... type);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Warms up the generated {@link ClassFileTransformer} to trigger class loading of classes used by the transformer
&nbsp;     * prior to its actual use. Ideally, warmup should include classes that cause a transformation and classes that
&nbsp;     * are ignored. Warming up can be especially useful when transforming classes on the boot path, where circularity
&nbsp;     * errors are more likely. At the same time, warming up might load classes that are expected to be unloaded
&nbsp;     * when this agent is installed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Warming up is applied just as a regular transformation and will also invoke the {@link Listener}.
&nbsp;     * This is done to avoid that listener classes can cause circularities. It is the users responsibility to suppress
&nbsp;     * such log output, if necessary.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param types The types to include in the warmup.
&nbsp;     * @return A new agent builder that considers the supplied classes in its warmup.
&nbsp;     */
&nbsp;    AgentBuilder warmUp(Collection&lt;Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;    /**
&nbsp;     * Assures that all modules of the supplied types are read by the module of any instrumented type. If the current VM does not support
&nbsp;     * the Java module system, calling this method has no effect and this instance is returned.
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation instance that is used for adding a module read-dependency.
&nbsp;     * @param type            The types for which to assure their module-visibility from any instrumented class.
&nbsp;     * @return A new instance of this agent builder that assures the supplied types module visibility.
&nbsp;     * @see Listener.ModuleReadEdgeCompleting
&nbsp;     */
&nbsp;    AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Class&lt;?&gt;... type);
&nbsp;
&nbsp;    /**
&nbsp;     * Assures that all supplied modules are read by the module of any instrumented type.
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation instance that is used for adding a module read-dependency.
&nbsp;     * @param module          The modules for which to assure their module-visibility from any instrumented class.
&nbsp;     * @return A new instance of this agent builder that assures the supplied types module visibility.
&nbsp;     * @see Listener.ModuleReadEdgeCompleting
&nbsp;     */
&nbsp;    AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, JavaModule... module);
&nbsp;
&nbsp;    /**
&nbsp;     * Assures that all supplied modules are read by the module of any instrumented type.
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation instance that is used for adding a module read-dependency.
&nbsp;     * @param modules         The modules for which to assure their module-visibility from any instrumented class.
&nbsp;     * @return A new instance of this agent builder that assures the supplied types module visibility.
&nbsp;     * @see Listener.ModuleReadEdgeCompleting
&nbsp;     */
&nbsp;    AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Collection&lt;? extends JavaModule&gt; modules);
&nbsp;
&nbsp;    /**
&nbsp;     * Assures that all modules of the supplied types are read by the module of any instrumented type and vice versa.
&nbsp;     * If the current VM does not support the Java module system, calling this method has no effect and this instance is returned.
&nbsp;     * Setting this option will also ensure that the instrumented type&#39;s package is opened to the target module, if applicable.
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation instance that is used for adding a module read-dependency.
&nbsp;     * @param type            The types for which to assure their module-visibility from and to any instrumented class.
&nbsp;     * @return A new instance of this agent builder that assures the supplied types module visibility.
&nbsp;     * @see Listener.ModuleReadEdgeCompleting
&nbsp;     */
&nbsp;    AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Class&lt;?&gt;... type);
&nbsp;
&nbsp;    /**
&nbsp;     * Assures that all supplied modules are read by the module of any instrumented type and vice versa.
&nbsp;     * Setting this option will also ensure that the instrumented type&#39;s package is opened to the target module.
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation instance that is used for adding a module read-dependency.
&nbsp;     * @param module          The modules for which to assure their module-visibility from and to any instrumented class.
&nbsp;     * @return A new instance of this agent builder that assures the supplied types module visibility.
&nbsp;     * @see Listener.ModuleReadEdgeCompleting
&nbsp;     */
&nbsp;    AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, JavaModule... module);
&nbsp;
&nbsp;    /**
&nbsp;     * Assures that all supplied modules are read by the module of any instrumented type and vice versa.
&nbsp;     * Setting this option will also ensure that the instrumented type&#39;s package is opened to the target module.
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation instance that is used for adding a module read-dependency.
&nbsp;     * @param modules         The modules for which to assure their module-visibility from and to any instrumented class.
&nbsp;     * @return A new instance of this agent builder that assures the supplied types module visibility.
&nbsp;     * @see Listener.ModuleReadEdgeCompleting
&nbsp;     */
&nbsp;    AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Collection&lt;? extends JavaModule&gt; modules);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Matches a type being loaded in order to apply the supplied {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s before loading this type.
&nbsp;     * If several matchers positively match a type only the latest registered matcher is considered for transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If this matcher is chained with additional subsequent matchers, any matcher is executed in registration order with matchers that were registered
&nbsp;     * first being executed first. Doing so, later transformations can override transformations that are applied by this matcher. To avoid this, it is
&nbsp;     * possible to register this transformation as terminal via {@link Identified.Extendable#asTerminalTransformation()} where no subsequent matchers
&nbsp;     * are applied if this matcher matched a given type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When applying a matcher, regard the performance implications by {@link AgentBuilder#ignore(ElementMatcher)}. The former
&nbsp;     * matcher is applied first such that it makes sense to ignore name spaces that are irrelevant to instrumentation. If possible, it is
&nbsp;     * also recommended, to exclude class loaders such as for example the bootstrap class loader by using
&nbsp;     * {@link AgentBuilder#type(ElementMatcher, ElementMatcher)} instead.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param typeMatcher An {@link net.bytebuddy.matcher.ElementMatcher} that is applied on the type being loaded that
&nbsp;     *                    decides if the entailed {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should
&nbsp;     *                    be applied for that type.
&nbsp;     * @return A definable that represents this agent builder which allows for the definition of one or several
&nbsp;     * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s to be applied when the given {@code typeMatcher}
&nbsp;     * indicates a match.
&nbsp;     */
&nbsp;    Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Matches a type being loaded in order to apply the supplied {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s before loading this type.
&nbsp;     * If several matchers positively match a type only the latest registered matcher is considered for transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If this matcher is chained with additional subsequent matchers, any matcher is executed in registration order with matchers that were registered
&nbsp;     * first being executed first. Doing so, later transformations can override transformations that are applied by this matcher. To avoid this, it is
&nbsp;     * possible to register this transformation as terminal via {@link Identified.Extendable#asTerminalTransformation()} where no subsequent matchers
&nbsp;     * are applied if this matcher matched a given type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When applying a matcher, regard the performance implications by {@link AgentBuilder#ignore(ElementMatcher)}. The former
&nbsp;     * matcher is applied first such that it makes sense to ignore name spaces that are irrelevant to instrumentation. If possible, it
&nbsp;     * is also recommended, to exclude class loaders such as for example the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param typeMatcher        An {@link net.bytebuddy.matcher.ElementMatcher} that is applied on the type being
&nbsp;     *                           loaded that decides if the entailed
&nbsp;     *                           {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should be applied for
&nbsp;     *                           that type.
&nbsp;     * @param classLoaderMatcher An {@link net.bytebuddy.matcher.ElementMatcher} that is applied to the
&nbsp;     *                           {@link java.lang.ClassLoader} that is loading the type being loaded. This matcher
&nbsp;     *                           is always applied first where the type matcher is not applied in case that this
&nbsp;     *                           matcher does not indicate a match.
&nbsp;     * @return A definable that represents this agent builder which allows for the definition of one or several
&nbsp;     * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s to be applied when both the given
&nbsp;     * {@code typeMatcher} and {@code classLoaderMatcher} indicate a match.
&nbsp;     */
&nbsp;    Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Matches a type being loaded in order to apply the supplied {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s before loading this type.
&nbsp;     * If several matchers positively match a type only the latest registered matcher is considered for transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If this matcher is chained with additional subsequent matchers, any matcher is executed in registration order with matchers that were registered
&nbsp;     * first being executed first. Doing so, later transformations can override transformations that are applied by this matcher. To avoid this, it is
&nbsp;     * possible to register this transformation as terminal via {@link Identified.Extendable#asTerminalTransformation()} where no subsequent matchers
&nbsp;     * are applied if this matcher matched a given type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When applying a matcher, regard the performance implications by {@link AgentBuilder#ignore(ElementMatcher)}. The former
&nbsp;     * matcher is applied first such that it makes sense to ignore name spaces that are irrelevant to instrumentation. If possible, it
&nbsp;     * is also recommended, to exclude class loaders such as for example the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param typeMatcher        An {@link net.bytebuddy.matcher.ElementMatcher} that is applied on the type being
&nbsp;     *                           loaded that decides if the entailed
&nbsp;     *                           {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should be applied for
&nbsp;     *                           that type.
&nbsp;     * @param classLoaderMatcher An {@link net.bytebuddy.matcher.ElementMatcher} that is applied to the
&nbsp;     *                           {@link java.lang.ClassLoader} that is loading the type being loaded. This matcher
&nbsp;     *                           is always applied second where the type matcher is not applied in case that this
&nbsp;     *                           matcher does not indicate a match.
&nbsp;     * @param moduleMatcher      An {@link net.bytebuddy.matcher.ElementMatcher} that is applied to the {@link JavaModule}
&nbsp;     *                           of the type being loaded. This matcher is always applied first where the class loader and
&nbsp;     *                           type matchers are not applied in case that this matcher does not indicate a match. On a JVM
&nbsp;     *                           that does not support the Java modules system, this matcher is not applied.
&nbsp;     * @return A definable that represents this agent builder which allows for the definition of one or several
&nbsp;     * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s to be applied when both the given
&nbsp;     * {@code typeMatcher} and {@code classLoaderMatcher} indicate a match.
&nbsp;     */
&nbsp;    Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                               ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                               ElementMatcher&lt;? super JavaModule&gt; moduleMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Matches a type being loaded in order to apply the supplied {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s before loading this type.
&nbsp;     * If several matchers positively match a type only the latest registered matcher is considered for transformation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If this matcher is chained with additional subsequent matchers, any matcher is executed in registration order with matchers that were registered
&nbsp;     * first being executed first. Doing so, later transformations can override transformations that are applied by this matcher. To avoid this, it is
&nbsp;     * possible to register this transformation as terminal via {@link Identified.Extendable#asTerminalTransformation()} where no subsequent matchers
&nbsp;     * are applied if this matcher matched a given type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: When applying a matcher, regard the performance implications by {@link AgentBuilder#ignore(ElementMatcher)}. The former
&nbsp;     * matcher is applied first such that it makes sense to ignore name spaces that are irrelevant to instrumentation. If possible, it
&nbsp;     * is also recommended, to exclude class loaders such as for example the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param matcher A matcher that decides if the entailed {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should be
&nbsp;     *                applied for a type that is being loaded.
&nbsp;     * @return A definable that represents this agent builder which allows for the definition of one or several
&nbsp;     * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s to be applied when the given {@code matcher}
&nbsp;     * indicates a match.
&nbsp;     */
&nbsp;    Identified.Narrowable type(RawMatcher matcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Excludes any type that is matched by the provided matcher from instrumentation and considers types by all {@link ClassLoader}s.
&nbsp;     * By default, Byte Buddy does not instrument synthetic types or types that are loaded by the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When ignoring a type, any subsequently chained matcher is applied after this matcher in the order of their registration. Also, if
&nbsp;     * any matcher indicates that a type is to be ignored, none of the following chained matchers is executed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: For performance reasons, it is recommended to always include a matcher that excludes as many namespaces
&nbsp;     * as possible. Byte Buddy can determine a type&#39;s name without parsing its class file and can therefore discard such
&nbsp;     * types with minimal overhead. When a different property of a type - such as for example its modifiers or its annotations
&nbsp;     * is accessed - Byte Buddy parses the class file lazily in order to allow for such a matching. Therefore, any exclusion
&nbsp;     * of a name should always be done as a first step and even if it does not influence the selection of what types are
&nbsp;     * matched. Without changing this property, the class file of every type is being parsed!
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: If a type is loaded during the instrumentation of the same type, this causes the original call site that loads the type
&nbsp;     * to remain unbound, causing a {@link LinkageError}. It is therefore important to not instrument types that may be loaded during the application
&nbsp;     * of a {@link Transformer}. For this reason, it is not recommended to instrument classes of the bootstrap class loader that Byte Buddy might
&nbsp;     * require for instrumenting a class or to instrument any of Byte Buddy&#39;s classes. If such instrumentation is desired, it is important to
&nbsp;     * assert for each class that they are not loaded during instrumentation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param typeMatcher A matcher that identifies types that should not be instrumented.
&nbsp;     * @return A new instance of this agent builder that ignores all types that are matched by the provided matcher.
&nbsp;     * All previous matchers for ignored types are discarded.
&nbsp;     */
&nbsp;    Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Excludes any type that is matched by the provided matcher and is loaded by a class loader matching the second matcher.
&nbsp;     * By default, Byte Buddy does not instrument synthetic types, types within a {@code net.bytebuddy.*} package or types that
&nbsp;     * are loaded by the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When ignoring a type, any subsequently chained matcher is applied after this matcher in the order of their registration. Also, if
&nbsp;     * any matcher indicates that a type is to be ignored, none of the following chained matchers is executed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: For performance reasons, it is recommended to always include a matcher that excludes as many namespaces
&nbsp;     * as possible. Byte Buddy can determine a type&#39;s name without parsing its class file and can therefore discard such
&nbsp;     * types with minimal overhead. When a different property of a type - such as for example its modifiers or its annotations
&nbsp;     * is accessed - Byte Buddy parses the class file lazily in order to allow for such a matching. Therefore, any exclusion
&nbsp;     * of a name should always be done as a first step and even if it does not influence the selection of what types are
&nbsp;     * matched. Without changing this property, the class file of every type is being parsed!
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: If a type is loaded during the instrumentation of the same type, this causes the original call site that loads the type
&nbsp;     * to remain unbound, causing a {@link LinkageError}. It is therefore important to not instrument types that may be loaded during the application
&nbsp;     * of a {@link Transformer}. For this reason, it is not recommended to instrument classes of the bootstrap class loader that Byte Buddy might
&nbsp;     * require for instrumenting a class or to instrument any of Byte Buddy&#39;s classes. If such instrumentation is desired, it is important to
&nbsp;     * assert for each class that they are not loaded during instrumentation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param typeMatcher        A matcher that identifies types that should not be instrumented.
&nbsp;     * @param classLoaderMatcher A matcher that identifies a class loader that identifies classes that should not be instrumented.
&nbsp;     * @return A new instance of this agent builder that ignores all types that are matched by the provided matcher.
&nbsp;     * All previous matchers for ignored types are discarded.
&nbsp;     */
&nbsp;    Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Excludes any type that is matched by the provided matcher and is loaded by a class loader matching the second matcher.
&nbsp;     * By default, Byte Buddy does not instrument synthetic types, types within a {@code net.bytebuddy.*} package or types that
&nbsp;     * are loaded by the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When ignoring a type, any subsequently chained matcher is applied after this matcher in the order of their registration. Also, if
&nbsp;     * any matcher indicates that a type is to be ignored, none of the following chained matchers is executed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: For performance reasons, it is recommended to always include a matcher that excludes as many namespaces
&nbsp;     * as possible. Byte Buddy can determine a type&#39;s name without parsing its class file and can therefore discard such
&nbsp;     * types with minimal overhead. When a different property of a type - such as for example its modifiers or its annotations
&nbsp;     * is accessed - Byte Buddy parses the class file lazily in order to allow for such a matching. Therefore, any exclusion
&nbsp;     * of a name should always be done as a first step and even if it does not influence the selection of what types are
&nbsp;     * matched. Without changing this property, the class file of every type is being parsed!
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: If a type is loaded during the instrumentation of the same type, this causes the original call site that loads the type
&nbsp;     * to remain unbound, causing a {@link LinkageError}. It is therefore important to not instrument types that may be loaded during the application
&nbsp;     * of a {@link Transformer}. For this reason, it is not recommended to instrument classes of the bootstrap class loader that Byte Buddy might
&nbsp;     * require for instrumenting a class or to instrument any of Byte Buddy&#39;s classes. If such instrumentation is desired, it is important to
&nbsp;     * assert for each class that they are not loaded during instrumentation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param typeMatcher        A matcher that identifies types that should not be instrumented.
&nbsp;     * @param classLoaderMatcher A matcher that identifies a class loader that identifies classes that should not be instrumented.
&nbsp;     * @param moduleMatcher      A matcher that identifies a module that identifies classes that should not be instrumented. On a JVM
&nbsp;     *                           that does not support the Java modules system, this matcher is not applied.
&nbsp;     * @return A new instance of this agent builder that ignores all types that are matched by the provided matcher.
&nbsp;     * All previous matchers for ignored types are discarded.
&nbsp;     */
&nbsp;    Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                   ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                   ElementMatcher&lt;? super JavaModule&gt; moduleMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Excludes any type that is matched by the raw matcher provided to this method. By default, Byte Buddy does not
&nbsp;     * instrument synthetic types, types within a {@code net.bytebuddy.*} package or types that are loaded by the bootstrap class loader.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * When ignoring a type, any subsequently chained matcher is applied after this matcher in the order of their registration. Also, if
&nbsp;     * any matcher indicates that a type is to be ignored, none of the following chained matchers is executed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: For performance reasons, it is recommended to always include a matcher that excludes as many namespaces
&nbsp;     * as possible. Byte Buddy can determine a type&#39;s name without parsing its class file and can therefore discard such
&nbsp;     * types with minimal overhead. When a different property of a type - such as for example its modifiers or its annotations
&nbsp;     * is accessed - Byte Buddy parses the class file lazily in order to allow for such a matching. Therefore, any exclusion
&nbsp;     * of a name should always be done as a first step and even if it does not influence the selection of what types are
&nbsp;     * matched. Without changing this property, the class file of every type is being parsed!
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: If a type is loaded during the instrumentation of the same type, this causes the original call site that loads the type
&nbsp;     * to remain unbound, causing a {@link LinkageError}. It is therefore important to not instrument types that may be loaded during the application
&nbsp;     * of a {@link Transformer}. For this reason, it is not recommended to instrument classes of the bootstrap class loader that Byte Buddy might
&nbsp;     * require for instrumenting a class or to instrument any of Byte Buddy&#39;s classes. If such instrumentation is desired, it is important to
&nbsp;     * assert for each class that they are not loaded during instrumentation.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param rawMatcher A raw matcher that identifies types that should not be instrumented.
&nbsp;     * @return A new instance of this agent builder that ignores all types that are matched by the provided matcher.
&nbsp;     * All previous matchers for ignored types are discarded.
&nbsp;     */
&nbsp;    Ignored ignore(RawMatcher rawMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a {@link ResettableClassFileTransformer} that implements the configuration of this
&nbsp;     * agent builder. When using a raw class file transformer, the {@link InstallationListener} callbacks are
&nbsp;     * not invoked and the set {@link RedefinitionStrategy} is not applied onto currently loaded classes.
&nbsp;     *
&nbsp;     * @return A class file transformer that implements the configuration of this agent builder.
&nbsp;     */
&nbsp;    ClassFileTransformer makeRaw();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with a given {@link java.lang.instrument.Instrumentation}. If retransformation is enabled,
&nbsp;     * the installation also causes all loaded types to be retransformed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation The instrumentation on which this agent builder&#39;s configuration is to be installed.
&nbsp;     * @return The installed class file transformer.
&nbsp;     */
&nbsp;    ResettableClassFileTransformer installOn(Instrumentation instrumentation);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with the Byte Buddy-agent which must be installed prior to calling this method. If retransformation
&nbsp;     * is enabled, the installation also causes all loaded types to be retransformed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @return The installed class file transformer.
&nbsp;     * @see AgentBuilder#installOn(Instrumentation)
&nbsp;     */
&nbsp;    ResettableClassFileTransformer installOnByteBuddyAgent();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with a given {@link java.lang.instrument.Instrumentation}. If retransformation is enabled,
&nbsp;     * the installation also causes all loaded types to be retransformed which have changed compared to the previous
&nbsp;     * class file transformer that is provided as an argument. Without specification, {@link PatchMode#OVERLAP} is used.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation      The instrumentation on which this agent builder&#39;s configuration is to be installed.
&nbsp;     * @param classFileTransformer The class file transformer that is being patched.
&nbsp;     * @return The installed class file transformer.
&nbsp;     */
&nbsp;    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with a given {@link java.lang.instrument.Instrumentation}. If retransformation is enabled,
&nbsp;     * the installation also causes all loaded types to be retransformed which have changed compared to the previous
&nbsp;     * class file transformer that is provided as an argument. Without specification, {@link PatchMode#OVERLAP} is used.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation      The instrumentation on which this agent builder&#39;s configuration is to be installed.
&nbsp;     * @param classFileTransformer The class file transformer that is being patched.
&nbsp;     * @param differentialMatcher  The differential matcher to decide what types need retransformation.
&nbsp;     * @return The installed class file transformer.
&nbsp;     */
&nbsp;    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with a given {@link java.lang.instrument.Instrumentation}. If retransformation is enabled,
&nbsp;     * the installation also causes all loaded types to be retransformed which have changed compared to the previous
&nbsp;     * class file transformer that is provided as an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation      The instrumentation on which this agent builder&#39;s configuration is to be installed.
&nbsp;     * @param classFileTransformer The class file transformer that is being patched.
&nbsp;     * @param patchMode            The patch mode to apply.
&nbsp;     * @return The installed class file transformer.
&nbsp;     */
&nbsp;    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, PatchMode patchMode);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with a given {@link java.lang.instrument.Instrumentation}. If retransformation is enabled,
&nbsp;     * the installation also causes all loaded types to be retransformed which have changed compared to the previous
&nbsp;     * class file transformer that is provided as an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation      The instrumentation on which this agent builder&#39;s configuration is to be installed.
&nbsp;     * @param classFileTransformer The class file transformer that is being patched.
&nbsp;     * @param differentialMatcher  The differential matcher to decide what types need retransformation.
&nbsp;     * @param patchMode            The patch mode to apply.
&nbsp;     * @return The installed class file transformer.
&nbsp;     */
&nbsp;    ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher, PatchMode patchMode);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with the Byte Buddy-agent which must be installed prior to calling this method. If retransformation
&nbsp;     * is enabled, the installation also causes all loaded types to be retransformed which have changed compared to the previous
&nbsp;     * class file transformer that is provided as an argument. Without specification, {@link PatchMode#OVERLAP} is used.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param classFileTransformer The class file transformer that is being patched.
&nbsp;     * @return The installed class file transformer.
&nbsp;     * @see AgentBuilder#patchOn(Instrumentation, ResettableClassFileTransformer)
&nbsp;     */
&nbsp;    ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Creates and installs a {@link ResettableClassFileTransformer} that implements the configuration of
&nbsp;     * this agent builder with the Byte Buddy-agent which must be installed prior to calling this method. If retransformation
&nbsp;     * is enabled, the installation also causes all loaded types to be retransformed which have changed compared to the previous
&nbsp;     * class file transformer that is provided as an argument.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * In order to assure the correct handling of the {@link InstallationListener}, an uninstallation should be applied
&nbsp;     * via the {@link ResettableClassFileTransformer}&#39;s {@code reset} methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param classFileTransformer The class file transformer that is being patched.
&nbsp;     * @param patchMode            The patch mode to apply.
&nbsp;     * @return The installed class file transformer.
&nbsp;     * @see AgentBuilder#patchOn(Instrumentation, ResettableClassFileTransformer, PatchMode)
&nbsp;     */
&nbsp;    ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer, PatchMode patchMode);
&nbsp;
&nbsp;    /**
&nbsp;     * An abstraction for extending a matcher.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type that is produced by chaining a matcher.
&nbsp;     */
&nbsp;    interface Matchable&lt;T extends Matchable&lt;T&gt;&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if both the previous matcher and the supplied matcher are matched. When matching a
&nbsp;         * type, class loaders are not considered.
&nbsp;         *
&nbsp;         * @param typeMatcher A matcher for the type being matched.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T and(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if both the previous matcher and the supplied matcher are matched.
&nbsp;         *
&nbsp;         * @param typeMatcher        A matcher for the type being matched.
&nbsp;         * @param classLoaderMatcher A matcher for the type&#39;s class loader.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T and(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if both the previous matcher and the supplied matcher are matched.
&nbsp;         *
&nbsp;         * @param typeMatcher        A matcher for the type being matched.
&nbsp;         * @param classLoaderMatcher A matcher for the type&#39;s class loader.
&nbsp;         * @param moduleMatcher      A matcher for the type&#39;s module. On a JVM that does not support modules, the Java module is represented by {@code null}.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T and(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;              ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;              ElementMatcher&lt;? super JavaModule&gt; moduleMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if both the previous matcher and the supplied matcher are matched.
&nbsp;         *
&nbsp;         * @param rawMatcher A raw matcher for the type being matched.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T and(RawMatcher rawMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if the previous matcher or the supplied matcher are matched. When matching a
&nbsp;         * type, the class loader is not considered.
&nbsp;         *
&nbsp;         * @param typeMatcher A matcher for the type being matched.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T or(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if the previous matcher or the supplied matcher are matched.
&nbsp;         *
&nbsp;         * @param typeMatcher        A matcher for the type being matched.
&nbsp;         * @param classLoaderMatcher A matcher for the type&#39;s class loader.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T or(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if the previous matcher or the supplied matcher are matched.
&nbsp;         *
&nbsp;         * @param typeMatcher        A matcher for the type being matched.
&nbsp;         * @param classLoaderMatcher A matcher for the type&#39;s class loader.
&nbsp;         * @param moduleMatcher      A matcher for the type&#39;s module. On a JVM that does not support modules, the Java module is represented by {@code null}.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T or(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;             ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;             ElementMatcher&lt;? super JavaModule&gt; moduleMatcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a matching that is positive if the previous matcher or the supplied matcher are matched.
&nbsp;         *
&nbsp;         * @param rawMatcher A raw matcher for the type being matched.
&nbsp;         * @return A chained matcher.
&nbsp;         */
&nbsp;        T or(RawMatcher rawMatcher);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows to further specify ignored types.
&nbsp;     */
&nbsp;    interface Ignored extends Matchable&lt;Ignored&gt;, AgentBuilder {
&nbsp;        /* this is merely a unionizing interface that does not declare methods */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An agent builder configuration that allows the registration of listeners to the redefinition process.
&nbsp;     */
&nbsp;    interface RedefinitionListenable extends AgentBuilder {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A redefinition listener is invoked before each batch of type redefinitions and on every error as well as
&nbsp;         * after the redefinition was completed. A redefinition listener can be used for debugging or logging purposes
&nbsp;         * and to apply actions between each batch, e.g. to pause or wait in order to avoid rendering the current VM
&nbsp;         * non-responsive if a lot of classes are redefined.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Adding several listeners does not replace previous listeners but applies them in the registration order.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param redefinitionListener The listener to register.
&nbsp;         * @return A new instance of this agent builder which notifies the specified listener upon type redefinitions.
&nbsp;         */
&nbsp;        RedefinitionListenable with(RedefinitionStrategy.Listener redefinitionListener);
&nbsp;
&nbsp;        /**
&nbsp;         * Specifies resubmission for given unloaded types or types that fail upon an exception during instrumentation.
&nbsp;         *
&nbsp;         * @param resubmissionScheduler The resubmission scheduler to use.
&nbsp;         * @return A new builder to determine what types should be resubmitted given the supplied resubmission scheduler.
&nbsp;         */
&nbsp;        WithoutResubmissionSpecification withResubmission(RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler);
&nbsp;
&nbsp;        /**
&nbsp;         * A matcher that determines if types should be resubmitted if it is not yet loaded and if an exception is raised.
&nbsp;         */
&nbsp;        interface ResubmissionOnErrorMatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if a type should be resubmitted if it is not yet loaded and an exception occurs during instrumentation.
&nbsp;             *
&nbsp;             * @param throwable   The exception being raised.
&nbsp;             * @param typeName    The name of the instrumented type.
&nbsp;             * @param classLoader The class loader of the instrumented type or {@code null} if the type is loaded by the bootstrap class loader.
&nbsp;             * @param module      The module of the instrumented type or {@code null} if the current VM does not support modules.
&nbsp;             * @return {@code true} if the type should be resubmitted.
&nbsp;             */
&nbsp;            boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
&nbsp;
&nbsp;            /**
&nbsp;             * A trivial matcher for resubmission upon an exception.
&nbsp;             */
<b class="fc">&nbsp;            enum Trivial implements ResubmissionOnErrorMatcher {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Always matches a type.
&nbsp;                 */
<b class="fc">&nbsp;                MATCHING(true),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Never matches a type.
&nbsp;                 */
<b class="fc">&nbsp;                NON_MATCHING(false);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this matcher is matching.
&nbsp;                 */
&nbsp;                private final boolean matching;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new trivial matcher for a resubmission upon an exception.
&nbsp;                 *
&nbsp;                 * @param matching {@code true} if this matcher is matching.
&nbsp;                 */
<b class="fc">&nbsp;                Trivial(boolean matching) {</b>
<b class="fc">&nbsp;                    this.matching = matching;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return matching;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for resubmission upon an error that matches both of the supplied delegate matchers.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Conjunction implements ResubmissionOnErrorMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented matchers in their application order.
&nbsp;                 */
&nbsp;                private final List&lt;ResubmissionOnErrorMatcher&gt; matchers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new conjunction for a resubmission matcher upon an error.
&nbsp;                 *
&nbsp;                 * @param matcher The represented matchers in their application order.
&nbsp;                 */
&nbsp;                public Conjunction(ResubmissionOnErrorMatcher... matcher) {
<b class="fc">&nbsp;                    this(Arrays.asList(matcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new conjunction for a resubmission matcher upon an error.
&nbsp;                 *
&nbsp;                 * @param matchers The represented matchers in their application order.
&nbsp;                 */
<b class="fc">&nbsp;                public Conjunction(List&lt;? extends ResubmissionOnErrorMatcher&gt; matchers) {</b>
<b class="fc">&nbsp;                    this.matchers = new ArrayList&lt;ResubmissionOnErrorMatcher&gt;(matchers.size());</b>
<b class="fc">&nbsp;                    for (ResubmissionOnErrorMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (matcher instanceof Conjunction) {</b>
<b class="nc">&nbsp;                            this.matchers.addAll(((Conjunction) matcher).matchers);</b>
<b class="fc">&nbsp;                        } else if (matcher != Trivial.MATCHING) {</b>
<b class="fc">&nbsp;                            this.matchers.add(matcher);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    for (ResubmissionOnErrorMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (!matcher.matches(throwable, typeName, classLoader, module)) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for resubmission upon an error that matches either of the supplied delegate matchers.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Disjunction implements ResubmissionOnErrorMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented matchers in their application order.
&nbsp;                 */
&nbsp;                private final List&lt;ResubmissionOnErrorMatcher&gt; matchers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new disjunction for a resubmission matcher upon an error.
&nbsp;                 *
&nbsp;                 * @param matcher The represented matchers in their application order.
&nbsp;                 */
&nbsp;                public Disjunction(ResubmissionOnErrorMatcher... matcher) {
<b class="fc">&nbsp;                    this(Arrays.asList(matcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new conjunction for a resubmission matcher upon an error.
&nbsp;                 *
&nbsp;                 * @param matchers The represented matchers in their application order.
&nbsp;                 */
<b class="fc">&nbsp;                public Disjunction(List&lt;? extends ResubmissionOnErrorMatcher&gt; matchers) {</b>
<b class="fc">&nbsp;                    this.matchers = new ArrayList&lt;ResubmissionOnErrorMatcher&gt;(matchers.size());</b>
<b class="fc">&nbsp;                    for (ResubmissionOnErrorMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (matcher instanceof Disjunction) {</b>
<b class="nc">&nbsp;                            this.matchers.addAll(((Disjunction) matcher).matchers);</b>
<b class="fc">&nbsp;                        } else if (matcher != Trivial.NON_MATCHING) {</b>
<b class="fc">&nbsp;                            this.matchers.add(matcher);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    for (ResubmissionOnErrorMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (matcher.matches(throwable, typeName, classLoader, module)) {</b>
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for resubmission upon error that uses element matchers for each argument to determine a resubmission.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForElementMatchers implements ResubmissionOnErrorMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the exception that was caused.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super Throwable&gt; exceptionMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the instrumented type&#39;s name.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;String&gt; typeNameMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the instrumented type&#39;s class loader.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the instrumented type&#39;s module.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super JavaModule&gt; moduleMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new matcher for resubmission upon an exception that is using element matchers.
&nbsp;                 *
&nbsp;                 * @param exceptionMatcher   The matcher to use for the exception that was caused.
&nbsp;                 * @param typeNameMatcher    The matcher to use for the instrumented type&#39;s name.
&nbsp;                 * @param classLoaderMatcher The matcher to use for the instrumented type&#39;s class loader.
&nbsp;                 * @param moduleMatcher      The matcher to use for the instrumented type&#39;s module.
&nbsp;                 */
&nbsp;                public ForElementMatchers(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                          ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                          ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
<b class="fc">&nbsp;                                          ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {</b>
<b class="fc">&nbsp;                    this.exceptionMatcher = exceptionMatcher;</b>
<b class="fc">&nbsp;                    this.typeNameMatcher = typeNameMatcher;</b>
<b class="fc">&nbsp;                    this.classLoaderMatcher = classLoaderMatcher;</b>
<b class="fc">&nbsp;                    this.moduleMatcher = moduleMatcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(Throwable throwable, String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return exceptionMatcher.matches(throwable)</b>
<b class="fc">&nbsp;                            &amp;&amp; typeNameMatcher.matches(typeName)</b>
<b class="fc">&nbsp;                            &amp;&amp; classLoaderMatcher.matches(classLoader)</b>
<b class="fc">&nbsp;                            &amp;&amp; moduleMatcher.matches(module);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A matcher that determines if types should be resubmitted if it is not yet loaded.
&nbsp;         */
&nbsp;        interface ResubmissionImmediateMatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if a type should be resubmitted if it is not yet loaded.
&nbsp;             *
&nbsp;             * @param typeName    The name of the instrumented type.
&nbsp;             * @param classLoader The class loader of the instrumented type or {@code null} if the type is loaded by the bootstrap class loader.
&nbsp;             * @param module      The module of the instrumented type or {@code null} if the current VM does not support modules.
&nbsp;             * @return {@code true} if the type should be resubmitted.
&nbsp;             */
&nbsp;            boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
&nbsp;
&nbsp;            /**
&nbsp;             * A trivial matcher for immediate resubmission.
&nbsp;             */
<b class="fc">&nbsp;            enum Trivial implements ResubmissionImmediateMatcher {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Always matches a type.
&nbsp;                 */
<b class="fc">&nbsp;                MATCHING(true),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Never matches a type.
&nbsp;                 */
<b class="fc">&nbsp;                NON_MATCHING(false);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this matcher is matching.
&nbsp;                 */
&nbsp;                private final boolean matching;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new trivial matcher for immediate resubmission.
&nbsp;                 *
&nbsp;                 * @param matching {@code true} if this matcher is matching.
&nbsp;                 */
<b class="fc">&nbsp;                Trivial(boolean matching) {</b>
<b class="fc">&nbsp;                    this.matching = matching;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return matching;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for immediate resubmission that matches both of the supplied delegate matchers.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Conjunction implements ResubmissionImmediateMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matchers in their application order.
&nbsp;                 */
&nbsp;                private final List&lt;ResubmissionImmediateMatcher&gt; matchers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new conjunction for an immediate resubmission matcher.
&nbsp;                 *
&nbsp;                 * @param matcher The matchers in their application order.
&nbsp;                 */
&nbsp;                public Conjunction(ResubmissionImmediateMatcher... matcher) {
<b class="fc">&nbsp;                    this(Arrays.asList(matcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new conjunction for an immediate resubmission matcher.
&nbsp;                 *
&nbsp;                 * @param matchers The matchers in their application order.
&nbsp;                 */
<b class="fc">&nbsp;                public Conjunction(List&lt;? extends ResubmissionImmediateMatcher&gt; matchers) {</b>
<b class="fc">&nbsp;                    this.matchers = new ArrayList&lt;ResubmissionImmediateMatcher&gt;(matchers.size());</b>
<b class="fc">&nbsp;                    for (ResubmissionImmediateMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (matcher instanceof Conjunction) {</b>
<b class="nc">&nbsp;                            this.matchers.addAll(((Conjunction) matcher).matchers);</b>
<b class="fc">&nbsp;                        } else if (matcher != Trivial.NON_MATCHING) {</b>
<b class="fc">&nbsp;                            this.matchers.add(matcher);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    for (ResubmissionImmediateMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (!matcher.matches(typeName, classLoader, module)) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for immediate resubmission that matches either of the supplied delegate matchers.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Disjunction implements ResubmissionImmediateMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matchers in their application order.
&nbsp;                 */
&nbsp;                private final List&lt;ResubmissionImmediateMatcher&gt; matchers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new conjunction for an immediate resubmission matcher.
&nbsp;                 *
&nbsp;                 * @param matcher The matchers in their application order.
&nbsp;                 */
&nbsp;                public Disjunction(ResubmissionImmediateMatcher... matcher) {
<b class="fc">&nbsp;                    this(Arrays.asList(matcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new disjunction for an immediate resubmission matcher.
&nbsp;                 *
&nbsp;                 * @param matchers The matchers in their application order.
&nbsp;                 */
<b class="fc">&nbsp;                public Disjunction(List&lt;? extends ResubmissionImmediateMatcher&gt; matchers) {</b>
<b class="fc">&nbsp;                    this.matchers = new ArrayList&lt;ResubmissionImmediateMatcher&gt;(matchers.size());</b>
<b class="fc">&nbsp;                    for (ResubmissionImmediateMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (matcher instanceof Disjunction) {</b>
<b class="nc">&nbsp;                            this.matchers.addAll(((Disjunction) matcher).matchers);</b>
<b class="fc">&nbsp;                        } else if (matcher != Trivial.NON_MATCHING) {</b>
<b class="fc">&nbsp;                            this.matchers.add(matcher);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    for (ResubmissionImmediateMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                        if (matcher.matches(typeName, classLoader, module)) {</b>
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for immediate resubmission that uses element matchers for each argument to determine a resubmission.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForElementMatchers implements ResubmissionImmediateMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the instrumented type&#39;s name.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;String&gt; typeNameMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the instrumented type&#39;s class loader.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to use for the instrumented type&#39;s module.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super JavaModule&gt; moduleMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new matcher for immediate resubmission that is using element matchers.
&nbsp;                 *
&nbsp;                 * @param typeNameMatcher    The matcher to use for the instrumented type&#39;s name.
&nbsp;                 * @param classLoaderMatcher The matcher to use for the instrumented type&#39;s class loader.
&nbsp;                 * @param moduleMatcher      The matcher to use for the instrumented type&#39;s module.
&nbsp;                 */
&nbsp;                public ForElementMatchers(ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                          ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
<b class="fc">&nbsp;                                          ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {</b>
<b class="fc">&nbsp;                    this.typeNameMatcher = typeNameMatcher;</b>
<b class="fc">&nbsp;                    this.classLoaderMatcher = classLoaderMatcher;</b>
<b class="fc">&nbsp;                    this.moduleMatcher = moduleMatcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return typeNameMatcher.matches(typeName)</b>
<b class="fc">&nbsp;                            &amp;&amp; classLoaderMatcher.matches(classLoader)</b>
<b class="fc">&nbsp;                            &amp;&amp; moduleMatcher.matches(module);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An {@link AgentBuilder} specification that requires a resubmission specification.
&nbsp;         */
&nbsp;        interface WithoutResubmissionSpecification {
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types that yield an error are resubmitted as transformation of the
&nbsp;             * loaded type.
&nbsp;             *
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitOnError();
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types that yield an error are resubmitted as transformation of the
&nbsp;             * loaded type, given that the specified matcher matches the type in question.
&nbsp;             *
&nbsp;             * @param exceptionMatcher Determines if a type should be resubmitted upon a given exception.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types that yield an error are resubmitted as transformation of the
&nbsp;             * loaded type, given that the specified matchers match the type in question.
&nbsp;             *
&nbsp;             * @param exceptionMatcher Determines if a type should be resubmitted upon a given exception.
&nbsp;             * @param typeNameMatcher  Determines if a type should be resubmitted if the type has a given name.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                                          ElementMatcher&lt;String&gt; typeNameMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types that yield an error are resubmitted as transformation of the
&nbsp;             * loaded type, given that the specified matchers match the type in question.
&nbsp;             *
&nbsp;             * @param exceptionMatcher   Determines if a type should be resubmitted upon a given exception.
&nbsp;             * @param typeNameMatcher    Determines if a type should be resubmitted if the type has a given name.
&nbsp;             * @param classLoaderMatcher Determines if a type should be resubmitted upon being loaded by a given class loader.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                                          ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                          ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types that yield an error are resubmitted as transformation of the
&nbsp;             * loaded type, given that the specified matchers match the type in question.
&nbsp;             *
&nbsp;             * @param exceptionMatcher   Determines if a type should be resubmitted upon a given exception.
&nbsp;             * @param typeNameMatcher    Determines if a type should be resubmitted if the type has a given name.
&nbsp;             * @param classLoaderMatcher Determines if a type should be resubmitted upon being loaded by a given class loader.
&nbsp;             * @param moduleMatcher      Determines if a type should be resubmitted upon a given Java module.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                                          ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                          ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                                          ElementMatcher&lt;? super JavaModule&gt; moduleMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types that yield an error are resubmitted as transformation of the
&nbsp;             * loaded type, given that the specified matcher matches the type in question.
&nbsp;             *
&nbsp;             * @param matcher Determines if a type should be resubmitted.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitOnError(ResubmissionOnErrorMatcher matcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types should not be transformed when they are loaded for the first
&nbsp;             * time but should rather be resubmitted after they are loaded.
&nbsp;             *
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitImmediate();
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types should not be transformed when they are loaded for the first
&nbsp;             * time but should rather be resubmitted after they are loaded.
&nbsp;             *
&nbsp;             * @param typeNameMatcher Determines if a type should be resubmitted if the type has a given name.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitImmediate(ElementMatcher&lt;String&gt; typeNameMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types should not be transformed when they are loaded for the first
&nbsp;             * time but should rather be resubmitted after they are loaded.
&nbsp;             *
&nbsp;             * @param typeNameMatcher    Determines if a type should be resubmitted if the type has a given name.
&nbsp;             * @param classLoaderMatcher Determines if a type should be resubmitted upon being loaded by a given class loader.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitImmediate(ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                            ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types should not be transformed when they are loaded for the first
&nbsp;             * time but should rather be resubmitted after they are loaded.
&nbsp;             *
&nbsp;             * @param typeNameMatcher    Determines if a type should be resubmitted if the type has a given name.
&nbsp;             * @param classLoaderMatcher Determines if a type should be resubmitted upon being loaded by a given class loader.
&nbsp;             * @param moduleMatcher      Determines if a type should be resubmitted upon a given Java module.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitImmediate(ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                            ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                                            ElementMatcher&lt;? super JavaModule&gt; moduleMatcher);
&nbsp;
&nbsp;            /**
&nbsp;             * Specifies that transformations of unloaded types should not be transformed when they are loaded for the first
&nbsp;             * time but should rather be resubmitted after they are loaded.
&nbsp;             *
&nbsp;             * @param matcher Determines if a type should be resubmitted.
&nbsp;             * @return A new agent builder that allows for further resubmission specifications.
&nbsp;             */
&nbsp;            WithResubmissionSpecification resubmitImmediate(ResubmissionImmediateMatcher matcher);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A complete but extendable resubmission specification.
&nbsp;         */
&nbsp;        interface WithResubmissionSpecification extends WithoutResubmissionSpecification, AgentBuilder {
&nbsp;            /* union type */
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An agent builder configuration strategy that allows the definition of a discovery strategy.
&nbsp;         */
&nbsp;        interface WithImplicitDiscoveryStrategy extends RedefinitionListenable {
&nbsp;
&nbsp;            /**
&nbsp;             * Limits the redefinition attempt to the specified types.
&nbsp;             *
&nbsp;             * @param type The types to consider for redefinition.
&nbsp;             * @return A new instance of this agent builder which only considers the supplied types for redefinition.
&nbsp;             */
&nbsp;            RedefinitionListenable redefineOnly(Class&lt;?&gt;... type);
&nbsp;
&nbsp;            /**
&nbsp;             * A discovery strategy is responsible for locating loaded types that should be considered for redefinition.
&nbsp;             *
&nbsp;             * @param redefinitionDiscoveryStrategy The redefinition discovery strategy to use.
&nbsp;             * @return A new instance of this agent builder which makes use of the specified discovery strategy.
&nbsp;             */
&nbsp;            RedefinitionListenable with(RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An agent builder configuration that allows the configuration of a batching strategy.
&nbsp;         */
&nbsp;        interface WithoutBatchStrategy extends WithImplicitDiscoveryStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * A batch allocator is responsible for diving a redefining of existing types into several chunks. This allows
&nbsp;             * to narrow down errors for the redefining of specific types or to apply a {@link RedefinitionStrategy.Listener}
&nbsp;             * action between chunks.
&nbsp;             *
&nbsp;             * @param redefinitionBatchAllocator The batch allocator to use.
&nbsp;             * @return A new instance of this agent builder which makes use of the specified batch allocator.
&nbsp;             */
&nbsp;            WithImplicitDiscoveryStrategy with(RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Describes an {@link net.bytebuddy.agent.builder.AgentBuilder} which was handed a matcher for identifying
&nbsp;     * types to instrumented in order to supply one or several
&nbsp;     * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s.
&nbsp;     */
&nbsp;    interface Identified {
&nbsp;
&nbsp;        /**
&nbsp;         * Applies the given transformer for the already supplied matcher.
&nbsp;         *
&nbsp;         * @param transformer The transformer to apply.
&nbsp;         * @return A new instance of this agent builder with the transformer being applied when the previously supplied matcher
&nbsp;         * identified a type for instrumentation which also allows for the registration of subsequent transformers.
&nbsp;         */
&nbsp;        Extendable transform(Transformer transformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Allows to specify a type matcher for a type to instrument.
&nbsp;         */
&nbsp;        interface Narrowable extends Matchable&lt;Narrowable&gt;, Identified {
&nbsp;            /* this is merely a unionizing interface that does not declare methods */
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * This interface is used to allow for optionally providing several
&nbsp;         * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer} to applied when a matcher identifies a type
&nbsp;         * to be instrumented. Any subsequent transformers are applied in the order they are registered.
&nbsp;         */
&nbsp;        interface Extendable extends AgentBuilder, Identified {
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the previously defined transformation as terminal such that no subsequent transformers are applied even
&nbsp;             * if their matchers would include the type that was matched for applying this transformer. If this option is not set,
&nbsp;             * subsequent transformations are applied after this transformation such that it is possible that they override non-additive
&nbsp;             * type transformations.
&nbsp;             *
&nbsp;             * @return A new agent builder that applies the previously configured transformer terminally.
&nbsp;             */
&nbsp;            AgentBuilder asTerminalTransformation();
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A matcher that allows to determine if a {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}
&nbsp;     * should be applied during the execution of a {@link java.lang.instrument.ClassFileTransformer} that was
&nbsp;     * generated by an {@link net.bytebuddy.agent.builder.AgentBuilder}.
&nbsp;     */
&nbsp;    interface RawMatcher {
&nbsp;
&nbsp;        /**
&nbsp;         * Decides if the given {@code typeDescription} should be instrumented with the entailed
&nbsp;         * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s.
&nbsp;         *
&nbsp;         * @param typeDescription     A description of the type to be instrumented.
&nbsp;         * @param classLoader         The class loader of the instrumented type. Might be {@code null} if this class
&nbsp;         *                            loader represents the bootstrap class loader.
&nbsp;         * @param module              The transformed type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param classBeingRedefined The class being redefined which is only not {@code null} if a retransformation
&nbsp;         *                            is applied.
&nbsp;         * @param protectionDomain    The protection domain of the type being transformed or {@code null} if none is available.
&nbsp;         * @return {@code true} if the entailed {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s should
&nbsp;         * be applied for the given {@code typeDescription}.
&nbsp;         */
&nbsp;        boolean matches(TypeDescription typeDescription,
&nbsp;                        @MaybeNull ClassLoader classLoader,
&nbsp;                        @MaybeNull JavaModule module,
&nbsp;                        @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                        @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;        /**
&nbsp;         * A matcher that always or never matches a type.
&nbsp;         */
<b class="fc">&nbsp;        enum Trivial implements RawMatcher {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Always matches a type.
&nbsp;             */
<b class="fc">&nbsp;            MATCHING(true),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Never matches a type.
&nbsp;             */
<b class="fc">&nbsp;            NON_MATCHING(false);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this matcher always matches a type.
&nbsp;             */
&nbsp;            private final boolean matches;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new trivial raw matcher.
&nbsp;             *
&nbsp;             * @param matches {@code true} if this matcher always matches a type.
&nbsp;             */
<b class="fc">&nbsp;            Trivial(boolean matches) {</b>
<b class="fc">&nbsp;                this.matches = matches;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return matches;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A raw matcher indicating the state of a type&#39;s class loading.
&nbsp;         */
<b class="fc">&nbsp;        enum ForLoadState implements RawMatcher {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a type was already loaded.
&nbsp;             */
<b class="fc">&nbsp;            LOADED(false),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a type was not yet loaded.
&nbsp;             */
<b class="fc">&nbsp;            UNLOADED(true);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if a type is expected to be unloaded..
&nbsp;             */
&nbsp;            private final boolean unloaded;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new load state matcher.
&nbsp;             *
&nbsp;             * @param unloaded {@code true} if a type is expected to be unloaded..
&nbsp;             */
<b class="fc">&nbsp;            ForLoadState(boolean unloaded) {</b>
<b class="fc">&nbsp;                this.unloaded = unloaded;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return classBeingRedefined == null == unloaded;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Only matches loaded types that can be fully resolved. Types with missing dependencies might not be
&nbsp;         * resolvable and can therefore trigger errors during redefinition.
&nbsp;         */
<b class="fc">&nbsp;        enum ForResolvableTypes implements RawMatcher {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                if (classBeingRedefined != null) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return Class.forName(classBeingRedefined.getName(), true, classLoader) == classBeingRedefined;</b>
<b class="fc">&nbsp;                    } catch (Throwable ignored) {</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns an inverted version of this matcher.
&nbsp;             *
&nbsp;             * @return An inverted version of this matcher.
&nbsp;             */
&nbsp;            public RawMatcher inverted() {
<b class="nc">&nbsp;                return new Inversion(this);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A conjunction of two raw matchers.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Conjunction implements RawMatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The matchers to apply in their application order.
&nbsp;             */
&nbsp;            private final List&lt;RawMatcher&gt; matchers;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new conjunction of two raw matchers.
&nbsp;             *
&nbsp;             * @param matcher The matchers to apply in their application order.
&nbsp;             */
&nbsp;            protected Conjunction(RawMatcher... matcher) {
<b class="fc">&nbsp;                this(Arrays.asList(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new conjunction of two raw matchers.
&nbsp;             *
&nbsp;             * @param matchers The matchers to apply in their application order.
&nbsp;             */
<b class="fc">&nbsp;            protected Conjunction(List&lt;? extends RawMatcher&gt; matchers) {</b>
<b class="fc">&nbsp;                this.matchers = new ArrayList&lt;RawMatcher&gt;(matchers.size());</b>
<b class="fc">&nbsp;                for (RawMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                    if (matcher instanceof Conjunction) {</b>
<b class="nc">&nbsp;                        this.matchers.addAll(((Conjunction) matcher).matchers);</b>
<b class="fc">&nbsp;                    } else if (matcher != Trivial.MATCHING) {</b>
<b class="fc">&nbsp;                        this.matchers.add(matcher);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                for (RawMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                    if (!matcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A disjunction of two raw matchers.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Disjunction implements RawMatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The matchers to apply in their application order.
&nbsp;             */
&nbsp;            private final List&lt;RawMatcher&gt; matchers;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new conjunction of two raw matchers.
&nbsp;             *
&nbsp;             * @param matcher The matchers to apply in their application order.
&nbsp;             */
&nbsp;            protected Disjunction(RawMatcher... matcher) {
<b class="fc">&nbsp;                this(Arrays.asList(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new conjunction of two raw matchers.
&nbsp;             *
&nbsp;             * @param matchers The matchers to apply in their application order.
&nbsp;             */
<b class="fc">&nbsp;            protected Disjunction(List&lt;? extends RawMatcher&gt; matchers) {</b>
<b class="fc">&nbsp;                this.matchers = new ArrayList&lt;RawMatcher&gt;(matchers.size());</b>
<b class="fc">&nbsp;                for (RawMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                    if (matcher instanceof Disjunction) {</b>
<b class="nc">&nbsp;                        this.matchers.addAll(((Disjunction) matcher).matchers);</b>
<b class="fc">&nbsp;                    } else if (matcher != Trivial.NON_MATCHING) {</b>
<b class="fc">&nbsp;                        this.matchers.add(matcher);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                for (RawMatcher matcher : matchers) {</b>
<b class="fc">&nbsp;                    if (matcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A raw matcher that inverts a raw matcher&#39;s result.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Inversion implements RawMatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to invert.
&nbsp;             */
&nbsp;            private final RawMatcher matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw matcher that inverts its result.
&nbsp;             *
&nbsp;             * @param matcher The matcher to invert.
&nbsp;             */
<b class="fc">&nbsp;            public Inversion(RawMatcher matcher) {</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return !matcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A raw matcher implementation that checks a {@link TypeDescription}
&nbsp;         * and its {@link java.lang.ClassLoader} against two suitable matchers in order to determine if the matched
&nbsp;         * type should be instrumented.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForElementMatchers implements RawMatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * The type matcher to apply to a {@link TypeDescription}.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super TypeDescription&gt; typeMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader matcher to apply to a {@link java.lang.ClassLoader}.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * A module matcher to apply to a {@code java.lang.Module}.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super JavaModule&gt; moduleMatcher;
&nbsp;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new {@link net.bytebuddy.agent.builder.AgentBuilder.RawMatcher} that only matches the
&nbsp;             * supplied {@link TypeDescription} against a supplied matcher.
&nbsp;             *
&nbsp;             * @param typeMatcher The type matcher to apply to a {@link TypeDescription}.
&nbsp;             */
&nbsp;            public ForElementMatchers(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="fc">&nbsp;                this(typeMatcher, any());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new {@link net.bytebuddy.agent.builder.AgentBuilder.RawMatcher} that only matches the
&nbsp;             * supplied {@link TypeDescription} and its {@link java.lang.ClassLoader} against two matcher in order
&nbsp;             * to decided if an instrumentation should be conducted.
&nbsp;             *
&nbsp;             * @param typeMatcher        The type matcher to apply to a {@link TypeDescription}.
&nbsp;             * @param classLoaderMatcher The class loader matcher to apply to a {@link java.lang.ClassLoader}.
&nbsp;             */
&nbsp;            public ForElementMatchers(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                                      ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="fc">&nbsp;                this(typeMatcher, classLoaderMatcher, any());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new {@link net.bytebuddy.agent.builder.AgentBuilder.RawMatcher} that only matches the
&nbsp;             * supplied {@link TypeDescription}, its {@link java.lang.ClassLoader} and module against element
&nbsp;             * suitable matchers.
&nbsp;             *
&nbsp;             * @param typeMatcher        The type matcher to apply to a {@link TypeDescription}.
&nbsp;             * @param classLoaderMatcher The class loader matcher to apply to a {@link java.lang.ClassLoader}.
&nbsp;             * @param moduleMatcher      A module matcher to apply to a {@code java.lang.Module}.
&nbsp;             */
&nbsp;            public ForElementMatchers(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                                      ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
<b class="fc">&nbsp;                                      ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {</b>
<b class="fc">&nbsp;                this.typeMatcher = typeMatcher;</b>
<b class="fc">&nbsp;                this.classLoaderMatcher = classLoaderMatcher;</b>
<b class="fc">&nbsp;                this.moduleMatcher = moduleMatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean matches(TypeDescription typeDescription,
&nbsp;                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                   @MaybeNull JavaModule module,
&nbsp;                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                   @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return moduleMatcher.matches(module) &amp;&amp; classLoaderMatcher.matches(classLoader) &amp;&amp; typeMatcher.matches(typeDescription);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A listener that is informed about events that occur during an instrumentation process.
&nbsp;     */
&nbsp;    interface Listener {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a transformed type is loaded.
&nbsp;         */
&nbsp;        boolean LOADED = true;
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked upon a type being supplied to a transformer.
&nbsp;         *
&nbsp;         * @param typeName    The binary name of the instrumented type.
&nbsp;         * @param classLoader The class loader which is loading this type or {@code null} if loaded by the boots loader.
&nbsp;         * @param module      The instrumented type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param loaded      {@code true} if the type is already loaded.
&nbsp;         */
&nbsp;        void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked prior to a successful transformation being applied.
&nbsp;         *
&nbsp;         * @param typeDescription The type that is being transformed.
&nbsp;         * @param classLoader     The class loader which is loading this type or {@code null} if loaded by the boots loader.
&nbsp;         * @param module          The transformed type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param loaded          {@code true} if the type is already loaded.
&nbsp;         * @param dynamicType     The dynamic type that was created.
&nbsp;         */
&nbsp;        void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked when a type is not transformed but ignored.
&nbsp;         *
&nbsp;         * @param typeDescription The type being ignored for transformation.
&nbsp;         * @param classLoader     The class loader which is loading this type or {@code null} if loaded by the boots loader.
&nbsp;         * @param module          The ignored type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param loaded          {@code true} if the type is already loaded.
&nbsp;         */
&nbsp;        void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked when an error has occurred during transformation.
&nbsp;         *
&nbsp;         * @param typeName    The binary name of the instrumented type.
&nbsp;         * @param classLoader The class loader which is loading this type or {@code null} if loaded by the boots loader.
&nbsp;         * @param module      The instrumented type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param loaded      {@code true} if the type is already loaded.
&nbsp;         * @param throwable   The occurred error.
&nbsp;         */
&nbsp;        void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked after a class was attempted to be loaded, independently of its treatment.
&nbsp;         *
&nbsp;         * @param typeName    The binary name of the instrumented type.
&nbsp;         * @param classLoader The class loader which is loading this type or {@code null} if loaded by the boots loader.
&nbsp;         * @param module      The instrumented type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param loaded      {@code true} if the type is already loaded.
&nbsp;         */
&nbsp;        void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded);
&nbsp;
&nbsp;        /**
&nbsp;         * A no-op implementation of a {@link net.bytebuddy.agent.builder.AgentBuilder.Listener}.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements Listener {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An adapter for a listener where all methods are implemented as non-operational.
&nbsp;         */
<b class="fc">&nbsp;        abstract class Adapter implements Listener {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that writes events to a {@link PrintStream}. This listener prints a line per event, including the event type and
&nbsp;         * the name of the type in question.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class StreamWriting implements Listener {
&nbsp;
&nbsp;            /**
&nbsp;             * The prefix that is appended to all written messages.
&nbsp;             */
&nbsp;            protected static final String PREFIX = &quot;[Byte Buddy]&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The print stream written to.
&nbsp;             */
&nbsp;            private final PrintStream printStream;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new stream writing listener.
&nbsp;             *
&nbsp;             * @param printStream The print stream written to.
&nbsp;             */
<b class="fc">&nbsp;            public StreamWriting(PrintStream printStream) {</b>
<b class="fc">&nbsp;                this.printStream = printStream;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new stream writing listener that writes to {@link System#out}.
&nbsp;             *
&nbsp;             * @return A listener writing events to the standard output stream.
&nbsp;             */
&nbsp;            public static StreamWriting toSystemOut() {
<b class="fc">&nbsp;                return new StreamWriting(System.out);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new stream writing listener that writes to {@link System#err}.
&nbsp;             *
&nbsp;             * @return A listener writing events to the standard error stream.
&nbsp;             */
&nbsp;            public static StreamWriting toSystemError() {
<b class="fc">&nbsp;                return new StreamWriting(System.err);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a version of this listener that only reports successfully transformed classes and failed transformations.
&nbsp;             *
&nbsp;             * @return A version of this listener that only reports successfully transformed classes and failed transformations.
&nbsp;             */
&nbsp;            public Listener withTransformationsOnly() {
<b class="fc">&nbsp;                return new WithTransformationsOnly(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a version of this listener that only reports failed transformations.
&nbsp;             *
&nbsp;             * @return A version of this listener that only reports failed transformations.
&nbsp;             */
&nbsp;            public Listener withErrorsOnly() {
<b class="fc">&nbsp;                return new WithErrorsOnly(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; DISCOVERY %s [%s, %s, %s, loaded=%b]%n&quot;, typeName, classLoader, module, Thread.currentThread(), loaded);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; TRANSFORM %s [%s, %s, %s, loaded=%b]%n&quot;, typeDescription.getName(), classLoader, module, Thread.currentThread(), loaded);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; IGNORE %s [%s, %s, %s, loaded=%b]%n&quot;, typeDescription.getName(), classLoader, module, Thread.currentThread(), loaded);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
<b class="fc">&nbsp;                synchronized (printStream) {</b>
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; ERROR %s [%s, %s, %s, loaded=%b]%n&quot;, typeName, classLoader, module, Thread.currentThread(), loaded);</b>
<b class="fc">&nbsp;                    throwable.printStackTrace(printStream);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; COMPLETE %s [%s, %s, %s, loaded=%b]%n&quot;, typeName, classLoader, module, Thread.currentThread(), loaded);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that filters types with a given name from being logged.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Filtering implements Listener {
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to decide upon a type should be logged.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super String&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate listener.
&nbsp;             */
&nbsp;            private final Listener delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new filtering listener.
&nbsp;             *
&nbsp;             * @param matcher  The matcher to decide upon a type should be logged.
&nbsp;             * @param delegate The delegate listener.
&nbsp;             */
<b class="fc">&nbsp;            public Filtering(ElementMatcher&lt;? super String&gt; matcher, Listener delegate) {</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                if (matcher.matches(typeName)) {</b>
<b class="fc">&nbsp;                    delegate.onDiscovery(typeName, classLoader, module, loaded);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
<b class="fc">&nbsp;                if (matcher.matches(typeDescription.getName())) {</b>
<b class="fc">&nbsp;                    delegate.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                if (matcher.matches(typeDescription.getName())) {</b>
<b class="fc">&nbsp;                    delegate.onIgnored(typeDescription, classLoader, module, loaded);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
<b class="fc">&nbsp;                if (matcher.matches(typeName)) {</b>
<b class="fc">&nbsp;                    delegate.onError(typeName, classLoader, module, loaded, throwable);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                if (matcher.matches(typeName)) {</b>
<b class="fc">&nbsp;                    delegate.onComplete(typeName, classLoader, module, loaded);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that only delegates events if they are successful or failed transformations.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class WithTransformationsOnly extends Adapter {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate listener.
&nbsp;             */
&nbsp;            private final Listener delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new listener that only delegates events if they are successful or failed transformations.
&nbsp;             *
&nbsp;             * @param delegate The delegate listener.
&nbsp;             */
<b class="fc">&nbsp;            public WithTransformationsOnly(Listener delegate) {</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
<b class="fc">&nbsp;                delegate.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
<b class="fc">&nbsp;                delegate.onError(typeName, classLoader, module, loaded, throwable);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that only delegates events if they are failed transformations.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class WithErrorsOnly extends Adapter {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate listener.
&nbsp;             */
&nbsp;            private final Listener delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new listener that only delegates events if they are failed transformations.
&nbsp;             *
&nbsp;             * @param delegate The delegate listener.
&nbsp;             */
<b class="fc">&nbsp;            public WithErrorsOnly(Listener delegate) {</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
<b class="fc">&nbsp;                delegate.onError(typeName, classLoader, module, loaded, throwable);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that adds read-edges to any module of an instrumented class upon its transformation and opens the class&#39;s package to the module.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ModuleReadEdgeCompleting extends Adapter {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumentation instance used for adding read edges.
&nbsp;             */
&nbsp;            private final Instrumentation instrumentation;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the listener should also add a read-edge from the supplied modules to the instrumented type&#39;s module.
&nbsp;             * This will also ensure that the package of the instrumented type is exported to the target module.
&nbsp;             */
&nbsp;            private final boolean addTargetEdge;
&nbsp;
&nbsp;            /**
&nbsp;             * The modules to add as a read edge to any transformed class&#39;s module.
&nbsp;             */
&nbsp;            private final Set&lt;? extends JavaModule&gt; modules;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new module read-edge completing listener.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance used for adding read edges.
&nbsp;             * @param addTargetEdge   {@code true} if the listener should also add a read-edge from the supplied
&nbsp;             *                        modules to the instrumented type&#39;s module. This will also ensure that the package
&nbsp;             *                        of the instrumented type is exported to the target module.
&nbsp;             * @param modules         The modules to add as a read edge to any transformed class&#39;s module.
&nbsp;             */
<b class="fc">&nbsp;            public ModuleReadEdgeCompleting(Instrumentation instrumentation, boolean addTargetEdge, Set&lt;? extends JavaModule&gt; modules) {</b>
<b class="fc">&nbsp;                this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;                this.addTargetEdge = addTargetEdge;</b>
<b class="fc">&nbsp;                this.modules = modules;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a listener that adds module edges from and to the instrumented type&#39;s module.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance used for adding read edges.
&nbsp;             * @param addTargetEdge   {@code true} if the listener should also add a read-edge from the supplied
&nbsp;             *                        modules to the instrumented type&#39;s module. This will also ensure that the package
&nbsp;             *                        of the instrumented type is exported to the target module.
&nbsp;             * @param type            The types for which to extract the modules.
&nbsp;             * @return An appropriate listener.
&nbsp;             */
&nbsp;            public static Listener of(Instrumentation instrumentation, boolean addTargetEdge, Class&lt;?&gt;... type) {
<b class="nc">&nbsp;                Set&lt;JavaModule&gt; modules = new HashSet&lt;JavaModule&gt;();</b>
<b class="nc">&nbsp;                for (Class&lt;?&gt; aType : type) {</b>
<b class="nc">&nbsp;                    modules.add(JavaModule.ofType(aType));</b>
&nbsp;                }
<b class="nc">&nbsp;                return modules.isEmpty()</b>
<b class="nc">&nbsp;                        ? Listener.NoOp.INSTANCE</b>
<b class="nc">&nbsp;                        : new Listener.ModuleReadEdgeCompleting(instrumentation, addTargetEdge, modules);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
<b class="fc">&nbsp;                if (module != JavaModule.UNSUPPORTED &amp;&amp; module.isNamed()) {</b>
<b class="fc">&nbsp;                    for (JavaModule target : modules) {</b>
<b class="fc">&nbsp;                        if (!module.canRead(target) || addTargetEdge &amp;&amp; !module.isOpened(typeDescription.getPackage(), target)) {</b>
<b class="fc">&nbsp;                            PackageDescription location = typeDescription.getPackage();</b>
<b class="fc">&nbsp;                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation,</b>
&nbsp;                                    module,
<b class="fc">&nbsp;                                    Collections.singleton(target),</b>
<b class="fc">&nbsp;                                    Collections.&lt;String, Set&lt;JavaModule&gt;&gt;emptyMap(),</b>
<b class="fc">&nbsp;                                    !addTargetEdge || location == null || location.isDefault()</b>
<b class="fc">&nbsp;                                            ? Collections.&lt;String, Set&lt;JavaModule&gt;&gt;emptyMap()</b>
<b class="nc">&nbsp;                                            : Collections.singletonMap(location.getName(), Collections.singleton(target)),</b>
<b class="fc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;&gt;emptySet(),</b>
<b class="fc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt;emptyMap());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if (addTargetEdge &amp;&amp; !target.canRead(module)) {</b>
<b class="fc">&nbsp;                            ClassInjector.UsingInstrumentation.redefineModule(instrumentation,</b>
&nbsp;                                    target,
<b class="fc">&nbsp;                                    Collections.singleton(module),</b>
<b class="fc">&nbsp;                                    Collections.&lt;String, Set&lt;JavaModule&gt;&gt;emptyMap(),</b>
<b class="fc">&nbsp;                                    Collections.&lt;String, Set&lt;JavaModule&gt;&gt;emptyMap(),</b>
<b class="fc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;&gt;emptySet(),</b>
<b class="fc">&nbsp;                                    Collections.&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt;emptyMap());</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound listener that allows to group several listeners in one instance.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Compound implements Listener {
&nbsp;
&nbsp;            /**
&nbsp;             * The listeners that are represented by this compound listener in their application order.
&nbsp;             */
&nbsp;            private final List&lt;Listener&gt; listeners;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound listener.
&nbsp;             *
&nbsp;             * @param listener The listeners to apply in their application order.
&nbsp;             */
&nbsp;            public Compound(Listener... listener) {
<b class="fc">&nbsp;                this(Arrays.asList(listener));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound listener.
&nbsp;             *
&nbsp;             * @param listeners The listeners to apply in their application order.
&nbsp;             */
<b class="fc">&nbsp;            public Compound(List&lt;? extends Listener&gt; listeners) {</b>
<b class="fc">&nbsp;                this.listeners = new ArrayList&lt;Listener&gt;();</b>
<b class="fc">&nbsp;                for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                    if (listener instanceof Compound) {</b>
<b class="nc">&nbsp;                        this.listeners.addAll(((Compound) listener).listeners);</b>
<b class="fc">&nbsp;                    } else if (!(listener instanceof NoOp)) {</b>
<b class="fc">&nbsp;                        this.listeners.add(listener);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onDiscovery(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                    listener.onDiscovery(typeName, classLoader, module, loaded);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onTransformation(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, DynamicType dynamicType) {
<b class="fc">&nbsp;                for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                    listener.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onIgnored(TypeDescription typeDescription, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                    listener.onIgnored(typeDescription, classLoader, module, loaded);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
<b class="fc">&nbsp;                for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                    listener.onError(typeName, classLoader, module, loaded, throwable);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onComplete(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded) {
<b class="fc">&nbsp;                for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                    listener.onComplete(typeName, classLoader, module, loaded);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A circularity lock is responsible for preventing that a {@link ClassFileLocator} is used recursively.
&nbsp;     * This can happen when a class file transformation causes another class to be loaded. Without avoiding
&nbsp;     * such circularities, a class loading is aborted by a {@link ClassCircularityError} which causes the
&nbsp;     * class loading to fail.
&nbsp;     */
&nbsp;    interface CircularityLock {
&nbsp;
&nbsp;        /**
&nbsp;         * Attempts to acquire a circularity lock.
&nbsp;         *
&nbsp;         * @return {@code true} if the lock was acquired successfully, {@code false} if it is already hold.
&nbsp;         */
&nbsp;        boolean acquire();
&nbsp;
&nbsp;        /**
&nbsp;         * Releases the circularity lock if it is currently acquired.
&nbsp;         */
&nbsp;        void release();
&nbsp;
&nbsp;        /**
&nbsp;         * An inactive circularity lock which is always acquirable.
&nbsp;         */
<b class="fc">&nbsp;        enum Inactive implements CircularityLock {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean acquire() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void release() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of a circularity lock. Since class loading already synchronizes on a class loader,
&nbsp;         * it suffices to apply a thread-local lock.
&nbsp;         */
<b class="fc">&nbsp;        class Default implements CircularityLock {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A map of threads to an unused boolean to emulate a thread-local state without using
&nbsp;             * thread locals. This avoids using thread-local maps and does not interfere with Java
&nbsp;             * fibers in case that an instrumentation is executed from a virtual thread where thread
&nbsp;             * locals are not permitted.
&nbsp;             */
<b class="fc">&nbsp;            private final ConcurrentMap&lt;Thread, Boolean&gt; threads = new ConcurrentHashMap&lt;Thread, Boolean&gt;();</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean acquire() {
<b class="fc">&nbsp;                return threads.putIfAbsent(Thread.currentThread(), true) == null;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void release() {
<b class="fc">&nbsp;                threads.remove(Thread.currentThread());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the current thread is currently locked.
&nbsp;             *
&nbsp;             * @return {@code true} if the current thread is currently locked.
&nbsp;             */
&nbsp;            protected boolean isLocked() {
<b class="fc">&nbsp;                return threads.containsKey(Thread.currentThread());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A circularity lock that holds a global monitor and does not permit concurrent access.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Global implements CircularityLock {
&nbsp;
&nbsp;            /**
&nbsp;             * The lock to hold.
&nbsp;             */
&nbsp;            private final Lock lock;
&nbsp;
&nbsp;            /**
&nbsp;             * The time to wait for the lock.
&nbsp;             */
&nbsp;            private final long time;
&nbsp;
&nbsp;            /**
&nbsp;             * The time&#39;s time unit.
&nbsp;             */
&nbsp;            private final TimeUnit timeUnit;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new global circularity lock that does not wait for a release.
&nbsp;             */
&nbsp;            public Global() {
<b class="fc">&nbsp;                this(0, TimeUnit.MILLISECONDS);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new global circularity lock.
&nbsp;             *
&nbsp;             * @param time     The time to wait for the lock.
&nbsp;             * @param timeUnit The time&#39;s time unit.
&nbsp;             */
<b class="fc">&nbsp;            public Global(long time, TimeUnit timeUnit) {</b>
<b class="fc">&nbsp;                lock = new ReentrantLock();</b>
<b class="fc">&nbsp;                this.time = time;</b>
<b class="fc">&nbsp;                this.timeUnit = timeUnit;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean acquire() {
&nbsp;                try {
<b class="fc">&nbsp;                    return time == 0</b>
<b class="fc">&nbsp;                            ? lock.tryLock()</b>
<b class="fc">&nbsp;                            : lock.tryLock(time, timeUnit);</b>
<b class="nc">&nbsp;                } catch (InterruptedException ignored) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void release() {
<b class="fc">&nbsp;                lock.unlock();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type strategy is responsible for creating a type builder for a type that is being instrumented.
&nbsp;     */
&nbsp;    interface TypeStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type builder for a given type.
&nbsp;         *
&nbsp;         * @param typeDescription       The type being instrumented.
&nbsp;         * @param byteBuddy             The Byte Buddy configuration.
&nbsp;         * @param classFileLocator      The class file locator to use.
&nbsp;         * @param methodNameTransformer The method name transformer to use.
&nbsp;         * @param classLoader           The instrumented type&#39;s class loader or {@code null} if the type is loaded by the bootstrap loader.
&nbsp;         * @param module                The instrumented type&#39;s module or {@code null} if it is not declared by a module.
&nbsp;         * @param protectionDomain      The instrumented type&#39;s protection domain or {@code null} if it does not define a protection domain.
&nbsp;         * @return A type builder for the given arguments.
&nbsp;         */
&nbsp;        DynamicType.Builder&lt;?&gt; builder(TypeDescription typeDescription,
&nbsp;                                       ByteBuddy byteBuddy,
&nbsp;                                       ClassFileLocator classFileLocator,
&nbsp;                                       MethodNameTransformer methodNameTransformer,
&nbsp;                                       @MaybeNull ClassLoader classLoader,
&nbsp;                                       @MaybeNull JavaModule module,
&nbsp;                                       @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;        /**
&nbsp;         * Default implementations of type strategies.
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements TypeStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A definition handler that performs a rebasing for all types.
&nbsp;             */
<b class="fc">&nbsp;            REBASE {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public DynamicType.Builder&lt;?&gt; builder(TypeDescription typeDescription,
&nbsp;                                                      ByteBuddy byteBuddy,
&nbsp;                                                      ClassFileLocator classFileLocator,
&nbsp;                                                      MethodNameTransformer methodNameTransformer,
&nbsp;                                                      @MaybeNull ClassLoader classLoader,
&nbsp;                                                      @MaybeNull JavaModule module,
&nbsp;                                                      @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return byteBuddy.rebase(typeDescription, classFileLocator, methodNameTransformer);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A definition handler that performs a redefinition for all types.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Note that the default agent builder is configured to apply a self initialization where a static class initializer
&nbsp;             * is added to the redefined class. This can be disabled by for example using a {@link InitializationStrategy.Minimal} or
&nbsp;             * {@link InitializationStrategy.NoOp}. Also, consider the constraints implied by {@link ByteBuddy#redefine(TypeDescription, ClassFileLocator)}.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * For prohibiting any changes on a class file, use {@link AgentBuilder#disableClassFormatChanges()}
&nbsp;             * &lt;/p&gt;
&nbsp;             */
<b class="fc">&nbsp;            REDEFINE {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public DynamicType.Builder&lt;?&gt; builder(TypeDescription typeDescription,
&nbsp;                                                      ByteBuddy byteBuddy,
&nbsp;                                                      ClassFileLocator classFileLocator,
&nbsp;                                                      MethodNameTransformer methodNameTransformer,
&nbsp;                                                      @MaybeNull ClassLoader classLoader,
&nbsp;                                                      @MaybeNull JavaModule module,
&nbsp;                                                      @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return byteBuddy.redefine(typeDescription, classFileLocator);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A definition handler that performs a redefinition for all types and ignores all methods that were not declared by the instrumented type.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Note that the default agent builder is configured to apply a self initialization where a static class initializer
&nbsp;             * is added to the redefined class. This can be disabled by for example using a {@link InitializationStrategy.Minimal} or
&nbsp;             * {@link InitializationStrategy.NoOp}. Also, consider the constraints implied by {@link ByteBuddy#redefine(TypeDescription, ClassFileLocator)}.
&nbsp;             * Using this strategy also configures Byte Buddy to create frozen instrumented types and discards any explicit configuration.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * For prohibiting any changes on a class file, use {@link AgentBuilder#disableClassFormatChanges()}
&nbsp;             * &lt;/p&gt;
&nbsp;             */
<b class="fc">&nbsp;            REDEFINE_FROZEN {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public DynamicType.Builder&lt;?&gt; builder(TypeDescription typeDescription,
&nbsp;                                                      ByteBuddy byteBuddy,
&nbsp;                                                      ClassFileLocator classFileLocator,
&nbsp;                                                      MethodNameTransformer methodNameTransformer,
&nbsp;                                                      @MaybeNull ClassLoader classLoader,
&nbsp;                                                      @MaybeNull JavaModule module,
&nbsp;                                                      @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return byteBuddy.with(InstrumentedType.Factory.Default.FROZEN)</b>
<b class="fc">&nbsp;                            .with(VisibilityBridgeStrategy.Default.NEVER)</b>
<b class="fc">&nbsp;                            .redefine(typeDescription, classFileLocator)</b>
<b class="fc">&nbsp;                            .ignoreAlso(LatentMatcher.ForSelfDeclaredMethod.NOT_DECLARED);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A definition handler that performs a decoration of declared methods only. Using this type strategy
&nbsp;             * implies the limitations that are described by {@link ByteBuddy#decorate(TypeDescription, ClassFileLocator)}.
&nbsp;             * This type strategy can be useful when only applying {@link AsmVisitorWrapper}s without attempting to change
&nbsp;             * the class file layout..
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Note that the default agent builder is configured to apply a self initialization where a static class initializer
&nbsp;             * is added to the redefined class. This can be disabled by for example using a {@link InitializationStrategy.Minimal} or
&nbsp;             * {@link InitializationStrategy.NoOp}. Also, consider the constraints implied by {@link ByteBuddy#redefine(TypeDescription, ClassFileLocator)}.
&nbsp;             * Using this strategy also configures Byte Buddy to create frozen instrumented types and discards any explicit configuration.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * For prohibiting any changes on a class file, use {@link AgentBuilder#disableClassFormatChanges()}
&nbsp;             * &lt;/p&gt;
&nbsp;             */
<b class="fc">&nbsp;            DECORATE {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public DynamicType.Builder&lt;?&gt; builder(TypeDescription typeDescription,
&nbsp;                                                      ByteBuddy byteBuddy,
&nbsp;                                                      ClassFileLocator classFileLocator,
&nbsp;                                                      MethodNameTransformer methodNameTransformer,
&nbsp;                                                      @MaybeNull ClassLoader classLoader,
&nbsp;                                                      @MaybeNull JavaModule module,
&nbsp;                                                      @MaybeNull ProtectionDomain protectionDomain) {
<b class="nc">&nbsp;                    return byteBuddy.decorate(typeDescription, classFileLocator);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type strategy that applies a build {@link EntryPoint}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForBuildEntryPoint implements TypeStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The entry point to apply.
&nbsp;             */
&nbsp;            private final EntryPoint entryPoint;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type strategy for an entry point.
&nbsp;             *
&nbsp;             * @param entryPoint The entry point to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForBuildEntryPoint(EntryPoint entryPoint) {</b>
<b class="fc">&nbsp;                this.entryPoint = entryPoint;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Builder&lt;?&gt; builder(TypeDescription typeDescription,
&nbsp;                                                  ByteBuddy byteBuddy,
&nbsp;                                                  ClassFileLocator classFileLocator,
&nbsp;                                                  MethodNameTransformer methodNameTransformer,
&nbsp;                                                  @MaybeNull ClassLoader classLoader,
&nbsp;                                                  @MaybeNull JavaModule module,
&nbsp;                                                  @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return entryPoint.transform(typeDescription, byteBuddy, classFileLocator, methodNameTransformer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A transformer allows to apply modifications to a {@link net.bytebuddy.dynamic.DynamicType}. Such a modification
&nbsp;     * is then applied to any instrumented type that was matched by the preceding matcher.
&nbsp;     */
&nbsp;    interface Transformer {
&nbsp;
&nbsp;        /**
&nbsp;         * Allows for a transformation of a {@link net.bytebuddy.dynamic.DynamicType.Builder}.
&nbsp;         *
&nbsp;         * @param builder          The dynamic builder to transform.
&nbsp;         * @param typeDescription  The description of the type currently being instrumented.
&nbsp;         * @param classLoader      The class loader of the instrumented class. Might be {@code null} to represent the bootstrap class loader.
&nbsp;         * @param module           The class&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param protectionDomain The protection domain of the transformed type or {@code null} if not available
&nbsp;         * @return A transformed version of the supplied {@code builder}.
&nbsp;         */
&nbsp;        DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                         TypeDescription typeDescription,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         @MaybeNull JavaModule module,
&nbsp;                                         @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer that applies a build {@link Plugin}. Note that a transformer is never completed as class loading
&nbsp;         * might happen dynamically such that plugins are not closed.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForBuildPlugin implements Transformer {
&nbsp;
&nbsp;            /**
&nbsp;             * The plugin to apply.
&nbsp;             */
&nbsp;            private final Plugin plugin;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new transformer for a build {@link Plugin}.
&nbsp;             *
&nbsp;             * @param plugin The plugin to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForBuildPlugin(Plugin plugin) {</b>
<b class="fc">&nbsp;                this.plugin = plugin;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                                    TypeDescription typeDescription,
&nbsp;                                                    @MaybeNull ClassLoader classLoader,
&nbsp;                                                    @MaybeNull JavaModule module,
&nbsp;                                                    @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return plugin.apply(builder, typeDescription, ClassFileLocator.ForClassLoader.of(classLoader));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for applying an {@link Advice} where this advice class might reference types of both the agent&#39;s and the user&#39;s
&nbsp;         * class loader. Using this transformer, it is possible to apply advice without including any library dependencies of this advice
&nbsp;         * class which are then rather looked up from the transformed class&#39;s class loader. For this to work, it is required to register
&nbsp;         * the advice class&#39;s class loader manually via the {@code include} methods and to reference the advice class by its fully-qualified
&nbsp;         * name. The advice class is then never loaded by rather described by a {@link TypePool}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForAdvice implements Transformer {
&nbsp;
&nbsp;            /**
&nbsp;             * The advice to use.
&nbsp;             */
&nbsp;            private final Advice.WithCustomMapping advice;
&nbsp;
&nbsp;            /**
&nbsp;             * The exception handler to register for the advice.
&nbsp;             */
&nbsp;            private final Advice.ExceptionHandler exceptionHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use for the advice.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * The class file locator to query for the advice class.
&nbsp;             */
&nbsp;            private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;            /**
&nbsp;             * The pool strategy to use for looking up an advice.
&nbsp;             */
&nbsp;            private final PoolStrategy poolStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The location strategy to use for class loaders when resolving advice classes.
&nbsp;             */
&nbsp;            private final LocationStrategy locationStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The advice entries to apply.
&nbsp;             */
&nbsp;            private final List&lt;Entry&gt; entries;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new advice transformer with a default setup.
&nbsp;             */
&nbsp;            public ForAdvice() {
<b class="fc">&nbsp;                this(Advice.withCustomMapping());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new advice transformer which applies the given advice.
&nbsp;             *
&nbsp;             * @param advice The configured advice to use.
&nbsp;             */
&nbsp;            public ForAdvice(Advice.WithCustomMapping advice) {
<b class="fc">&nbsp;                this(advice,</b>
&nbsp;                        Advice.ExceptionHandler.Default.SUPPRESSING,
&nbsp;                        Assigner.DEFAULT,
&nbsp;                        ClassFileLocator.NoOp.INSTANCE,
&nbsp;                        PoolStrategy.Default.FAST,
&nbsp;                        LocationStrategy.ForClassLoader.STRONG,
<b class="fc">&nbsp;                        Collections.&lt;Entry&gt;emptyList());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new advice transformer.
&nbsp;             *
&nbsp;             * @param advice           The configured advice to use.
&nbsp;             * @param exceptionHandler The exception handler to use.
&nbsp;             * @param assigner         The assigner to use.
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             * @param poolStrategy     The pool strategy to use for looking up an advice.
&nbsp;             * @param locationStrategy The location strategy to use for class loaders when resolving advice classes.
&nbsp;             * @param entries          The advice entries to apply.
&nbsp;             */
&nbsp;            protected ForAdvice(Advice.WithCustomMapping advice,
&nbsp;                                Advice.ExceptionHandler exceptionHandler,
&nbsp;                                Assigner assigner,
&nbsp;                                ClassFileLocator classFileLocator,
&nbsp;                                PoolStrategy poolStrategy,
&nbsp;                                LocationStrategy locationStrategy,
<b class="fc">&nbsp;                                List&lt;Entry&gt; entries) {</b>
<b class="fc">&nbsp;                this.advice = advice;</b>
<b class="fc">&nbsp;                this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.classFileLocator = classFileLocator;</b>
<b class="fc">&nbsp;                this.poolStrategy = poolStrategy;</b>
<b class="fc">&nbsp;                this.locationStrategy = locationStrategy;</b>
<b class="fc">&nbsp;                this.entries = entries;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Builder&lt;?&gt; transform(DynamicType.Builder&lt;?&gt; builder,
&nbsp;                                                    TypeDescription typeDescription,
&nbsp;                                                    @MaybeNull ClassLoader classLoader,
&nbsp;                                                    @MaybeNull JavaModule module,
&nbsp;                                                    @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                ClassFileLocator classFileLocator = new ClassFileLocator.Compound(this.classFileLocator, locationStrategy.classFileLocator(classLoader, module));</b>
<b class="fc">&nbsp;                TypePool typePool = poolStrategy.typePool(classFileLocator, classLoader);</b>
<b class="fc">&nbsp;                AsmVisitorWrapper.ForDeclaredMethods asmVisitorWrapper = new AsmVisitorWrapper.ForDeclaredMethods();</b>
<b class="fc">&nbsp;                for (Entry entry : entries) {</b>
<b class="fc">&nbsp;                    asmVisitorWrapper = asmVisitorWrapper.invokable(entry.getMatcher().resolve(typeDescription), wrap(typeDescription,</b>
&nbsp;                            classLoader,
&nbsp;                            module,
&nbsp;                            protectionDomain,
<b class="fc">&nbsp;                            entry.resolve(advice, typePool, classFileLocator).withAssigner(assigner).withExceptionHandler(exceptionHandler)));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return builder.visit(asmVisitorWrapper);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Allows for decoration of advice for subclass implementations of this transformer. Note that a subclass is not retained when
&nbsp;             * using the builder methods of this class. Subclasses should also override the {@code make} method of this class to allow
&nbsp;             * propagating the custom configuration.
&nbsp;             *
&nbsp;             * @param typeDescription  The description of the type currently being instrumented.
&nbsp;             * @param classLoader      The class loader of the instrumented class. Might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @param module           The class&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;             * @param protectionDomain The protection domain of the transformed type or {@code null} if not available
&nbsp;             * @param advice           The advice to wrap.
&nbsp;             * @return A visitor wrapper that represents the supplied advice.
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unused&quot;)
&nbsp;            protected AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper wrap(TypeDescription typeDescription,
&nbsp;                                                                                     @MaybeNull ClassLoader classLoader,
&nbsp;                                                                                     @MaybeNull JavaModule module,
&nbsp;                                                                                     @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                                                                     Advice advice) {
<b class="fc">&nbsp;                return advice;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an advice transformer. This method is to be overridden when overriding the {@code wrap} method.
&nbsp;             *
&nbsp;             * @param advice           The configured advice to use.
&nbsp;             * @param exceptionHandler The exception handler to use.
&nbsp;             * @param assigner         The assigner to use.
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             * @param poolStrategy     The pool strategy to use for looking up an advice.
&nbsp;             * @param locationStrategy The location strategy to use for class loaders when resolving advice classes.
&nbsp;             * @param entries          The advice entries to apply.
&nbsp;             * @return An appropriate advice transformer.
&nbsp;             */
&nbsp;            protected ForAdvice make(Advice.WithCustomMapping advice,
&nbsp;                                     Advice.ExceptionHandler exceptionHandler,
&nbsp;                                     Assigner assigner,
&nbsp;                                     ClassFileLocator classFileLocator,
&nbsp;                                     PoolStrategy poolStrategy,
&nbsp;                                     LocationStrategy locationStrategy,
&nbsp;                                     List&lt;Entry&gt; entries) {
<b class="fc">&nbsp;                return new ForAdvice(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a pool strategy for creating a {@link TypePool} that should be used for creating the advice class.
&nbsp;             *
&nbsp;             * @param poolStrategy The pool strategy to use.
&nbsp;             * @return A new instance of this advice transformer that applies the supplied pool strategy.
&nbsp;             */
&nbsp;            public ForAdvice with(PoolStrategy poolStrategy) {
<b class="nc">&nbsp;                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a location strategy for creating a {@link ClassFileLocator} from the class loader that is supplied during transformation
&nbsp;             * that should be used for looking up advice-relevant classes.
&nbsp;             *
&nbsp;             * @param locationStrategy The location strategy to use.
&nbsp;             * @return A new instance of this advice transformer that applies the supplied location strategy.
&nbsp;             */
&nbsp;            public ForAdvice with(LocationStrategy locationStrategy) {
<b class="fc">&nbsp;                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Registers an exception handler for suppressed exceptions to use by the registered advice.
&nbsp;             *
&nbsp;             * @param exceptionHandler The exception handler to use.
&nbsp;             * @return A new instance of this advice transformer that applies the supplied exception handler.
&nbsp;             * @see Advice#withExceptionHandler(StackManipulation)
&nbsp;             */
&nbsp;            public ForAdvice withExceptionHandler(Advice.ExceptionHandler exceptionHandler) {
<b class="fc">&nbsp;                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Registers an assigner to be used by the advice class.
&nbsp;             *
&nbsp;             * @param assigner The assigner to use.
&nbsp;             * @return A new instance of this advice transformer that applies the supplied assigner.
&nbsp;             * @see Advice#withAssigner(Assigner)
&nbsp;             */
&nbsp;            public ForAdvice with(Assigner assigner) {
<b class="fc">&nbsp;                return make(advice, exceptionHandler, assigner, classFileLocator, poolStrategy, locationStrategy, entries);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Includes the supplied class loaders as a source for looking up an advice class or its dependencies.
&nbsp;             * Note that the supplied class loaders are queried for types before the class loader of the instrumented class.
&nbsp;             *
&nbsp;             * @param classLoader The class loaders to include when looking up classes in their order. Duplicates are filtered.
&nbsp;             * @return A new instance of this advice transformer that considers the supplied class loaders as a lookup source.
&nbsp;             */
&nbsp;            public ForAdvice include(ClassLoader... classLoader) {
<b class="fc">&nbsp;                Set&lt;ClassFileLocator&gt; classFileLocators = new LinkedHashSet&lt;ClassFileLocator&gt;();</b>
<b class="fc">&nbsp;                for (ClassLoader aClassLoader : classLoader) {</b>
<b class="fc">&nbsp;                    classFileLocators.add(ClassFileLocator.ForClassLoader.of(aClassLoader));</b>
&nbsp;                }
<b class="fc">&nbsp;                return include(new ArrayList&lt;ClassFileLocator&gt;(classFileLocators));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Includes the supplied class file locators as a source for looking up an advice class or its dependencies.
&nbsp;             * Note that the supplied class loaders are queried for types before the class loader of the instrumented class.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locators to include when looking up classes in their order. Duplicates are filtered.
&nbsp;             * @return A new instance of this advice transformer that considers the supplied class file locators as a lookup source.
&nbsp;             */
&nbsp;            public ForAdvice include(ClassFileLocator... classFileLocator) {
<b class="nc">&nbsp;                return include(Arrays.asList(classFileLocator));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Includes the supplied class file locators as a source for looking up an advice class or its dependencies.
&nbsp;             * Note that the supplied class loaders are queried for types before the class loader of the instrumented class.
&nbsp;             *
&nbsp;             * @param classFileLocators The class file locators to include when looking up classes in their order. Duplicates are filtered.
&nbsp;             * @return A new instance of this advice transformer that considers the supplied class file locators as a lookup source.
&nbsp;             */
&nbsp;            public ForAdvice include(List&lt;? extends ClassFileLocator&gt; classFileLocators) {
<b class="fc">&nbsp;                return make(advice,</b>
&nbsp;                        exceptionHandler,
&nbsp;                        assigner,
<b class="fc">&nbsp;                        new ClassFileLocator.Compound(CompoundList.of(classFileLocator, classFileLocators)),</b>
&nbsp;                        poolStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        entries);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the given advice class onto all methods that satisfy the supplied matcher.
&nbsp;             *
&nbsp;             * @param matcher The matcher to determine what methods the advice should be applied to.
&nbsp;             * @param name    The fully-qualified, binary name of the advice class.
&nbsp;             * @return A new instance of this advice transformer that applies the given advice to all matched methods of an instrumented type.
&nbsp;             */
&nbsp;            public ForAdvice advice(ElementMatcher&lt;? super MethodDescription&gt; matcher, String name) {
<b class="fc">&nbsp;                return advice(new LatentMatcher.Resolved&lt;MethodDescription&gt;(matcher), name);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the given advice class onto all methods that satisfy the supplied matcher.
&nbsp;             *
&nbsp;             * @param matcher The matcher to determine what methods the advice should be applied to.
&nbsp;             * @param name    The fully-qualified, binary name of the advice class.
&nbsp;             * @return A new instance of this advice transformer that applies the given advice to all matched methods of an instrumented type.
&nbsp;             */
&nbsp;            public ForAdvice advice(LatentMatcher&lt;? super MethodDescription&gt; matcher, String name) {
<b class="fc">&nbsp;                return make(advice,</b>
&nbsp;                        exceptionHandler,
&nbsp;                        assigner,
&nbsp;                        classFileLocator,
&nbsp;                        poolStrategy,
&nbsp;                        locationStrategy,
<b class="fc">&nbsp;                        CompoundList.of(entries, new Entry.ForUnifiedAdvice(matcher, name)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the given advice class onto all methods that satisfy the supplied matcher.
&nbsp;             *
&nbsp;             * @param matcher The matcher to determine what methods the advice should be applied to.
&nbsp;             * @param enter   The fully-qualified, binary name of the enter advice class.
&nbsp;             * @param exit    The fully-qualified, binary name of the exit advice class.
&nbsp;             * @return A new instance of this advice transformer that applies the given advice to all matched methods of an instrumented type.
&nbsp;             */
&nbsp;            public ForAdvice advice(ElementMatcher&lt;? super MethodDescription&gt; matcher, String enter, String exit) {
<b class="nc">&nbsp;                return advice(new LatentMatcher.Resolved&lt;MethodDescription&gt;(matcher), enter, exit);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies the given advice class onto all methods that satisfy the supplied matcher.
&nbsp;             *
&nbsp;             * @param matcher The matcher to determine what methods the advice should be applied to.
&nbsp;             * @param enter   The fully-qualified, binary name of the enter advice class.
&nbsp;             * @param exit    The fully-qualified, binary name of the exit advice class.
&nbsp;             * @return A new instance of this advice transformer that applies the given advice to all matched methods of an instrumented type.
&nbsp;             */
&nbsp;            public ForAdvice advice(LatentMatcher&lt;? super MethodDescription&gt; matcher, String enter, String exit) {
<b class="nc">&nbsp;                return make(advice,</b>
&nbsp;                        exceptionHandler,
&nbsp;                        assigner,
&nbsp;                        classFileLocator,
&nbsp;                        poolStrategy,
&nbsp;                        locationStrategy,
<b class="nc">&nbsp;                        CompoundList.of(entries, new Entry.ForSplitAdvice(matcher, enter, exit)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An entry for an advice to apply.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected abstract static class Entry {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher for advised methods.
&nbsp;                 */
&nbsp;                private final LatentMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new entry.
&nbsp;                 *
&nbsp;                 * @param matcher The matcher for advised methods.
&nbsp;                 */
<b class="fc">&nbsp;                protected Entry(LatentMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                    this.matcher = matcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the matcher for advised methods.
&nbsp;                 *
&nbsp;                 * @return The matcher for advised methods.
&nbsp;                 */
&nbsp;                protected LatentMatcher&lt;? super MethodDescription&gt; getMatcher() {
<b class="fc">&nbsp;                    return matcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the advice for this entry.
&nbsp;                 *
&nbsp;                 * @param advice           The advice configuration.
&nbsp;                 * @param typePool         The type pool to use.
&nbsp;                 * @param classFileLocator The class file locator to use.
&nbsp;                 * @return The resolved advice.
&nbsp;                 */
&nbsp;                protected abstract Advice resolve(Advice.WithCustomMapping advice, TypePool typePool, ClassFileLocator classFileLocator);
&nbsp;
&nbsp;                /**
&nbsp;                 * An entry for an advice class where both the (optional) entry and exit advice methods are declared by the same class.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForUnifiedAdvice extends Entry {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the advice class.
&nbsp;                     */
&nbsp;                    protected final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new entry for an advice class where both the (optional) entry and exit advice methods are declared by the same class.
&nbsp;                     *
&nbsp;                     * @param matcher The matcher for advised methods.
&nbsp;                     * @param name    The name of the advice class.
&nbsp;                     */
&nbsp;                    protected ForUnifiedAdvice(LatentMatcher&lt;? super MethodDescription&gt; matcher, String name) {
<b class="fc">&nbsp;                        super(matcher);</b>
<b class="fc">&nbsp;                        this.name = name;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Advice resolve(Advice.WithCustomMapping advice, TypePool typePool, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                        return advice.to(typePool.describe(name).resolve(), classFileLocator);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An entry for an advice class where both entry and exit advice methods are declared by the different classes.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForSplitAdvice extends Entry {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The fully-qualified, binary name of the enter advice class.
&nbsp;                     */
&nbsp;                    private final String enter;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The fully-qualified, binary name of the exit advice class.
&nbsp;                     */
&nbsp;                    private final String exit;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new entry for an advice class with explicit entry and exit advice classes.
&nbsp;                     *
&nbsp;                     * @param matcher The matcher for advised methods.
&nbsp;                     * @param enter   The fully-qualified, binary name of the enter advice class.
&nbsp;                     * @param exit    The fully-qualified, binary name of the exit advice class.
&nbsp;                     */
&nbsp;                    protected ForSplitAdvice(LatentMatcher&lt;? super MethodDescription&gt; matcher, String enter, String exit) {
<b class="nc">&nbsp;                        super(matcher);</b>
<b class="nc">&nbsp;                        this.enter = enter;</b>
<b class="nc">&nbsp;                        this.exit = exit;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Advice resolve(Advice.WithCustomMapping advice, TypePool typePool, ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;                        return advice.to(typePool.describe(enter).resolve(), typePool.describe(exit).resolve(), classFileLocator);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type locator allows to specify how {@link TypeDescription}s are resolved by an {@link net.bytebuddy.agent.builder.AgentBuilder}.
&nbsp;     */
&nbsp;    interface PoolStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type pool for a given class file locator.
&nbsp;         *
&nbsp;         * @param classFileLocator The class file locator to use.
&nbsp;         * @param classLoader      The class loader for which the class file locator was
&nbsp;         *                         created or {@code null} if the boot loader.
&nbsp;         * @return A type pool for the supplied class file locator.
&nbsp;         */
&nbsp;        TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader);
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a type pool for a given class file locator. If a cache is used, the type that is
&nbsp;         * currently instrumented is not used.
&nbsp;         *
&nbsp;         * @param classFileLocator The class file locator to use.
&nbsp;         * @param classLoader      The class loader for which the class file locator
&nbsp;         *                         was created or {@code null} if the boot loader.
&nbsp;         * @param name             The name of the currently instrumented type.
&nbsp;         * @return A type pool for the supplied class file locator.
&nbsp;         */
&nbsp;        TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name);
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A default type locator that resolves types only if any property that is not the type&#39;s name is requested.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The returned type pool uses a {@link net.bytebuddy.pool.TypePool.CacheProvider.Simple} and the
&nbsp;         * {@link ClassFileLocator} that is provided by the builder&#39;s {@link LocationStrategy}.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements PoolStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A type locator that parses the code segment of each method for extracting information about parameter
&nbsp;             * names even if they are not explicitly included in a class file.
&nbsp;             *
&nbsp;             * @see net.bytebuddy.pool.TypePool.Default.ReaderMode#EXTENDED
&nbsp;             */
<b class="fc">&nbsp;            EXTENDED(TypePool.Default.ReaderMode.EXTENDED),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A type locator that skips the code segment of each method and does therefore not extract information
&nbsp;             * about parameter names. Parameter names are still included if they are explicitly included in a class file.
&nbsp;             *
&nbsp;             * @see net.bytebuddy.pool.TypePool.Default.ReaderMode#FAST
&nbsp;             */
<b class="fc">&nbsp;            FAST(TypePool.Default.ReaderMode.FAST);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The reader mode to apply by this type locator.
&nbsp;             */
&nbsp;            private final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type locator.
&nbsp;             *
&nbsp;             * @param readerMode The reader mode to apply by this type locator.
&nbsp;             */
<b class="fc">&nbsp;            Default(TypePool.Default.ReaderMode readerMode) {</b>
<b class="fc">&nbsp;                this.readerMode = readerMode;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(),</b>
&nbsp;                        classFileLocator,
&nbsp;                        readerMode));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
<b class="fc">&nbsp;                return typePool(classFileLocator, classLoader);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A type locator that resolves all type descriptions eagerly.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The returned type pool uses a {@link net.bytebuddy.pool.TypePool.CacheProvider.Simple} and the
&nbsp;         * {@link ClassFileLocator} that is provided by the builder&#39;s {@link LocationStrategy}.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        enum Eager implements PoolStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A type locator that parses the code segment of each method for extracting information about parameter
&nbsp;             * names even if they are not explicitly included in a class file.
&nbsp;             *
&nbsp;             * @see net.bytebuddy.pool.TypePool.Default.ReaderMode#EXTENDED
&nbsp;             */
<b class="fc">&nbsp;            EXTENDED(TypePool.Default.ReaderMode.EXTENDED),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A type locator that skips the code segment of each method and does therefore not extract information
&nbsp;             * about parameter names. Parameter names are still included if they are explicitly included in a class file.
&nbsp;             *
&nbsp;             * @see net.bytebuddy.pool.TypePool.Default.ReaderMode#FAST
&nbsp;             */
<b class="fc">&nbsp;            FAST(TypePool.Default.ReaderMode.FAST);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The reader mode to apply by this type locator.
&nbsp;             */
&nbsp;            private final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type locator.
&nbsp;             *
&nbsp;             * @param readerMode The reader mode to apply by this type locator.
&nbsp;             */
<b class="fc">&nbsp;            Eager(TypePool.Default.ReaderMode readerMode) {</b>
<b class="fc">&nbsp;                this.readerMode = readerMode;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                return new TypePool.Default(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                return typePool(classFileLocator, classLoader);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A type locator that attempts loading a type if it cannot be located by the underlying lazy type pool.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * The returned type pool uses a {@link net.bytebuddy.pool.TypePool.CacheProvider.Simple} and the
&nbsp;         * {@link ClassFileLocator} that is provided by the builder&#39;s {@link LocationStrategy}. Any types
&nbsp;         * are loaded via the instrumented type&#39;s {@link ClassLoader}.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        enum ClassLoading implements PoolStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A type locator that parses the code segment of each method for extracting information about parameter
&nbsp;             * names even if they are not explicitly included in a class file.
&nbsp;             *
&nbsp;             * @see net.bytebuddy.pool.TypePool.Default.ReaderMode#EXTENDED
&nbsp;             */
<b class="fc">&nbsp;            EXTENDED(TypePool.Default.ReaderMode.EXTENDED),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A type locator that skips the code segment of each method and does therefore not extract information
&nbsp;             * about parameter names. Parameter names are still included if they are explicitly included in a class file.
&nbsp;             *
&nbsp;             * @see net.bytebuddy.pool.TypePool.Default.ReaderMode#FAST
&nbsp;             */
<b class="fc">&nbsp;            FAST(TypePool.Default.ReaderMode.FAST);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The reader mode to apply by this type locator.
&nbsp;             */
&nbsp;            private final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type locator.
&nbsp;             *
&nbsp;             * @param readerMode The reader mode to apply by this type locator.
&nbsp;             */
<b class="fc">&nbsp;            ClassLoading(TypePool.Default.ReaderMode readerMode) {</b>
<b class="fc">&nbsp;                this.readerMode = readerMode;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                return TypePool.ClassLoading.of(classLoader, new TypePool.Default.WithLazyResolution(TypePool.CacheProvider.Simple.withObjectType(), classFileLocator, readerMode));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                return typePool(classFileLocator, classLoader);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A type locator that uses type pools but allows for the configuration of a custom cache provider by class loader. Note that a
&nbsp;         * {@link TypePool} can grow in size and that a static reference is kept to this pool by Byte Buddy&#39;s registration of a
&nbsp;         * {@link ClassFileTransformer} what can cause a memory leak if the supplied caches are not cleared on a regular basis. Also note
&nbsp;         * that a cache provider can be accessed concurrently by multiple {@link ClassLoader}s.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * All types that are returned by the locator&#39;s type pool are resolved lazily.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class WithTypePoolCache implements PoolStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The reader mode to use for parsing a class file.
&nbsp;             */
&nbsp;            protected final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type locator that creates {@link TypePool}s but provides a custom {@link net.bytebuddy.pool.TypePool.CacheProvider}.
&nbsp;             *
&nbsp;             * @param readerMode The reader mode to use for parsing a class file.
&nbsp;             */
<b class="fc">&nbsp;            protected WithTypePoolCache(TypePool.Default.ReaderMode readerMode) {</b>
<b class="fc">&nbsp;                this.readerMode = readerMode;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(locate(classLoader), classFileLocator, readerMode));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool typePool(ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name) {
<b class="nc">&nbsp;                return new TypePool.LazyFacade(new TypePool.Default.WithLazyResolution(new TypePool.CacheProvider.Discriminating(ElementMatchers.&lt;String&gt;is(name),</b>
&nbsp;                        new TypePool.CacheProvider.Simple(),
<b class="nc">&nbsp;                        locate(classLoader)), classFileLocator, readerMode));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Locates a cache provider for a given class loader.
&nbsp;             *
&nbsp;             * @param classLoader The class loader for which to locate a cache. This class loader might
&nbsp;             *                    be {@code null} to represent the bootstrap loader.
&nbsp;             * @return The cache provider to use.
&nbsp;             */
&nbsp;            protected abstract TypePool.CacheProvider locate(@MaybeNull ClassLoader classLoader);
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a type locator {@link WithTypePoolCache} (note documentation of the linked class) that is based on a
&nbsp;             * {@link ConcurrentMap}. It is the responsibility of the type locator&#39;s user to avoid the type locator from leaking memory.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Simple extends WithTypePoolCache {
&nbsp;
&nbsp;                /**
&nbsp;                 * A default value for marking the boostrap class loader.
&nbsp;                 */
<b class="fc">&nbsp;                private static final ClassLoader BOOTSTRAP_MARKER = doPrivileged(BootstrapMarkerAction.INSTANCE);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The concurrent map that is used for storing a cache provider per class loader.
&nbsp;                 */
&nbsp;                private final ConcurrentMap&lt;? super ClassLoader, TypePool.CacheProvider&gt; cacheProviders;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new type locator that caches a cache provider per class loader in a concurrent map. The type
&nbsp;                 * locator uses a fast {@link net.bytebuddy.pool.TypePool.Default.ReaderMode}.
&nbsp;                 *
&nbsp;                 * @param cacheProviders The concurrent map that is used for storing a cache provider per class loader.
&nbsp;                 */
&nbsp;                public Simple(ConcurrentMap&lt;? super ClassLoader, TypePool.CacheProvider&gt; cacheProviders) {
<b class="nc">&nbsp;                    this(TypePool.Default.ReaderMode.FAST, cacheProviders);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new type locator that caches a cache provider per class loader in a concurrent map.
&nbsp;                 *
&nbsp;                 * @param readerMode     The reader mode to use for parsing a class file.
&nbsp;                 * @param cacheProviders The concurrent map that is used for storing a cache provider per class loader.
&nbsp;                 */
&nbsp;                public Simple(TypePool.Default.ReaderMode readerMode, ConcurrentMap&lt;? super ClassLoader, TypePool.CacheProvider&gt; cacheProviders) {
<b class="fc">&nbsp;                    super(readerMode);</b>
<b class="fc">&nbsp;                    this.cacheProviders = cacheProviders;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;                 *
&nbsp;                 * @param action The action to execute from a privileged context.
&nbsp;                 * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;                 * @return The action&#39;s resolved value.
&nbsp;                 */
&nbsp;                @AccessControllerPlugin.Enhance
&nbsp;                private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;                    return action.run();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected TypePool.CacheProvider locate(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                    classLoader = classLoader == null ? getBootstrapMarkerLoader() : classLoader;</b>
<b class="fc">&nbsp;                    TypePool.CacheProvider cacheProvider = cacheProviders.get(classLoader);</b>
<b class="fc">&nbsp;                    while (cacheProvider == null) {</b>
<b class="fc">&nbsp;                        cacheProvider = TypePool.CacheProvider.Simple.withObjectType();</b>
<b class="fc">&nbsp;                        TypePool.CacheProvider previous = cacheProviders.putIfAbsent(classLoader, cacheProvider);</b>
<b class="fc">&nbsp;                        if (previous != null) {</b>
<b class="nc">&nbsp;                            cacheProvider = previous;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return cacheProvider;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * Returns the class loader to serve as a cache key if a cache provider for the bootstrap class loader is requested.
&nbsp;                 * This class loader is represented by {@code null} in the JVM which is an invalid value for many {@link ConcurrentMap}
&nbsp;                 * implementations.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * By default, a custom class loader is created to use as a marker.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 *
&nbsp;                 * @return A class loader to represent the bootstrap class loader.
&nbsp;                 */
&nbsp;                protected ClassLoader getBootstrapMarkerLoader() {
<b class="fc">&nbsp;                    return BOOTSTRAP_MARKER;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An action that creates a class loader to mark the bootstrap loader without using {@code null}.
&nbsp;                 */
<b class="fc">&nbsp;                protected enum BootstrapMarkerAction implements PrivilegedAction&lt;ClassLoader&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassLoader run() {
<b class="fc">&nbsp;                        return new URLClassLoader(new URL[0], ClassLoadingStrategy.BOOTSTRAP_LOADER);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An initialization strategy which determines the handling of {@link net.bytebuddy.implementation.LoadedTypeInitializer}s
&nbsp;     * and the loading of auxiliary types. The agent builder does not reuse the {@link TypeResolutionStrategy} as Javaagents cannot access
&nbsp;     * a loaded class after a transformation such that different initialization strategies become meaningful.
&nbsp;     */
&nbsp;    interface InitializationStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new dispatcher for injecting this initialization strategy during a transformation process.
&nbsp;         *
&nbsp;         * @return The dispatcher to be used.
&nbsp;         */
&nbsp;        Dispatcher dispatcher();
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for changing a class file to adapt a self-initialization strategy.
&nbsp;         */
&nbsp;        interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms the instrumented type to implement an appropriate initialization strategy.
&nbsp;             *
&nbsp;             * @param builder The builder which should implement the initialization strategy.
&nbsp;             * @return The given {@code builder} with the initialization strategy applied.
&nbsp;             */
&nbsp;            DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder);
&nbsp;
&nbsp;            /**
&nbsp;             * Registers a dynamic type for initialization and/or begins the initialization process.
&nbsp;             *
&nbsp;             * @param dynamicType       The dynamic type that is created.
&nbsp;             * @param classLoader       The class loader of the dynamic type which can be {@code null} to represent the bootstrap class loader.
&nbsp;             * @param protectionDomain  The instrumented type&#39;s protection domain or {@code null} if no protection domain is available.
&nbsp;             * @param injectionStrategy The injection strategy to use.
&nbsp;             */
&nbsp;            void register(DynamicType dynamicType,
&nbsp;                          @MaybeNull ClassLoader classLoader,
&nbsp;                          @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                          InjectionStrategy injectionStrategy);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A non-initializing initialization strategy.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements InitializationStrategy, Dispatcher {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Dispatcher dispatcher() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder) {
<b class="fc">&nbsp;                return builder;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void register(DynamicType dynamicType,
&nbsp;                                 @MaybeNull ClassLoader classLoader,
&nbsp;                                 @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                 InjectionStrategy injectionStrategy) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An initialization strategy that loads auxiliary types before loading the instrumented type. This strategy skips all types
&nbsp;         * that are a subtype of the instrumented type which would cause a premature loading of the instrumented type and abort
&nbsp;         * the instrumentation process.
&nbsp;         */
<b class="fc">&nbsp;        enum Minimal implements InitializationStrategy, Dispatcher {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Dispatcher dispatcher() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder) {
<b class="fc">&nbsp;                return builder;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void register(DynamicType dynamicType,
&nbsp;                                 @MaybeNull ClassLoader classLoader,
&nbsp;                                 @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                 InjectionStrategy injectionStrategy) {
<b class="fc">&nbsp;                Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = dynamicType.getAuxiliaryTypes();</b>
<b class="fc">&nbsp;                Map&lt;TypeDescription, byte[]&gt; independentTypes = new LinkedHashMap&lt;TypeDescription, byte[]&gt;(auxiliaryTypes);</b>
<b class="fc">&nbsp;                for (TypeDescription auxiliaryType : auxiliaryTypes.keySet()) {</b>
<b class="fc">&nbsp;                    if (!auxiliaryType.getDeclaredAnnotations().isAnnotationPresent(AuxiliaryType.SignatureRelevant.class)) {</b>
<b class="fc">&nbsp;                        independentTypes.remove(auxiliaryType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (!independentTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                    ClassInjector classInjector = injectionStrategy.resolve(classLoader, protectionDomain);</b>
<b class="fc">&nbsp;                    Map&lt;TypeDescription, LoadedTypeInitializer&gt; loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();</b>
<b class="fc">&nbsp;                    for (Map.Entry&lt;TypeDescription, Class&lt;?&gt;&gt; entry : classInjector.inject(independentTypes).entrySet()) {</b>
<b class="fc">&nbsp;                        loadedTypeInitializers.get(entry.getKey()).onLoad(entry.getValue());</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An initialization strategy that adds a code block to an instrumented type&#39;s type initializer which
&nbsp;         * then calls a specific class that is responsible for the explicit initialization.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class SelfInjection implements InitializationStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The nexus accessor to use.
&nbsp;             */
&nbsp;            protected final NexusAccessor nexusAccessor;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new self-injection strategy.
&nbsp;             *
&nbsp;             * @param nexusAccessor The nexus accessor to use.
&nbsp;             */
<b class="fc">&nbsp;            protected SelfInjection(NexusAccessor nexusAccessor) {</b>
<b class="fc">&nbsp;                this.nexusAccessor = nexusAccessor;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;DMI_RANDOM_USED_ONLY_ONCE&quot;, justification = &quot;Avoids thread-contention.&quot;)
&nbsp;            public InitializationStrategy.Dispatcher dispatcher() {
<b class="fc">&nbsp;                return dispatcher(new Random().nextInt());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new dispatcher.
&nbsp;             *
&nbsp;             * @param identification The identification code to use.
&nbsp;             * @return An appropriate dispatcher for an initialization strategy.
&nbsp;             */
&nbsp;            protected abstract InitializationStrategy.Dispatcher dispatcher(int identification);
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for a self-initialization strategy.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected abstract static class Dispatcher implements InitializationStrategy.Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The nexus accessor to use.
&nbsp;                 */
&nbsp;                protected final NexusAccessor nexusAccessor;
&nbsp;
&nbsp;                /**
&nbsp;                 * A random identification for the applied self-initialization.
&nbsp;                 */
&nbsp;                protected final int identification;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher.
&nbsp;                 *
&nbsp;                 * @param nexusAccessor  The nexus accessor to use.
&nbsp;                 * @param identification A random identification for the applied self-initialization.
&nbsp;                 */
<b class="fc">&nbsp;                protected Dispatcher(NexusAccessor nexusAccessor, int identification) {</b>
<b class="fc">&nbsp;                    this.nexusAccessor = nexusAccessor;</b>
<b class="fc">&nbsp;                    this.identification = identification;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder) {
<b class="fc">&nbsp;                    return builder.initializer(new NexusAccessor.InitializationAppender(identification));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type initializer that injects all auxiliary types of the instrumented type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class InjectingInitializer implements LoadedTypeInitializer {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The auxiliary types mapped to their class file representation.
&nbsp;                     */
&nbsp;                    private final Map&lt;TypeDescription, byte[]&gt; rawAuxiliaryTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented types and auxiliary types mapped to their loaded type initializers.
&nbsp;                     * The instrumented types and auxiliary types mapped to their loaded type initializers.
&nbsp;                     */
&nbsp;                    private final Map&lt;TypeDescription, LoadedTypeInitializer&gt; loadedTypeInitializers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The class injector to use.
&nbsp;                     */
&nbsp;                    private final ClassInjector classInjector;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new injection initializer.
&nbsp;                     *
&nbsp;                     * @param instrumentedType       The instrumented type.
&nbsp;                     * @param rawAuxiliaryTypes      The auxiliary types mapped to their class file representation.
&nbsp;                     * @param loadedTypeInitializers The instrumented types and auxiliary types mapped to their loaded type initializers.
&nbsp;                     * @param classInjector          The class injector to use.
&nbsp;                     */
&nbsp;                    protected InjectingInitializer(TypeDescription instrumentedType,
&nbsp;                                                   Map&lt;TypeDescription, byte[]&gt; rawAuxiliaryTypes,
&nbsp;                                                   Map&lt;TypeDescription, LoadedTypeInitializer&gt; loadedTypeInitializers,
<b class="fc">&nbsp;                                                   ClassInjector classInjector) {</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                        this.rawAuxiliaryTypes = rawAuxiliaryTypes;</b>
<b class="fc">&nbsp;                        this.loadedTypeInitializers = loadedTypeInitializers;</b>
<b class="fc">&nbsp;                        this.classInjector = classInjector;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onLoad(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                        for (Map.Entry&lt;TypeDescription, Class&lt;?&gt;&gt; auxiliary : classInjector.inject(rawAuxiliaryTypes).entrySet()) {</b>
<b class="fc">&nbsp;                            loadedTypeInitializers.get(auxiliary.getKey()).onLoad(auxiliary.getValue());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        loadedTypeInitializers.get(instrumentedType).onLoad(type);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isAlive() {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A form of self-injection where auxiliary types that are annotated by
&nbsp;             * {@link net.bytebuddy.implementation.auxiliary.AuxiliaryType.SignatureRelevant} of the instrumented type are loaded lazily and
&nbsp;             * any other auxiliary type is loaded eagerly.
&nbsp;             */
&nbsp;            public static class Split extends SelfInjection {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new split self-injection strategy that uses a default nexus accessor.
&nbsp;                 */
&nbsp;                public Split() {
<b class="fc">&nbsp;                    this(new NexusAccessor());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new split self-injection strategy that uses the supplied nexus accessor.
&nbsp;                 *
&nbsp;                 * @param nexusAccessor The nexus accessor to use.
&nbsp;                 */
&nbsp;                public Split(NexusAccessor nexusAccessor) {
<b class="fc">&nbsp;                    super(nexusAccessor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected InitializationStrategy.Dispatcher dispatcher(int identification) {
<b class="fc">&nbsp;                    return new Dispatcher(nexusAccessor, identification);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for the {@link net.bytebuddy.agent.builder.AgentBuilder.InitializationStrategy.SelfInjection.Split} strategy.
&nbsp;                 */
&nbsp;                protected static class Dispatcher extends SelfInjection.Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new split dispatcher.
&nbsp;                     *
&nbsp;                     * @param nexusAccessor  The nexus accessor to use.
&nbsp;                     * @param identification A random identification for the applied self-initialization.
&nbsp;                     */
&nbsp;                    protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
<b class="fc">&nbsp;                        super(nexusAccessor, identification);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(DynamicType dynamicType,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                         InjectionStrategy injectionStrategy) {
<b class="fc">&nbsp;                        Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = dynamicType.getAuxiliaryTypes();</b>
&nbsp;                        LoadedTypeInitializer loadedTypeInitializer;
<b class="fc">&nbsp;                        if (!auxiliaryTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                            TypeDescription instrumentedType = dynamicType.getTypeDescription();</b>
<b class="fc">&nbsp;                            ClassInjector classInjector = injectionStrategy.resolve(classLoader, protectionDomain);</b>
<b class="fc">&nbsp;                            Map&lt;TypeDescription, byte[]&gt; independentTypes = new LinkedHashMap&lt;TypeDescription, byte[]&gt;(auxiliaryTypes);</b>
<b class="fc">&nbsp;                            Map&lt;TypeDescription, byte[]&gt; dependentTypes = new LinkedHashMap&lt;TypeDescription, byte[]&gt;(auxiliaryTypes);</b>
<b class="fc">&nbsp;                            for (TypeDescription auxiliaryType : auxiliaryTypes.keySet()) {</b>
<b class="fc">&nbsp;                                (auxiliaryType.getDeclaredAnnotations().isAnnotationPresent(AuxiliaryType.SignatureRelevant.class)</b>
<b class="fc">&nbsp;                                        ? dependentTypes</b>
<b class="fc">&nbsp;                                        : independentTypes).remove(auxiliaryType);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            Map&lt;TypeDescription, LoadedTypeInitializer&gt; loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();</b>
<b class="fc">&nbsp;                            if (!independentTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                                for (Map.Entry&lt;TypeDescription, Class&lt;?&gt;&gt; entry : classInjector.inject(independentTypes).entrySet()) {</b>
<b class="fc">&nbsp;                                    loadedTypeInitializers.get(entry.getKey()).onLoad(entry.getValue());</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;                            }
<b class="fc">&nbsp;                            Map&lt;TypeDescription, LoadedTypeInitializer&gt; lazyInitializers = new HashMap&lt;TypeDescription, LoadedTypeInitializer&gt;(loadedTypeInitializers);</b>
<b class="fc">&nbsp;                            loadedTypeInitializers.keySet().removeAll(independentTypes.keySet());</b>
<b class="fc">&nbsp;                            loadedTypeInitializer = lazyInitializers.size() &gt; 1 // there exist auxiliary types that need lazy loading</b>
<b class="fc">&nbsp;                                    ? new Dispatcher.InjectingInitializer(instrumentedType, dependentTypes, lazyInitializers, classInjector)</b>
<b class="nc">&nbsp;                                    : lazyInitializers.get(instrumentedType);</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            loadedTypeInitializer = dynamicType.getLoadedTypeInitializers().get(dynamicType.getTypeDescription());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        nexusAccessor.register(dynamicType.getTypeDescription().getName(), classLoader, identification, loadedTypeInitializer);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A form of self-injection where any auxiliary type is loaded lazily.
&nbsp;             */
&nbsp;            public static class Lazy extends SelfInjection {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy self-injection strategy that uses a default nexus accessor.
&nbsp;                 */
&nbsp;                public Lazy() {
<b class="fc">&nbsp;                    this(new NexusAccessor());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy self-injection strategy that uses the supplied nexus accessor.
&nbsp;                 *
&nbsp;                 * @param nexusAccessor The nexus accessor to use.
&nbsp;                 */
&nbsp;                public Lazy(NexusAccessor nexusAccessor) {
<b class="fc">&nbsp;                    super(nexusAccessor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected InitializationStrategy.Dispatcher dispatcher(int identification) {
<b class="fc">&nbsp;                    return new Dispatcher(nexusAccessor, identification);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for the {@link net.bytebuddy.agent.builder.AgentBuilder.InitializationStrategy.SelfInjection.Lazy} strategy.
&nbsp;                 */
&nbsp;                protected static class Dispatcher extends SelfInjection.Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy dispatcher.
&nbsp;                     *
&nbsp;                     * @param nexusAccessor  The nexus accessor to use.
&nbsp;                     * @param identification A random identification for the applied self-initialization.
&nbsp;                     */
&nbsp;                    protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
<b class="fc">&nbsp;                        super(nexusAccessor, identification);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(DynamicType dynamicType,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                         InjectionStrategy injectionStrategy) {
<b class="fc">&nbsp;                        Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = dynamicType.getAuxiliaryTypes();</b>
<b class="fc">&nbsp;                        LoadedTypeInitializer loadedTypeInitializer = auxiliaryTypes.isEmpty()</b>
<b class="nc">&nbsp;                                ? dynamicType.getLoadedTypeInitializers().get(dynamicType.getTypeDescription())</b>
<b class="fc">&nbsp;                                : new Dispatcher.InjectingInitializer(dynamicType.getTypeDescription(), auxiliaryTypes, dynamicType.getLoadedTypeInitializers(), injectionStrategy.resolve(classLoader, protectionDomain));</b>
<b class="fc">&nbsp;                        nexusAccessor.register(dynamicType.getTypeDescription().getName(), classLoader, identification, loadedTypeInitializer);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A form of self-injection where any auxiliary type is loaded eagerly.
&nbsp;             */
&nbsp;            public static class Eager extends SelfInjection {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new eager self-injection strategy that uses a default nexus accessor.
&nbsp;                 */
&nbsp;                public Eager() {
<b class="fc">&nbsp;                    this(new NexusAccessor());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new eager self-injection strategy that uses the supplied nexus accessor.
&nbsp;                 *
&nbsp;                 * @param nexusAccessor The nexus accessor to use.
&nbsp;                 */
&nbsp;                public Eager(NexusAccessor nexusAccessor) {
<b class="fc">&nbsp;                    super(nexusAccessor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected InitializationStrategy.Dispatcher dispatcher(int identification) {
<b class="fc">&nbsp;                    return new Dispatcher(nexusAccessor, identification);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for the {@link net.bytebuddy.agent.builder.AgentBuilder.InitializationStrategy.SelfInjection.Eager} strategy.
&nbsp;                 */
&nbsp;                protected static class Dispatcher extends SelfInjection.Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new eager dispatcher.
&nbsp;                     *
&nbsp;                     * @param nexusAccessor  The nexus accessor to use.
&nbsp;                     * @param identification A random identification for the applied self-initialization.
&nbsp;                     */
&nbsp;                    protected Dispatcher(NexusAccessor nexusAccessor, int identification) {
<b class="fc">&nbsp;                        super(nexusAccessor, identification);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void register(DynamicType dynamicType,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                         InjectionStrategy injectionStrategy) {
<b class="fc">&nbsp;                        Map&lt;TypeDescription, byte[]&gt; auxiliaryTypes = dynamicType.getAuxiliaryTypes();</b>
<b class="fc">&nbsp;                        Map&lt;TypeDescription, LoadedTypeInitializer&gt; loadedTypeInitializers = dynamicType.getLoadedTypeInitializers();</b>
<b class="fc">&nbsp;                        if (!auxiliaryTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                            for (Map.Entry&lt;TypeDescription, Class&lt;?&gt;&gt; entry : injectionStrategy.resolve(classLoader, protectionDomain).inject(auxiliaryTypes).entrySet()) {</b>
<b class="fc">&nbsp;                                loadedTypeInitializers.get(entry.getKey()).onLoad(entry.getValue());</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
<b class="fc">&nbsp;                        LoadedTypeInitializer loadedTypeInitializer = loadedTypeInitializers.get(dynamicType.getTypeDescription());</b>
<b class="fc">&nbsp;                        nexusAccessor.register(dynamicType.getTypeDescription().getName(), classLoader, identification, loadedTypeInitializer);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A strategy for injecting auxiliary types into a class loader.
&nbsp;     */
&nbsp;    interface InjectionStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the class injector to use for a given class loader and protection domain.
&nbsp;         *
&nbsp;         * @param classLoader      The class loader to use or {@code null} if using the bootstrap loader.
&nbsp;         * @param protectionDomain The protection domain to use or {@code null} if all privileges should be assigned.
&nbsp;         * @return The class injector to use.
&nbsp;         */
&nbsp;        ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;        /**
&nbsp;         * An injection strategy that does not permit class injection.
&nbsp;         */
<b class="fc">&nbsp;        enum Disabled implements InjectionStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Class injection is disabled&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An injection strategy that uses Java reflection. This strategy is not capable of injecting classes into the bootstrap class loader.
&nbsp;         */
<b class="fc">&nbsp;        enum UsingReflection implements InjectionStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                if (classLoader == null) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot inject auxiliary class into bootstrap loader using reflection&quot;);</b>
<b class="fc">&nbsp;                } else if (ClassInjector.UsingReflection.isAvailable()) {</b>
<b class="fc">&nbsp;                    return new ClassInjector.UsingReflection(classLoader, protectionDomain);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Reflection-based injection is not available on the current VM&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An injection strategy that uses {@code sun.misc.Unsafe} or {@code jdk.internal.misc.Unsafe} to inject classes.
&nbsp;         */
<b class="fc">&nbsp;        enum UsingUnsafe implements InjectionStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                if (ClassInjector.UsingUnsafe.isAvailable()) {</b>
<b class="fc">&nbsp;                    return new ClassInjector.UsingUnsafe(classLoader, protectionDomain);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unsafe-based injection is not available on the current VM&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An injection strategy that uses a factory for creating an unsafe injector.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfFactory implements InjectionStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * The factory to use for creating an unsafe injector.
&nbsp;                 */
&nbsp;                private final ClassInjector.UsingUnsafe.Factory factory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an injection strategy based on a factory.
&nbsp;                 *
&nbsp;                 * @param factory The factory to use for creating an unsafe injector.
&nbsp;                 */
<b class="fc">&nbsp;                public OfFactory(ClassInjector.UsingUnsafe.Factory factory) {</b>
<b class="fc">&nbsp;                    this.factory = factory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return factory.make(classLoader, protectionDomain);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An injection strategy that uses JNA to inject classes. This strategy is only available if JNA was added as a dependency.
&nbsp;         */
<b class="fc">&nbsp;        enum UsingJna implements InjectionStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                if (ClassInjector.UsingJna.isAvailable()) {</b>
<b class="fc">&nbsp;                    return new ClassInjector.UsingJna(classLoader, protectionDomain);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;JNA-based injection is not available on the current VM&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An injection strategy that uses bootstrap injection using an {@link Instrumentation} instance.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class UsingInstrumentation implements InjectionStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumentation instance to use.
&nbsp;             */
&nbsp;            private final Instrumentation instrumentation;
&nbsp;
&nbsp;            /**
&nbsp;             * The folder to store jar files being used for bootstrap injection.
&nbsp;             */
&nbsp;            private final File folder;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new bootstrap injection strategy.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use.
&nbsp;             * @param folder          The folder to store jar files being used for bootstrap injection.
&nbsp;             */
<b class="fc">&nbsp;            public UsingInstrumentation(Instrumentation instrumentation, File folder) {</b>
<b class="fc">&nbsp;                this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;                this.folder = folder;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassInjector resolve(@MaybeNull ClassLoader classLoader, @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                return classLoader == null</b>
<b class="fc">&nbsp;                        ? ClassInjector.UsingInstrumentation.of(folder, ClassInjector.UsingInstrumentation.Target.BOOTSTRAP, instrumentation)</b>
<b class="fc">&nbsp;                        : UsingReflection.INSTANCE.resolve(classLoader, protectionDomain);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description strategy is responsible for resolving a {@link TypeDescription} when transforming or retransforming/-defining a type.
&nbsp;     */
&nbsp;    interface DescriptionStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates if this description strategy makes use of loaded type information and yields a different type description if no loaded type is available.
&nbsp;         *
&nbsp;         * @return {@code true} if this description strategy prefers loaded type information when describing a type and only uses a type pool
&nbsp;         * if loaded type information is not available.
&nbsp;         */
&nbsp;        boolean isLoadedFirst();
&nbsp;
&nbsp;        /**
&nbsp;         * Describes the given type.
&nbsp;         *
&nbsp;         * @param name            The binary name of the type to describe.
&nbsp;         * @param type            The type that is being redefined, if a redefinition is applied or {@code null} if no redefined type is available.
&nbsp;         * @param typePool        The type pool to use for locating a type if required.
&nbsp;         * @param classLoader     The type&#39;s class loader where {@code null} represents the bootstrap class loader.
&nbsp;         * @param circularityLock The currently used circularity lock.
&nbsp;         * @param module          The type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @return An appropriate type description.
&nbsp;         */
&nbsp;        TypeDescription apply(String name, @MaybeNull Class&lt;?&gt; type, TypePool typePool, CircularityLock circularityLock, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
&nbsp;
&nbsp;        /**
&nbsp;         * Default implementations of a {@link DescriptionStrategy}.
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements DescriptionStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A description type strategy represents a type as a {@link net.bytebuddy.description.type.TypeDescription.ForLoadedType} if a
&nbsp;             * retransformation or redefinition is applied on a type. Using a loaded type typically results in better performance as no
&nbsp;             * I/O is required for resolving type descriptions. However, any interaction with the type is carried out via the Java reflection
&nbsp;             * API. Using the reflection API triggers eager loading of any type that is part of a method or field signature. If any of these
&nbsp;             * types are missing from the class path, this eager loading will cause a {@link NoClassDefFoundError}. Some Java code declares
&nbsp;             * optional dependencies to other classes which are only realized if the optional dependency is present. Such code relies on the
&nbsp;             * Java reflection API not being used for types using optional dependencies.
&nbsp;             *
&nbsp;             * @see FallbackStrategy.Simple#ENABLED
&nbsp;             * @see FallbackStrategy.ByThrowableType#ofOptionalTypes()
&nbsp;             */
<b class="fc">&nbsp;            HYBRID(true) {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public TypeDescription apply(String name,
&nbsp;                                             @MaybeNull Class&lt;?&gt; type,
&nbsp;                                             TypePool typePool,
&nbsp;                                             CircularityLock circularityLock,
&nbsp;                                             @MaybeNull ClassLoader classLoader,
&nbsp;                                             @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return type == null</b>
<b class="fc">&nbsp;                            ? typePool.describe(name).resolve()</b>
<b class="fc">&nbsp;                            : TypeDescription.ForLoadedType.of(type);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A description strategy that always describes Java types using a {@link TypePool}. This requires that any type - even if it is already
&nbsp;             * loaded and a {@link Class} instance is available - is processed as a non-loaded type description. Doing so can cause overhead as processing
&nbsp;             * loaded types is supported very efficiently by a JVM.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Avoiding the usage of loaded types can improve robustness as this approach does not rely on the Java reflection API which triggers eager
&nbsp;             * validation of this loaded type which can fail an application if optional types are used by any types field or method signatures. Also, it
&nbsp;             * is possible to guarantee debugging meta data to be available also for retransformed or redefined types if a {@link TypeStrategy} specifies
&nbsp;             * the extraction of such meta data.
&nbsp;             * &lt;/p&gt;
&nbsp;             */
<b class="fc">&nbsp;            POOL_ONLY(false) {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public TypeDescription apply(String name,
&nbsp;                                             @MaybeNull Class&lt;?&gt; type,
&nbsp;                                             TypePool typePool,
&nbsp;                                             CircularityLock circularityLock,
&nbsp;                                             @MaybeNull ClassLoader classLoader,
&nbsp;                                             @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return typePool.describe(name).resolve();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A description strategy that always describes Java types using a {@link TypePool} unless a type cannot be resolved by a pool and a loaded
&nbsp;             * {@link Class} instance  is available. Doing so can cause overhead as processing loaded types is supported very efficiently by a JVM.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * Avoiding the usage of loaded types can improve robustness as this approach does not rely on the Java reflection API which triggers eager
&nbsp;             * validation of this loaded type which can fail an application if optional types are used by any types field or method signatures. Also, it
&nbsp;             * is possible to guarantee debugging meta data to be available also for retransformed or redefined types if a {@link TypeStrategy} specifies
&nbsp;             * the extraction of such meta data.
&nbsp;             * &lt;/p&gt;
&nbsp;             */
<b class="fc">&nbsp;            POOL_FIRST(false) {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public TypeDescription apply(String name,
&nbsp;                                             @MaybeNull Class&lt;?&gt; type,
&nbsp;                                             TypePool typePool,
&nbsp;                                             CircularityLock circularityLock,
&nbsp;                                             @MaybeNull ClassLoader classLoader,
&nbsp;                                             @MaybeNull JavaModule module) {
<b class="nc">&nbsp;                    TypePool.Resolution resolution = typePool.describe(name);</b>
<b class="nc">&nbsp;                    return resolution.isResolved() || type == null</b>
<b class="nc">&nbsp;                            ? resolution.resolve()</b>
<b class="nc">&nbsp;                            : TypeDescription.ForLoadedType.of(type);</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates if loaded type information is preferred over using a type pool for describing a type.
&nbsp;             */
&nbsp;            private final boolean loadedFirst;
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates if loaded type information is preferred over using a type pool for describing a type.
&nbsp;             *
&nbsp;             * @param loadedFirst {@code true} if loaded type information is preferred over using a type pool for describing a type.
&nbsp;             */
<b class="fc">&nbsp;            Default(boolean loadedFirst) {</b>
<b class="fc">&nbsp;                this.loadedFirst = loadedFirst;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a description strategy that uses this strategy but loads any super type. If a super type is not yet loaded,
&nbsp;             * this causes this super type to never be instrumented. Therefore, this option should only be used if all instrumented
&nbsp;             * types are guaranteed to be top-level types.
&nbsp;             *
&nbsp;             * @return This description strategy where all super types are loaded during the instrumentation.
&nbsp;             * @see SuperTypeLoading
&nbsp;             */
&nbsp;            public DescriptionStrategy withSuperTypeLoading() {
<b class="fc">&nbsp;                return new SuperTypeLoading(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isLoadedFirst() {
<b class="fc">&nbsp;                return loadedFirst;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a description strategy that uses this strategy but loads any super type asynchronously. Super types are loaded via
&nbsp;             * another thread supplied by the executor service to enforce the instrumentation of any such super type. It is recommended
&nbsp;             * to allow the executor service to create new threads without bound as class loading blocks any thread until all super types
&nbsp;             * were instrumented.
&nbsp;             *
&nbsp;             * @param executorService The executor service to use.
&nbsp;             * @return This description strategy where all super types are loaded asynchronously during the instrumentation.
&nbsp;             * @see SuperTypeLoading.Asynchronous
&nbsp;             */
&nbsp;            public DescriptionStrategy withSuperTypeLoading(ExecutorService executorService) {
<b class="fc">&nbsp;                return new SuperTypeLoading.Asynchronous(this, executorService);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A description strategy that enforces the loading of any super type of a type description but delegates the actual type description
&nbsp;         * to another description strategy.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Warning&lt;/b&gt;: When using this description strategy, a type is not instrumented if any of its subtypes is loaded first.
&nbsp;         * The instrumentation API does not submit such types to a class file transformer on most VM implementations.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class SuperTypeLoading implements DescriptionStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate description strategy.
&nbsp;             */
&nbsp;            private final DescriptionStrategy delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description strategy that enforces loading of a super type.
&nbsp;             *
&nbsp;             * @param delegate The delegate description strategy.
&nbsp;             */
<b class="fc">&nbsp;            public SuperTypeLoading(DescriptionStrategy delegate) {</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isLoadedFirst() {
<b class="nc">&nbsp;                return delegate.isLoadedFirst();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription apply(String name,
&nbsp;                                         @MaybeNull Class&lt;?&gt; type,
&nbsp;                                         TypePool typePool,
&nbsp;                                         CircularityLock circularityLock,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         @MaybeNull JavaModule module) {
<b class="nc">&nbsp;                TypeDescription typeDescription = delegate.apply(name, type, typePool, circularityLock, classLoader, module);</b>
<b class="nc">&nbsp;                return typeDescription instanceof TypeDescription.ForLoadedType</b>
<b class="nc">&nbsp;                        ? typeDescription</b>
<b class="nc">&nbsp;                        : new TypeDescription.SuperTypeLoading(typeDescription, classLoader, new UnlockingClassLoadingDelegate(circularityLock));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A class loading delegate that unlocks the circularity lock during class loading.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class UnlockingClassLoadingDelegate implements TypeDescription.SuperTypeLoading.ClassLoadingDelegate {
&nbsp;
&nbsp;                /**
&nbsp;                 * The circularity lock to unlock.
&nbsp;                 */
&nbsp;                private final CircularityLock circularityLock;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an unlocking class loading delegate.
&nbsp;                 *
&nbsp;                 * @param circularityLock The circularity lock to unlock.
&nbsp;                 */
<b class="nc">&nbsp;                protected UnlockingClassLoadingDelegate(CircularityLock circularityLock) {</b>
<b class="nc">&nbsp;                    this.circularityLock = circularityLock;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; load(String name, @MaybeNull ClassLoader classLoader) throws ClassNotFoundException {
<b class="nc">&nbsp;                    circularityLock.release();</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        return Class.forName(name, false, classLoader);</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        circularityLock.acquire();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A description strategy that enforces the loading of any super type of a type description but delegates the actual type description
&nbsp;             * to another description strategy.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Note&lt;/b&gt;: This description strategy delegates class loading to another thread in order to enforce the instrumentation of any
&nbsp;             * unloaded super type. This requires the executor service to supply at least as many threads as the deepest type hierarchy within the
&nbsp;             * application minus one for the instrumented type as class loading blocks any thread until all of its super types are loaded. These
&nbsp;             * threads are typically short lived which predestines the use of a {@link Executors#newCachedThreadPool()} without any upper bound
&nbsp;             * for the maximum number of created threads.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Important&lt;/b&gt;: This strategy can dead-lock under two circumstances:
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;ul&gt;
&nbsp;             * &lt;li&gt;
&nbsp;             * &lt;b&gt;Classes declare circularities&lt;/b&gt;: Under normal circumstances, such scenarios result in a {@link ClassCircularityError} but
&nbsp;             * can result in dead-locks when using this instrumentation strategy.
&nbsp;             * &lt;/li&gt;
&nbsp;             * &lt;li&gt;
&nbsp;             * &lt;b&gt;Class loaders declare custom locks&lt;/b&gt;: If a class loader locks another lock but itself during class loading, this lock cannot
&nbsp;             * be released by this strategy.
&nbsp;             * &lt;/li&gt;
&nbsp;             * &lt;/ul&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * For the above reasons, it is not recommended to use this strategy when the target class loader is unknown or if the target application
&nbsp;             * might contain corrupt class files.
&nbsp;             * &lt;/p&gt;
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Asynchronous implements DescriptionStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegate description strategy.
&nbsp;                 */
&nbsp;                private final DescriptionStrategy delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * The executor service to use for loading super types.
&nbsp;                 */
&nbsp;                private final ExecutorService executorService;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new description strategy that enforces super type loading from another thread.
&nbsp;                 *
&nbsp;                 * @param delegate        The delegate description strategy.
&nbsp;                 * @param executorService The executor service to use for loading super types.
&nbsp;                 */
<b class="fc">&nbsp;                public Asynchronous(DescriptionStrategy delegate, ExecutorService executorService) {</b>
<b class="fc">&nbsp;                    this.delegate = delegate;</b>
<b class="fc">&nbsp;                    this.executorService = executorService;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isLoadedFirst() {
<b class="nc">&nbsp;                    return delegate.isLoadedFirst();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription apply(String name,
&nbsp;                                             @MaybeNull Class&lt;?&gt; type,
&nbsp;                                             TypePool typePool,
&nbsp;                                             CircularityLock circularityLock,
&nbsp;                                             @MaybeNull ClassLoader classLoader,
&nbsp;                                             @MaybeNull JavaModule module) {
<b class="nc">&nbsp;                    TypeDescription typeDescription = delegate.apply(name, type, typePool, circularityLock, classLoader, module);</b>
<b class="nc">&nbsp;                    return typeDescription instanceof TypeDescription.ForLoadedType</b>
<b class="nc">&nbsp;                            ? typeDescription</b>
<b class="nc">&nbsp;                            : new TypeDescription.SuperTypeLoading(typeDescription, classLoader, new ThreadSwitchingClassLoadingDelegate(executorService));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A class loading delegate that delegates loading of the super type to another thread.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ThreadSwitchingClassLoadingDelegate implements TypeDescription.SuperTypeLoading.ClassLoadingDelegate {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The executor service to delegate class loading to.
&nbsp;                     */
&nbsp;                    private final ExecutorService executorService;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new thread-switching class loading delegate.
&nbsp;                     *
&nbsp;                     * @param executorService The executor service to delegate class loading to.
&nbsp;                     */
<b class="nc">&nbsp;                    protected ThreadSwitchingClassLoadingDelegate(ExecutorService executorService) {</b>
<b class="nc">&nbsp;                        this.executorService = executorService;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;?&gt; load(String name, @MaybeNull ClassLoader classLoader) {
<b class="nc">&nbsp;                        boolean holdsLock = classLoader != null &amp;&amp; Thread.holdsLock(classLoader);</b>
<b class="nc">&nbsp;                        AtomicBoolean signal = new AtomicBoolean(holdsLock);</b>
<b class="nc">&nbsp;                        Future&lt;Class&lt;?&gt;&gt; future = executorService.submit(holdsLock</b>
<b class="nc">&nbsp;                                ? new NotifyingClassLoadingAction(name, classLoader, signal)</b>
<b class="nc">&nbsp;                                : new SimpleClassLoadingAction(name, classLoader));</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            while (holdsLock &amp;&amp; signal.get()) {</b>
<b class="nc">&nbsp;                                classLoader.wait();</b>
&nbsp;                            }
<b class="nc">&nbsp;                            return future.get();</b>
<b class="nc">&nbsp;                        } catch (ExecutionException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Could not load &quot; + name + &quot; asynchronously&quot;, exception.getCause());</b>
<b class="nc">&nbsp;                        } catch (Exception exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Could not load &quot; + name + &quot; asynchronously&quot;, exception);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A class loading action that simply loads a type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class SimpleClassLoadingAction implements Callable&lt;Class&lt;?&gt;&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The loaded type&#39;s name.
&nbsp;                         */
&nbsp;                        private final String name;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type&#39;s class loader or {@code null} if the type is loaded by the bootstrap loader.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                        private final ClassLoader classLoader;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a simple class loading action.
&nbsp;                         *
&nbsp;                         * @param name        The loaded type&#39;s name.
&nbsp;                         * @param classLoader The type&#39;s class loader or {@code null} if the type is loaded by the bootstrap loader.
&nbsp;                         */
<b class="nc">&nbsp;                        protected SimpleClassLoadingAction(String name, @MaybeNull ClassLoader classLoader) {</b>
<b class="nc">&nbsp;                            this.name = name;</b>
<b class="nc">&nbsp;                            this.classLoader = classLoader;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Class&lt;?&gt; call() throws ClassNotFoundException {
<b class="nc">&nbsp;                            return Class.forName(name, false, classLoader);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A class loading action that notifies the class loader&#39;s lock after the type was loaded.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class NotifyingClassLoadingAction implements Callable&lt;Class&lt;?&gt;&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The loaded type&#39;s name.
&nbsp;                         */
&nbsp;                        private final String name;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type&#39;s class loader which must not be the boot loader, i.e {@code null}.
&nbsp;                         */
&nbsp;                        private final ClassLoader classLoader;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The signal that indicates the completion of the class loading with {@code false}.
&nbsp;                         */
&nbsp;                        private final AtomicBoolean signal;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a notifying class loading action.
&nbsp;                         *
&nbsp;                         * @param name        The loaded type&#39;s name.
&nbsp;                         * @param classLoader The type&#39;s class loader which must not be the boot loader, i.e {@code null}.
&nbsp;                         * @param signal      The signal that indicates the completion of the class loading with {@code false}.
&nbsp;                         */
<b class="nc">&nbsp;                        protected NotifyingClassLoadingAction(String name, ClassLoader classLoader, AtomicBoolean signal) {</b>
<b class="nc">&nbsp;                            this.name = name;</b>
<b class="nc">&nbsp;                            this.classLoader = classLoader;</b>
<b class="nc">&nbsp;                            this.signal = signal;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Class&lt;?&gt; call() throws ClassNotFoundException {
<b class="nc">&nbsp;                            synchronized (classLoader) {</b>
&nbsp;                                try {
<b class="nc">&nbsp;                                    return Class.forName(name, false, classLoader);</b>
&nbsp;                                } finally {
<b class="nc">&nbsp;                                    signal.set(false);</b>
<b class="nc">&nbsp;                                    classLoader.notifyAll();</b>
<b class="nc">&nbsp;                                }</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A strategy for creating a {@link ClassFileLocator} when instrumenting a type.
&nbsp;     */
&nbsp;    interface LocationStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a class file locator for a given class loader and module combination.
&nbsp;         *
&nbsp;         * @param classLoader The class loader that is loading an instrumented type. Might be {@code null} to represent the bootstrap class loader.
&nbsp;         * @param module      The type&#39;s module or {@code null} if Java modules are not supported on the current VM.
&nbsp;         * @return The class file locator to use.
&nbsp;         */
&nbsp;        ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module);
&nbsp;
&nbsp;        /**
&nbsp;         * A location strategy that never locates any byte code.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements LocationStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                return ClassFileLocator.NoOp.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A location strategy that locates class files by querying an instrumented type&#39;s {@link ClassLoader}.
&nbsp;         */
<b class="fc">&nbsp;        enum ForClassLoader implements LocationStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A location strategy that keeps a strong reference to the class loader the created class file locator represents.
&nbsp;             */
<b class="fc">&nbsp;            STRONG {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return ClassFileLocator.ForClassLoader.of(classLoader);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A location strategy that keeps a weak reference to the class loader the created class file locator represents.
&nbsp;             * As a consequence, any returned class file locator stops working once the represented class loader is garbage collected.
&nbsp;             */
<b class="fc">&nbsp;            WEAK {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                    return ClassFileLocator.ForClassLoader.WeaklyReferenced.of(classLoader);</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Adds additional location strategies as fallbacks to this location strategy.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locators to query if this location strategy cannot locate a class file.
&nbsp;             * @return A compound location strategy that first applies this location strategy and then queries the supplied class file locators.
&nbsp;             */
&nbsp;            public LocationStrategy withFallbackTo(ClassFileLocator... classFileLocator) {
<b class="fc">&nbsp;                return withFallbackTo(Arrays.asList(classFileLocator));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Adds additional location strategies as fallbacks to this location strategy.
&nbsp;             *
&nbsp;             * @param classFileLocators The class file locators to query if this location strategy cannot locate a class file.
&nbsp;             * @return A compound location strategy that first applies this location strategy and then queries the supplied class file locators.
&nbsp;             */
&nbsp;            public LocationStrategy withFallbackTo(Collection&lt;? extends ClassFileLocator&gt; classFileLocators) {
<b class="fc">&nbsp;                List&lt;LocationStrategy&gt; locationStrategies = new ArrayList&lt;LocationStrategy&gt;(classFileLocators.size());</b>
<b class="fc">&nbsp;                for (ClassFileLocator classFileLocator : classFileLocators) {</b>
<b class="fc">&nbsp;                    locationStrategies.add(new Simple(classFileLocator));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return withFallbackTo(locationStrategies);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Adds additional location strategies as fallbacks to this location strategy.
&nbsp;             *
&nbsp;             * @param locationStrategy The fallback location strategies to use.
&nbsp;             * @return A compound location strategy that first applies this location strategy and then the supplied fallback location strategies
&nbsp;             * in the supplied order.
&nbsp;             */
&nbsp;            public LocationStrategy withFallbackTo(LocationStrategy... locationStrategy) {
<b class="fc">&nbsp;                return withFallbackTo(Arrays.asList(locationStrategy));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Adds additional location strategies as fallbacks to this location strategy.
&nbsp;             *
&nbsp;             * @param locationStrategies The fallback location strategies to use.
&nbsp;             * @return A compound location strategy that first applies this location strategy and then the supplied fallback location strategies
&nbsp;             * in the supplied order.
&nbsp;             */
&nbsp;            public LocationStrategy withFallbackTo(List&lt;? extends LocationStrategy&gt; locationStrategies) {
<b class="fc">&nbsp;                List&lt;LocationStrategy&gt; allLocationStrategies = new ArrayList&lt;LocationStrategy&gt;(locationStrategies.size() + 1);</b>
<b class="fc">&nbsp;                allLocationStrategies.add(this);</b>
<b class="fc">&nbsp;                allLocationStrategies.addAll(locationStrategies);</b>
<b class="fc">&nbsp;                return new Compound(allLocationStrategies);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple location strategy that queries a given class file locator.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements LocationStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The class file locator to query.
&nbsp;             */
&nbsp;            private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;            /**
&nbsp;             * A simple location strategy that queries a given class file locator.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locator to query.
&nbsp;             */
<b class="fc">&nbsp;            public Simple(ClassFileLocator classFileLocator) {</b>
<b class="fc">&nbsp;                this.classFileLocator = classFileLocator;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                return classFileLocator;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound location strategy that applies a list of location strategies.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Compound implements LocationStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * The location strategies in their application order.
&nbsp;             */
&nbsp;            private final List&lt;LocationStrategy&gt; locationStrategies;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound location strategy.
&nbsp;             *
&nbsp;             * @param locationStrategy The location strategies in their application order.
&nbsp;             */
&nbsp;            public Compound(LocationStrategy... locationStrategy) {
<b class="fc">&nbsp;                this(Arrays.asList(locationStrategy));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound location strategy.
&nbsp;             *
&nbsp;             * @param locationStrategies The location strategies in their application order.
&nbsp;             */
<b class="fc">&nbsp;            public Compound(List&lt;? extends LocationStrategy&gt; locationStrategies) {</b>
<b class="fc">&nbsp;                this.locationStrategies = new ArrayList&lt;LocationStrategy&gt;();</b>
<b class="fc">&nbsp;                for (LocationStrategy locationStrategy : locationStrategies) {</b>
<b class="fc">&nbsp;                    if (locationStrategy instanceof Compound) {</b>
<b class="nc">&nbsp;                        this.locationStrategies.addAll(((Compound) locationStrategy).locationStrategies);</b>
<b class="fc">&nbsp;                    } else if (!(locationStrategy instanceof NoOp)) {</b>
<b class="fc">&nbsp;                        this.locationStrategies.add(locationStrategy);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassFileLocator classFileLocator(@MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module) {
<b class="fc">&nbsp;                List&lt;ClassFileLocator&gt; classFileLocators = new ArrayList&lt;ClassFileLocator&gt;(locationStrategies.size());</b>
<b class="fc">&nbsp;                for (LocationStrategy locationStrategy : locationStrategies) {</b>
<b class="fc">&nbsp;                    classFileLocators.add(locationStrategy.classFileLocator(classLoader, module));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new ClassFileLocator.Compound(classFileLocators);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A fallback strategy allows to reattempt a transformation or a consideration for redefinition/retransformation in case an exception
&nbsp;     * occurs. Doing so, it is possible to use a {@link TypePool} rather than using a loaded type description backed by a {@link Class}.
&nbsp;     * Loaded types can raise exceptions and errors if a {@link ClassLoader} cannot resolve all types that this class references. Using
&nbsp;     * a type pool, such errors can be avoided as type descriptions can be resolved lazily, avoiding such errors.
&nbsp;     */
&nbsp;    interface FallbackStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if the supplied type and throwable combination should result in a reattempt where the
&nbsp;         * loaded type is not used for querying information.
&nbsp;         *
&nbsp;         * @param type      The loaded type that was queried during the transformation attempt.
&nbsp;         * @param throwable The error or exception that was caused during the transformation.
&nbsp;         * @return {@code true} if the supplied type and throwable combination should
&nbsp;         */
&nbsp;        boolean isFallback(Class&lt;?&gt; type, Throwable throwable);
&nbsp;
&nbsp;        /**
&nbsp;         * A simple fallback strategy that either always reattempts a transformation or never does so.
&nbsp;         */
<b class="fc">&nbsp;        enum Simple implements FallbackStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An enabled fallback strategy that always attempts a new trial.
&nbsp;             */
<b class="fc">&nbsp;            ENABLED(true),</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A disabled fallback strategy that never attempts a new trial.
&nbsp;             */
<b class="fc">&nbsp;            DISABLED(false);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this fallback strategy is enabled.
&nbsp;             */
&nbsp;            private final boolean enabled;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default fallback strategy.
&nbsp;             *
&nbsp;             * @param enabled {@code true} if this fallback strategy is enabled.
&nbsp;             */
<b class="fc">&nbsp;            Simple(boolean enabled) {</b>
<b class="fc">&nbsp;                this.enabled = enabled;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isFallback(Class&lt;?&gt; type, Throwable throwable) {
<b class="fc">&nbsp;                return enabled;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A fallback strategy that discriminates by the type of the {@link Throwable} that triggered a request.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ByThrowableType implements FallbackStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * A set of throwable types that should trigger a fallback attempt.
&nbsp;             */
&nbsp;            private final Set&lt;? extends Class&lt;? extends Throwable&gt;&gt; types;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new throwable type-discriminating fallback strategy.
&nbsp;             *
&nbsp;             * @param type The throwable types that should trigger a fallback.
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;            public ByThrowableType(Class&lt;? extends Throwable&gt;... type) {
<b class="fc">&nbsp;                this(new HashSet&lt;Class&lt;? extends Throwable&gt;&gt;(Arrays.asList(type)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new throwable type-discriminating fallback strategy.
&nbsp;             *
&nbsp;             * @param types The throwable types that should trigger a fallback.
&nbsp;             */
<b class="fc">&nbsp;            public ByThrowableType(Set&lt;? extends Class&lt;? extends Throwable&gt;&gt; types) {</b>
<b class="fc">&nbsp;                this.types = types;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a fallback strategy that attempts a fallback if an error indicating a type error is the reason for requesting a reattempt.
&nbsp;             *
&nbsp;             * @return A fallback strategy that triggers a reattempt if a {@link LinkageError} or a {@link TypeNotPresentException} is raised.
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;            public static FallbackStrategy ofOptionalTypes() {
<b class="fc">&nbsp;                return new ByThrowableType(LinkageError.class, TypeNotPresentException.class);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isFallback(Class&lt;?&gt; type, Throwable throwable) {
<b class="fc">&nbsp;                for (Class&lt;? extends Throwable&gt; aType : types) {</b>
<b class="fc">&nbsp;                    if (aType.isInstance(throwable)) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A listener that is notified during the installation and the resetting of a class file transformer.
&nbsp;     */
&nbsp;    interface InstallationListener {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that an exception is handled.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        Throwable SUPPRESS_ERROR = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked prior to the installation of a class file transformer.
&nbsp;         *
&nbsp;         * @param instrumentation      The instrumentation on which the class file transformer is installed.
&nbsp;         * @param classFileTransformer The class file transformer that is being installed.
&nbsp;         */
&nbsp;        void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked upon the successful installation of a class file transformer. This method is only invoked if no error occurred during the
&nbsp;         * installation or if such an error was handled by {@link InstallationListener#onError(Instrumentation, ResettableClassFileTransformer, Throwable)}.
&nbsp;         *
&nbsp;         * @param instrumentation      The instrumentation on which the class file transformer is installed.
&nbsp;         * @param classFileTransformer The class file transformer that is being installed.
&nbsp;         */
&nbsp;        void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked if an installation causes an error. The listener has an opportunity to handle the error. This method is invoked prior to
&nbsp;         * {@link InstallationListener#onInstall(Instrumentation, ResettableClassFileTransformer)}.
&nbsp;         *
&nbsp;         * @param instrumentation      The instrumentation on which the class file transformer is installed.
&nbsp;         * @param classFileTransformer The class file transformer that is being installed.
&nbsp;         * @param throwable            The throwable that causes the error.
&nbsp;         * @return The error to propagate or {@code null} if the error is handled. Any subsequent listeners are not called if the exception is handled.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked if an installation is reset.
&nbsp;         *
&nbsp;         * @param instrumentation      The instrumentation on which the class file transformer is installed.
&nbsp;         * @param classFileTransformer The class file transformer that is being installed.
&nbsp;         */
&nbsp;        void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked before a warump is executed.
&nbsp;         *
&nbsp;         * @param types                The types that are used for the warmup.
&nbsp;         * @param classFileTransformer The class file transformer that is warmed up.
&nbsp;         */
&nbsp;        void onBeforeWarmUp(Set&lt;Class&lt;?&gt;&gt; types, ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked when a class yields an unexpected error that is not catched by the listener.
&nbsp;         *
&nbsp;         * @param type                 The type that caused the error.
&nbsp;         * @param classFileTransformer The class file transformer that is warmed up.
&nbsp;         * @param throwable            The throwable that represents the error.
&nbsp;         */
&nbsp;        void onWarmUpError(Class&lt;?&gt; type, ResettableClassFileTransformer classFileTransformer, Throwable throwable);
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked after a warump is executed.
&nbsp;         *
&nbsp;         * @param types                The types that are used for the warmup mapped to their transformed byte code
&nbsp;         *                             or {@code null} if the type was not transformed or failed to transform.
&nbsp;         * @param classFileTransformer The class file transformer that is warmed up.
&nbsp;         * @param transformed          {@code true} if at least one class caused an actual transformation.
&nbsp;         */
&nbsp;        void onAfterWarmUp(Map&lt;Class&lt;?&gt;, byte[]&gt; types, ResettableClassFileTransformer classFileTransformer, boolean transformed);
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational listener that does not do anything.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements InstallationListener {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                return throwable;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeWarmUp(Set&lt;Class&lt;?&gt;&gt; types, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onWarmUpError(Class&lt;?&gt; type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onAfterWarmUp(Map&lt;Class&lt;?&gt;, byte[]&gt; types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that suppresses any installation error.
&nbsp;         */
<b class="fc">&nbsp;        enum ErrorSuppressing implements InstallationListener {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                return SUPPRESS_ERROR;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeWarmUp(Set&lt;Class&lt;?&gt;&gt; types, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onWarmUpError(Class&lt;?&gt; type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onAfterWarmUp(Map&lt;Class&lt;?&gt;, byte[]&gt; types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An adapter implementation for an installation listener that serves as a convenience.
&nbsp;         */
<b class="fc">&nbsp;        abstract class Adapter implements InstallationListener {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                return throwable;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeWarmUp(Set&lt;Class&lt;?&gt;&gt; types, ResettableClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onWarmUpError(Class&lt;?&gt; type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onAfterWarmUp(Map&lt;Class&lt;?&gt;, byte[]&gt; types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * This installation listener prints the status of any installation to a {@link PrintStream}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class StreamWriting implements InstallationListener {
&nbsp;
&nbsp;            /**
&nbsp;             * The prefix prepended to any message written.
&nbsp;             */
&nbsp;            protected static final String PREFIX = &quot;[Byte Buddy]&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The print stream to write to.
&nbsp;             */
&nbsp;            private final PrintStream printStream;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new stream writing installation listener.
&nbsp;             *
&nbsp;             * @param printStream The print stream to write to.
&nbsp;             */
<b class="fc">&nbsp;            public StreamWriting(PrintStream printStream) {</b>
<b class="fc">&nbsp;                this.printStream = printStream;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a stream writing installation listener that prints to {@link System#out}.
&nbsp;             *
&nbsp;             * @return An installation listener that prints to {@link System#out}.
&nbsp;             */
&nbsp;            public static InstallationListener toSystemOut() {
<b class="fc">&nbsp;                return new StreamWriting(System.out);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a stream writing installation listener that prints to {@link System#err}.
&nbsp;             *
&nbsp;             * @return An installation listener that prints to {@link System#err}.
&nbsp;             */
&nbsp;            public static InstallationListener toSystemError() {
<b class="fc">&nbsp;                return new StreamWriting(System.err);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; BEFORE_INSTALL %s on %s%n&quot;, classFileTransformer, instrumentation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; INSTALL %s on %s%n&quot;, classFileTransformer, instrumentation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                synchronized (printStream) {</b>
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; ERROR %s on %s%n&quot;, classFileTransformer, instrumentation);</b>
<b class="fc">&nbsp;                    throwable.printStackTrace(printStream);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return throwable;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; RESET %s on %s%n&quot;, classFileTransformer, instrumentation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeWarmUp(Set&lt;Class&lt;?&gt;&gt; types, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; BEFORE_WARMUP %s on %s%n&quot;, classFileTransformer, types);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onWarmUpError(Class&lt;?&gt; type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                synchronized (printStream) {</b>
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; ERROR_WARMUP %s on %s%n&quot;, classFileTransformer, type);</b>
<b class="fc">&nbsp;                    throwable.printStackTrace(printStream);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onAfterWarmUp(Map&lt;Class&lt;?&gt;, byte[]&gt; types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
<b class="fc">&nbsp;                printStream.printf(PREFIX + &quot; AFTER_WARMUP %s %s on %s%n&quot;, transformed ? &quot;transformed&quot; : &quot;not transformed&quot;, classFileTransformer, types.keySet());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound installation listener.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Compound implements InstallationListener {
&nbsp;
&nbsp;            /**
&nbsp;             * The installation listeners to notify.
&nbsp;             */
&nbsp;            private final List&lt;InstallationListener&gt; installationListeners;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound listener.
&nbsp;             *
&nbsp;             * @param installationListener The installation listeners to notify.
&nbsp;             */
&nbsp;            public Compound(InstallationListener... installationListener) {
<b class="fc">&nbsp;                this(Arrays.asList(installationListener));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound listener.
&nbsp;             *
&nbsp;             * @param installationListeners The installation listeners to notify.
&nbsp;             */
<b class="fc">&nbsp;            public Compound(List&lt;? extends InstallationListener&gt; installationListeners) {</b>
<b class="fc">&nbsp;                this.installationListeners = new ArrayList&lt;InstallationListener&gt;();</b>
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    if (installationListener instanceof Compound) {</b>
<b class="nc">&nbsp;                        this.installationListeners.addAll(((Compound) installationListener).installationListeners);</b>
<b class="fc">&nbsp;                    } else if (!(installationListener instanceof NoOp)) {</b>
<b class="fc">&nbsp;                        this.installationListeners.add(installationListener);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    installationListener.onBeforeInstall(instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    installationListener.onInstall(instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Throwable onError(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    if (throwable == SUPPRESS_ERROR) {</b>
<b class="fc">&nbsp;                        return SUPPRESS_ERROR;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    throwable = installationListener.onError(instrumentation, classFileTransformer, throwable);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return throwable;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    installationListener.onReset(instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onBeforeWarmUp(Set&lt;Class&lt;?&gt;&gt; types, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    installationListener.onBeforeWarmUp(types, classFileTransformer);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onWarmUpError(Class&lt;?&gt; type, ResettableClassFileTransformer classFileTransformer, Throwable throwable) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    installationListener.onWarmUpError(type, classFileTransformer, throwable);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void onAfterWarmUp(Map&lt;Class&lt;?&gt;, byte[]&gt; types, ResettableClassFileTransformer classFileTransformer, boolean transformed) {
<b class="fc">&nbsp;                for (InstallationListener installationListener : installationListeners) {</b>
<b class="fc">&nbsp;                    installationListener.onAfterWarmUp(types, classFileTransformer, transformed);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This strategy determines how the provided class file buffer is used.
&nbsp;     */
&nbsp;    interface ClassFileBufferStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a class file locator for the class file buffer that is provided to the class file transformer.
&nbsp;         *
&nbsp;         * @param name                 The instrumented type&#39;s binary name.
&nbsp;         * @param binaryRepresentation The instrumented type&#39;s binary representation.
&nbsp;         * @param classLoader          The instrumented type&#39;s class loader or {@code null} if the type is loaded by the bootstrap class loader.
&nbsp;         * @param module               The instrumented type&#39;s module or {@code null} if the current VM does not support modules.
&nbsp;         * @param protectionDomain     The instrumented type&#39;s protection domain or {@code null} if not available
&nbsp;         * @return An appropriate class file locator.
&nbsp;         */
&nbsp;        ClassFileLocator resolve(String name,
&nbsp;                                 byte[] binaryRepresentation,
&nbsp;                                 @MaybeNull ClassLoader classLoader,
&nbsp;                                 @MaybeNull JavaModule module,
&nbsp;                                 @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the type pool for a given type name by the supplied {@link PoolStrategy}.
&nbsp;         *
&nbsp;         * @param poolStrategy     The pool strategy to use.
&nbsp;         * @param classFileLocator The class file locator to use.
&nbsp;         * @param classLoader      The class loader to use.
&nbsp;         * @param name             The name of the type for which the type pool is resolved.
&nbsp;         * @return A suitable type pool.
&nbsp;         */
&nbsp;        TypePool typePool(PoolStrategy poolStrategy, ClassFileLocator classFileLocator, @MaybeNull ClassLoader classLoader, String name);
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation of default class file buffer strategy.
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements ClassFileBufferStrategy {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A class file buffer strategy that retains the original class file buffer.
&nbsp;             */
<b class="fc">&nbsp;            RETAINING {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public ClassFileLocator resolve(String name,
&nbsp;                                                byte[] binaryRepresentation,
&nbsp;                                                @MaybeNull ClassLoader classLoader,
&nbsp;                                                @MaybeNull JavaModule module,
&nbsp;                                                @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return ClassFileLocator.Simple.of(name, binaryRepresentation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /** {@inheritDoc} */
&nbsp;                public TypePool typePool(PoolStrategy poolStrategy,
&nbsp;                                         ClassFileLocator classFileLocator,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         String name) {
<b class="fc">&nbsp;                    return poolStrategy.typePool(classFileLocator, classLoader, name);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A class file buffer strategy that discards the original class file buffer.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Warning&lt;/b&gt;: This strategy discards any changes that were applied by previous Java agents.
&nbsp;             * &lt;/p&gt;
&nbsp;             */
<b class="fc">&nbsp;            DISCARDING {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public ClassFileLocator resolve(String name,
&nbsp;                                                byte[] binaryRepresentation,
&nbsp;                                                @MaybeNull ClassLoader classLoader,
&nbsp;                                                @MaybeNull JavaModule module,
&nbsp;                                                @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    return ClassFileLocator.NoOp.INSTANCE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /** {@inheritDoc} */
&nbsp;                public TypePool typePool(PoolStrategy poolStrategy,
&nbsp;                                         ClassFileLocator classFileLocator,
&nbsp;                                         @MaybeNull ClassLoader classLoader,
&nbsp;                                         String name) {
<b class="nc">&nbsp;                    return poolStrategy.typePool(classFileLocator, classLoader);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A decorator that allows to change the class file transformer that is registered.
&nbsp;     */
&nbsp;    interface TransformerDecorator {
&nbsp;
&nbsp;        /**
&nbsp;         * Decorates the applied class file transformer.
&nbsp;         *
&nbsp;         * @param classFileTransformer The original transformer created by the agent builder.
&nbsp;         * @return The class file transformer that is actually being registered.
&nbsp;         */
&nbsp;        ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer decorator that retains the original transformer.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements TransformerDecorator {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                return classFileTransformer;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Wraps a class file transformer to become substitutable.
&nbsp;         */
<b class="nc">&nbsp;        enum ForSubstitution implements TransformerDecorator {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
<b class="nc">&nbsp;                return ResettableClassFileTransformer.WithDelegation.Substitutable.of(classFileTransformer);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound transformer decorator.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Compound implements TransformerDecorator {
&nbsp;
&nbsp;            /**
&nbsp;             * The listeners to invoke.
&nbsp;             */
&nbsp;            private final List&lt;TransformerDecorator&gt; transformerDecorators;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound transformer decorator.
&nbsp;             *
&nbsp;             * @param transformerDecorator The transformer decorators to add.
&nbsp;             */
&nbsp;            public Compound(TransformerDecorator... transformerDecorator) {
<b class="fc">&nbsp;                this(Arrays.asList(transformerDecorator));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound listener.
&nbsp;             *
&nbsp;             * @param transformerDecorators The transformerDecorators to invoke.
&nbsp;             */
<b class="fc">&nbsp;            public Compound(List&lt;? extends TransformerDecorator&gt; transformerDecorators) {</b>
<b class="fc">&nbsp;                this.transformerDecorators = new ArrayList&lt;TransformerDecorator&gt;();</b>
<b class="fc">&nbsp;                for (TransformerDecorator transformerDecorator : transformerDecorators) {</b>
<b class="fc">&nbsp;                    if (transformerDecorator instanceof Compound) {</b>
<b class="nc">&nbsp;                        this.transformerDecorators.addAll(((Compound) transformerDecorator).transformerDecorators);</b>
<b class="fc">&nbsp;                    } else if (!(transformerDecorator instanceof NoOp)) {</b>
<b class="fc">&nbsp;                        this.transformerDecorators.add(transformerDecorator);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer decorate(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                for (TransformerDecorator transformerDecorator : transformerDecorators) {</b>
<b class="fc">&nbsp;                    classFileTransformer = transformerDecorator.decorate(classFileTransformer);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return classFileTransformer;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A redefinition strategy regulates how already loaded classes are modified by a built agent.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
<b class="fc">&nbsp;    enum RedefinitionStrategy {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Disables redefinition such that already loaded classes are not affected by the agent.
&nbsp;         */
<b class="fc">&nbsp;        DISABLED(false, false) {</b>
&nbsp;            @Override
&nbsp;            public void apply(Instrumentation instrumentation,
&nbsp;                              PoolStrategy poolStrategy, LocationStrategy locationStrategy, DescriptionStrategy descriptionStrategy, FallbackStrategy fallbackStrategy, DiscoveryStrategy discoveryStrategy, LambdaInstrumentationStrategy lambdaInstrumentationStrategy, AgentBuilder.Listener listener,
&nbsp;                              Listener redefinitionListener, RawMatcher matcher, BatchAllocator redefinitionBatchAllocator, CircularityLock circularityLock) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected void check(Instrumentation instrumentation) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot apply redefinition on disabled strategy&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Collector make(PoolStrategy poolStrategy,
&nbsp;                                     LocationStrategy locationStrategy,
&nbsp;                                     DescriptionStrategy descriptionStrategy,
&nbsp;                                     FallbackStrategy fallbackStrategy,
&nbsp;                                     AgentBuilder.Listener listener,
&nbsp;                                     RawMatcher matcher,
&nbsp;                                     CircularityLock circularityLock) {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A disabled redefinition strategy cannot create a collector&quot;);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Applies a &lt;b&gt;redefinition&lt;/b&gt; to all classes that are already loaded and that would have been transformed if
&nbsp;         * the built agent was registered before they were loaded. The created {@link ClassFileTransformer} is &lt;b&gt;not&lt;/b&gt;
&nbsp;         * registered for applying retransformations.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Using this strategy, a redefinition is applied as a single transformation request. This means that a single illegal
&nbsp;         * redefinition of a class causes the entire redefinition attempt to fail.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: When applying a redefinition, it is normally required to use a {@link TypeStrategy} that applies
&nbsp;         * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
&nbsp;         * the constraints given by this type strategy.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        REDEFINITION(true, false) {</b>
&nbsp;            @Override
&nbsp;            protected void check(Instrumentation instrumentation) {
<b class="fc">&nbsp;                if (!instrumentation.isRedefineClassesSupported()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot apply redefinition on &quot; + instrumentation);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Collector make(PoolStrategy poolStrategy,
&nbsp;                                     LocationStrategy locationStrategy,
&nbsp;                                     DescriptionStrategy descriptionStrategy,
&nbsp;                                     FallbackStrategy fallbackStrategy,
&nbsp;                                     AgentBuilder.Listener listener,
&nbsp;                                     RawMatcher matcher,
&nbsp;                                     CircularityLock circularityLock) {
<b class="fc">&nbsp;                return new Collector.ForRedefinition(matcher,</b>
&nbsp;                        poolStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        listener,
&nbsp;                        fallbackStrategy,
&nbsp;                        circularityLock);
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Applies a &lt;b&gt;retransformation&lt;/b&gt; to all classes that are already loaded and that would have been transformed if
&nbsp;         * the built agent was registered before they were loaded. The created {@link ClassFileTransformer} is registered
&nbsp;         * for applying retransformations.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Using this strategy, a retransformation is applied as a single transformation request. This means that a single illegal
&nbsp;         * retransformation of a class causes the entire retransformation attempt to fail.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: When applying a retransformation, it is normally required to use a {@link TypeStrategy} that applies
&nbsp;         * a redefinition instead of rebasing classes such as {@link TypeStrategy.Default#REDEFINE}. Also, consider
&nbsp;         * the constraints given by this type strategy.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        RETRANSFORMATION(true, true) {</b>
&nbsp;            @Override
&nbsp;            protected void check(Instrumentation instrumentation) {
<b class="fc">&nbsp;                if (!DISPATCHER.isRetransformClassesSupported(instrumentation)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot apply retransformation on &quot; + instrumentation);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Collector make(PoolStrategy poolStrategy,
&nbsp;                                     LocationStrategy locationStrategy,
&nbsp;                                     DescriptionStrategy descriptionStrategy,
&nbsp;                                     FallbackStrategy fallbackStrategy,
&nbsp;                                     AgentBuilder.Listener listener,
&nbsp;                                     RawMatcher matcher,
&nbsp;                                     CircularityLock circularityLock) {
<b class="fc">&nbsp;                return new Collector.ForRetransformation(matcher,</b>
&nbsp;                        poolStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        listener,
&nbsp;                        fallbackStrategy,
&nbsp;                        circularityLock);
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to use for interacting with the instrumentation API.
&nbsp;         */
<b class="fc">&nbsp;        protected static final Dispatcher DISPATCHER = Default.doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that this redefinition strategy is enabled.
&nbsp;         */
&nbsp;        private final boolean enabled;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if this strategy applies retransformation.
&nbsp;         */
&nbsp;        private final boolean retransforming;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new redefinition strategy.
&nbsp;         *
&nbsp;         * @param enabled        {@code true} if this strategy is enabled.
&nbsp;         * @param retransforming {@code true} if this strategy applies retransformation.
&nbsp;         */
<b class="fc">&nbsp;        RedefinitionStrategy(boolean enabled, boolean retransforming) {</b>
<b class="fc">&nbsp;            this.enabled = enabled;</b>
<b class="fc">&nbsp;            this.retransforming = retransforming;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates if this strategy requires a class file transformer to be registered with a hint to apply the
&nbsp;         * transformer for retransformation.
&nbsp;         *
&nbsp;         * @return {@code true} if a class file transformer must be registered with a hint for retransformation.
&nbsp;         */
&nbsp;        protected boolean isRetransforming() {
<b class="fc">&nbsp;            return retransforming;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if this strategy can be applied to the supplied instrumentation instance.
&nbsp;         *
&nbsp;         * @param instrumentation The instrumentation instance to validate.
&nbsp;         */
&nbsp;        protected abstract void check(Instrumentation instrumentation);
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that this redefinition strategy applies a modification of already loaded classes.
&nbsp;         *
&nbsp;         * @return {@code true} if this redefinition strategy applies a modification of already loaded classes.
&nbsp;         */
&nbsp;        protected boolean isEnabled() {
<b class="fc">&nbsp;            return enabled;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a collector instance that is responsible for collecting loaded classes for potential retransformation.
&nbsp;         *
&nbsp;         * @param poolStrategy        The pool strategy to use.
&nbsp;         * @param locationStrategy    The location strategy to use.
&nbsp;         * @param descriptionStrategy The description strategy for resolving type descriptions for types.
&nbsp;         * @param fallbackStrategy    The fallback strategy to apply.
&nbsp;         * @param listener            The listener to notify on transformations.
&nbsp;         * @param matcher             The matcher to identify what types to redefine.
&nbsp;         * @param circularityLock     The circularity lock to use.
&nbsp;         * @return A new collector for collecting already loaded classes for transformation.
&nbsp;         */
&nbsp;        protected abstract Collector make(PoolStrategy poolStrategy,
&nbsp;                                          LocationStrategy locationStrategy,
&nbsp;                                          DescriptionStrategy descriptionStrategy,
&nbsp;                                          FallbackStrategy fallbackStrategy,
&nbsp;                                          AgentBuilder.Listener listener,
&nbsp;                                          RawMatcher matcher,
&nbsp;                                          CircularityLock circularityLock);
&nbsp;
&nbsp;        /**
&nbsp;         * Applies this redefinition strategy by submitting all loaded types to redefinition. If this redefinition strategy is disabled,
&nbsp;         * this method is non-operational.
&nbsp;         *
&nbsp;         * @param instrumentation               The instrumentation instance to use.
&nbsp;         * @param poolStrategy                  The type locator to use.
&nbsp;         * @param locationStrategy              The location strategy to use.
&nbsp;         * @param descriptionStrategy           The description strategy for resolving type descriptions for types.
&nbsp;         * @param fallbackStrategy              The fallback strategy to apply.
&nbsp;         * @param redefinitionDiscoveryStrategy The discovery strategy for loaded types to be redefined.
&nbsp;         * @param lambdaInstrumentationStrategy A strategy to determine of the {@code LambdaMetafactory} should be instrumented to allow for the
&nbsp;         *                                      instrumentation of classes that represent lambda expressions.
&nbsp;         * @param listener                      The listener to notify on transformations.
&nbsp;         * @param redefinitionListener          The redefinition listener for the redefinition strategy to apply.
&nbsp;         * @param matcher                       The matcher to identify what types to redefine.
&nbsp;         * @param redefinitionBatchAllocator    The batch allocator for the redefinition strategy to apply.
&nbsp;         * @param circularityLock               The circularity lock to use.
&nbsp;         */
&nbsp;        protected void apply(Instrumentation instrumentation,
&nbsp;                             PoolStrategy poolStrategy,
&nbsp;                             LocationStrategy locationStrategy,
&nbsp;                             DescriptionStrategy descriptionStrategy,
&nbsp;                             FallbackStrategy fallbackStrategy,
&nbsp;                             DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                             LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                             AgentBuilder.Listener listener,
&nbsp;                             Listener redefinitionListener,
&nbsp;                             RawMatcher matcher,
&nbsp;                             BatchAllocator redefinitionBatchAllocator,
&nbsp;                             CircularityLock circularityLock) {
<b class="fc">&nbsp;            check(instrumentation);</b>
<b class="fc">&nbsp;            int batch = RedefinitionStrategy.BatchAllocator.FIRST_BATCH;</b>
<b class="fc">&nbsp;            for (Iterable&lt;Class&lt;?&gt;&gt; types : redefinitionDiscoveryStrategy.resolve(instrumentation)) {</b>
<b class="fc">&nbsp;                RedefinitionStrategy.Collector collector = make(poolStrategy,</b>
&nbsp;                        locationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        listener,
&nbsp;                        matcher,
&nbsp;                        circularityLock);
<b class="fc">&nbsp;                for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                    if (type == null || type.isArray() || type.isPrimitive() || !lambdaInstrumentationStrategy.isInstrumented(type)) {</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    collector.consider(type, DISPATCHER.isModifiableClass(instrumentation, type) || ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtMost(ClassFileVersion.JAVA_V5));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                batch = collector.apply(instrumentation, redefinitionBatchAllocator, redefinitionListener, batch);</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A batch allocator which is responsible for applying a redefinition in a batches. A class redefinition or
&nbsp;         * retransformation can be a time-consuming operation rendering a JVM non-responsive. In combination with a
&nbsp;         * a {@link RedefinitionStrategy.Listener}, it is also possible to apply pauses between batches to distribute
&nbsp;         * the load of a retransformation over time.
&nbsp;         */
&nbsp;        public interface BatchAllocator {
&nbsp;
&nbsp;            /**
&nbsp;             * The index of the first batch.
&nbsp;             */
&nbsp;            int FIRST_BATCH = 0;
&nbsp;
&nbsp;            /**
&nbsp;             * Splits a list of types to be retransformed into separate batches.
&nbsp;             *
&nbsp;             * @param types A list of types which should be retransformed.
&nbsp;             * @return An iterable of retransformations within a batch.
&nbsp;             */
&nbsp;            Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; batch(List&lt;Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;            /**
&nbsp;             * A batch allocator that includes all types in a single batch.
&nbsp;             */
<b class="fc">&nbsp;            enum ForTotal implements BatchAllocator {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; batch(List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return types.isEmpty()</b>
<b class="fc">&nbsp;                            ? Collections.&lt;List&lt;Class&lt;?&gt;&gt;&gt;emptySet()</b>
<b class="fc">&nbsp;                            : Collections.singleton(types);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A batch allocator that creates chunks with a fixed size as batch jobs.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForFixedSize implements BatchAllocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The size of each chunk.
&nbsp;                 */
&nbsp;                private final int size;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new batch allocator that creates fixed-sized chunks.
&nbsp;                 *
&nbsp;                 * @param size The size of each chunk.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForFixedSize(int size) {</b>
<b class="fc">&nbsp;                    this.size = size;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new batch allocator that creates chunks of a fixed size.
&nbsp;                 *
&nbsp;                 * @param size The size of each chunk or {@code 0} if the batch should be included in a single chunk.
&nbsp;                 * @return An appropriate batch allocator.
&nbsp;                 */
&nbsp;                public static BatchAllocator ofSize(int size) {
<b class="fc">&nbsp;                    if (size &gt; 0) {</b>
<b class="fc">&nbsp;                        return new ForFixedSize(size);</b>
<b class="fc">&nbsp;                    } else if (size == 0) {</b>
<b class="fc">&nbsp;                        return ForTotal.INSTANCE;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;Cannot define a batch with a negative size: &quot; + size);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; batch(List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    List&lt;List&lt;Class&lt;?&gt;&gt;&gt; batches = new ArrayList&lt;List&lt;Class&lt;?&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    for (int index = 0; index &lt; types.size(); index += size) {</b>
<b class="fc">&nbsp;                        batches.add(new ArrayList&lt;Class&lt;?&gt;&gt;(types.subList(index, Math.min(types.size(), index + size))));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return batches;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A batch allocator that groups all batches by discriminating types using a type matcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForMatchedGrouping implements BatchAllocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type matchers to apply.
&nbsp;                 */
&nbsp;                private final Collection&lt;? extends ElementMatcher&lt;? super TypeDescription&gt;&gt; matchers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new batch allocator that groups all batches by discriminating types using a type matcher. All batches
&nbsp;                 * are applied in their application order with any unmatched type being included in the last batch.
&nbsp;                 *
&nbsp;                 * @param matcher The type matchers to apply in their application order.
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                public ForMatchedGrouping(ElementMatcher&lt;? super TypeDescription&gt;... matcher) {
<b class="fc">&nbsp;                    this(new LinkedHashSet&lt;ElementMatcher&lt;? super TypeDescription&gt;&gt;(Arrays.asList(matcher)));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new batch allocator that groups all batches by discriminating types using a type matcher. All batches
&nbsp;                 * are applied in their application order with any unmatched type being included in the last batch.
&nbsp;                 *
&nbsp;                 * @param matchers The type matchers to apply in their application order.
&nbsp;                 */
<b class="fc">&nbsp;                public ForMatchedGrouping(Collection&lt;? extends ElementMatcher&lt;? super TypeDescription&gt;&gt; matchers) {</b>
<b class="fc">&nbsp;                    this.matchers = matchers;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Assures that any group is at least of a given size. If a group is smaller than a given size, it is merged with its types
&nbsp;                 * are merged with its subsequent group(s) as long as such groups exist.
&nbsp;                 *
&nbsp;                 * @param threshold The minimum threshold for any batch.
&nbsp;                 * @return An appropriate batch allocator.
&nbsp;                 */
&nbsp;                public BatchAllocator withMinimum(int threshold) {
<b class="fc">&nbsp;                    return Slicing.withMinimum(threshold, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Assures that any group is at least of a given size. If a group is bigger than a given size, it is split into two several
&nbsp;                 * batches.
&nbsp;                 *
&nbsp;                 * @param threshold The maximum threshold for any batch.
&nbsp;                 * @return An appropriate batch allocator.
&nbsp;                 */
&nbsp;                public BatchAllocator withMaximum(int threshold) {
<b class="fc">&nbsp;                    return Slicing.withMaximum(threshold, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Assures that any group is within a size range described by the supplied minimum and maximum. Groups are split and merged
&nbsp;                 * according to the supplied thresholds. The last group contains might be smaller than the supplied minimum.
&nbsp;                 *
&nbsp;                 * @param minimum The minimum threshold for any batch.
&nbsp;                 * @param maximum The maximum threshold for any batch.
&nbsp;                 * @return An appropriate batch allocator.
&nbsp;                 */
&nbsp;                public BatchAllocator withinRange(int minimum, int maximum) {
<b class="fc">&nbsp;                    return Slicing.withinRange(minimum, maximum, this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; batch(List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    Map&lt;ElementMatcher&lt;? super TypeDescription&gt;, List&lt;Class&lt;?&gt;&gt;&gt; matched = new LinkedHashMap&lt;ElementMatcher&lt;? super TypeDescription&gt;, List&lt;Class&lt;?&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    List&lt;Class&lt;?&gt;&gt; unmatched = new ArrayList&lt;Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                    for (ElementMatcher&lt;? super TypeDescription&gt; matcher : matchers) {</b>
<b class="fc">&nbsp;                        matched.put(matcher, new ArrayList&lt;Class&lt;?&gt;&gt;());</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                    typeLoop:
<b class="fc">&nbsp;                    for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                        for (ElementMatcher&lt;? super TypeDescription&gt; matcher : matchers) {</b>
<b class="fc">&nbsp;                            if (matcher.matches(TypeDescription.ForLoadedType.of(type))) {</b>
<b class="fc">&nbsp;                                matched.get(matcher).add(type);</b>
<b class="fc">&nbsp;                                continue typeLoop;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        unmatched.add(type);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    List&lt;List&lt;Class&lt;?&gt;&gt;&gt; batches = new ArrayList&lt;List&lt;Class&lt;?&gt;&gt;&gt;(matchers.size() + 1);</b>
<b class="fc">&nbsp;                    for (List&lt;Class&lt;?&gt;&gt; batch : matched.values()) {</b>
<b class="fc">&nbsp;                        if (!batch.isEmpty()) {</b>
<b class="fc">&nbsp;                            batches.add(batch);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    if (!unmatched.isEmpty()) {</b>
<b class="fc">&nbsp;                        batches.add(unmatched);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return batches;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A slicing batch allocator that assures that any batch is within a certain size range.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Slicing implements BatchAllocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The minimum size of each slice.
&nbsp;                 */
&nbsp;                private final int minimum;
&nbsp;
&nbsp;                /**
&nbsp;                 * The maximum size of each slice.
&nbsp;                 */
&nbsp;                private final int maximum;
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegate batch allocator.
&nbsp;                 */
&nbsp;                private final BatchAllocator batchAllocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new slicing batch allocator.
&nbsp;                 *
&nbsp;                 * @param minimum        The minimum size of each slice.
&nbsp;                 * @param maximum        The maximum size of each slice.
&nbsp;                 * @param batchAllocator The delegate batch allocator.
&nbsp;                 */
<b class="fc">&nbsp;                protected Slicing(int minimum, int maximum, BatchAllocator batchAllocator) {</b>
<b class="fc">&nbsp;                    this.minimum = minimum;</b>
<b class="fc">&nbsp;                    this.maximum = maximum;</b>
<b class="fc">&nbsp;                    this.batchAllocator = batchAllocator;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new slicing batch allocator.
&nbsp;                 *
&nbsp;                 * @param minimum        The minimum size of each slice.
&nbsp;                 * @param batchAllocator The delegate batch allocator.
&nbsp;                 * @return An appropriate slicing batch allocator.
&nbsp;                 */
&nbsp;                public static BatchAllocator withMinimum(int minimum, BatchAllocator batchAllocator) {
<b class="fc">&nbsp;                    return withinRange(minimum, Integer.MAX_VALUE, batchAllocator);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new slicing batch allocator.
&nbsp;                 *
&nbsp;                 * @param maximum        The maximum size of each slice.
&nbsp;                 * @param batchAllocator The delegate batch allocator.
&nbsp;                 * @return An appropriate slicing batch allocator.
&nbsp;                 */
&nbsp;                public static BatchAllocator withMaximum(int maximum, BatchAllocator batchAllocator) {
<b class="fc">&nbsp;                    return withinRange(1, maximum, batchAllocator);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new slicing batch allocator.
&nbsp;                 *
&nbsp;                 * @param minimum        The minimum size of each slice.
&nbsp;                 * @param maximum        The maximum size of each slice.
&nbsp;                 * @param batchAllocator The delegate batch allocator.
&nbsp;                 * @return An appropriate slicing batch allocator.
&nbsp;                 */
&nbsp;                public static BatchAllocator withinRange(int minimum, int maximum, BatchAllocator batchAllocator) {
<b class="fc">&nbsp;                    if (minimum &lt;= 0) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;Minimum must be a positive number: &quot; + minimum);</b>
<b class="fc">&nbsp;                    } else if (minimum &gt; maximum) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;Minimum must not be bigger than maximum: &quot; + minimum + &quot; &gt;&quot; + maximum);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Slicing(minimum, maximum, batchAllocator);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; batch(List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return new SlicingIterable(minimum, maximum, batchAllocator.batch(types));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An iterable that slices batches into parts of a minimum and maximum size.
&nbsp;                 */
&nbsp;                protected static class SlicingIterable implements Iterable&lt;List&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The minimum size of any slice.
&nbsp;                     */
&nbsp;                    private final int minimum;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The maximum size of any slice.
&nbsp;                     */
&nbsp;                    private final int maximum;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The delegate iterable.
&nbsp;                     */
&nbsp;                    private final Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; iterable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new slicing iterable.
&nbsp;                     *
&nbsp;                     * @param minimum  The minimum size of any slice.
&nbsp;                     * @param maximum  The maximum size of any slice.
&nbsp;                     * @param iterable The delegate iterable.
&nbsp;                     */
<b class="fc">&nbsp;                    protected SlicingIterable(int minimum, int maximum, Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; iterable) {</b>
<b class="fc">&nbsp;                        this.minimum = minimum;</b>
<b class="fc">&nbsp;                        this.maximum = maximum;</b>
<b class="fc">&nbsp;                        this.iterable = iterable;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterator&lt;List&lt;Class&lt;?&gt;&gt;&gt; iterator() {
<b class="fc">&nbsp;                        return new SlicingIterator(minimum, maximum, iterable.iterator());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An iterator that slices batches into parts of a minimum and maximum size.
&nbsp;                     */
&nbsp;                    protected static class SlicingIterator implements Iterator&lt;List&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The minimum size of any slice.
&nbsp;                         */
&nbsp;                        private final int minimum;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The maximum size of any slice.
&nbsp;                         */
&nbsp;                        private final int maximum;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The delegate iterator.
&nbsp;                         */
&nbsp;                        private final Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; iterator;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A buffer containing all types that surpassed the maximum.
&nbsp;                         */
&nbsp;                        private List&lt;Class&lt;?&gt;&gt; buffer;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new slicing iterator.
&nbsp;                         *
&nbsp;                         * @param minimum  The minimum size of any slice.
&nbsp;                         * @param maximum  The maximum size of any slice.
&nbsp;                         * @param iterator The delegate iterator.
&nbsp;                         */
<b class="fc">&nbsp;                        protected SlicingIterator(int minimum, int maximum, Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; iterator) {</b>
<b class="fc">&nbsp;                            this.minimum = minimum;</b>
<b class="fc">&nbsp;                            this.maximum = maximum;</b>
<b class="fc">&nbsp;                            this.iterator = iterator;</b>
<b class="fc">&nbsp;                            buffer = new ArrayList&lt;Class&lt;?&gt;&gt;();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean hasNext() {
<b class="fc">&nbsp;                            return !buffer.isEmpty() || iterator.hasNext();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public List&lt;Class&lt;?&gt;&gt; next() {
<b class="fc">&nbsp;                            if (buffer.isEmpty()) {</b>
<b class="fc">&nbsp;                                buffer = iterator.next();</b>
&nbsp;                            }
<b class="fc">&nbsp;                            while (buffer.size() &lt; minimum &amp;&amp; iterator.hasNext()) {</b>
<b class="fc">&nbsp;                                buffer.addAll(iterator.next());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            if (buffer.size() &gt; maximum) {</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    return buffer.subList(0, maximum);</b>
&nbsp;                                } finally {
<b class="fc">&nbsp;                                    buffer = new ArrayList&lt;Class&lt;?&gt;&gt;(buffer.subList(maximum, buffer.size()));</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            } else {
&nbsp;                                try {
<b class="fc">&nbsp;                                    return buffer;</b>
&nbsp;                                } finally {
<b class="fc">&nbsp;                                    buffer = new ArrayList&lt;Class&lt;?&gt;&gt;();</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void remove() {
<b class="fc">&nbsp;                            throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A partitioning batch allocator that splits types for redefinition into a fixed amount of parts.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Partitioning implements BatchAllocator {
&nbsp;
&nbsp;                /**
&nbsp;                 * The amount of batches to generate.
&nbsp;                 */
&nbsp;                private final int parts;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new batch allocator that splits types for redefinition into a fixed amount of parts.
&nbsp;                 *
&nbsp;                 * @param parts The amount of parts to create.
&nbsp;                 */
<b class="fc">&nbsp;                protected Partitioning(int parts) {</b>
<b class="fc">&nbsp;                    this.parts = parts;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a part-splitting batch allocator.
&nbsp;                 *
&nbsp;                 * @param parts The amount of parts to create.
&nbsp;                 * @return A batch allocator that splits the redefined types into a fixed amount of batches.
&nbsp;                 */
&nbsp;                public static BatchAllocator of(int parts) {
<b class="fc">&nbsp;                    if (parts &lt; 1) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;A batch size must be positive: &quot; + parts);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new Partitioning(parts);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; batch(List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    if (types.isEmpty()) {</b>
<b class="fc">&nbsp;                        return Collections.emptyList();</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        List&lt;List&lt;Class&lt;?&gt;&gt;&gt; batches = new ArrayList&lt;List&lt;Class&lt;?&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                        int size = types.size() / parts, reminder = types.size() % parts;</b>
<b class="fc">&nbsp;                        for (int index = reminder; index &lt; types.size(); index += size) {</b>
<b class="fc">&nbsp;                            batches.add(new ArrayList&lt;Class&lt;?&gt;&gt;(types.subList(index, index + size)));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if (batches.isEmpty()) {</b>
<b class="fc">&nbsp;                            return Collections.singletonList(types);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            batches.get(0).addAll(0, types.subList(0, reminder));</b>
<b class="fc">&nbsp;                            return batches;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener to be applied during a redefinition.
&nbsp;         */
&nbsp;        public interface Listener {
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked before applying a batch.
&nbsp;             *
&nbsp;             * @param index A running index of the batch starting at {@code 0}.
&nbsp;             * @param batch The types included in this batch.
&nbsp;             * @param types All types included in the redefinition.
&nbsp;             */
&nbsp;            void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon an error during a batch. This method is not invoked if the failure handler handled this error.
&nbsp;             *
&nbsp;             * @param index     A running index of the batch starting at {@code 0}.
&nbsp;             * @param batch     The types included in this batch.
&nbsp;             * @param throwable The throwable that caused this invocation.
&nbsp;             * @param types     All types included in the redefinition.
&nbsp;             * @return A set of classes which should be attempted to be redefined. Typically, this should be a subset of the classes
&nbsp;             * contained in {@code batch} but not all classes.
&nbsp;             */
&nbsp;            Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon completion of all batches.
&nbsp;             *
&nbsp;             * @param amount   The total amount of batches that were executed.
&nbsp;             * @param types    All types included in the redefinition.
&nbsp;             * @param failures A mapping of batch types to their unhandled failures.
&nbsp;             */
&nbsp;            void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures);
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational listener.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements Listener {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return Collections.emptyList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener that invokes {@link Thread#yield()} prior to every batch but the first batch.
&nbsp;             */
<b class="fc">&nbsp;            enum Yielding implements Listener {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    if (index &gt; 0) {</b>
<b class="fc">&nbsp;                        Thread.yield();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return Collections.emptyList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener that halts a retransformation process upon an exception.
&nbsp;             */
<b class="fc">&nbsp;            enum ErrorEscalating implements Listener {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A listener that fails the retransformation upon the first failed retransformation of a batch.
&nbsp;                 */
<b class="fc">&nbsp;                FAIL_FAST {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Could not transform any of &quot; + batch, throwable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A listener that fails the retransformation after all batches were executed if any error occurred.
&nbsp;                 */
<b class="fc">&nbsp;                FAIL_LAST {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                        return Collections.emptyList();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
<b class="fc">&nbsp;                        if (!failures.isEmpty()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Could not transform any of &quot; + failures);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener adapter that offers non-operational implementations of all listener methods.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            abstract class Adapter implements Listener {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return Collections.emptyList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * A batch reallocator allows to split up a failed retransformation into additional batches which are reenqueed to the
&nbsp;             * current retransformation process. To do so, any batch with at least to classes is rerouted through a {@link BatchAllocator}
&nbsp;             * which is responsible for regrouping the classes that failed to be retransformed into new batches.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Important&lt;/b&gt;: To avoid endless looping over classes that cannot be successfully retransformed, the supplied batch
&nbsp;             * allocator must not resubmit batches that previously failed as an identical outcome is likely.
&nbsp;             * &lt;/p&gt;
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class BatchReallocator extends Adapter {
&nbsp;
&nbsp;                /**
&nbsp;                 * The batch allocator to use for reallocating failed batches.
&nbsp;                 */
&nbsp;                private final BatchAllocator batchAllocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new batch reallocator.
&nbsp;                 *
&nbsp;                 * @param batchAllocator The batch allocator to use for reallocating failed batches.
&nbsp;                 */
<b class="fc">&nbsp;                public BatchReallocator(BatchAllocator batchAllocator) {</b>
<b class="fc">&nbsp;                    this.batchAllocator = batchAllocator;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a batch allocator that splits any batch into two parts and resubmits these parts as two batches.
&nbsp;                 *
&nbsp;                 * @return A batch reallocating batch listener that splits failed batches into two parts for resubmission.
&nbsp;                 */
&nbsp;                public static Listener splitting() {
<b class="fc">&nbsp;                    return new BatchReallocator(new BatchAllocator.Partitioning(2));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return batch.size() &lt; 2</b>
<b class="fc">&nbsp;                            ? Collections.&lt;List&lt;Class&lt;?&gt;&gt;&gt;emptyList()</b>
<b class="fc">&nbsp;                            : batchAllocator.batch(batch);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener that invokes {@link Thread#sleep(long)} prior to every batch but the first batch.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Pausing extends Adapter {
&nbsp;
&nbsp;                /**
&nbsp;                 * The time to sleep in milliseconds between every two batches.
&nbsp;                 */
&nbsp;                private final long value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new pausing listener.
&nbsp;                 *
&nbsp;                 * @param value The time to sleep in milliseconds between every two batches.
&nbsp;                 */
<b class="fc">&nbsp;                protected Pausing(long value) {</b>
<b class="fc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a listener that pauses for the specified amount of time. If the specified value is {@code 0}, a
&nbsp;                 * non-operational listener is returned.
&nbsp;                 *
&nbsp;                 * @param value    The amount of time to pause between redefinition batches.
&nbsp;                 * @param timeUnit The time unit of {@code value}.
&nbsp;                 * @return An appropriate listener.
&nbsp;                 */
&nbsp;                public static Listener of(long value, TimeUnit timeUnit) {
<b class="nc">&nbsp;                    if (value &gt; 0L) {</b>
<b class="nc">&nbsp;                        return new Pausing(timeUnit.toMillis(value));</b>
<b class="nc">&nbsp;                    } else if (value == 0L) {</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Cannot sleep for a non-positive amount of time: &quot; + value);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    if (index &gt; 0) {</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            Thread.sleep(value);</b>
<b class="nc">&nbsp;                        } catch (InterruptedException exception) {</b>
<b class="nc">&nbsp;                            Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(exception);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener that writes events to a {@link PrintStream}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class StreamWriting implements Listener {
&nbsp;
&nbsp;                /**
&nbsp;                 * The print stream to write any events to.
&nbsp;                 */
&nbsp;                private final PrintStream printStream;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new stream writing listener.
&nbsp;                 *
&nbsp;                 * @param printStream The print stream to write any events to.
&nbsp;                 */
<b class="fc">&nbsp;                public StreamWriting(PrintStream printStream) {</b>
<b class="fc">&nbsp;                    this.printStream = printStream;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Writes the stream result to {@link System#out}.
&nbsp;                 *
&nbsp;                 * @return An appropriate listener.
&nbsp;                 */
&nbsp;                public static Listener toSystemOut() {
<b class="fc">&nbsp;                    return new StreamWriting(System.out);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Writes the stream result to {@link System#err}.
&nbsp;                 *
&nbsp;                 * @return An appropriate listener.
&nbsp;                 */
&nbsp;                public static Listener toSystemError() {
<b class="fc">&nbsp;                    return new StreamWriting(System.err);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + &quot; REDEFINE BATCH #%d [%d of %d type(s)]%n&quot;, index, batch.size(), types.size());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    synchronized (printStream) {</b>
<b class="fc">&nbsp;                        printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + &quot; REDEFINE ERROR #%d [%d of %d type(s)]%n&quot;, index, batch.size(), types.size());</b>
<b class="fc">&nbsp;                        throwable.printStackTrace(printStream);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return Collections.emptyList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
<b class="fc">&nbsp;                    printStream.printf(AgentBuilder.Listener.StreamWriting.PREFIX + &quot; REDEFINE COMPLETE %d batch(es) containing %d types [%d failed batch(es)]%n&quot;, amount, types.size(), failures.size());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compound listener that delegates events to several listeners.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Compound implements Listener {
&nbsp;
&nbsp;                /**
&nbsp;                 * The listeners to invoke.
&nbsp;                 */
&nbsp;                private final List&lt;Listener&gt; listeners;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound listener.
&nbsp;                 *
&nbsp;                 * @param listener The listeners to invoke.
&nbsp;                 */
&nbsp;                public Compound(Listener... listener) {
<b class="fc">&nbsp;                    this(Arrays.asList(listener));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound listener.
&nbsp;                 *
&nbsp;                 * @param listeners The listeners to invoke.
&nbsp;                 */
<b class="fc">&nbsp;                public Compound(List&lt;? extends Listener&gt; listeners) {</b>
<b class="fc">&nbsp;                    this.listeners = new ArrayList&lt;Listener&gt;();</b>
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        if (listener instanceof Compound) {</b>
<b class="nc">&nbsp;                            this.listeners.addAll(((Compound) listener).listeners);</b>
<b class="fc">&nbsp;                        } else if (!(listener instanceof NoOp)) {</b>
<b class="fc">&nbsp;                            this.listeners.add(listener);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBatch(int index, List&lt;Class&lt;?&gt;&gt; batch, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onBatch(index, batch, types);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; onError(int index, List&lt;Class&lt;?&gt;&gt; batch, Throwable throwable, List&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    List&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt; reattempts = new ArrayList&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt;();</b>
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        reattempts.add(listener.onError(index, batch, throwable, types));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new CompoundIterable(reattempts);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(int amount, List&lt;Class&lt;?&gt;&gt; types, Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onComplete(amount, types, failures);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A compound iterable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class CompoundIterable implements Iterable&lt;List&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The iterables to consider.
&nbsp;                     */
&nbsp;                    private final List&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt; iterables;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a compound iterable.
&nbsp;                     *
&nbsp;                     * @param iterables The iterables to consider.
&nbsp;                     */
<b class="fc">&nbsp;                    protected CompoundIterable(List&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt; iterables) {</b>
<b class="fc">&nbsp;                        this.iterables = iterables;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterator&lt;List&lt;Class&lt;?&gt;&gt;&gt; iterator() {
<b class="fc">&nbsp;                        return new CompoundIterator(new ArrayList&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt;(iterables));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A compound iterator that combines several iterables.
&nbsp;                     */
&nbsp;                    protected static class CompoundIterator implements Iterator&lt;List&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The current iterator or {@code null} if no such iterator is defined.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        private Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; current;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A backlog of iterables to still consider.
&nbsp;                         */
&nbsp;                        private final List&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt; backlog;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a compound iterator.
&nbsp;                         *
&nbsp;                         * @param iterables The iterables to consider.
&nbsp;                         */
<b class="fc">&nbsp;                        protected CompoundIterator(List&lt;Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt; iterables) {</b>
<b class="fc">&nbsp;                            backlog = iterables;</b>
<b class="fc">&nbsp;                            forward();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean hasNext() {
<b class="fc">&nbsp;                            return current != null &amp;&amp; current.hasNext();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public List&lt;Class&lt;?&gt;&gt; next() {
&nbsp;                            try {
<b class="fc">&nbsp;                                if (current != null) {</b>
<b class="fc">&nbsp;                                    return current.next();</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    throw new NoSuchElementException();</b>
&nbsp;                                }
&nbsp;                            } finally {
<b class="fc">&nbsp;                                forward();</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Forwards the iterator to the next relevant iterable.
&nbsp;                         */
&nbsp;                        private void forward() {
<b class="fc">&nbsp;                            while ((current == null || !current.hasNext()) &amp;&amp; !backlog.isEmpty()) {</b>
<b class="fc">&nbsp;                                current = backlog.remove(0).iterator();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void remove() {
<b class="fc">&nbsp;                            throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy for discovering types to redefine.
&nbsp;         */
&nbsp;        public interface DiscoveryStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an iterable of types to retransform. Types might be loaded during a previous retransformation which might require
&nbsp;             * multiple passes for a retransformation.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance used for the redefinition.
&nbsp;             * @return An iterable of types to consider for retransformation.
&nbsp;             */
&nbsp;            Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; resolve(Instrumentation instrumentation);
&nbsp;
&nbsp;            /**
&nbsp;             * A discovery strategy that considers all loaded types supplied by {@link Instrumentation#getAllLoadedClasses()}.
&nbsp;             */
<b class="fc">&nbsp;            enum SinglePass implements DiscoveryStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; resolve(Instrumentation instrumentation) {
<b class="fc">&nbsp;                    return Collections.&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt;singleton(Arrays.&lt;Class&lt;?&gt;&gt;asList(instrumentation.getAllLoadedClasses()));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A discovery strategy that considers all loaded types supplied by {@link Instrumentation#getAllLoadedClasses()}. For each reiteration,
&nbsp;             * this strategy checks if additional types were loaded after the previously supplied types. Doing so, types that were loaded during
&nbsp;             * instrumentations can be retransformed as such types are not passed to any class file transformer.
&nbsp;             */
<b class="fc">&nbsp;            enum Reiterating implements DiscoveryStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; resolve(Instrumentation instrumentation) {
<b class="fc">&nbsp;                    return new ReiteratingIterable(instrumentation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An iterable that returns any loaded types and checks if any additional types were loaded during the last instrumentation.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ReiteratingIterable implements Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumentation instance to use.
&nbsp;                     */
&nbsp;                    private final Instrumentation instrumentation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new reiterating iterable.
&nbsp;                     *
&nbsp;                     * @param instrumentation The instrumentation instance to use.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ReiteratingIterable(Instrumentation instrumentation) {</b>
<b class="fc">&nbsp;                        this.instrumentation = instrumentation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterator&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; iterator() {
<b class="fc">&nbsp;                        return new ReiteratingIterator(instrumentation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A reiterating iterator that considers types that were loaded during an instrumentation.
&nbsp;                 */
&nbsp;                protected static class ReiteratingIterator implements Iterator&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumentation instance to use.
&nbsp;                     */
&nbsp;                    private final Instrumentation instrumentation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A set containing all previously discovered types.
&nbsp;                     */
&nbsp;                    private final Set&lt;Class&lt;?&gt;&gt; processed;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The current list of types or {@code null} if the current list of types is not prepared.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    private List&lt;Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new reiterating iterator.
&nbsp;                     *
&nbsp;                     * @param instrumentation The instrumentation instance to use.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ReiteratingIterator(Instrumentation instrumentation) {</b>
<b class="fc">&nbsp;                        this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;                        processed = new HashSet&lt;Class&lt;?&gt;&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean hasNext() {
<b class="fc">&nbsp;                        if (types == null) {</b>
<b class="fc">&nbsp;                            types = new ArrayList&lt;Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                            for (Class&lt;?&gt; type : instrumentation.getAllLoadedClasses()) {</b>
<b class="fc">&nbsp;                                if (type != null &amp;&amp; processed.add(type)) {</b>
<b class="fc">&nbsp;                                    types.add(type);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        return !types.isEmpty();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterable&lt;Class&lt;?&gt;&gt; next() {
<b class="fc">&nbsp;                        if (hasNext()) {</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                return types;</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                types = null;</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            throw new NoSuchElementException();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void remove() {
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * &lt;p&gt;
&nbsp;                 * A discovery strategy that simplifies the application of {@link Reiterating} by assuming that the
&nbsp;                 * loaded classes that are returned by {@link Instrumentation#getAllLoadedClasses()} are always
&nbsp;                 * returned in the same order.
&nbsp;                 * &lt;/p&gt;
&nbsp;                 * &lt;p&gt;
&nbsp;                 * &lt;b&gt;Important&lt;/b&gt;: While this increases the performance of reiteration, it relies on an implementation
&nbsp;                 * detail of the JVM. Also, this strategy does not consider the possibility of classes being unloaded
&nbsp;                 * during reiteration. For these reasons, this strategy has to be used with care!
&nbsp;                 * &lt;/p&gt;
&nbsp;                 */
<b class="fc">&nbsp;                enum WithSortOrderAssumption implements DiscoveryStrategy {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; resolve(Instrumentation instrumentation) {
<b class="fc">&nbsp;                        return new OrderedReiteratingIterable(instrumentation);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An iterable that reiterates over an array of loaded classes by the previously observed length.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class OrderedReiteratingIterable implements Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The instrumentation instance to use.
&nbsp;                         */
&nbsp;                        private final Instrumentation instrumentation;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new reiterating iterable.
&nbsp;                         *
&nbsp;                         * @param instrumentation The instrumentation instance to use.
&nbsp;                         */
<b class="fc">&nbsp;                        protected OrderedReiteratingIterable(Instrumentation instrumentation) {</b>
<b class="fc">&nbsp;                            this.instrumentation = instrumentation;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Iterator&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; iterator() {
<b class="fc">&nbsp;                            return new OrderedReiteratingIterator(instrumentation);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An iterator that reiterates over an array of loaded classes by the previously observed length.
&nbsp;                     */
&nbsp;                    protected static class OrderedReiteratingIterator implements Iterator&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The instrumentation instance to use.
&nbsp;                         */
&nbsp;                        private final Instrumentation instrumentation;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The length of the last known array of known classes.
&nbsp;                         */
&nbsp;                        private int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The current list of types or {@code null} if the current list of types is not prepared.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        private List&lt;Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new reiterating iterator.
&nbsp;                         *
&nbsp;                         * @param instrumentation The instrumentation instance to use.
&nbsp;                         */
<b class="fc">&nbsp;                        protected OrderedReiteratingIterator(Instrumentation instrumentation) {</b>
<b class="fc">&nbsp;                            this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;                            index = 0;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean hasNext() {
<b class="fc">&nbsp;                            if (types == null) {</b>
<b class="fc">&nbsp;                                Class&lt;?&gt;[] type = instrumentation.getAllLoadedClasses();</b>
<b class="fc">&nbsp;                                types = new ArrayList&lt;Class&lt;?&gt;&gt;(Arrays.asList(type).subList(index, type.length));</b>
<b class="fc">&nbsp;                                index = type.length;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return !types.isEmpty();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Iterable&lt;Class&lt;?&gt;&gt; next() {
<b class="fc">&nbsp;                            if (hasNext()) {</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    return types;</b>
&nbsp;                                } finally {
<b class="fc">&nbsp;                                    types = null;</b>
<b class="nc">&nbsp;                                }</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                throw new NoSuchElementException();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void remove() {
<b class="fc">&nbsp;                            throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An explicit discovery strategy that only attempts the redefinition of specific types.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Explicit implements DiscoveryStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * The types to redefine.
&nbsp;                 */
&nbsp;                private final Set&lt;Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new explicit discovery strategy.
&nbsp;                 *
&nbsp;                 * @param type The types to redefine.
&nbsp;                 */
&nbsp;                public Explicit(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;                    this(new LinkedHashSet&lt;Class&lt;?&gt;&gt;(Arrays.asList(type)));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new explicit discovery strategy.
&nbsp;                 *
&nbsp;                 * @param types The types to redefine.
&nbsp;                 */
<b class="fc">&nbsp;                public Explicit(Set&lt;Class&lt;?&gt;&gt; types) {</b>
<b class="fc">&nbsp;                    this.types = types;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterable&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt; resolve(Instrumentation instrumentation) {
<b class="fc">&nbsp;                    return Collections.&lt;Iterable&lt;Class&lt;?&gt;&gt;&gt;singleton(types);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resubmission scheduler is responsible for scheduling a job that is resubmitting unloaded types that failed during retransformation.
&nbsp;         */
&nbsp;        public interface ResubmissionScheduler {
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if this scheduler is currently available.
&nbsp;             *
&nbsp;             * @return {@code true} if this scheduler is alive.
&nbsp;             */
&nbsp;            boolean isAlive();
&nbsp;
&nbsp;            /**
&nbsp;             * Schedules a resubmission job for regular application.
&nbsp;             *
&nbsp;             * @param job The job to schedule.
&nbsp;             * @return A cancelable that is canceled upon resetting the corresponding class file transformer.
&nbsp;             */
&nbsp;            Cancelable schedule(Runnable job);
&nbsp;
&nbsp;            /**
&nbsp;             * A cancelable allows to discontinue a resubmission job.
&nbsp;             */
&nbsp;            interface Cancelable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Cancels this resubmission job.
&nbsp;                 */
&nbsp;                void cancel();
&nbsp;
&nbsp;                /**
&nbsp;                 * A non-operational cancelable.
&nbsp;                 */
<b class="fc">&nbsp;                enum NoOp implements Cancelable {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void cancel() {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A cancelable for a {@link Future}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForFuture implements Cancelable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The future to cancel upon cancellation of this instance.
&nbsp;                     */
&nbsp;                    private final Future&lt;?&gt; future;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a cancelable for a future.
&nbsp;                     *
&nbsp;                     * @param future The future to cancel upon cancellation of this instance.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForFuture(Future&lt;?&gt; future) {</b>
<b class="fc">&nbsp;                        this.future = future;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void cancel() {
<b class="fc">&nbsp;                        future.cancel(true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resubmission scheduler that does not apply any scheduling.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements ResubmissionScheduler {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAlive() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Cancelable schedule(Runnable job) {
<b class="fc">&nbsp;                    return Cancelable.NoOp.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resubmission scheduler that schedules jobs at a fixed rate.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class AtFixedRate implements ResubmissionScheduler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The executor service to schedule to.
&nbsp;                 */
&nbsp;                private final ScheduledExecutorService scheduledExecutorService;
&nbsp;
&nbsp;                /**
&nbsp;                 * The time interval between schedulings.
&nbsp;                 */
&nbsp;                private final long time;
&nbsp;
&nbsp;                /**
&nbsp;                 * The time&#39;s time unit.
&nbsp;                 */
&nbsp;                private final TimeUnit timeUnit;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resubmission scheduler which schedules executions at a fixed rate.
&nbsp;                 *
&nbsp;                 * @param scheduledExecutorService The executor service to schedule to.
&nbsp;                 * @param time                     The time interval between schedulings.
&nbsp;                 * @param timeUnit                 The time&#39;s time unit.
&nbsp;                 */
<b class="fc">&nbsp;                public AtFixedRate(ScheduledExecutorService scheduledExecutorService, long time, TimeUnit timeUnit) {</b>
<b class="fc">&nbsp;                    this.scheduledExecutorService = scheduledExecutorService;</b>
<b class="fc">&nbsp;                    this.time = time;</b>
<b class="fc">&nbsp;                    this.timeUnit = timeUnit;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAlive() {
<b class="fc">&nbsp;                    return !scheduledExecutorService.isShutdown();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Cancelable schedule(Runnable job) {
<b class="fc">&nbsp;                    return new Cancelable.ForFuture(scheduledExecutorService.scheduleAtFixedRate(job, time, time, timeUnit));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resubmission scheduler that schedules jobs with a fixed delay.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class WithFixedDelay implements ResubmissionScheduler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The executor service to schedule to.
&nbsp;                 */
&nbsp;                private final ScheduledExecutorService scheduledExecutorService;
&nbsp;
&nbsp;                /**
&nbsp;                 * The time interval to pause between completed jobs.
&nbsp;                 */
&nbsp;                private final long time;
&nbsp;
&nbsp;                /**
&nbsp;                 * The time&#39;s time unit.
&nbsp;                 */
&nbsp;                private final TimeUnit timeUnit;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resubmission scheduler with a fixed delay between job executions.
&nbsp;                 *
&nbsp;                 * @param scheduledExecutorService The executor service to schedule to.
&nbsp;                 * @param time                     The time interval to pause between completed jobs.
&nbsp;                 * @param timeUnit                 The time&#39;s time unit.
&nbsp;                 */
<b class="fc">&nbsp;                public WithFixedDelay(ScheduledExecutorService scheduledExecutorService, long time, TimeUnit timeUnit) {</b>
<b class="fc">&nbsp;                    this.scheduledExecutorService = scheduledExecutorService;</b>
<b class="fc">&nbsp;                    this.time = time;</b>
<b class="fc">&nbsp;                    this.timeUnit = timeUnit;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAlive() {
<b class="fc">&nbsp;                    return !scheduledExecutorService.isShutdown();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Cancelable schedule(Runnable job) {
<b class="nc">&nbsp;                    return new Cancelable.ForFuture(scheduledExecutorService.scheduleWithFixedDelay(job, time, time, timeUnit));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resubmission strategy is responsible for enabling resubmission of types that failed to resubmit.
&nbsp;         */
&nbsp;        protected interface ResubmissionStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon installation of an agent builder.
&nbsp;             *
&nbsp;             * @param instrumentation            The instrumentation instance to use.
&nbsp;             * @param poolStrategy               The pool strategy to use.
&nbsp;             * @param locationStrategy           The location strategy to use.
&nbsp;             * @param descriptionStrategy        The description strategy to use.
&nbsp;             * @param fallbackStrategy           The fallback strategy to use.
&nbsp;             * @param listener                   The listener to use.
&nbsp;             * @param installationListener       The installation listener to use.
&nbsp;             * @param circularityLock            The circularity lock to use.
&nbsp;             * @param matcher                    The matcher to apply for analyzing if a type is to be resubmitted.
&nbsp;             * @param redefinitionStrategy       The redefinition strategy to use.
&nbsp;             * @param redefinitionBatchAllocator The batch allocator to use.
&nbsp;             * @param redefinitionBatchListener  The batch listener to notify.
&nbsp;             * @return A potentially modified listener to apply.
&nbsp;             */
&nbsp;            Installation apply(Instrumentation instrumentation,
&nbsp;                               PoolStrategy poolStrategy,
&nbsp;                               LocationStrategy locationStrategy,
&nbsp;                               DescriptionStrategy descriptionStrategy,
&nbsp;                               FallbackStrategy fallbackStrategy,
&nbsp;                               AgentBuilder.Listener listener,
&nbsp;                               InstallationListener installationListener,
&nbsp;                               CircularityLock circularityLock,
&nbsp;                               RawMatcher matcher,
&nbsp;                               RedefinitionStrategy redefinitionStrategy,
&nbsp;                               RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                               RedefinitionStrategy.Listener redefinitionBatchListener);
&nbsp;
&nbsp;            /**
&nbsp;             * A disabled resubmission strategy.
&nbsp;             */
<b class="fc">&nbsp;            enum Disabled implements ResubmissionStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Installation apply(Instrumentation instrumentation,
&nbsp;                                          PoolStrategy poolStrategy,
&nbsp;                                          LocationStrategy locationStrategy,
&nbsp;                                          DescriptionStrategy descriptionStrategy,
&nbsp;                                          FallbackStrategy fallbackStrategy,
&nbsp;                                          AgentBuilder.Listener listener,
&nbsp;                                          InstallationListener installationListener,
&nbsp;                                          CircularityLock circularityLock,
&nbsp;                                          RawMatcher matcher,
&nbsp;                                          RedefinitionStrategy redefinitionStrategy,
&nbsp;                                          RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                                          RedefinitionStrategy.Listener redefinitionBatchListener) {
<b class="fc">&nbsp;                    return new Installation(listener, installationListener, ResubmissionEnforcer.Disabled.INSTANCE);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An enabled resubmission strategy.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Enabled implements ResubmissionStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * A scheduler that is responsible for resubmission of types.
&nbsp;                 */
&nbsp;                private final ResubmissionScheduler resubmissionScheduler;
&nbsp;
&nbsp;                /**
&nbsp;                 * A matcher to determine resubmissions on errors.
&nbsp;                 */
&nbsp;                private final RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * A matcher to determine resubmissions without errors.
&nbsp;                 */
&nbsp;                private final RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new enabled resubmission strategy.
&nbsp;                 *
&nbsp;                 * @param resubmissionScheduler        A scheduler that is responsible for resubmission of types.
&nbsp;                 * @param resubmissionOnErrorMatcher   A matcher to determine resubmissions on errors.
&nbsp;                 * @param resubmissionImmediateMatcher A matcher to determine resubmissions without errors.
&nbsp;                 */
&nbsp;                protected Enabled(ResubmissionScheduler resubmissionScheduler,
&nbsp;                                  RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher,
<b class="fc">&nbsp;                                  RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher) {</b>
<b class="fc">&nbsp;                    this.resubmissionScheduler = resubmissionScheduler;</b>
<b class="fc">&nbsp;                    this.resubmissionOnErrorMatcher = resubmissionOnErrorMatcher;</b>
<b class="fc">&nbsp;                    this.resubmissionImmediateMatcher = resubmissionImmediateMatcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Installation apply(Instrumentation instrumentation,
&nbsp;                                          PoolStrategy poolStrategy,
&nbsp;                                          LocationStrategy locationStrategy,
&nbsp;                                          DescriptionStrategy descriptionStrategy,
&nbsp;                                          FallbackStrategy fallbackStrategy,
&nbsp;                                          AgentBuilder.Listener listener,
&nbsp;                                          InstallationListener installationListener,
&nbsp;                                          CircularityLock circularityLock,
&nbsp;                                          RawMatcher matcher,
&nbsp;                                          RedefinitionStrategy redefinitionStrategy,
&nbsp;                                          RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                                          RedefinitionStrategy.Listener redefinitionBatchListener) {
<b class="fc">&nbsp;                    if (resubmissionScheduler.isAlive()) {</b>
<b class="fc">&nbsp;                        ConcurrentMap&lt;StorageKey, Set&lt;String&gt;&gt; types = new ConcurrentHashMap&lt;StorageKey, Set&lt;String&gt;&gt;();</b>
<b class="fc">&nbsp;                        Resubmitter resubmitter = new Resubmitter(resubmissionOnErrorMatcher, resubmissionImmediateMatcher, types);</b>
<b class="fc">&nbsp;                        return new Installation(new AgentBuilder.Listener.Compound(resubmitter, listener),</b>
&nbsp;                                new InstallationListener.Compound(new ResubmissionInstallationListener(instrumentation,
&nbsp;                                        resubmissionScheduler,
&nbsp;                                        poolStrategy,
&nbsp;                                        locationStrategy,
&nbsp;                                        descriptionStrategy,
&nbsp;                                        fallbackStrategy,
&nbsp;                                        listener,
&nbsp;                                        circularityLock,
&nbsp;                                        matcher,
&nbsp;                                        redefinitionStrategy,
&nbsp;                                        redefinitionBatchAllocator,
&nbsp;                                        redefinitionBatchListener,
&nbsp;                                        types), installationListener),
&nbsp;                                resubmitter);
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Resubmission scheduler &quot; + resubmissionScheduler + &quot; is not alive&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A handler for resubmissions.
&nbsp;                 */
&nbsp;                protected static class Resubmitter extends AgentBuilder.Listener.Adapter implements ResubmissionEnforcer {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A matcher to determine resubmissions on errors.
&nbsp;                     */
&nbsp;                    private final RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A matcher to determine resubmissions without errors.
&nbsp;                     */
&nbsp;                    private final RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A map of class loaders to their types to resubmit.
&nbsp;                     */
&nbsp;                    private final ConcurrentMap&lt;StorageKey, Set&lt;String&gt;&gt; types;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resubmitter.
&nbsp;                     *
&nbsp;                     * @param resubmissionOnErrorMatcher   A matcher to determine resubmissions on errors.
&nbsp;                     * @param resubmissionImmediateMatcher A matcher to determine resubmissions without errors.
&nbsp;                     * @param types                        A map of class loaders to their types to resubmit.
&nbsp;                     */
&nbsp;                    protected Resubmitter(RedefinitionListenable.ResubmissionOnErrorMatcher resubmissionOnErrorMatcher,
&nbsp;                                          RedefinitionListenable.ResubmissionImmediateMatcher resubmissionImmediateMatcher,
<b class="fc">&nbsp;                                          ConcurrentMap&lt;StorageKey, Set&lt;String&gt;&gt; types) {</b>
<b class="fc">&nbsp;                        this.resubmissionOnErrorMatcher = resubmissionOnErrorMatcher;</b>
<b class="fc">&nbsp;                        this.resubmissionImmediateMatcher = resubmissionImmediateMatcher;</b>
<b class="fc">&nbsp;                        this.types = types;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;GC_UNRELATED_TYPES&quot;, justification = &quot;Cross-comparison is intended.&quot;)
&nbsp;                    public void onError(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, boolean loaded, Throwable throwable) {
<b class="fc">&nbsp;                        if (!loaded &amp;&amp; resubmissionOnErrorMatcher.matches(throwable, typeName, classLoader, module)) {</b>
<b class="fc">&nbsp;                            Set&lt;String&gt; types = this.types.get(new LookupKey(classLoader));</b>
<b class="fc">&nbsp;                            if (types == null) {</b>
<b class="fc">&nbsp;                                types = new ConcurrentHashSet&lt;String&gt;();</b>
<b class="fc">&nbsp;                                Set&lt;String&gt; previous = this.types.putIfAbsent(new StorageKey(classLoader), types);</b>
<b class="fc">&nbsp;                                if (previous != null) {</b>
<b class="nc">&nbsp;                                    types = previous;</b>
&nbsp;                                }
&nbsp;                            }
<b class="fc">&nbsp;                            types.add(typeName);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;GC_UNRELATED_TYPES&quot;, justification = &quot;Cross-comparison is intended.&quot;)
&nbsp;                    public boolean isEnforced(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class&lt;?&gt; classBeingRedefined) {
<b class="nc">&nbsp;                        if (classBeingRedefined == null &amp;&amp; resubmissionImmediateMatcher.matches(typeName, classLoader, module)) {</b>
<b class="nc">&nbsp;                            Set&lt;String&gt; types = this.types.get(new LookupKey(classLoader));</b>
<b class="nc">&nbsp;                            if (types == null) {</b>
<b class="nc">&nbsp;                                types = new ConcurrentHashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;                                Set&lt;String&gt; previous = this.types.putIfAbsent(new StorageKey(classLoader), types);</b>
<b class="nc">&nbsp;                                if (previous != null) {</b>
<b class="nc">&nbsp;                                    types = previous;</b>
&nbsp;                                }
&nbsp;                            }
<b class="nc">&nbsp;                            types.add(typeName);</b>
<b class="nc">&nbsp;                            return true;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A set projection for a {@link ConcurrentHashMap}.
&nbsp;                     *
&nbsp;                     * @param &lt;T&gt; The element type of the set projection.
&nbsp;                     */
&nbsp;                    protected static class ConcurrentHashSet&lt;T&gt; extends AbstractSet&lt;T&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The delegate map.
&nbsp;                         */
&nbsp;                        private final ConcurrentMap&lt;T, Boolean&gt; delegate;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a concurrent hash set.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ConcurrentHashSet() {</b>
<b class="fc">&nbsp;                            delegate = new ConcurrentHashMap&lt;T, Boolean&gt;();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean add(T value) {
<b class="fc">&nbsp;                            return delegate.put(value, Boolean.TRUE) == null;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public boolean remove(Object value) {
<b class="nc">&nbsp;                            return delegate.remove(value) != null;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Iterator&lt;T&gt; iterator() {
<b class="fc">&nbsp;                            return delegate.keySet().iterator();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public int size() {
<b class="nc">&nbsp;                            return delegate.size();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A job that resubmits any matched type that previously failed during transformation.
&nbsp;                 */
&nbsp;                protected static class ResubmissionInstallationListener extends AgentBuilder.InstallationListener.Adapter implements Runnable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumentation instance to use.
&nbsp;                     */
&nbsp;                    private final Instrumentation instrumentation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The resubmission scheduler to use.
&nbsp;                     */
&nbsp;                    private final ResubmissionScheduler resubmissionScheduler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The location strategy to use.
&nbsp;                     */
&nbsp;                    private final LocationStrategy locationStrategy;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The pool strategy to use.
&nbsp;                     */
&nbsp;                    private final PoolStrategy poolStrategy;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The description strategy to use.
&nbsp;                     */
&nbsp;                    private final DescriptionStrategy descriptionStrategy;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The fallback strategy to use.
&nbsp;                     */
&nbsp;                    private final FallbackStrategy fallbackStrategy;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The listener to use.
&nbsp;                     */
&nbsp;                    private final AgentBuilder.Listener listener;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The circularity lock to use.
&nbsp;                     */
&nbsp;                    private final CircularityLock circularityLock;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The matcher to apply for analyzing if a type is to be resubmitted.
&nbsp;                     */
&nbsp;                    private final RawMatcher matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The redefinition strategy to use.
&nbsp;                     */
&nbsp;                    private final RedefinitionStrategy redefinitionStrategy;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The batch allocator to use.
&nbsp;                     */
&nbsp;                    private final BatchAllocator redefinitionBatchAllocator;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The batch listener to notify.
&nbsp;                     */
&nbsp;                    private final Listener redefinitionBatchListener;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A map of class loaders to their types to resubmit.
&nbsp;                     */
&nbsp;                    private final ConcurrentMap&lt;StorageKey, Set&lt;String&gt;&gt; types;
&nbsp;
&nbsp;                    /**
&nbsp;                     * This scheduler&#39;s cancelable or {@code null} if no cancelable was registered.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    private volatile ResubmissionScheduler.Cancelable cancelable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resubmission job.
&nbsp;                     *
&nbsp;                     * @param resubmissionScheduler      The resubmission scheduler to use.
&nbsp;                     * @param instrumentation            The instrumentation instance to use.
&nbsp;                     * @param poolStrategy               The pool strategy to use.
&nbsp;                     * @param locationStrategy           The location strategy to use.
&nbsp;                     * @param descriptionStrategy        The description strategy to use.
&nbsp;                     * @param fallbackStrategy           The fallback strategy to use.
&nbsp;                     * @param listener                   The listener to use.
&nbsp;                     * @param circularityLock            The circularity lock to use.
&nbsp;                     * @param matcher                    The matcher to apply for analyzing if a type is to be resubmitted.
&nbsp;                     * @param redefinitionStrategy       The redefinition strategy to use.
&nbsp;                     * @param redefinitionBatchAllocator The batch allocator to use.
&nbsp;                     * @param redefinitionBatchListener  The batch listener to notify.
&nbsp;                     * @param types                      A map of class loaders to their types to resubmit.
&nbsp;                     */
&nbsp;                    protected ResubmissionInstallationListener(Instrumentation instrumentation,
&nbsp;                                                               ResubmissionScheduler resubmissionScheduler,
&nbsp;                                                               PoolStrategy poolStrategy,
&nbsp;                                                               LocationStrategy locationStrategy,
&nbsp;                                                               DescriptionStrategy descriptionStrategy,
&nbsp;                                                               FallbackStrategy fallbackStrategy,
&nbsp;                                                               AgentBuilder.Listener listener,
&nbsp;                                                               CircularityLock circularityLock,
&nbsp;                                                               RawMatcher matcher,
&nbsp;                                                               RedefinitionStrategy redefinitionStrategy,
&nbsp;                                                               BatchAllocator redefinitionBatchAllocator,
&nbsp;                                                               Listener redefinitionBatchListener,
<b class="fc">&nbsp;                                                               ConcurrentMap&lt;StorageKey, Set&lt;String&gt;&gt; types) {</b>
<b class="fc">&nbsp;                        this.instrumentation = instrumentation;</b>
<b class="fc">&nbsp;                        this.resubmissionScheduler = resubmissionScheduler;</b>
<b class="fc">&nbsp;                        this.poolStrategy = poolStrategy;</b>
<b class="fc">&nbsp;                        this.locationStrategy = locationStrategy;</b>
<b class="fc">&nbsp;                        this.descriptionStrategy = descriptionStrategy;</b>
<b class="fc">&nbsp;                        this.fallbackStrategy = fallbackStrategy;</b>
<b class="fc">&nbsp;                        this.listener = listener;</b>
<b class="fc">&nbsp;                        this.circularityLock = circularityLock;</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
<b class="fc">&nbsp;                        this.redefinitionStrategy = redefinitionStrategy;</b>
<b class="fc">&nbsp;                        this.redefinitionBatchAllocator = redefinitionBatchAllocator;</b>
<b class="fc">&nbsp;                        this.redefinitionBatchListener = redefinitionBatchListener;</b>
<b class="fc">&nbsp;                        this.types = types;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onInstall(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                        cancelable = resubmissionScheduler.schedule(this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void onReset(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="nc">&nbsp;                        ResubmissionScheduler.Cancelable cancelable = this.cancelable;</b>
<b class="nc">&nbsp;                        if (cancelable != null) {</b>
<b class="nc">&nbsp;                            cancelable.cancel();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void run() {
<b class="fc">&nbsp;                        boolean release = circularityLock.acquire();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            RedefinitionStrategy.Collector collector = redefinitionStrategy.make(poolStrategy,</b>
&nbsp;                                    locationStrategy,
&nbsp;                                    descriptionStrategy,
&nbsp;                                    fallbackStrategy,
&nbsp;                                    listener,
&nbsp;                                    matcher,
&nbsp;                                    circularityLock);
<b class="fc">&nbsp;                            Iterator&lt;Map.Entry&lt;StorageKey, Set&lt;String&gt;&gt;&gt; entries = types.entrySet().iterator();</b>
<b class="fc">&nbsp;                            while (entries.hasNext()) {</b>
<b class="fc">&nbsp;                                if (Thread.interrupted()) {</b>
&nbsp;                                    return;
&nbsp;                                }
<b class="fc">&nbsp;                                Map.Entry&lt;StorageKey, Set&lt;String&gt;&gt; entry = entries.next();</b>
<b class="fc">&nbsp;                                ClassLoader classLoader = entry.getKey().get();</b>
<b class="fc">&nbsp;                                if (classLoader != null || entry.getKey().isBootstrapLoader()) {</b>
<b class="fc">&nbsp;                                    Iterator&lt;String&gt; iterator = entry.getValue().iterator();</b>
<b class="fc">&nbsp;                                    while (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                                        if (Thread.interrupted()) {</b>
&nbsp;                                            return;
&nbsp;                                        }
&nbsp;                                        try {
<b class="fc">&nbsp;                                            Class&lt;?&gt; type = Class.forName(iterator.next(), false, classLoader);</b>
<b class="fc">&nbsp;                                            collector.consider(type, !type.isArray()</b>
<b class="fc">&nbsp;                                                    &amp;&amp; !type.isPrimitive()</b>
<b class="fc">&nbsp;                                                    &amp;&amp; (DISPATCHER.isModifiableClass(instrumentation, type)</b>
<b class="fc">&nbsp;                                                    || ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtMost(ClassFileVersion.JAVA_V5)));</b>
<b class="nc">&nbsp;                                        } catch (Throwable ignored) {</b>
&nbsp;                                            /* do nothing */
&nbsp;                                        } finally {
<b class="fc">&nbsp;                                            iterator.remove();</b>
<b class="fc">&nbsp;                                        }</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                } else {</b>
<b class="nc">&nbsp;                                    entries.remove();</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            collector.apply(instrumentation,</b>
&nbsp;                                    redefinitionBatchAllocator,
&nbsp;                                    redefinitionBatchListener,
&nbsp;                                    BatchAllocator.FIRST_BATCH);
&nbsp;                        } finally {
<b class="fc">&nbsp;                            if (release) {</b>
<b class="nc">&nbsp;                                circularityLock.release();</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A key for a class loader that can only be used for looking up a preexisting value but avoids reference management.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class LookupKey {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented class loader.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    private final ClassLoader classLoader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented class loader&#39;s hash code or {@code 0} if this entry represents the bootstrap class loader.
&nbsp;                     */
&nbsp;                    private final int hashCode;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lookup key.
&nbsp;                     *
&nbsp;                     * @param classLoader The represented class loader.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LookupKey(@MaybeNull ClassLoader classLoader) {</b>
<b class="fc">&nbsp;                        this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                        hashCode = System.identityHashCode(classLoader);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode() {
<b class="fc">&nbsp;                        return hashCode;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @SuppressFBWarnings(value = &quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, justification = &quot;Cross-comparison is intended.&quot;)
&nbsp;                    public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                        if (this == other) {</b>
<b class="fc">&nbsp;                            return true;</b>
<b class="fc">&nbsp;                        } else if (other instanceof LookupKey) {</b>
<b class="fc">&nbsp;                            return classLoader == ((LookupKey) other).classLoader;</b>
<b class="fc">&nbsp;                        } else if (other instanceof StorageKey) {</b>
<b class="fc">&nbsp;                            StorageKey storageKey = (StorageKey) other;</b>
<b class="fc">&nbsp;                            return hashCode == storageKey.hashCode &amp;&amp; classLoader == storageKey.get();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A key for a class loader that only weakly references the class loader.
&nbsp;                 */
<b class="fc">&nbsp;                protected static class StorageKey extends WeakReference&lt;ClassLoader&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented class loader&#39;s hash code or {@code 0} if this entry represents the bootstrap class loader.
&nbsp;                     */
&nbsp;                    private final int hashCode;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new storage key.
&nbsp;                     *
&nbsp;                     * @param classLoader The represented class loader or {@code null} for the bootstrap class loader.
&nbsp;                     */
&nbsp;                    protected StorageKey(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;                        super(classLoader);</b>
<b class="fc">&nbsp;                        hashCode = System.identityHashCode(classLoader);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Checks if this reference represents the bootstrap class loader.
&nbsp;                     *
&nbsp;                     * @return {@code true} if this entry represents the bootstrap class loader.
&nbsp;                     */
&nbsp;                    protected boolean isBootstrapLoader() {
<b class="fc">&nbsp;                        return hashCode == 0;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public int hashCode() {
<b class="fc">&nbsp;                        return hashCode;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @SuppressFBWarnings(value = &quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, justification = &quot;Cross-comparison is intended.&quot;)
&nbsp;                    public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                        if (this == other) {</b>
<b class="fc">&nbsp;                            return true;</b>
<b class="fc">&nbsp;                        } else if (other instanceof LookupKey) {</b>
<b class="fc">&nbsp;                            LookupKey lookupKey = (LookupKey) other;</b>
<b class="fc">&nbsp;                            return hashCode == lookupKey.hashCode &amp;&amp; get() == lookupKey.classLoader;</b>
<b class="fc">&nbsp;                        } else if (other instanceof StorageKey) {</b>
<b class="fc">&nbsp;                            StorageKey storageKey = (StorageKey) other;</b>
<b class="fc">&nbsp;                            return hashCode == storageKey.hashCode &amp;&amp; get() == storageKey.get();</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an installation of a resubmission strategy.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Installation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The listener to apply.
&nbsp;                 */
&nbsp;                private final AgentBuilder.Listener listener;
&nbsp;
&nbsp;                /**
&nbsp;                 * The installation listener to apply.
&nbsp;                 */
&nbsp;                private final InstallationListener installationListener;
&nbsp;
&nbsp;                /**
&nbsp;                 * The resubmission enforcer to apply.
&nbsp;                 */
&nbsp;                private final ResubmissionEnforcer resubmissionEnforcer;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new installation.
&nbsp;                 *
&nbsp;                 * @param listener             The listener to apply.
&nbsp;                 * @param installationListener The installation listener to apply.
&nbsp;                 * @param resubmissionEnforcer The resubmission enforcer to apply.
&nbsp;                 */
<b class="fc">&nbsp;                protected Installation(AgentBuilder.Listener listener, InstallationListener installationListener, ResubmissionEnforcer resubmissionEnforcer) {</b>
<b class="fc">&nbsp;                    this.listener = listener;</b>
<b class="fc">&nbsp;                    this.installationListener = installationListener;</b>
<b class="fc">&nbsp;                    this.resubmissionEnforcer = resubmissionEnforcer;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the listener to apply.
&nbsp;                 *
&nbsp;                 * @return The listener to apply.
&nbsp;                 */
&nbsp;                protected AgentBuilder.Listener getListener() {
<b class="fc">&nbsp;                    return listener;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the installation listener to apply.
&nbsp;                 *
&nbsp;                 * @return The installation listener to apply.
&nbsp;                 */
&nbsp;                protected InstallationListener getInstallationListener() {
<b class="fc">&nbsp;                    return installationListener;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the resubmission enforcer to apply.
&nbsp;                 *
&nbsp;                 * @return The resubmission enforcer to apply.
&nbsp;                 */
&nbsp;                protected ResubmissionEnforcer getResubmissionEnforcer() {
<b class="fc">&nbsp;                    return resubmissionEnforcer;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A resubmission enforcer determines if a non-loaded class should be scheduled for resubmission or be treated upon first load.
&nbsp;         */
&nbsp;        protected interface ResubmissionEnforcer {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if a class should be scheduled for resubmission.
&nbsp;             *
&nbsp;             * @param typeName            The name of the instrumented class.
&nbsp;             * @param classLoader         The class loader of the instrumented class or {@code null} if the boot loader.
&nbsp;             * @param module              The module of the instrumented class or {@code null} if the module system is not supported.
&nbsp;             * @param classBeingRedefined The class to be redefined or {@code null} if the current type is loaded for the first time.
&nbsp;             * @return {@code true} if the class should be scheduled for resubmission.
&nbsp;             */
&nbsp;            boolean isEnforced(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class&lt;?&gt; classBeingRedefined);
&nbsp;
&nbsp;            /**
&nbsp;             * A resubmission enforcer that does not consider non-loaded classes.
&nbsp;             */
<b class="fc">&nbsp;            enum Disabled implements ResubmissionEnforcer {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isEnforced(String typeName, @MaybeNull ClassLoader classLoader, @MaybeNull JavaModule module, @MaybeNull Class&lt;?&gt; classBeingRedefined) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interacting with the instrumentation API.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.instrument.Instrumentation&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the supplied type is modifiable.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance available.
&nbsp;             * @param type            The type to check for modifiability.
&nbsp;             * @return {@code true} if the supplied type is modifiable.
&nbsp;             */
&nbsp;            boolean isModifiableClass(Instrumentation instrumentation, Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if retransformation is supported for the supplied instrumentation instance.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance available.
&nbsp;             * @return {@code true} if the supplied instance supports retransformation.
&nbsp;             */
&nbsp;            @JavaDispatcher.Defaults
&nbsp;            boolean isRetransformClassesSupported(Instrumentation instrumentation);
&nbsp;
&nbsp;            /**
&nbsp;             * Retransforms the supplied classes.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use for retransformation.
&nbsp;             * @param type            The types to retransform.
&nbsp;             * @throws UnmodifiableClassException If the supplied classes cannot be retransformed.
&nbsp;             */
&nbsp;            void retransformClasses(Instrumentation instrumentation, Class&lt;?&gt;[] type) throws UnmodifiableClassException;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A collector is responsible for collecting classes that are to be considered for modification.
&nbsp;         */
&nbsp;        protected abstract static class Collector {
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to identify what types to redefine.
&nbsp;             */
&nbsp;            private final RawMatcher matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The pool strategy to use.
&nbsp;             */
&nbsp;            private final PoolStrategy poolStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The location strategy to use.
&nbsp;             */
&nbsp;            protected final LocationStrategy locationStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The description strategy for resolving type descriptions for types.
&nbsp;             */
&nbsp;            private final DescriptionStrategy descriptionStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The listener to notify on transformations.
&nbsp;             */
&nbsp;            protected final AgentBuilder.Listener listener;
&nbsp;
&nbsp;            /**
&nbsp;             * The fallback strategy to apply.
&nbsp;             */
&nbsp;            private final FallbackStrategy fallbackStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The circularity lock to use.
&nbsp;             */
&nbsp;            protected final CircularityLock circularityLock;
&nbsp;
&nbsp;            /**
&nbsp;             * All types that were collected for redefinition.
&nbsp;             */
&nbsp;            protected final List&lt;Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new collector.
&nbsp;             *
&nbsp;             * @param matcher             The matcher to identify what types to redefine.
&nbsp;             * @param poolStrategy        The pool strategy to use.
&nbsp;             * @param locationStrategy    The location strategy to use.
&nbsp;             * @param descriptionStrategy The description strategy for resolving type descriptions for types.
&nbsp;             * @param listener            The listener to notify on transformations.
&nbsp;             * @param fallbackStrategy    The fallback strategy to apply.
&nbsp;             * @param circularityLock     The circularity lock to use.
&nbsp;             */
&nbsp;            protected Collector(RawMatcher matcher,
&nbsp;                                PoolStrategy poolStrategy,
&nbsp;                                LocationStrategy locationStrategy,
&nbsp;                                DescriptionStrategy descriptionStrategy,
&nbsp;                                AgentBuilder.Listener listener,
&nbsp;                                FallbackStrategy fallbackStrategy,
<b class="fc">&nbsp;                                CircularityLock circularityLock) {</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.poolStrategy = poolStrategy;</b>
<b class="fc">&nbsp;                this.locationStrategy = locationStrategy;</b>
<b class="fc">&nbsp;                this.descriptionStrategy = descriptionStrategy;</b>
<b class="fc">&nbsp;                this.listener = listener;</b>
<b class="fc">&nbsp;                this.fallbackStrategy = fallbackStrategy;</b>
<b class="fc">&nbsp;                this.circularityLock = circularityLock;</b>
<b class="fc">&nbsp;                types = new ArrayList&lt;Class&lt;?&gt;&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Considers a loaded class for collection.
&nbsp;             *
&nbsp;             * @param type       The loaded type being considered.
&nbsp;             * @param modifiable {@code true} if the considered type is considered modifiable.
&nbsp;             */
&nbsp;            protected void consider(Class&lt;?&gt; type, boolean modifiable) {
<b class="fc">&nbsp;                JavaModule module = JavaModule.ofType(type);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    TypePool typePool = poolStrategy.typePool(locationStrategy.classFileLocator(type.getClassLoader(), module), type.getClassLoader());</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        doConsider(matcher,</b>
&nbsp;                                listener,
<b class="fc">&nbsp;                                descriptionStrategy.apply(TypeDescription.ForLoadedType.getName(type), type, typePool, circularityLock, type.getClassLoader(), module),</b>
&nbsp;                                type,
&nbsp;                                type,
&nbsp;                                module,
&nbsp;                                modifiable);
<b class="fc">&nbsp;                    } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                        if (descriptionStrategy.isLoadedFirst() &amp;&amp; fallbackStrategy.isFallback(type, throwable)) {</b>
<b class="fc">&nbsp;                            doConsider(matcher,</b>
&nbsp;                                    listener,
<b class="fc">&nbsp;                                    typePool.describe(TypeDescription.ForLoadedType.getName(type)).resolve(),</b>
&nbsp;                                    type,
&nbsp;                                    null,
&nbsp;                                    module,
&nbsp;                                    true);
&nbsp;                        } else {
<b class="fc">&nbsp;                            throw throwable;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                } catch (Throwable throwable) {</b>
&nbsp;                    try {
&nbsp;                        try {
<b class="fc">&nbsp;                            listener.onDiscovery(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);</b>
&nbsp;                        } finally {
<b class="nc">&nbsp;                            try {</b>
<b class="fc">&nbsp;                                listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED, throwable);</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    } catch (Throwable ignored) {</b>
&nbsp;                        // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Does consider the retransformation or redefinition of a loaded type.
&nbsp;             *
&nbsp;             * @param matcher             A type matcher to apply.
&nbsp;             * @param listener            The listener to apply during the consideration.
&nbsp;             * @param typeDescription     The type description of the type being considered.
&nbsp;             * @param type                The loaded type being considered.
&nbsp;             * @param classBeingRedefined The loaded type being considered or {@code null} if it should be considered non-available.
&nbsp;             * @param module              The type&#39;s Java module or {@code null} if the current VM does not support modules.
&nbsp;             * @param modifiable          {@code true} if the considered type is considered modifiable.
&nbsp;             */
&nbsp;            private void doConsider(RawMatcher matcher,
&nbsp;                                    AgentBuilder.Listener listener,
&nbsp;                                    TypeDescription typeDescription,
&nbsp;                                    Class&lt;?&gt; type,
&nbsp;                                    @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                    @MaybeNull JavaModule module,
&nbsp;                                    boolean modifiable) {
<b class="fc">&nbsp;                if (!modifiable || !matcher.matches(typeDescription, type.getClassLoader(), module, classBeingRedefined, type.getProtectionDomain())) {</b>
&nbsp;                    try {
&nbsp;                        try {
<b class="fc">&nbsp;                            listener.onDiscovery(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, classBeingRedefined != null);</b>
<b class="fc">&nbsp;                            listener.onIgnored(typeDescription, type.getClassLoader(), module, classBeingRedefined != null);</b>
<b class="fc">&nbsp;                        } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                            listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, classBeingRedefined != null, throwable);</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, classBeingRedefined != null);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    } catch (Throwable ignored) {</b>
&nbsp;                        // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
<b class="fc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    types.add(type);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies all types that this collector collected.
&nbsp;             *
&nbsp;             * @param instrumentation            The instrumentation instance to apply changes to.
&nbsp;             * @param redefinitionBatchAllocator The redefinition batch allocator to use.
&nbsp;             * @param redefinitionListener       The redefinition listener to use.
&nbsp;             * @param batch                      The next batch&#39;s index.
&nbsp;             * @return The next batch&#39;s index after this application.
&nbsp;             */
&nbsp;            protected int apply(Instrumentation instrumentation,
&nbsp;                                BatchAllocator redefinitionBatchAllocator,
&nbsp;                                Listener redefinitionListener,
&nbsp;                                int batch) {
<b class="fc">&nbsp;                Map&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt; failures = new HashMap&lt;List&lt;Class&lt;?&gt;&gt;, Throwable&gt;();</b>
<b class="fc">&nbsp;                PrependableIterator prependableIterator = new PrependableIterator(redefinitionBatchAllocator.batch(this.types));</b>
<b class="fc">&nbsp;                while (prependableIterator.hasNext()) {</b>
<b class="fc">&nbsp;                    List&lt;Class&lt;?&gt;&gt; types = prependableIterator.next();</b>
<b class="fc">&nbsp;                    redefinitionListener.onBatch(batch, types, this.types);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        doApply(instrumentation, types);</b>
<b class="fc">&nbsp;                    } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                        prependableIterator.prepend(redefinitionListener.onError(batch, types, throwable, this.types));</b>
<b class="fc">&nbsp;                        failures.put(types, throwable);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    batch += 1;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                redefinitionListener.onComplete(batch, types, failures);</b>
<b class="fc">&nbsp;                return batch;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this collector.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to apply the transformation for.
&nbsp;             * @param types           The types of the current patch to transform.
&nbsp;             * @throws UnmodifiableClassException If a class is not modifiable.
&nbsp;             * @throws ClassNotFoundException     If a class could not be found.
&nbsp;             */
&nbsp;            protected abstract void doApply(Instrumentation instrumentation,
&nbsp;                                            List&lt;Class&lt;?&gt;&gt; types) throws UnmodifiableClassException, ClassNotFoundException;
&nbsp;
&nbsp;            /**
&nbsp;             * An iterator that allows prepending of iterables to be applied previous to another iterator.
&nbsp;             */
&nbsp;            protected static class PrependableIterator implements Iterator&lt;List&lt;Class&lt;?&gt;&gt;&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The current iterator.
&nbsp;                 */
&nbsp;                private Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; current;
&nbsp;
&nbsp;                /**
&nbsp;                 * The backlog of iterators to apply.
&nbsp;                 */
&nbsp;                private final List&lt;Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt; backlog;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new prependable iterator.
&nbsp;                 *
&nbsp;                 * @param origin The original iterable to begin with.
&nbsp;                 */
<b class="fc">&nbsp;                protected PrependableIterator(Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; origin) {</b>
<b class="fc">&nbsp;                    current = origin.iterator();</b>
<b class="fc">&nbsp;                    backlog = new ArrayList&lt;Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt;&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Prepends an iterable to the backlog.
&nbsp;                 *
&nbsp;                 * @param iterable The iterable to prepend.
&nbsp;                 */
&nbsp;                public void prepend(Iterable&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; iterable) {
<b class="fc">&nbsp;                    Iterator&lt;? extends List&lt;Class&lt;?&gt;&gt;&gt; iterator = iterable.iterator();</b>
<b class="fc">&nbsp;                    if (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                        if (current.hasNext()) {</b>
<b class="nc">&nbsp;                            backlog.add(current);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        current = iterator;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean hasNext() {
<b class="fc">&nbsp;                    return current.hasNext();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;Class&lt;?&gt;&gt; next() {
&nbsp;                    try {
<b class="fc">&nbsp;                        return current.next();</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        while (!current.hasNext() &amp;&amp; !backlog.isEmpty()) {</b>
<b class="nc">&nbsp;                            current = backlog.remove(backlog.size() - 1);</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void remove() {
<b class="nc">&nbsp;                    throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A collector that applies a &lt;b&gt;redefinition&lt;/b&gt; of already loaded classes.
&nbsp;             */
&nbsp;            protected static class ForRedefinition extends Collector {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new collector for redefinition.
&nbsp;                 *
&nbsp;                 * @param matcher             The matcher to identify what types to redefine.
&nbsp;                 * @param poolStrategy        The pool strategy to use.
&nbsp;                 * @param locationStrategy    The location strategy to use.
&nbsp;                 * @param descriptionStrategy The description strategy for resolving type descriptions for types.
&nbsp;                 * @param listener            The listener to notify on transformations.
&nbsp;                 * @param fallbackStrategy    The fallback strategy to apply.
&nbsp;                 * @param circularityLock     The circularity lock to use.
&nbsp;                 */
&nbsp;                protected ForRedefinition(RawMatcher matcher,
&nbsp;                                          PoolStrategy poolStrategy,
&nbsp;                                          LocationStrategy locationStrategy,
&nbsp;                                          DescriptionStrategy descriptionStrategy,
&nbsp;                                          AgentBuilder.Listener listener,
&nbsp;                                          FallbackStrategy fallbackStrategy,
&nbsp;                                          CircularityLock circularityLock) {
<b class="fc">&nbsp;                    super(matcher, poolStrategy, locationStrategy, descriptionStrategy, listener, fallbackStrategy, circularityLock);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void doApply(Instrumentation instrumentation,
&nbsp;                                       List&lt;Class&lt;?&gt;&gt; types) throws UnmodifiableClassException, ClassNotFoundException {
<b class="fc">&nbsp;                    List&lt;ClassDefinition&gt; classDefinitions = new ArrayList&lt;ClassDefinition&gt;(types.size());</b>
<b class="fc">&nbsp;                    for (Class&lt;?&gt; type : types) {</b>
&nbsp;                        try {
&nbsp;                            try {
<b class="fc">&nbsp;                                classDefinitions.add(new ClassDefinition(type, locationStrategy.classFileLocator(type.getClassLoader(), JavaModule.ofType(type))</b>
<b class="fc">&nbsp;                                        .locate(TypeDescription.ForLoadedType.getName(type))</b>
<b class="fc">&nbsp;                                        .resolve()));</b>
<b class="nc">&nbsp;                            } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                                JavaModule module = JavaModule.ofType(type);</b>
&nbsp;                                try {
<b class="nc">&nbsp;                                    listener.onDiscovery(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);</b>
&nbsp;                                } finally {
<b class="nc">&nbsp;                                    try {</b>
<b class="nc">&nbsp;                                        listener.onError(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED, throwable);</b>
&nbsp;                                    } finally {
<b class="nc">&nbsp;                                        listener.onComplete(TypeDescription.ForLoadedType.getName(type), type.getClassLoader(), module, AgentBuilder.Listener.LOADED);</b>
<b class="nc">&nbsp;                                    }</b>
<b class="nc">&nbsp;                                }</b>
<b class="fc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } catch (Throwable ignored) {</b>
&nbsp;                            // Ignore exceptions that are thrown by listeners to mimic the behavior of a transformation.
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    if (!classDefinitions.isEmpty()) {</b>
<b class="fc">&nbsp;                        circularityLock.release();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            instrumentation.redefineClasses(classDefinitions.toArray(new ClassDefinition[0]));</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            circularityLock.acquire();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A collector that applies a &lt;b&gt;retransformation&lt;/b&gt; of already loaded classes.
&nbsp;             */
&nbsp;            protected static class ForRetransformation extends Collector {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a collector to apply a retransformation.
&nbsp;                 *
&nbsp;                 * @param matcher             The matcher to identify what types to redefine.
&nbsp;                 * @param poolStrategy        The pool strategy to use.
&nbsp;                 * @param locationStrategy    The location strategy to use.
&nbsp;                 * @param descriptionStrategy The description strategy for resolving type descriptions for types.
&nbsp;                 * @param listener            The listener to notify on transformations.
&nbsp;                 * @param fallbackStrategy    The fallback strategy to apply.
&nbsp;                 * @param circularityLock     The circularity lock to use.
&nbsp;                 */
&nbsp;                protected ForRetransformation(RawMatcher matcher,
&nbsp;                                              PoolStrategy poolStrategy,
&nbsp;                                              LocationStrategy locationStrategy,
&nbsp;                                              DescriptionStrategy descriptionStrategy,
&nbsp;                                              AgentBuilder.Listener listener,
&nbsp;                                              FallbackStrategy fallbackStrategy,
&nbsp;                                              CircularityLock circularityLock) {
<b class="fc">&nbsp;                    super(matcher, poolStrategy, locationStrategy, descriptionStrategy, listener, fallbackStrategy, circularityLock);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void doApply(Instrumentation instrumentation,
&nbsp;                                       List&lt;Class&lt;?&gt;&gt; types) throws UnmodifiableClassException {
<b class="fc">&nbsp;                    if (!types.isEmpty()) {</b>
<b class="fc">&nbsp;                        circularityLock.release();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            DISPATCHER.retransformClasses(instrumentation, types.toArray(new Class&lt;?&gt;[0]));</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            circularityLock.acquire();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Implements the instrumentation of the {@code LambdaMetafactory} if this feature is enabled.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Warning&lt;/b&gt;: This feature is not recommended for production systems but only for experiments or debugging
&nbsp;     * purposes. It might no longer work in a future release and makes assumptions over JVM-internal API.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
<b class="fc">&nbsp;    enum LambdaInstrumentationStrategy {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy that enables instrumentation of the {@code LambdaMetafactory} if such a factory exists on the current VM.
&nbsp;         * Classes representing lambda expressions that are created by Byte Buddy are fully compatible to those created by
&nbsp;         * the JVM and can be serialized or deserialized to one another. The classes do however show a few differences:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;Byte Buddy&#39;s classes are public with a public executing transformer. Doing so, it is not necessary to instantiate a
&nbsp;         * non-capturing lambda expression by reflection. This is done because Byte Buddy is not necessarily capable
&nbsp;         * of using reflection due to an active security manager.&lt;/li&gt;
&nbsp;         * &lt;li&gt;Byte Buddy&#39;s classes are not marked as synthetic as an agent builder does not instrument synthetic classes
&nbsp;         * by default.&lt;/li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         */
<b class="fc">&nbsp;        ENABLED {</b>
&nbsp;            @Override
&nbsp;            protected void apply(ByteBuddy byteBuddy,
&nbsp;                                 Instrumentation instrumentation,
&nbsp;                                 ClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                if (LambdaFactory.register(classFileTransformer, new LambdaInstanceFactory(byteBuddy))) {</b>
&nbsp;                    Class&lt;?&gt; lambdaMetaFactory;
&nbsp;                    try {
<b class="nc">&nbsp;                        lambdaMetaFactory = Class.forName(&quot;java.lang.invoke.LambdaMetafactory&quot;);</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
&nbsp;                        return;
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    byteBuddy.with(Implementation.Context.Disabled.Factory.INSTANCE)</b>
<b class="nc">&nbsp;                            .redefine(lambdaMetaFactory)</b>
<b class="nc">&nbsp;                            .method(ElementMatchers.&lt;MethodDescription&gt;isPublic().and(named(&quot;metafactory&quot;)))</b>
<b class="nc">&nbsp;                            .intercept(new Implementation.Simple(LambdaMetafactoryFactory.REGULAR))</b>
<b class="nc">&nbsp;                            .method(ElementMatchers.&lt;MethodDescription&gt;isPublic().and(named(&quot;altMetafactory&quot;)))</b>
<b class="nc">&nbsp;                            .intercept(new Implementation.Simple(LambdaMetafactoryFactory.ALTERNATIVE))</b>
<b class="nc">&nbsp;                            .make()</b>
<b class="nc">&nbsp;                            .load(lambdaMetaFactory.getClassLoader(), ClassReloadingStrategy.of(instrumentation));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected boolean isInstrumented(@MaybeNull Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy that does not instrument the {@code LambdaMetafactory}.
&nbsp;         */
<b class="fc">&nbsp;        DISABLED {</b>
&nbsp;            @Override
&nbsp;            protected void apply(ByteBuddy byteBuddy,
&nbsp;                                 Instrumentation instrumentation,
&nbsp;                                 ClassFileTransformer classFileTransformer) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected boolean isInstrumented(@MaybeNull Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return type == null || !type.getName().contains(&quot;/&quot;);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Releases the supplied class file transformer when it was built with {@link AgentBuilder#with(LambdaInstrumentationStrategy)} enabled.
&nbsp;         * Subsequently, the class file transformer is no longer applied when a class that represents a lambda expression is created.
&nbsp;         *
&nbsp;         * @param classFileTransformer The class file transformer to release.
&nbsp;         * @param instrumentation      The instrumentation instance that is used to potentially rollback the instrumentation of the {@code LambdaMetafactory}.
&nbsp;         */
&nbsp;        public static void release(ClassFileTransformer classFileTransformer, Instrumentation instrumentation) {
<b class="nc">&nbsp;            if (LambdaFactory.release(classFileTransformer)) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    ClassReloadingStrategy.of(instrumentation).reset(Class.forName(&quot;java.lang.invoke.LambdaMetafactory&quot;));</b>
<b class="nc">&nbsp;                } catch (Exception exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not release lambda transformer&quot;, exception);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns an enabled lambda instrumentation strategy for {@code true}.
&nbsp;         *
&nbsp;         * @param enabled If lambda instrumentation should be enabled.
&nbsp;         * @return {@code true} if the returned strategy should be enabled.
&nbsp;         */
&nbsp;        public static LambdaInstrumentationStrategy of(boolean enabled) {
<b class="fc">&nbsp;            return enabled</b>
<b class="fc">&nbsp;                    ? ENABLED</b>
<b class="fc">&nbsp;                    : DISABLED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a transformation to lambda instances if applicable.
&nbsp;         *
&nbsp;         * @param byteBuddy            The Byte Buddy instance to use.
&nbsp;         * @param instrumentation      The instrumentation instance for applying a redefinition.
&nbsp;         * @param classFileTransformer The class file transformer to apply.
&nbsp;         */
&nbsp;        protected abstract void apply(ByteBuddy byteBuddy, Instrumentation instrumentation, ClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates if this strategy enables instrumentation of the {@code LambdaMetafactory}.
&nbsp;         *
&nbsp;         * @return {@code true} if this strategy is enabled.
&nbsp;         */
&nbsp;        public boolean isEnabled() {
<b class="fc">&nbsp;            return this == ENABLED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Validates if the supplied class is instrumented. For lambda types (which are loaded by anonymous class loader), this method
&nbsp;         * should return false if lambda instrumentation is disabled.
&nbsp;         *
&nbsp;         * @param type The redefined type or {@code null} if no such type exists.
&nbsp;         * @return {@code true} if the supplied type should be instrumented according to this strategy.
&nbsp;         */
&nbsp;        protected abstract boolean isInstrumented(@MaybeNull Class&lt;?&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for rewriting the JDK&#39;s {@code java.lang.invoke.LambdaMetafactory} methods for use with Byte Buddy. The code that is
&nbsp;         * created by this factory is roughly equivalent to the following:
&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;         * public static CallSite metafactory(MethodHandles.Lookup caller,
&nbsp;         *                                    String interfaceMethodName,
&nbsp;         *                                    MethodType factoryType,
&nbsp;         *                                    MethodType interfaceMethodType,
&nbsp;         *                                    MethodHandle implementation,
&nbsp;         *                                    MethodType dynamicMethodType) throws Exception {
&nbsp;         *   boolean serializable = false;
&nbsp;         *  {@code List&lt;Class&lt;?&gt;&gt;} markerInterfaces = Collections.emptyList();
&nbsp;         *  {@code List&lt;MethodType&gt;} additionalBridges = Collections.emptyList();
&nbsp;         *   byte[] binaryRepresentation = (byte[]) ClassLoader.getSystemClassLoader().loadClass(&quot;net.bytebuddy.agent.builder.LambdaFactory&quot;).getDeclaredMethod(&quot;make&quot;,
&nbsp;         *     Object.class,
&nbsp;         *     String.class,
&nbsp;         *     Object.class,
&nbsp;         *     Object.class,
&nbsp;         *     Object.class,
&nbsp;         *     Object.class,
&nbsp;         *     boolean.class,
&nbsp;         *     List.class,
&nbsp;         *     List.class).invoke(null,
&nbsp;         *       caller,
&nbsp;         *       interfaceMethodName,
&nbsp;         *       factoryType,
&nbsp;         *       interfaceMethodType,
&nbsp;         *       implementation,
&nbsp;         *       dynamicMethodType,
&nbsp;         *       serializable,
&nbsp;         *       markerInterfaces,
&nbsp;         *       additionalBridges);
&nbsp;         *  {@code Class&lt;?&gt;} lambdaClass = ... // loading code
&nbsp;         *   return factoryType.parameterCount() == 0
&nbsp;         *     ? new ConstantCallSite(MethodHandles.constant(factoryType.returnType(), lambdaClass.getDeclaredConstructors()[0].newInstance()))
&nbsp;         *     : new ConstantCallSite(Lookup.IMPL_LOOKUP.findStatic(lambdaClass, &quot;get$Lambda&quot;, factoryType));
&nbsp;         * }
&nbsp;         * &lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;         * The code&#39;s preamble is adjusted for the alternative metafactory to ressemble the following:
&nbsp;         * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;         * public static CallSite altMetafactory(MethodHandles.Lookup caller,
&nbsp;         *                                       String interfaceMethodName,
&nbsp;         *                                       MethodType factoryType,
&nbsp;         *                                       Object... argument) throws Exception {
&nbsp;         *   int flags = (Integer) argument[3];
&nbsp;         *   int index = 4;
&nbsp;         *  {@code Class&lt;?&gt;[]} markerInterface;
&nbsp;         *   if ((flags{@code &amp;} 2) != 0) {
&nbsp;         *     int count = (Integer) argument[index++];
&nbsp;         *     markerInterface = new{@code Class&lt;?&gt;}[count];
&nbsp;         *     System.arraycopy(argument, index, markerInterface, 0, count);
&nbsp;         *     index += count;
&nbsp;         *   } else {
&nbsp;         *     markerInterface = new{@code Class&lt;?&gt;}[0];
&nbsp;         *   }
&nbsp;         *   MethodType[] additionalBridge;
&nbsp;         *   if ((flags{@code &amp;} 2) != 0) {
&nbsp;         *     int count = (Integer) argument[index++];
&nbsp;         *     additionalBridge = new MethodType[count];
&nbsp;         *     System.arraycopy(argument, index, additionalBridge, 0, count);
&nbsp;         *   } else {
&nbsp;         *     additionalBridge = new MethodType[0];
&nbsp;         *   }
&nbsp;         *   MethodType interfaceMethodType = (MethodType) argument[0];
&nbsp;         *   MethodHandle implementation = (MethodHandle) argument[1];
&nbsp;         *   MethodType dynamicMethodType = (MethodType) argument[2];
&nbsp;         *   boolean serializable = (flags{@code &amp;} 1) != 0;
&nbsp;         *  {@code List&lt;Class&lt;?&gt;&gt;} markerInterfaces = Arrays.asList(markerInterface);
&nbsp;         *  {@code List&lt;MethodType&gt;} additionalBridges = Arrays.asList(additionalBridge);
&nbsp;         *   // ... reminder of method as before
&nbsp;         * }
&nbsp;         * &lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;         */
<b class="fc">&nbsp;        protected enum LambdaMetafactoryFactory implements ByteCodeAppender {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Implements the {@code java.lang.invoke.LambdaMetafactory#metafactory} method.
&nbsp;             */
<b class="fc">&nbsp;            REGULAR(6, 11) {</b>
&nbsp;                @Override
&nbsp;                protected void onDispatch(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 6);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Collections&quot;, &quot;emptyList&quot;, &quot;()Ljava/util/List;&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Collections&quot;, &quot;emptyList&quot;, &quot;()Ljava/util/List;&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_APPEND, 3, new Object[]{Opcodes.INTEGER, &quot;java/util/List&quot;, &quot;java/util/List&quot;}, 0, null);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Implements the {@code java.lang.invoke.LambdaMetafactory#altMetafactory} method.
&nbsp;             */
<b class="fc">&nbsp;            ALTERNATIVE(6, 16) {</b>
&nbsp;                @Override
&nbsp;                protected void onDispatch(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/lang/Integer&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Integer&quot;, &quot;intValue&quot;, &quot;()I&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 4);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_4);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 4);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.IAND);</b>
<b class="fc">&nbsp;                    Label first = new Label();</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFEQ, first);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitIincInsn(5, 1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/lang/Integer&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Integer&quot;, &quot;intValue&quot;, &quot;()I&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Class&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 6);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 6);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/System&quot;, &quot;arraycopy&quot;, &quot;(Ljava/lang/Object;ILjava/lang/Object;II)V&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.IADD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 5);</b>
<b class="fc">&nbsp;                    Label second = new Label();</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.GOTO, second);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(first);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_APPEND, 2, new Object[]{Opcodes.INTEGER, Opcodes.INTEGER}, 0, null);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Class&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 6);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(second);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[]{&quot;[Ljava/lang/Class;&quot;}, 0, null);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 4);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.IAND);</b>
<b class="fc">&nbsp;                    Label third = new Label();</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFEQ, third);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitIincInsn(5, 1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/lang/Integer&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Integer&quot;, &quot;intValue&quot;, &quot;()I&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/invoke/MethodType&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/System&quot;, &quot;arraycopy&quot;, &quot;(Ljava/lang/Object;ILjava/lang/Object;II)V&quot;, false);</b>
<b class="fc">&nbsp;                    Label forth = new Label();</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.GOTO, forth);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(third);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/invoke/MethodType&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(forth);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[]{&quot;[Ljava/lang/invoke/MethodType;&quot;}, 0, null);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/lang/invoke/MethodType&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/lang/invoke/MethodHandle&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 9);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;java/lang/invoke/MethodType&quot;);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 4);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.IAND);</b>
<b class="fc">&nbsp;                    Label fifth = new Label();</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.IFEQ, fifth);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                    Label sixth = new Label();</b>
<b class="fc">&nbsp;                    methodVisitor.visitJumpInsn(Opcodes.GOTO, sixth);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(fifth);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_APPEND, 3, new Object[]{&quot;java/lang/invoke/MethodType&quot;, &quot;java/lang/invoke/MethodHandle&quot;, &quot;java/lang/invoke/MethodType&quot;}, 0, null);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(sixth);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]{Opcodes.INTEGER});</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 11);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 6);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;asList&quot;, &quot;([Ljava/lang/Object;)Ljava/util/List;&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 12);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/util/Arrays&quot;, &quot;asList&quot;, &quot;([Ljava/lang/Object;)Ljava/util/List;&quot;, false);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 13);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 3);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 4);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 5);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ILOAD, 11);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ISTORE, 6);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 12);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 7);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ALOAD, 13);</b>
<b class="fc">&nbsp;                    methodVisitor.visitVarInsn(Opcodes.ASTORE, 8);</b>
<b class="fc">&nbsp;                    methodVisitor.visitFrame(Opcodes.F_FULL, 9, new Object[]{&quot;java/lang/invoke/MethodHandles$Lookup&quot;,</b>
&nbsp;                            &quot;java/lang/String&quot;,
&nbsp;                            &quot;java/lang/invoke/MethodType&quot;,
&nbsp;                            &quot;java/lang/invoke/MethodType&quot;,
&nbsp;                            &quot;java/lang/invoke/MethodHandle&quot;,
&nbsp;                            &quot;java/lang/invoke/MethodType&quot;,
&nbsp;                            Opcodes.INTEGER,
&nbsp;                            &quot;java/util/List&quot;,
&nbsp;                            &quot;java/util/List&quot;}, 0, null);
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * A loader for the generated lambda class.
&nbsp;             */
<b class="fc">&nbsp;            private static final Loader LOADER = resolve();</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the loader for the current VM.
&nbsp;             *
&nbsp;             * @return An appropriate loader.
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = {&quot;DE_MIGHT_IGNORE&quot;, &quot;REC_CATCH_EXCEPTION&quot;}, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;            private static Loader resolve() {
&nbsp;                try {
<b class="fc">&nbsp;                    Class&lt;?&gt; type = Class.forName(&quot;java.lang.invoke.MethodHandles$Lookup&quot;, false, null);</b>
<b class="fc">&nbsp;                    type.getMethod(&quot;defineHiddenClass&quot;,</b>
&nbsp;                            byte[].class,
&nbsp;                            boolean.class,
<b class="fc">&nbsp;                            Class.forName(&quot;[Ljava.lang.invoke.MethodHandles$Lookup$ClassOption;&quot;, false, null));</b>
<b class="fc">&nbsp;                    type.getMethod(&quot;defineHiddenClassWithClassData&quot;,</b>
&nbsp;                            byte[].class,
&nbsp;                            Object.class,
&nbsp;                            boolean.class,
<b class="fc">&nbsp;                            Class.forName(&quot;[Ljava.lang.invoke.MethodHandles$Lookup$ClassOption;&quot;, false, null));</b>
<b class="fc">&nbsp;                    return Loader.UsingMethodHandleLookup.INSTANCE;</b>
<b class="nc">&nbsp;                } catch (Exception ignored) {</b>
&nbsp;                    /* do nothing */
&nbsp;                }
<b class="nc">&nbsp;                for (Loader.UsingUnsafe loader : Loader.UsingUnsafe.values()) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        Class.forName(loader.getType().replace(&#39;/&#39;, &#39;.&#39;),</b>
&nbsp;                                false,
<b class="nc">&nbsp;                                null).getMethod(&quot;defineAnonymousClass&quot;, Class.class, byte[].class, Object[].class);</b>
<b class="nc">&nbsp;                        return loader;</b>
<b class="nc">&nbsp;                    } catch (Exception ignored) {</b>
&nbsp;                        /* do nothing */
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return Loader.Unavailable.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The required stack size for this factory.
&nbsp;             */
&nbsp;            private final int stackSize;
&nbsp;
&nbsp;            /**
&nbsp;             * The required local variable length for this factory.
&nbsp;             */
&nbsp;            private final int localVariableLength;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new factory.
&nbsp;             *
&nbsp;             * @param stackSize           The required stack size for this factory.
&nbsp;             * @param localVariableLength The required local variable length for this factory.
&nbsp;             */
<b class="fc">&nbsp;            LambdaMetafactoryFactory(int stackSize, int localVariableLength) {</b>
<b class="fc">&nbsp;                this.stackSize = stackSize;</b>
<b class="fc">&nbsp;                this.localVariableLength = localVariableLength;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                onDispatch(methodVisitor);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/ClassLoader&quot;, &quot;getSystemClassLoader&quot;, &quot;()Ljava/lang/ClassLoader;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(&quot;net.bytebuddy.agent.builder.LambdaFactory&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/ClassLoader&quot;, &quot;loadClass&quot;, &quot;(Ljava/lang/String;)Ljava/lang/Class;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(&quot;make&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 9);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Class&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/lang/Object;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/lang/String;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/lang/Object;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_3);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/lang/Object;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_4);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/lang/Object;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_5);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/lang/Object;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 6);</b>
<b class="fc">&nbsp;                methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/Boolean&quot;, &quot;TYPE&quot;, &quot;Ljava/lang/Class;&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 7);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/util/List;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 8);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(Type.getType(&quot;Ljava/util/List;&quot;));</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Class&quot;, &quot;getDeclaredMethod&quot;, &quot;(Ljava/lang/String;[Ljava/lang/Class;)Ljava/lang/reflect/Method;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 9);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Object&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_3);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 3);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_4);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 4);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_5);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 5);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 6);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ILOAD, 6);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/Boolean&quot;, &quot;valueOf&quot;, &quot;(Z)Ljava/lang/Boolean;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 7);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 7);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitIntInsn(Opcodes.BIPUSH, 8);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 8);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/reflect/Method&quot;, &quot;invoke&quot;, &quot;(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, &quot;[B&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ASTORE, 9);</b>
<b class="fc">&nbsp;                LOADER.apply(methodVisitor);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodType&quot;, &quot;parameterCount&quot;, &quot;()I&quot;, false);</b>
<b class="fc">&nbsp;                Label first = new Label();</b>
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.IFNE, first);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.NEW, &quot;java/lang/invoke/ConstantCallSite&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodType&quot;, &quot;returnType&quot;, &quot;()Ljava/lang/Class;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/Class&quot;, &quot;getDeclaredConstructors&quot;, &quot;()[Ljava/lang/reflect/Constructor;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/Object&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/reflect/Constructor&quot;, &quot;newInstance&quot;, &quot;([Ljava/lang/Object;)Ljava/lang/Object;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/invoke/MethodHandles&quot;, &quot;constant&quot;, &quot;(Ljava/lang/Class;Ljava/lang/Object;)Ljava/lang/invoke/MethodHandle;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java/lang/invoke/ConstantCallSite&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/invoke/MethodHandle;)V&quot;, false);</b>
<b class="fc">&nbsp;                Label second = new Label();</b>
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.GOTO, second);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(first);</b>
<b class="fc">&nbsp;                methodVisitor.visitFrame(Opcodes.F_FULL, 11, new Object[]{&quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;java/lang/String&quot;, &quot;java/lang/invoke/MethodType&quot;, &quot;java/lang/invoke/MethodType&quot;, &quot;java/lang/invoke/MethodHandle&quot;, &quot;java/lang/invoke/MethodType&quot;, Opcodes.INTEGER, &quot;java/util/List&quot;, &quot;java/util/List&quot;, &quot;[B&quot;, &quot;java/lang/Class&quot;}, 0, new Object[]{});</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.NEW, &quot;java/lang/invoke/ConstantCallSite&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;IMPL_LOOKUP&quot;, &quot;Ljava/lang/invoke/MethodHandles$Lookup;&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                methodVisitor.visitLdcInsn(&quot;get$Lambda&quot;);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;findStatic&quot;, &quot;(Ljava/lang/Class;Ljava/lang/String;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/MethodHandle;&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL, &quot;java/lang/invoke/ConstantCallSite&quot;, &quot;&lt;init&gt;&quot;, &quot;(Ljava/lang/invoke/MethodHandle;)V&quot;, false);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(second);</b>
<b class="fc">&nbsp;                methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]{&quot;java/lang/invoke/CallSite&quot;});</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                return new Size(Math.max(stackSize, LOADER.getStackSize()), Math.max(localVariableLength, LOADER.getLocalVariableLength()));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon dispatch. As a result, all values that are presented to Byte Buddy&#39;s code generator
&nbsp;             * must be arranged on the stack.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor to use.
&nbsp;             */
&nbsp;            protected abstract void onDispatch(MethodVisitor methodVisitor);
&nbsp;
&nbsp;            /**
&nbsp;             * A loader is responsible for loading a generated class file in the current VM.
&nbsp;             */
&nbsp;            protected interface Loader {
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this loader.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor to use.
&nbsp;                 */
&nbsp;                void apply(MethodVisitor methodVisitor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the stack size that is required to implement this loader.
&nbsp;                 *
&nbsp;                 * @return The stack size that is required to implement this loader.
&nbsp;                 */
&nbsp;                int getStackSize();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the local variable length that is required to implement this loader.
&nbsp;                 *
&nbsp;                 * @return The local variable length that is required to implement this loader.
&nbsp;                 */
&nbsp;                int getLocalVariableLength();
&nbsp;
&nbsp;                /**
&nbsp;                 * An implementation that indicates that no loader is available.
&nbsp;                 */
<b class="fc">&nbsp;                enum Unavailable implements Loader {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;No lambda expression loading strategy available on current VM&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getStackSize() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;No lambda expression loading strategy available on current VM&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getLocalVariableLength() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;No lambda expression loading strategy available on current VM&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A loader that uses a method handle lookup object to load a class. This is implemented as follows:
&nbsp;                 * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;                 * MethodHandleInfo info = caller.revealDirect(implementation);
&nbsp;                 * boolean classData = (Modifier.isProtected(info.getModifiers())
&nbsp;                 *  {@code &amp;&amp;} !VerifyAccess.isSamePackage(caller.lookupClass(), info.getDeclaringClass()))
&nbsp;                 *   || info.getReferenceKind() == Opcodes.H_INVOKESPECIAL;
&nbsp;                 * MethodHandles.Lookup lookup;
&nbsp;                 * if (classData) {
&nbsp;                 *   lookup = caller.defineHiddenClassWithClassData(binaryRepresentation,
&nbsp;                 *     info,
&nbsp;                 *     true,
&nbsp;                 *     MethodHandles.Lookup.ClassOption.NESTMATE,
&nbsp;                 *     MethodHandles.Lookup.ClassOption.STRONG);
&nbsp;                 * } else {
&nbsp;                 *   lookup = caller.defineHiddenClass(binaryRepresentation,
&nbsp;                 *     true,
&nbsp;                 *     MethodHandles.Lookup.ClassOption.NESTMATE,
&nbsp;                 *     MethodHandles.Lookup.ClassOption.STRONG);
&nbsp;                 * }
&nbsp;                 * {@code Class&lt;?&gt;} lambdaClass = lookup.lookupClass();
&nbsp;                 * &lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;                 */
<b class="fc">&nbsp;                enum UsingMethodHandleLookup implements Loader {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 4);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;revealDirect&quot;, &quot;(Ljava/lang/invoke/MethodHandle;)Ljava/lang/invoke/MethodHandleInfo;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/lang/invoke/MethodHandleInfo&quot;, &quot;getModifiers&quot;, &quot;()I&quot;, true);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;java/lang/reflect/Modifier&quot;, &quot;isProtected&quot;, &quot;(I)Z&quot;, false);</b>
<b class="fc">&nbsp;                        Label first = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, first);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;lookupClass&quot;, &quot;()Ljava/lang/Class;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/lang/invoke/MethodHandleInfo&quot;, &quot;getDeclaringClass&quot;, &quot;()Ljava/lang/Class;&quot;, true);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, &quot;sun/invoke/util/VerifyAccess&quot;, &quot;isSamePackage&quot;, &quot;(Ljava/lang/Class;Ljava/lang/Class;)Z&quot;, false);</b>
<b class="fc">&nbsp;                        Label second = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, second);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(first);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_FULL, 11, new Object[]{&quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;java/lang/String&quot;, &quot;java/lang/invoke/MethodType&quot;, &quot;java/lang/invoke/MethodType&quot;, &quot;java/lang/invoke/MethodHandle&quot;, &quot;java/lang/invoke/MethodType&quot;, Opcodes.INTEGER, &quot;java/util/List&quot;, &quot;java/util/List&quot;, &quot;[B&quot;, &quot;java/lang/invoke/MethodHandleInfo&quot;}, 0, new Object[]{});</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, &quot;java/lang/invoke/MethodHandleInfo&quot;, &quot;getReferenceKind&quot;, &quot;()I&quot;, true);</b>
<b class="fc">&nbsp;                        methodVisitor.visitIntInsn(Opcodes.BIPUSH, 7);</b>
<b class="fc">&nbsp;                        Label third = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IF_ICMPNE, third);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(second);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                        Label forth = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.GOTO, forth);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(third);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_SAME, 0, null, 0, null);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(forth);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_SAME1, 0, null, 1, new Object[]{Opcodes.INTEGER});</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ISTORE, 11);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ILOAD, 11);</b>
<b class="fc">&nbsp;                        Label fifth = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, fifth);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                        methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/invoke/MethodHandles$Lookup$ClassOption&quot;);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/invoke/MethodHandles$Lookup$ClassOption&quot;, &quot;NESTMATE&quot;, &quot;Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;&quot;);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/invoke/MethodHandles$Lookup$ClassOption&quot;, &quot;STRONG&quot;, &quot;Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;&quot;);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;defineHiddenClassWithClassData&quot;, &quot;([BLjava/lang/Object;Z[Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;)Ljava/lang/invoke/MethodHandles$Lookup;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 12);</b>
<b class="fc">&nbsp;                        Label sixth = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(sixth);</b>
<b class="fc">&nbsp;                        Label seventh = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.GOTO, seventh);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(fifth);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[]{Opcodes.INTEGER}, 0, null);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_2);</b>
<b class="fc">&nbsp;                        methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, &quot;java/lang/invoke/MethodHandles$Lookup$ClassOption&quot;);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/invoke/MethodHandles$Lookup$ClassOption&quot;, &quot;NESTMATE&quot;, &quot;Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;&quot;);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ICONST_1);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, &quot;java/lang/invoke/MethodHandles$Lookup$ClassOption&quot;, &quot;STRONG&quot;, &quot;Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;&quot;);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;defineHiddenClass&quot;, &quot;([BZ[Ljava/lang/invoke/MethodHandles$Lookup$ClassOption;)Ljava/lang/invoke/MethodHandles$Lookup;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 12);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(seventh);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_APPEND, 1, new Object[]{&quot;java/lang/invoke/MethodHandles$Lookup&quot;}, 0, null);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 12);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;lookupClass&quot;, &quot;()Ljava/lang/Class;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_FULL, 10, new Object[]{&quot;java/lang/invoke/MethodHandles$Lookup&quot;,</b>
&nbsp;                                &quot;java/lang/String&quot;,
&nbsp;                                &quot;java/lang/invoke/MethodType&quot;,
&nbsp;                                &quot;java/lang/invoke/MethodType&quot;,
&nbsp;                                &quot;java/lang/invoke/MethodHandle&quot;,
&nbsp;                                &quot;java/lang/invoke/MethodType&quot;,
&nbsp;                                Opcodes.INTEGER,
&nbsp;                                &quot;java/util/List&quot;,
&nbsp;                                &quot;java/util/List&quot;,
&nbsp;                                &quot;java/lang/Class&quot;}, 0, null);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getStackSize() {
<b class="fc">&nbsp;                        return 8;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getLocalVariableLength() {
<b class="fc">&nbsp;                        return 15;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A loader that is using unsafe API to load a lambda implementation. The code for loading
&nbsp;                 * the class looks similar to the following:
&nbsp;                 * &lt;blockquote&gt;&lt;pre&gt;
&nbsp;                 * Unsafe unsafe = Unsafe.getUnsafe();
&nbsp;                 * {@code Class&lt;?&gt;} lambdaClass = unsafe.defineAnonymousClass(caller.lookupClass(),
&nbsp;                 *   binaryRepresentation,
&nbsp;                 *   null);
&nbsp;                 * unsafe.ensureClassInitialized(lambdaClass);
&nbsp;                 * &lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;                 */
<b class="fc">&nbsp;                enum UsingUnsafe implements Loader {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A loader that uses {@code jdk.internal.misc.Unsafe}.
&nbsp;                     */
<b class="fc">&nbsp;                    JDK_INTERNAL_MISC_UNSAFE(&quot;jdk/internal/misc/Unsafe&quot;),</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A loader that uses {@code sun.misc.Unsafe}.
&nbsp;                     */
<b class="fc">&nbsp;                    SUN_MISC_UNSAFE(&quot;sun/misc/Unsafe&quot;);</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The internal name of the unsafe type.
&nbsp;                     */
&nbsp;                    private final String type;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new loader using unsafe API.
&nbsp;                     *
&nbsp;                     * @param type The internal name of the unsafe type.
&nbsp;                     */
<b class="fc">&nbsp;                    UsingUnsafe(String type) {</b>
<b class="fc">&nbsp;                        this.type = type;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the internal name of the unsafe type.
&nbsp;                     *
&nbsp;                     * @return The internal name of the unsafe type.
&nbsp;                     */
&nbsp;                    protected String getType() {
<b class="nc">&nbsp;                        return type;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, type, &quot;getUnsafe&quot;, &quot;()L&quot; + type + &quot;;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 11);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 11);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, &quot;java/lang/invoke/MethodHandles$Lookup&quot;, &quot;lookupClass&quot;, &quot;()Ljava/lang/Class;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 9);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type, &quot;defineAnonymousClass&quot;, &quot;(Ljava/lang/Class;[B[Ljava/lang/Object;)Ljava/lang/Class;&quot;, false);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 11);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, 10);</b>
<b class="fc">&nbsp;                        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, type, &quot;ensureClassInitialized&quot;, &quot;(Ljava/lang/Class;)V&quot;, false);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getStackSize() {
<b class="fc">&nbsp;                        return 4;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int getLocalVariableLength() {
<b class="fc">&nbsp;                        return 13;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory that creates instances that represent lambda expressions.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class LambdaInstanceFactory {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of a factory for a lambda expression.
&nbsp;             */
&nbsp;            private static final String LAMBDA_FACTORY = &quot;get$Lambda&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * A prefix for a field that represents a property of a lambda expression.
&nbsp;             */
&nbsp;            private static final String FIELD_PREFIX = &quot;arg$&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * The infix to use for naming classes that represent lambda expression. The additional prefix
&nbsp;             * is necessary because the subsequent counter is not sufficient to keep names unique compared
&nbsp;             * to the original factory.
&nbsp;             */
&nbsp;            private static final String LAMBDA_TYPE_INFIX = &quot;$$Lambda$ByteBuddy$&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * A type-safe constant to express that a class is not already loaded when applying a class file transformer.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final Class&lt;?&gt; NOT_PREVIOUSLY_DEFINED = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A counter for naming lambda expressions randomly.
&nbsp;             */
<b class="fc">&nbsp;            private static final AtomicInteger LAMBDA_NAME_COUNTER = new AtomicInteger();</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The Byte Buddy instance to use for creating lambda objects.
&nbsp;             */
&nbsp;            private final ByteBuddy byteBuddy;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new lambda instance factory.
&nbsp;             *
&nbsp;             * @param byteBuddy The Byte Buddy instance to use for creating lambda objects.
&nbsp;             */
<b class="fc">&nbsp;            protected LambdaInstanceFactory(ByteBuddy byteBuddy) {</b>
<b class="fc">&nbsp;                this.byteBuddy = byteBuddy;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this lambda meta factory.
&nbsp;             *
&nbsp;             * @param targetTypeLookup            A lookup context representing the creating class of this lambda expression.
&nbsp;             * @param lambdaMethodName            The name of the lambda expression&#39;s represented method.
&nbsp;             * @param factoryMethodType           The type of the lambda expression&#39;s represented method.
&nbsp;             * @param lambdaMethodType            The type of the lambda expression&#39;s factory method.
&nbsp;             * @param targetMethodHandle          A handle representing the target of the lambda expression&#39;s method.
&nbsp;             * @param specializedLambdaMethodType A specialization of the type of the lambda expression&#39;s represented method.
&nbsp;             * @param serializable                {@code true} if the lambda expression should be serializable.
&nbsp;             * @param markerInterfaces            A list of interfaces for the lambda expression to represent.
&nbsp;             * @param additionalBridges           A list of additional bridge methods to be implemented by the lambda expression.
&nbsp;             * @param classFileTransformers       A collection of class file transformers to apply when creating the class.
&nbsp;             * @return A binary representation of the transformed class file.
&nbsp;             */
&nbsp;            public byte[] make(Object targetTypeLookup,
&nbsp;                               String lambdaMethodName,
&nbsp;                               Object factoryMethodType,
&nbsp;                               Object lambdaMethodType,
&nbsp;                               Object targetMethodHandle,
&nbsp;                               Object specializedLambdaMethodType,
&nbsp;                               boolean serializable,
&nbsp;                               List&lt;Class&lt;?&gt;&gt; markerInterfaces,
&nbsp;                               List&lt;?&gt; additionalBridges,
&nbsp;                               Collection&lt;? extends ClassFileTransformer&gt; classFileTransformers) {
<b class="nc">&nbsp;                JavaConstant.MethodType factoryMethod = JavaConstant.MethodType.ofLoaded(factoryMethodType);</b>
<b class="nc">&nbsp;                JavaConstant.MethodType lambdaMethod = JavaConstant.MethodType.ofLoaded(lambdaMethodType);</b>
<b class="nc">&nbsp;                JavaConstant.MethodHandle targetMethod = JavaConstant.MethodHandle.ofLoaded(targetMethodHandle, targetTypeLookup);</b>
<b class="nc">&nbsp;                JavaConstant.MethodType specializedLambdaMethod = JavaConstant.MethodType.ofLoaded(specializedLambdaMethodType);</b>
<b class="nc">&nbsp;                Class&lt;?&gt; targetType = JavaConstant.MethodHandle.lookupType(targetTypeLookup);</b>
<b class="nc">&nbsp;                String lambdaClassName = targetType.getName() + LAMBDA_TYPE_INFIX + LAMBDA_NAME_COUNTER.incrementAndGet();</b>
<b class="nc">&nbsp;                DynamicType.Builder&lt;?&gt; builder = byteBuddy</b>
<b class="nc">&nbsp;                        .subclass(factoryMethod.getReturnType(), ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="nc">&nbsp;                        .modifiers(TypeManifestation.FINAL, Visibility.PUBLIC)</b>
<b class="nc">&nbsp;                        .implement(markerInterfaces)</b>
<b class="nc">&nbsp;                        .name(lambdaClassName)</b>
<b class="nc">&nbsp;                        .defineConstructor(Visibility.PUBLIC)</b>
<b class="nc">&nbsp;                        .withParameters(factoryMethod.getParameterTypes())</b>
<b class="nc">&nbsp;                        .intercept(ConstructorImplementation.INSTANCE)</b>
<b class="nc">&nbsp;                        .method(named(lambdaMethodName)</b>
<b class="nc">&nbsp;                                .and(takesArguments(lambdaMethod.getParameterTypes()))</b>
<b class="nc">&nbsp;                                .and(returns(lambdaMethod.getReturnType())))</b>
<b class="nc">&nbsp;                        .intercept(new LambdaMethodImplementation(TypeDescription.ForLoadedType.of(targetType), targetMethod, specializedLambdaMethod));</b>
<b class="nc">&nbsp;                int index = 0;</b>
<b class="nc">&nbsp;                for (TypeDescription capturedType : factoryMethod.getParameterTypes()) {</b>
<b class="nc">&nbsp;                    builder = builder.defineField(FIELD_PREFIX + ++index, capturedType, Visibility.PRIVATE, FieldManifestation.FINAL);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                if (!factoryMethod.getParameterTypes().isEmpty()) {</b>
<b class="nc">&nbsp;                    builder = builder.defineMethod(LAMBDA_FACTORY, factoryMethod.getReturnType(), Visibility.PRIVATE, Ownership.STATIC)</b>
<b class="nc">&nbsp;                            .withParameters(factoryMethod.getParameterTypes())</b>
<b class="nc">&nbsp;                            .intercept(FactoryImplementation.INSTANCE);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (serializable) {</b>
<b class="nc">&nbsp;                    if (!markerInterfaces.contains(Serializable.class)) {</b>
<b class="nc">&nbsp;                        builder = builder.implement(Serializable.class);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    builder = builder.defineMethod(&quot;writeReplace&quot;, Object.class, Visibility.PRIVATE)</b>
<b class="nc">&nbsp;                            .intercept(new SerializationImplementation(TypeDescription.ForLoadedType.of(targetType),</b>
<b class="nc">&nbsp;                                    factoryMethod.getReturnType(),</b>
&nbsp;                                    lambdaMethodName,
&nbsp;                                    lambdaMethod,
&nbsp;                                    targetMethod,
<b class="nc">&nbsp;                                    JavaConstant.MethodType.ofLoaded(specializedLambdaMethodType)));</b>
<b class="nc">&nbsp;                } else if (factoryMethod.getReturnType().isAssignableTo(Serializable.class)) {</b>
<b class="nc">&nbsp;                    builder = builder.defineMethod(&quot;readObject&quot;, void.class, Visibility.PRIVATE)</b>
<b class="nc">&nbsp;                            .withParameters(ObjectInputStream.class)</b>
<b class="nc">&nbsp;                            .throwing(NotSerializableException.class)</b>
<b class="nc">&nbsp;                            .intercept(ExceptionMethod.throwing(NotSerializableException.class, &quot;Non-serializable lambda&quot;))</b>
<b class="nc">&nbsp;                            .defineMethod(&quot;writeObject&quot;, void.class, Visibility.PRIVATE)</b>
<b class="nc">&nbsp;                            .withParameters(ObjectOutputStream.class)</b>
<b class="nc">&nbsp;                            .throwing(NotSerializableException.class)</b>
<b class="nc">&nbsp;                            .intercept(ExceptionMethod.throwing(NotSerializableException.class, &quot;Non-serializable lambda&quot;));</b>
&nbsp;                }
<b class="nc">&nbsp;                for (Object additionalBridgeType : additionalBridges) {</b>
<b class="nc">&nbsp;                    JavaConstant.MethodType additionalBridge = JavaConstant.MethodType.ofLoaded(additionalBridgeType);</b>
<b class="nc">&nbsp;                    builder = builder.defineMethod(lambdaMethodName, additionalBridge.getReturnType(), MethodManifestation.BRIDGE, Visibility.PUBLIC)</b>
<b class="nc">&nbsp;                            .withParameters(additionalBridge.getParameterTypes())</b>
<b class="nc">&nbsp;                            .intercept(new BridgeMethodImplementation(lambdaMethodName, lambdaMethod));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                byte[] classFile = builder.make().getBytes();</b>
<b class="nc">&nbsp;                for (ClassFileTransformer classFileTransformer : classFileTransformers) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        byte[] transformedClassFile = classFileTransformer.transform(targetType.getClassLoader(),</b>
<b class="nc">&nbsp;                                lambdaClassName.replace(&#39;.&#39;, &#39;/&#39;),</b>
&nbsp;                                NOT_PREVIOUSLY_DEFINED,
<b class="nc">&nbsp;                                targetType.getProtectionDomain(),</b>
&nbsp;                                classFile);
<b class="nc">&nbsp;                        classFile = transformedClassFile == null</b>
<b class="nc">&nbsp;                                ? classFile</b>
<b class="nc">&nbsp;                                : transformedClassFile;</b>
<b class="nc">&nbsp;                    } catch (Throwable ignored) {</b>
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return classFile;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements a lambda class&#39;s executing transformer.
&nbsp;             */
<b class="nc">&nbsp;            protected enum ConstructorImplementation implements Implementation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A reference to the {@link Object} class&#39;s default executing transformer.
&nbsp;                 */
&nbsp;                private final transient MethodDescription.InDefinedShape objectConstructor;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new executing transformer implementation.
&nbsp;                 */
&nbsp;                ConstructorImplementation() {
&nbsp;                    objectConstructor = TypeDescription.ForLoadedType.of(Object.class).getDeclaredMethods().filter(isConstructor()).getOnly();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="nc">&nbsp;                    return new Appender(implementationTarget.getInstrumentedType().getDeclaredFields());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An appender to implement the executing transformer.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The fields that are declared by the instrumented type.
&nbsp;                     */
&nbsp;                    private final List&lt;FieldDescription.InDefinedShape&gt; declaredFields;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender.
&nbsp;                     *
&nbsp;                     * @param declaredFields The fields that are declared by the instrumented type.
&nbsp;                     */
<b class="nc">&nbsp;                    protected Appender(List&lt;FieldDescription.InDefinedShape&gt; declaredFields) {</b>
<b class="nc">&nbsp;                        this.declaredFields = declaredFields;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                        List&lt;StackManipulation&gt; fieldAssignments = new ArrayList&lt;StackManipulation&gt;(declaredFields.size() * 3);</b>
<b class="nc">&nbsp;                        for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="nc">&nbsp;                            fieldAssignments.add(MethodVariableAccess.loadThis());</b>
<b class="nc">&nbsp;                            fieldAssignments.add(MethodVariableAccess.load(parameterDescription));</b>
<b class="nc">&nbsp;                            fieldAssignments.add(FieldAccess.forField(declaredFields.get(parameterDescription.getIndex())).write());</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        return new Size(new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                                MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                                MethodInvocation.invoke(INSTANCE.objectConstructor),</b>
&nbsp;                                new StackManipulation.Compound(fieldAssignments),
&nbsp;                                MethodReturn.VOID
<b class="nc">&nbsp;                        ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a instance factory for a lambda expression&#39;s class.
&nbsp;             */
<b class="nc">&nbsp;            protected enum FactoryImplementation implements Implementation {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="nc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="nc">&nbsp;                    return new Appender(implementationTarget.getInstrumentedType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An appender for a lambda expression factory.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender.
&nbsp;                     *
&nbsp;                     * @param instrumentedType The instrumented type.
&nbsp;                     */
<b class="nc">&nbsp;                    protected Appender(TypeDescription instrumentedType) {</b>
<b class="nc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                        return new Size(new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                                TypeCreation.of(instrumentedType),</b>
&nbsp;                                Duplication.SINGLE,
<b class="nc">&nbsp;                                MethodVariableAccess.allArgumentsOf(instrumentedMethod),</b>
<b class="nc">&nbsp;                                MethodInvocation.invoke(instrumentedType.getDeclaredMethods().filter(isConstructor()).getOnly()),</b>
&nbsp;                                MethodReturn.REFERENCE
<b class="nc">&nbsp;                        ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements a lambda expression&#39;s functional method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class LambdaMethodImplementation implements Implementation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type that defines the lambda expression.
&nbsp;                 */
&nbsp;                private final TypeDescription targetType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The handle of the target method of the lambda expression.
&nbsp;                 */
&nbsp;                private final JavaConstant.MethodHandle targetMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The specialized type of the lambda method.
&nbsp;                 */
&nbsp;                private final JavaConstant.MethodType specializedLambdaMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a implementation of a lambda expression&#39;s functional method.
&nbsp;                 *
&nbsp;                 * @param targetType              The type that defines the lambda expression.
&nbsp;                 * @param targetMethod            The target method of the lambda expression.
&nbsp;                 * @param specializedLambdaMethod The specialized type of the lambda method.
&nbsp;                 */
&nbsp;                protected LambdaMethodImplementation(TypeDescription targetType,
&nbsp;                                                     JavaConstant.MethodHandle targetMethod,
<b class="nc">&nbsp;                                                     JavaConstant.MethodType specializedLambdaMethod) {</b>
<b class="nc">&nbsp;                    this.targetType = targetType;</b>
<b class="nc">&nbsp;                    this.targetMethod = targetMethod;</b>
<b class="nc">&nbsp;                    this.specializedLambdaMethod = specializedLambdaMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="nc">&nbsp;                    return Appender.of(targetMethod.getOwnerType()</b>
<b class="nc">&nbsp;                                    .getDeclaredMethods()</b>
<b class="nc">&nbsp;                                    .filter(hasMethodName(targetMethod.getName())</b>
<b class="nc">&nbsp;                                            .and(returns(targetMethod.getReturnType()))</b>
<b class="nc">&nbsp;                                            .and(takesArguments(targetMethod.getParameterTypes())))</b>
<b class="nc">&nbsp;                                    .getOnly(),</b>
&nbsp;                            specializedLambdaMethod,
<b class="nc">&nbsp;                            implementationTarget.getInstrumentedType().getDeclaredFields(),</b>
<b class="nc">&nbsp;                            targetMethod.getHandleType(),</b>
&nbsp;                            targetType);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An appender for a lambda expression&#39;s functional method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher using method handle lookup data, if available.
&nbsp;                     */
<b class="nc">&nbsp;                    private static final Dispatcher LOOKUP_DATA_DISPATCHER = dispatcher();</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves the dispatcher to use for special method invocations.
&nbsp;                     *
&nbsp;                     * @return An appropriate dispatcher for the current VM.
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                    private static Dispatcher dispatcher() {
&nbsp;                        try {
<b class="nc">&nbsp;                            Class&lt;?&gt; type = Class.forName(&quot;java.lang.invoke.MethodHandles$Lookup&quot;, false, null);</b>
<b class="nc">&nbsp;                            type.getMethod(&quot;classData&quot;, type, String.class, Class.class);</b>
<b class="nc">&nbsp;                            return new Dispatcher.UsingMethodHandle(new MethodDescription.ForLoadedMethod(Class.forName(&quot;java.lang.invoke.MethodHandle&quot;,</b>
&nbsp;                                    false,
<b class="nc">&nbsp;                                    null).getMethod(&quot;invokeExact&quot;, Object[].class)));</b>
<b class="nc">&nbsp;                        } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                            return Dispatcher.UsingDirectInvocation.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * The target method of the lambda expression.
&nbsp;                     */
&nbsp;                    private final MethodDescription targetMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The specialized type of the lambda method.
&nbsp;                     */
&nbsp;                    private final JavaConstant.MethodType specializedLambdaMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type&#39;s declared fields.
&nbsp;                     */
&nbsp;                    private final List&lt;FieldDescription.InDefinedShape&gt; declaredFields;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The dispatcher to use.
&nbsp;                     */
&nbsp;                    private final Dispatcher dispatcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an appender of a lambda expression&#39;s functional method.
&nbsp;                     *
&nbsp;                     * @param targetMethod            The target method of the lambda expression.
&nbsp;                     * @param specializedLambdaMethod The specialized type of the lambda method.
&nbsp;                     * @param declaredFields          The instrumented type&#39;s declared fields.
&nbsp;                     * @param dispatcher              The dispatcher to use.
&nbsp;                     */
&nbsp;                    protected Appender(MethodDescription targetMethod,
&nbsp;                                       JavaConstant.MethodType specializedLambdaMethod,
&nbsp;                                       List&lt;FieldDescription.InDefinedShape&gt; declaredFields,
<b class="nc">&nbsp;                                       Dispatcher dispatcher) {</b>
<b class="nc">&nbsp;                        this.targetMethod = targetMethod;</b>
<b class="nc">&nbsp;                        this.specializedLambdaMethod = specializedLambdaMethod;</b>
<b class="nc">&nbsp;                        this.declaredFields = declaredFields;</b>
<b class="nc">&nbsp;                        this.dispatcher = dispatcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves an appropriate appender for this lambda expression.
&nbsp;                     *
&nbsp;                     * @param targetMethod            The target method of the lambda expression.
&nbsp;                     * @param specializedLambdaMethod The specialized type of the lambda method.
&nbsp;                     * @param declaredFields          The instrumented type&#39;s declared fields.
&nbsp;                     * @param handleType              The handle type of the lambda expression&#39;s method handle.
&nbsp;                     * @param targetType              The target type that defines the lambda expression.
&nbsp;                     * @return An appropriate byte code appender.
&nbsp;                     */
&nbsp;                    protected static ByteCodeAppender of(MethodDescription targetMethod,
&nbsp;                                                         JavaConstant.MethodType specializedLambdaMethod,
&nbsp;                                                         List&lt;FieldDescription.InDefinedShape&gt; declaredFields,
&nbsp;                                                         JavaConstant.MethodHandle.HandleType handleType,
&nbsp;                                                         TypeDescription targetType) {
<b class="nc">&nbsp;                        return new Appender(targetMethod,</b>
&nbsp;                                specializedLambdaMethod,
&nbsp;                                declaredFields,
<b class="nc">&nbsp;                                handleType == JavaConstant.MethodHandle.HandleType.INVOKE_SPECIAL || !targetMethod.getDeclaringType().asErasure().isVisibleTo(targetType)</b>
<b class="nc">&nbsp;                                        ? LOOKUP_DATA_DISPATCHER</b>
<b class="nc">&nbsp;                                        : Dispatcher.UsingDirectInvocation.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                        List&lt;StackManipulation&gt; fieldAccess = new ArrayList&lt;StackManipulation&gt;(declaredFields.size() * 2 + 1);</b>
<b class="nc">&nbsp;                        for (FieldDescription.InDefinedShape fieldDescription : declaredFields) {</b>
<b class="nc">&nbsp;                            fieldAccess.add(MethodVariableAccess.loadThis());</b>
<b class="nc">&nbsp;                            fieldAccess.add(FieldAccess.forField(fieldDescription).read());</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        List&lt;StackManipulation&gt; parameterAccess = new ArrayList&lt;StackManipulation&gt;(instrumentedMethod.getParameters().size() * 2);</b>
<b class="nc">&nbsp;                        for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="nc">&nbsp;                            parameterAccess.add(MethodVariableAccess.load(parameterDescription));</b>
<b class="nc">&nbsp;                            parameterAccess.add(Assigner.DEFAULT.assign(parameterDescription.getType(),</b>
<b class="nc">&nbsp;                                    specializedLambdaMethod.getParameterTypes().get(parameterDescription.getIndex()).asGenericType(),</b>
&nbsp;                                    Assigner.Typing.DYNAMIC));
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        return new Size(new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                                targetMethod.isConstructor()</b>
<b class="nc">&nbsp;                                        ? new StackManipulation.Compound(TypeCreation.of(targetMethod.getDeclaringType().asErasure()), Duplication.SINGLE)</b>
<b class="nc">&nbsp;                                        : StackManipulation.Trivial.INSTANCE,</b>
<b class="nc">&nbsp;                                dispatcher.initialize(),</b>
&nbsp;                                new StackManipulation.Compound(fieldAccess),
&nbsp;                                new StackManipulation.Compound(parameterAccess),
<b class="nc">&nbsp;                                dispatcher.invoke(targetMethod),</b>
<b class="nc">&nbsp;                                Assigner.DEFAULT.assign(targetMethod.isConstructor()</b>
<b class="nc">&nbsp;                                                ? targetMethod.getDeclaringType().asGenericType()</b>
<b class="nc">&nbsp;                                                : targetMethod.getReturnType(),</b>
<b class="nc">&nbsp;                                        specializedLambdaMethod.getReturnType().asGenericType(),</b>
&nbsp;                                        Assigner.Typing.DYNAMIC),
<b class="nc">&nbsp;                                MethodReturn.of(specializedLambdaMethod.getReturnType())</b>
<b class="nc">&nbsp;                        ).apply(methodVisitor, implementationContext).getMaximalSize(), instrumentedMethod.getStackSize());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for a lambda expression&#39;s implementation.
&nbsp;                     */
&nbsp;                    protected interface Dispatcher {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Initializes this invocation.
&nbsp;                         *
&nbsp;                         * @return A stack manipulation that represents the initialization.
&nbsp;                         */
&nbsp;                        StackManipulation initialize();
&nbsp;
&nbsp;                        /**
&nbsp;                         * Invokes this invocation.
&nbsp;                         *
&nbsp;                         * @param methodDescription A description of the invoked method.
&nbsp;                         * @return A stack manipulation that represents the invocation.
&nbsp;                         */
&nbsp;                        StackManipulation invoke(MethodDescription methodDescription);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An invocation that is using a direct call to the target method.
&nbsp;                         */
<b class="nc">&nbsp;                        enum UsingDirectInvocation implements Dispatcher {</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * The singleton instance.
&nbsp;                             */
<b class="nc">&nbsp;                            INSTANCE;</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public StackManipulation initialize() {
<b class="nc">&nbsp;                                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public StackManipulation invoke(MethodDescription methodDescription) {
<b class="nc">&nbsp;                                return MethodInvocation.invoke(methodDescription);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An invocation that is using an exact invocation of a method handle.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class UsingMethodHandle extends StackManipulation.AbstractBase implements Dispatcher {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A description of {@code java.lang.invoke.MethodHandle#invokeExact(Object...)}.
&nbsp;                             */
&nbsp;                            private final MethodDescription.InDefinedShape invokeExact;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new dispatcher that is using a method handle.
&nbsp;                             *
&nbsp;                             * @param invokeExact A description of {@code java.lang.invoke.MethodHandle#invokeExact(Object...)}.
&nbsp;                             */
<b class="nc">&nbsp;                            protected UsingMethodHandle(MethodDescription.InDefinedShape invokeExact) {</b>
<b class="nc">&nbsp;                                this.invokeExact = invokeExact;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public StackManipulation initialize() {
<b class="nc">&nbsp;                                return this;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public StackManipulation invoke(MethodDescription methodDescription) {
<b class="nc">&nbsp;                                return MethodInvocation.invoke(invokeExact);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="nc">&nbsp;                                methodVisitor.visitLdcInsn(new ConstantDynamic(JavaConstant.Dynamic.DEFAULT_NAME,</b>
&nbsp;                                        &quot;Ljava/lang/invoke/MethodHandle;&quot;,
&nbsp;                                        new Handle(Opcodes.H_INVOKESTATIC,
&nbsp;                                                &quot;java/lang/invoke/MethodHandles&quot;,
&nbsp;                                                &quot;classData&quot;,
&nbsp;                                                &quot;(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/Class;)Ljava/lang/Object;&quot;,
&nbsp;                                                false)));
<b class="nc">&nbsp;                                return new Size(1, 1);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements the {@code writeReplace} method for serializable lambda expressions.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class SerializationImplementation implements Implementation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The lambda expression&#39;s declaring type.
&nbsp;                 */
&nbsp;                private final TypeDescription targetType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The lambda expression&#39;s functional type.
&nbsp;                 */
&nbsp;                private final TypeDescription lambdaType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The lambda expression&#39;s functional method name.
&nbsp;                 */
&nbsp;                private final String lambdaMethodName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method type of the lambda expression&#39;s functional method.
&nbsp;                 */
&nbsp;                private final JavaConstant.MethodType lambdaMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * A handle that references the lambda expressions invocation target.
&nbsp;                 */
&nbsp;                private final JavaConstant.MethodHandle targetMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The specialized method type of the lambda expression&#39;s functional method.
&nbsp;                 */
&nbsp;                private final JavaConstant.MethodType specializedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new implementation for a serializable&#39;s lambda expression&#39;s {@code writeReplace} method.
&nbsp;                 *
&nbsp;                 * @param targetType        The lambda expression&#39;s declaring type.
&nbsp;                 * @param lambdaType        The lambda expression&#39;s functional type.
&nbsp;                 * @param lambdaMethodName  The lambda expression&#39;s functional method name.
&nbsp;                 * @param lambdaMethod      The method type of the lambda expression&#39;s functional method.
&nbsp;                 * @param targetMethod      A handle that references the lambda expressions invocation target.
&nbsp;                 * @param specializedMethod The specialized method type of the lambda expression&#39;s functional method.
&nbsp;                 */
&nbsp;                protected SerializationImplementation(TypeDescription targetType,
&nbsp;                                                      TypeDescription lambdaType,
&nbsp;                                                      String lambdaMethodName,
&nbsp;                                                      JavaConstant.MethodType lambdaMethod,
&nbsp;                                                      JavaConstant.MethodHandle targetMethod,
<b class="nc">&nbsp;                                                      JavaConstant.MethodType specializedMethod) {</b>
<b class="nc">&nbsp;                    this.targetType = targetType;</b>
<b class="nc">&nbsp;                    this.lambdaType = lambdaType;</b>
<b class="nc">&nbsp;                    this.lambdaMethodName = lambdaMethodName;</b>
<b class="nc">&nbsp;                    this.lambdaMethod = lambdaMethod;</b>
<b class="nc">&nbsp;                    this.targetMethod = targetMethod;</b>
<b class="nc">&nbsp;                    this.specializedMethod = specializedMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
&nbsp;                    TypeDescription serializedLambda;
&nbsp;                    try {
<b class="nc">&nbsp;                        serializedLambda = TypeDescription.ForLoadedType.of(Class.forName(&quot;java.lang.invoke.SerializedLambda&quot;));</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot find class for lambda serialization&quot;, exception);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    List&lt;StackManipulation&gt; lambdaArguments = new ArrayList&lt;StackManipulation&gt;(implementationTarget.getInstrumentedType().getDeclaredFields().size());</b>
<b class="nc">&nbsp;                    for (FieldDescription.InDefinedShape fieldDescription : implementationTarget.getInstrumentedType().getDeclaredFields()) {</b>
<b class="nc">&nbsp;                        lambdaArguments.add(new StackManipulation.Compound(MethodVariableAccess.loadThis(),</b>
<b class="nc">&nbsp;                                FieldAccess.forField(fieldDescription).read(),</b>
<b class="nc">&nbsp;                                Assigner.DEFAULT.assign(fieldDescription.getType(), TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class), Assigner.Typing.STATIC)));</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return new ByteCodeAppender.Simple(new StackManipulation.Compound(</b>
<b class="nc">&nbsp;                            TypeCreation.of(serializedLambda),</b>
&nbsp;                            Duplication.SINGLE,
<b class="nc">&nbsp;                            ClassConstant.of(targetType),</b>
<b class="nc">&nbsp;                            new TextConstant(lambdaType.getInternalName()),</b>
&nbsp;                            new TextConstant(lambdaMethodName),
<b class="nc">&nbsp;                            new TextConstant(lambdaMethod.getDescriptor()),</b>
<b class="nc">&nbsp;                            IntegerConstant.forValue(targetMethod.getHandleType().getIdentifier()),</b>
<b class="nc">&nbsp;                            new TextConstant(targetMethod.getOwnerType().getInternalName()),</b>
<b class="nc">&nbsp;                            new TextConstant(targetMethod.getName()),</b>
<b class="nc">&nbsp;                            new TextConstant(targetMethod.getDescriptor()),</b>
<b class="nc">&nbsp;                            new TextConstant(specializedMethod.getDescriptor()),</b>
<b class="nc">&nbsp;                            ArrayFactory.forType(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)).withValues(lambdaArguments),</b>
<b class="nc">&nbsp;                            MethodInvocation.invoke(serializedLambda.getDeclaredMethods().filter(isConstructor()).getOnly()),</b>
&nbsp;                            MethodReturn.REFERENCE
&nbsp;                    ));
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implements an explicit bridge method for a lambda expression.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class BridgeMethodImplementation implements Implementation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the lambda expression&#39;s functional method.
&nbsp;                 */
&nbsp;                private final String lambdaMethodName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The actual type of the lambda expression&#39;s functional method.
&nbsp;                 */
&nbsp;                private final JavaConstant.MethodType lambdaMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new bridge method implementation for a lambda expression.
&nbsp;                 *
&nbsp;                 * @param lambdaMethodName The name of the lambda expression&#39;s functional method.
&nbsp;                 * @param lambdaMethod     The actual type of the lambda expression&#39;s functional method.
&nbsp;                 */
<b class="nc">&nbsp;                protected BridgeMethodImplementation(String lambdaMethodName, JavaConstant.MethodType lambdaMethod) {</b>
<b class="nc">&nbsp;                    this.lambdaMethodName = lambdaMethodName;</b>
<b class="nc">&nbsp;                    this.lambdaMethod = lambdaMethod;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ByteCodeAppender appender(Target implementationTarget) {
<b class="nc">&nbsp;                    return new Appender(implementationTarget.invokeSuper(new MethodDescription.SignatureToken(lambdaMethodName,</b>
<b class="nc">&nbsp;                            lambdaMethod.getReturnType(),</b>
<b class="nc">&nbsp;                            lambdaMethod.getParameterTypes())));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="nc">&nbsp;                    return instrumentedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An appender for implementing a bridge method for a lambda expression.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The invocation of the bridge&#39;s target method.
&nbsp;                     */
&nbsp;                    private final SpecialMethodInvocation bridgeTargetInvocation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new appender for invoking a lambda expression&#39;s bridge method target.
&nbsp;                     *
&nbsp;                     * @param bridgeTargetInvocation The invocation of the bridge&#39;s target method.
&nbsp;                     */
<b class="nc">&nbsp;                    protected Appender(SpecialMethodInvocation bridgeTargetInvocation) {</b>
<b class="nc">&nbsp;                        this.bridgeTargetInvocation = bridgeTargetInvocation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                        return new Compound(new Simple(</b>
<b class="nc">&nbsp;                                MethodVariableAccess.allArgumentsOf(instrumentedMethod)</b>
<b class="nc">&nbsp;                                        .asBridgeOf(bridgeTargetInvocation.getMethodDescription())</b>
<b class="nc">&nbsp;                                        .prependThisReference(),</b>
&nbsp;                                bridgeTargetInvocation,
<b class="nc">&nbsp;                                bridgeTargetInvocation.getMethodDescription().getReturnType().asErasure().isAssignableTo(instrumentedMethod.getReturnType().asErasure())</b>
<b class="nc">&nbsp;                                        ? StackManipulation.Trivial.INSTANCE</b>
<b class="nc">&nbsp;                                        : TypeCasting.to(instrumentedMethod.getReturnType()),</b>
<b class="nc">&nbsp;                                MethodReturn.of(instrumentedMethod.getReturnType())</b>
&nbsp;
<b class="nc">&nbsp;                        )).apply(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines how patching a {@link ResettableClassFileTransformer} resolves the transformer exchange.
&nbsp;     */
<b class="fc">&nbsp;    enum PatchMode {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Allows for a short period where neither class file transformer is registered. This might allow
&nbsp;         * for classes to execute without instrumentation if they are loaded in a short moment where neither
&nbsp;         * transformer is registered. In some rare cases, this might also cause that these classes are not
&nbsp;         * instrumented as a result of the patching.
&nbsp;         */
<b class="fc">&nbsp;        GAP {</b>
&nbsp;            @Override
&nbsp;            protected Handler toHandler(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                return new Handler.ForPatchWithGap(classFileTransformer);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Allows for a short period where both class file transformer are registered. This might allow
&nbsp;         * for classes to apply both instrumentations. In some rare cases, this might also cause that both
&nbsp;         * instrumentations are permanently applied.
&nbsp;         */
<b class="fc">&nbsp;        OVERLAP {</b>
&nbsp;            @Override
&nbsp;            protected Handler toHandler(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                return new Handler.ForPatchWithOverlap(classFileTransformer);</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Requires a {@link net.bytebuddy.agent.builder.ResettableClassFileTransformer.Substitutable} class file
&nbsp;         * transformer which can exchange the actual class file transformer without any overlaps or changes in order.
&nbsp;         * Normally, this can be achieved easily by adding {@link TransformerDecorator.ForSubstitution} as a last
&nbsp;         * decorator prior to installation.
&nbsp;         */
<b class="fc">&nbsp;        SUBSTITUTE {</b>
&nbsp;            @Override
&nbsp;            protected Handler toHandler(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                if (!(classFileTransformer instanceof ResettableClassFileTransformer.Substitutable)) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Original class file transformer is not substitutable: &quot; + classFileTransformer);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Handler.ForPatchWithSubstitution((ResettableClassFileTransformer.Substitutable) classFileTransformer);</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a default patch mode for a given {@link ResettableClassFileTransformer}.
&nbsp;         *
&nbsp;         * @param classFileTransformer The class file transformer to consider.
&nbsp;         * @return A meaningful default patch mode.
&nbsp;         */
&nbsp;        protected static PatchMode of(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;            return classFileTransformer instanceof ResettableClassFileTransformer.Substitutable</b>
<b class="nc">&nbsp;                    ? PatchMode.SUBSTITUTE</b>
<b class="fc">&nbsp;                    : PatchMode.OVERLAP;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this strategy to a handler.
&nbsp;         *
&nbsp;         * @param classFileTransformer The class file transformer to deregister.
&nbsp;         * @return The handler to apply.
&nbsp;         */
&nbsp;        protected abstract Handler toHandler(ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * A handler to allow for callbacks prior and after registering a {@link ClassFileTransformer}.
&nbsp;         */
&nbsp;        protected interface Handler {
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked prior to registering a class file transformer.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation to use.
&nbsp;             */
&nbsp;            void onBeforeRegistration(Instrumentation instrumentation);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon registering a class file transformer.
&nbsp;             *
&nbsp;             * @param classFileTransformer The class file transformer to register.
&nbsp;             * @return {@code true} if a regular registration should be applied to the transformer.
&nbsp;             */
&nbsp;            boolean onRegistration(ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked right after registering a class file transformer.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation to use.
&nbsp;             */
&nbsp;            void onAfterRegistration(Instrumentation instrumentation);
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational handler.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements Handler {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBeforeRegistration(Instrumentation instrumentation) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onAfterRegistration(Instrumentation instrumentation) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for patching by {@link PatchMode#GAP}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForPatchWithGap implements Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file transformer to deregister.
&nbsp;                 */
&nbsp;                private final ResettableClassFileTransformer classFileTransformer;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler.
&nbsp;                 *
&nbsp;                 * @param classFileTransformer The class file transformer to deregister.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForPatchWithGap(ResettableClassFileTransformer classFileTransformer) {</b>
<b class="fc">&nbsp;                    this.classFileTransformer = classFileTransformer;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBeforeRegistration(Instrumentation instrumentation) {
<b class="fc">&nbsp;                    if (!classFileTransformer.reset(instrumentation, RedefinitionStrategy.DISABLED)) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;Failed to deregister patched class file transformer: &quot; + classFileTransformer);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onAfterRegistration(Instrumentation instrumentation) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for patching by {@link PatchMode#OVERLAP}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForPatchWithOverlap implements Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file transformer to deregister.
&nbsp;                 */
&nbsp;                private final ResettableClassFileTransformer classFileTransformer;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler.
&nbsp;                 *
&nbsp;                 * @param classFileTransformer The class file transformer to deregister.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForPatchWithOverlap(ResettableClassFileTransformer classFileTransformer) {</b>
<b class="fc">&nbsp;                    this.classFileTransformer = classFileTransformer;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBeforeRegistration(Instrumentation instrumentation) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onAfterRegistration(Instrumentation instrumentation) {
<b class="fc">&nbsp;                    if (!classFileTransformer.reset(instrumentation, RedefinitionStrategy.DISABLED)) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;Failed to deregister patched class file transformer: &quot; + classFileTransformer);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for patching by {@link PatchMode#SUBSTITUTE}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForPatchWithSubstitution implements Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file transformer to substitute.
&nbsp;                 */
&nbsp;                private final ResettableClassFileTransformer.Substitutable classFileTransformer;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler for substitution.
&nbsp;                 *
&nbsp;                 * @param classFileTransformer The class file transformer to substitute.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForPatchWithSubstitution(ResettableClassFileTransformer.Substitutable classFileTransformer) {</b>
<b class="fc">&nbsp;                    this.classFileTransformer = classFileTransformer;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onBeforeRegistration(Instrumentation instrumentation) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean onRegistration(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                    this.classFileTransformer.substitute(classFileTransformer);</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onAfterRegistration(Instrumentation instrumentation) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * The default implementation of an {@link net.bytebuddy.agent.builder.AgentBuilder}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * By default, Byte Buddy ignores any types loaded by the bootstrap class loader and
&nbsp;     * any synthetic type. Self-injection and rebasing is enabled. In order to avoid class format changes, set
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}. All types are parsed without their debugging information
&nbsp;     * ({@link PoolStrategy.Default#FAST}).
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class Default implements AgentBuilder {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the Byte Buddy {@code net.bytebuddy.agent.Installer} class.
&nbsp;         */
&nbsp;        private static final String INSTALLER_TYPE = &quot;net.bytebuddy.agent.Installer&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the getter for {@code net.bytebuddy.agent.Installer} to read the {@link Instrumentation}.
&nbsp;         */
&nbsp;        private static final String INSTALLER_GETTER = &quot;getInstrumentation&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The value that is to be returned from a {@link java.lang.instrument.ClassFileTransformer} to indicate
&nbsp;         * that no class file transformation is to be applied.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        private static final byte[] NO_TRANSFORMATION = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A type-safe constant to express that a class is not already loaded when applying a class file transformer.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        private static final Class&lt;?&gt; NOT_PREVIOUSLY_DEFINED = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A dipatcher to use for interacting with the instrumentation API.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The default circularity lock that assures that no agent created by any agent builder within this
&nbsp;         * class loader causes a class loading circularity.
&nbsp;         */
<b class="fc">&nbsp;        private static final CircularityLock DEFAULT_LOCK = new CircularityLock.Default();</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link net.bytebuddy.ByteBuddy} instance to be used.
&nbsp;         */
&nbsp;        protected final ByteBuddy byteBuddy;
&nbsp;
&nbsp;        /**
&nbsp;         * The listener to notify on transformations.
&nbsp;         */
&nbsp;        protected final Listener listener;
&nbsp;
&nbsp;        /**
&nbsp;         * The circularity lock to use.
&nbsp;         */
&nbsp;        protected final CircularityLock circularityLock;
&nbsp;
&nbsp;        /**
&nbsp;         * The pool strategy to use.
&nbsp;         */
&nbsp;        protected final PoolStrategy poolStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The definition handler to use.
&nbsp;         */
&nbsp;        protected final TypeStrategy typeStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The location strategy to use.
&nbsp;         */
&nbsp;        protected final LocationStrategy locationStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * A class file locator to be used for additional lookup of globally available types.
&nbsp;         */
&nbsp;        protected final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;        /**
&nbsp;         * The native method strategy to use.
&nbsp;         */
&nbsp;        protected final NativeMethodStrategy nativeMethodStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The warmup strategy to use.
&nbsp;         */
&nbsp;        protected final WarmupStrategy warmupStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * A decorator to wrap the created class file transformer.
&nbsp;         */
&nbsp;        protected final TransformerDecorator transformerDecorator;
&nbsp;
&nbsp;        /**
&nbsp;         * The initialization strategy to use for creating classes.
&nbsp;         */
&nbsp;        protected final InitializationStrategy initializationStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The redefinition strategy to apply.
&nbsp;         */
&nbsp;        protected final RedefinitionStrategy redefinitionStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The discovery strategy for loaded types to be redefined.
&nbsp;         */
&nbsp;        protected final RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The batch allocator for the redefinition strategy to apply.
&nbsp;         */
&nbsp;        protected final RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator;
&nbsp;
&nbsp;        /**
&nbsp;         * The redefinition listener for the redefinition strategy to apply.
&nbsp;         */
&nbsp;        protected final RedefinitionStrategy.Listener redefinitionListener;
&nbsp;
&nbsp;        /**
&nbsp;         * The resubmission strategy to apply.
&nbsp;         */
&nbsp;        protected final RedefinitionStrategy.ResubmissionStrategy redefinitionResubmissionStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The injection strategy for injecting classes into a class loader.
&nbsp;         */
&nbsp;        protected final InjectionStrategy injectionStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy to determine of the {@code LambdaMetafactory} should be instrumented to allow for the instrumentation
&nbsp;         * of classes that represent lambda expressions.
&nbsp;         */
&nbsp;        protected final LambdaInstrumentationStrategy lambdaInstrumentationStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The description strategy for resolving type descriptions for types.
&nbsp;         */
&nbsp;        protected final DescriptionStrategy descriptionStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The fallback strategy to apply.
&nbsp;         */
&nbsp;        protected final FallbackStrategy fallbackStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The class file buffer strategy to use.
&nbsp;         */
&nbsp;        protected final ClassFileBufferStrategy classFileBufferStrategy;
&nbsp;
&nbsp;        /**
&nbsp;         * The installation listener to notify.
&nbsp;         */
&nbsp;        protected final InstallationListener installationListener;
&nbsp;
&nbsp;        /**
&nbsp;         * Identifies types that should not be instrumented.
&nbsp;         */
&nbsp;        protected final RawMatcher ignoreMatcher;
&nbsp;
&nbsp;        /**
&nbsp;         * The transformation object for handling type transformations.
&nbsp;         */
&nbsp;        protected final List&lt;Transformation&gt; transformations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default agent builder that uses a default {@link net.bytebuddy.ByteBuddy} instance for creating classes.
&nbsp;         */
&nbsp;        public Default() {
<b class="fc">&nbsp;            this(new ByteBuddy());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new agent builder with default settings. By default, Byte Buddy ignores any types loaded by the bootstrap class loader, any
&nbsp;         * type within a {@code net.bytebuddy} package and any synthetic type. Self-injection and rebasing is enabled. In order to avoid class format
&nbsp;         * changes, set {@link AgentBuilder#disableClassFormatChanges()}. All types are parsed without their debugging information
&nbsp;         * ({@link PoolStrategy.Default#FAST}).
&nbsp;         *
&nbsp;         * @param byteBuddy The Byte Buddy instance to be used.
&nbsp;         */
&nbsp;        public Default(ByteBuddy byteBuddy) {
<b class="fc">&nbsp;            this(byteBuddy,</b>
&nbsp;                    Listener.NoOp.INSTANCE,
&nbsp;                    DEFAULT_LOCK,
&nbsp;                    PoolStrategy.Default.FAST,
&nbsp;                    TypeStrategy.Default.REBASE,
&nbsp;                    LocationStrategy.ForClassLoader.STRONG,
&nbsp;                    ClassFileLocator.NoOp.INSTANCE,
&nbsp;                    NativeMethodStrategy.Disabled.INSTANCE,
&nbsp;                    WarmupStrategy.NoOp.INSTANCE,
&nbsp;                    TransformerDecorator.NoOp.INSTANCE,
&nbsp;                    new InitializationStrategy.SelfInjection.Split(),
&nbsp;                    RedefinitionStrategy.DISABLED,
&nbsp;                    RedefinitionStrategy.DiscoveryStrategy.SinglePass.INSTANCE,
&nbsp;                    RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE,
&nbsp;                    RedefinitionStrategy.Listener.NoOp.INSTANCE,
&nbsp;                    RedefinitionStrategy.ResubmissionStrategy.Disabled.INSTANCE,
&nbsp;                    InjectionStrategy.UsingReflection.INSTANCE,
&nbsp;                    LambdaInstrumentationStrategy.DISABLED,
&nbsp;                    DescriptionStrategy.Default.HYBRID,
<b class="fc">&nbsp;                    FallbackStrategy.ByThrowableType.ofOptionalTypes(),</b>
&nbsp;                    ClassFileBufferStrategy.Default.RETAINING,
&nbsp;                    InstallationListener.NoOp.INSTANCE,
&nbsp;                    new RawMatcher.Disjunction(
<b class="fc">&nbsp;                            new RawMatcher.ForElementMatchers(any(), isBootstrapClassLoader().or(isExtensionClassLoader())),</b>
<b class="fc">&nbsp;                            new RawMatcher.ForElementMatchers(nameStartsWith(&quot;net.bytebuddy.&quot;)</b>
<b class="fc">&nbsp;                                    .and(not(ElementMatchers.nameStartsWith(NamingStrategy.BYTE_BUDDY_RENAME_PACKAGE + &quot;.&quot;)))</b>
<b class="fc">&nbsp;                                    .or(nameStartsWith(&quot;sun.reflect.&quot;).or(nameStartsWith(&quot;jdk.internal.reflect.&quot;)))</b>
<b class="fc">&nbsp;                                    .&lt;TypeDescription&gt;or(isSynthetic()))),</b>
<b class="fc">&nbsp;                    Collections.&lt;Transformation&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new default agent builder.
&nbsp;         *
&nbsp;         * @param byteBuddy                        The Byte Buddy instance to be used.
&nbsp;         * @param listener                         The listener to notify on transformations.
&nbsp;         * @param circularityLock                  The circularity lock to use.
&nbsp;         * @param poolStrategy                     The pool strategy to use.
&nbsp;         * @param typeStrategy                     The definition handler to use.
&nbsp;         * @param locationStrategy                 The location strategy to use.
&nbsp;         * @param classFileLocator                 A class file locator to be used for additional lookup of globally available types.
&nbsp;         * @param nativeMethodStrategy             The native method strategy to apply.
&nbsp;         * @param warmupStrategy                   The warmup strategy to use.
&nbsp;         * @param transformerDecorator             A decorator to wrap the created class file transformer.
&nbsp;         * @param initializationStrategy           The initialization strategy to use for transformed types.
&nbsp;         * @param redefinitionStrategy             The redefinition strategy to apply.
&nbsp;         * @param redefinitionDiscoveryStrategy    The discovery strategy for loaded types to be redefined.
&nbsp;         * @param redefinitionBatchAllocator       The batch allocator for the redefinition strategy to apply.
&nbsp;         * @param redefinitionListener             The redefinition listener for the redefinition strategy to apply.
&nbsp;         * @param redefinitionResubmissionStrategy The resubmission strategy to apply.
&nbsp;         * @param injectionStrategy                The injection strategy for injecting classes into a class loader.
&nbsp;         * @param lambdaInstrumentationStrategy    A strategy to determine of the {@code LambdaMetafactory} should be instrumented to allow for the
&nbsp;         *                                         instrumentation of classes that represent lambda expressions.
&nbsp;         * @param descriptionStrategy              The description strategy for resolving type descriptions for types.
&nbsp;         * @param fallbackStrategy                 The fallback strategy to apply.
&nbsp;         * @param classFileBufferStrategy          The class file buffer strategy to use.
&nbsp;         * @param installationListener             The installation listener to notify.
&nbsp;         * @param ignoreMatcher                    Identifies types that should not be instrumented.
&nbsp;         * @param transformations                  The transformations to apply for any non-ignored type.
&nbsp;         */
&nbsp;        protected Default(ByteBuddy byteBuddy,
&nbsp;                          Listener listener,
&nbsp;                          CircularityLock circularityLock,
&nbsp;                          PoolStrategy poolStrategy,
&nbsp;                          TypeStrategy typeStrategy,
&nbsp;                          LocationStrategy locationStrategy,
&nbsp;                          ClassFileLocator classFileLocator,
&nbsp;                          NativeMethodStrategy nativeMethodStrategy,
&nbsp;                          WarmupStrategy warmupStrategy,
&nbsp;                          TransformerDecorator transformerDecorator,
&nbsp;                          InitializationStrategy initializationStrategy,
&nbsp;                          RedefinitionStrategy redefinitionStrategy,
&nbsp;                          RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                          RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                          RedefinitionStrategy.Listener redefinitionListener,
&nbsp;                          RedefinitionStrategy.ResubmissionStrategy redefinitionResubmissionStrategy,
&nbsp;                          InjectionStrategy injectionStrategy,
&nbsp;                          LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                          DescriptionStrategy descriptionStrategy,
&nbsp;                          FallbackStrategy fallbackStrategy,
&nbsp;                          ClassFileBufferStrategy classFileBufferStrategy,
&nbsp;                          InstallationListener installationListener,
&nbsp;                          RawMatcher ignoreMatcher,
<b class="fc">&nbsp;                          List&lt;Transformation&gt; transformations) {</b>
<b class="fc">&nbsp;            this.byteBuddy = byteBuddy;</b>
<b class="fc">&nbsp;            this.listener = listener;</b>
<b class="fc">&nbsp;            this.circularityLock = circularityLock;</b>
<b class="fc">&nbsp;            this.poolStrategy = poolStrategy;</b>
<b class="fc">&nbsp;            this.typeStrategy = typeStrategy;</b>
<b class="fc">&nbsp;            this.locationStrategy = locationStrategy;</b>
<b class="fc">&nbsp;            this.classFileLocator = classFileLocator;</b>
<b class="fc">&nbsp;            this.nativeMethodStrategy = nativeMethodStrategy;</b>
<b class="fc">&nbsp;            this.warmupStrategy = warmupStrategy;</b>
<b class="fc">&nbsp;            this.transformerDecorator = transformerDecorator;</b>
<b class="fc">&nbsp;            this.initializationStrategy = initializationStrategy;</b>
<b class="fc">&nbsp;            this.redefinitionStrategy = redefinitionStrategy;</b>
<b class="fc">&nbsp;            this.redefinitionDiscoveryStrategy = redefinitionDiscoveryStrategy;</b>
<b class="fc">&nbsp;            this.redefinitionBatchAllocator = redefinitionBatchAllocator;</b>
<b class="fc">&nbsp;            this.redefinitionListener = redefinitionListener;</b>
<b class="fc">&nbsp;            this.redefinitionResubmissionStrategy = redefinitionResubmissionStrategy;</b>
<b class="fc">&nbsp;            this.injectionStrategy = injectionStrategy;</b>
<b class="fc">&nbsp;            this.lambdaInstrumentationStrategy = lambdaInstrumentationStrategy;</b>
<b class="fc">&nbsp;            this.descriptionStrategy = descriptionStrategy;</b>
<b class="fc">&nbsp;            this.fallbackStrategy = fallbackStrategy;</b>
<b class="fc">&nbsp;            this.classFileBufferStrategy = classFileBufferStrategy;</b>
<b class="fc">&nbsp;            this.installationListener = installationListener;</b>
<b class="fc">&nbsp;            this.ignoreMatcher = ignoreMatcher;</b>
<b class="fc">&nbsp;            this.transformations = transformations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins. As {@link EntryPoint}, {@link EntryPoint.Default#REBASE} is implied.
&nbsp;         *
&nbsp;         * @param plugin The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(Plugin... plugin) {
<b class="fc">&nbsp;            return of(Arrays.asList(plugin));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins. As {@link EntryPoint}, {@link EntryPoint.Default#REBASE} is implied.
&nbsp;         *
&nbsp;         * @param plugins The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(List&lt;? extends Plugin&gt; plugins) {
<b class="fc">&nbsp;            return of(EntryPoint.Default.REBASE, plugins);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins.
&nbsp;         *
&nbsp;         * @param entryPoint The build entry point to use.
&nbsp;         * @param plugin     The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(EntryPoint entryPoint, Plugin... plugin) {
<b class="fc">&nbsp;            return of(entryPoint, Arrays.asList(plugin));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins.
&nbsp;         *
&nbsp;         * @param entryPoint The build entry point to use.
&nbsp;         * @param plugins    The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(EntryPoint entryPoint, List&lt;? extends Plugin&gt; plugins) {
<b class="fc">&nbsp;            return of(entryPoint, ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5), plugins);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins. As {@link EntryPoint}, {@link EntryPoint.Default#REBASE} is implied.
&nbsp;         *
&nbsp;         * @param classFileVersion The class file version to use.
&nbsp;         * @param plugin           The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(ClassFileVersion classFileVersion, Plugin... plugin) {
<b class="nc">&nbsp;            return of(classFileVersion, Arrays.asList(plugin));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins. As {@link EntryPoint}, {@link EntryPoint.Default#REBASE} is implied.
&nbsp;         *
&nbsp;         * @param classFileVersion The class file version to use.
&nbsp;         * @param plugins          The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(ClassFileVersion classFileVersion, List&lt;? extends Plugin&gt; plugins) {
<b class="nc">&nbsp;            return of(EntryPoint.Default.REBASE, classFileVersion, plugins);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins.
&nbsp;         *
&nbsp;         * @param entryPoint       The build entry point to use.
&nbsp;         * @param classFileVersion The class file version to use.
&nbsp;         * @param plugin           The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(EntryPoint entryPoint, ClassFileVersion classFileVersion, Plugin... plugin) {
<b class="nc">&nbsp;            return of(entryPoint, classFileVersion, Arrays.asList(plugin));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an {@link AgentBuilder} that realizes the provided build plugins.
&nbsp;         *
&nbsp;         * @param entryPoint       The build entry point to use.
&nbsp;         * @param classFileVersion The class file version to use.
&nbsp;         * @param plugins          The build plugins to apply as a Java agent.
&nbsp;         * @return An appropriate agent builder.
&nbsp;         */
&nbsp;        public static AgentBuilder of(EntryPoint entryPoint, ClassFileVersion classFileVersion, List&lt;? extends Plugin&gt; plugins) {
<b class="fc">&nbsp;            AgentBuilder agentBuilder = new AgentBuilder.Default(entryPoint.byteBuddy(classFileVersion)).with(new TypeStrategy.ForBuildEntryPoint(entryPoint));</b>
<b class="fc">&nbsp;            for (Plugin plugin : plugins) {</b>
<b class="fc">&nbsp;                agentBuilder = agentBuilder.type(plugin).transform(new Transformer.ForBuildPlugin(plugin));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return agentBuilder;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(ByteBuddy byteBuddy) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(Listener listener) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    new Listener.Compound(this.listener, listener),
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(CircularityLock circularityLock) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(TypeStrategy typeStrategy) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(PoolStrategy poolStrategy) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(LocationStrategy locationStrategy) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    new ClassFileLocator.Compound(this.classFileLocator, classFileLocator),
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder enableNativeMethodPrefix(String prefix) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
<b class="fc">&nbsp;                    NativeMethodStrategy.ForPrefix.of(prefix),</b>
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder disableNativeMethodPrefix() {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    NativeMethodStrategy.Disabled.INSTANCE,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder warmUp(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            return warmUp(Arrays.asList(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder warmUp(Collection&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;            if (types.isEmpty()) {</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
<b class="fc">&nbsp;            for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                if (type.isPrimitive() || type.isArray()) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot warm up primitive or array type: &quot; + type);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
<b class="fc">&nbsp;                    warmupStrategy.with(types),</b>
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(TransformerDecorator transformerDecorator) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    new TransformerDecorator.Compound(this.transformerDecorator, transformerDecorator),
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RedefinitionListenable.WithoutBatchStrategy with(RedefinitionStrategy redefinitionStrategy) {
<b class="fc">&nbsp;            return new Redefining(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    RedefinitionStrategy.DiscoveryStrategy.SinglePass.INSTANCE,
&nbsp;                    RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE,
&nbsp;                    RedefinitionStrategy.Listener.NoOp.INSTANCE,
&nbsp;                    RedefinitionStrategy.ResubmissionStrategy.Disabled.INSTANCE,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(InitializationStrategy initializationStrategy) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(LambdaInstrumentationStrategy lambdaInstrumentationStrategy) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(DescriptionStrategy descriptionStrategy) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(FallbackStrategy fallbackStrategy) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(ClassFileBufferStrategy classFileBufferStrategy) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(InstallationListener installationListener) {
<b class="fc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    new InstallationListener.Compound(this.installationListener, installationListener),
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder with(InjectionStrategy injectionStrategy) {
<b class="nc">&nbsp;            return new Default(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    initializationStrategy,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder disableClassFormatChanges() {
<b class="fc">&nbsp;            return new Default(byteBuddy.with(Implementation.Context.Disabled.Factory.INSTANCE),</b>
&nbsp;                    listener,
&nbsp;                    circularityLock,
&nbsp;                    poolStrategy,
<b class="fc">&nbsp;                    typeStrategy == TypeStrategy.Default.DECORATE</b>
<b class="nc">&nbsp;                            ? TypeStrategy.Default.DECORATE</b>
<b class="fc">&nbsp;                            : TypeStrategy.Default.REDEFINE_FROZEN,</b>
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    NativeMethodStrategy.Disabled.INSTANCE,
&nbsp;                    warmupStrategy,
&nbsp;                    transformerDecorator,
&nbsp;                    InitializationStrategy.NoOp.INSTANCE,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener,
&nbsp;                    redefinitionResubmissionStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    transformations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Class&lt;?&gt;... type) {
<b class="nc">&nbsp;            return JavaModule.isSupported()</b>
<b class="nc">&nbsp;                    ? with(Listener.ModuleReadEdgeCompleting.of(instrumentation, false, type))</b>
<b class="nc">&nbsp;                    : this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, JavaModule... module) {
<b class="nc">&nbsp;            return assureReadEdgeTo(instrumentation, Arrays.asList(module));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Collection&lt;? extends JavaModule&gt; modules) {
<b class="nc">&nbsp;            return with(new Listener.ModuleReadEdgeCompleting(instrumentation, false, new HashSet&lt;JavaModule&gt;(modules)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Class&lt;?&gt;... type) {
<b class="nc">&nbsp;            return JavaModule.isSupported()</b>
<b class="nc">&nbsp;                    ? with(Listener.ModuleReadEdgeCompleting.of(instrumentation, true, type))</b>
<b class="nc">&nbsp;                    : this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, JavaModule... module) {
<b class="nc">&nbsp;            return assureReadEdgeFromAndTo(instrumentation, Arrays.asList(module));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Collection&lt;? extends JavaModule&gt; modules) {
<b class="nc">&nbsp;            return with(new Listener.ModuleReadEdgeCompleting(instrumentation, true, new HashSet&lt;JavaModule&gt;(modules)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Identified.Narrowable type(RawMatcher matcher) {
<b class="fc">&nbsp;            return new Transforming(matcher, Collections.&lt;Transformer&gt;emptyList(), false);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="fc">&nbsp;            return type(typeMatcher, any());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="fc">&nbsp;            return type(typeMatcher, classLoaderMatcher, any());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                                          ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                          ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="fc">&nbsp;            return type(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, not(supportsModules()).or(moduleMatcher)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="fc">&nbsp;            return ignore(typeMatcher, any());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="fc">&nbsp;            return ignore(typeMatcher, classLoaderMatcher, any());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                              ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                              ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="fc">&nbsp;            return ignore(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, not(supportsModules()).or(moduleMatcher)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Ignored ignore(RawMatcher rawMatcher) {
<b class="fc">&nbsp;            return new Ignoring(rawMatcher);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer makeRaw() {
<b class="nc">&nbsp;            return makeRaw(listener, InstallationListener.NoOp.INSTANCE, RedefinitionStrategy.ResubmissionEnforcer.Disabled.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new class file transformer with a given listener.
&nbsp;         *
&nbsp;         * @param listener             The listener to supply.
&nbsp;         * @param installationListener The installation listener to notify.
&nbsp;         * @param resubmissionEnforcer The resubmission enforcer to use.
&nbsp;         * @return The resettable class file transformer to use.
&nbsp;         */
&nbsp;        private ResettableClassFileTransformer makeRaw(Listener listener,
&nbsp;                                                       InstallationListener installationListener,
&nbsp;                                                       RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer) {
<b class="fc">&nbsp;            return ExecutingTransformer.FACTORY.make(byteBuddy,</b>
&nbsp;                    listener,
&nbsp;                    poolStrategy,
&nbsp;                    typeStrategy,
&nbsp;                    locationStrategy,
&nbsp;                    classFileLocator,
&nbsp;                    nativeMethodStrategy,
&nbsp;                    initializationStrategy,
&nbsp;                    injectionStrategy,
&nbsp;                    lambdaInstrumentationStrategy,
&nbsp;                    descriptionStrategy,
&nbsp;                    fallbackStrategy,
&nbsp;                    classFileBufferStrategy,
&nbsp;                    installationListener,
&nbsp;                    ignoreMatcher,
&nbsp;                    resubmissionEnforcer,
&nbsp;                    transformations,
&nbsp;                    circularityLock);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the instrumentation provided by {@code net.bytebuddy.agent.Installer}.
&nbsp;         *
&nbsp;         * @return The installed instrumentation instance.
&nbsp;         */
&nbsp;        private static Instrumentation resolveByteBuddyAgentInstrumentation() {
&nbsp;            try {
<b class="fc">&nbsp;                Class&lt;?&gt; installer = ClassLoader.getSystemClassLoader().loadClass(INSTALLER_TYPE);</b>
<b class="fc">&nbsp;                JavaModule source = JavaModule.ofType(AgentBuilder.class), target = JavaModule.ofType(installer);</b>
<b class="fc">&nbsp;                if (source != null &amp;&amp; !source.canRead(target)) {</b>
<b class="nc">&nbsp;                    Class&lt;?&gt; module = Class.forName(&quot;java.lang.Module&quot;);</b>
<b class="nc">&nbsp;                    module.getMethod(&quot;addReads&quot;, module).invoke(source.unwrap(), target.unwrap());</b>
&nbsp;                }
<b class="fc">&nbsp;                return (Instrumentation) installer.getMethod(INSTALLER_GETTER).invoke(null);</b>
<b class="nc">&nbsp;            } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                throw exception;</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;The Byte Buddy agent is not installed or not accessible&quot;, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer installOn(Instrumentation instrumentation) {
<b class="fc">&nbsp;            return doInstall(instrumentation, new Transformation.SimpleMatcher(ignoreMatcher, transformations), PatchMode.Handler.NoOp.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer installOnByteBuddyAgent() {
<b class="fc">&nbsp;            return installOn(resolveByteBuddyAgentInstrumentation());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;            return patchOn(instrumentation, classFileTransformer, PatchMode.of(classFileTransformer));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher) {
<b class="nc">&nbsp;            return patchOn(instrumentation, classFileTransformer, differentialMatcher, PatchMode.of(classFileTransformer));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
<b class="fc">&nbsp;            return patchOn(instrumentation, classFileTransformer, new Transformation.DifferentialMatcher(ignoreMatcher, transformations, classFileTransformer instanceof ResettableClassFileTransformer.Substitutable</b>
<b class="nc">&nbsp;                    ? ((ResettableClassFileTransformer.Substitutable) classFileTransformer).unwrap()</b>
<b class="fc">&nbsp;                    : classFileTransformer), patchMode);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher, PatchMode patchMode) {
<b class="fc">&nbsp;            return doInstall(instrumentation, differentialMatcher, patchMode.toHandler(classFileTransformer));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer) {
<b class="nc">&nbsp;            return patchOn(resolveByteBuddyAgentInstrumentation(), classFileTransformer);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
<b class="nc">&nbsp;            return patchOn(resolveByteBuddyAgentInstrumentation(), classFileTransformer, patchMode);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Installs the class file transformer.
&nbsp;         *
&nbsp;         * @param instrumentation The instrumentation to install the matcher on.
&nbsp;         * @param matcher         The matcher to identify redefined types.
&nbsp;         * @param handler         The handler to use for implementing a patch mode.
&nbsp;         * @return The created class file transformer.
&nbsp;         */
&nbsp;        private ResettableClassFileTransformer doInstall(Instrumentation instrumentation, RawMatcher matcher, PatchMode.Handler handler) {
<b class="fc">&nbsp;            if (!circularityLock.acquire()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Could not acquire the circularity lock upon installation.&quot;);</b>
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                RedefinitionStrategy.ResubmissionStrategy.Installation installation = redefinitionResubmissionStrategy.apply(instrumentation,</b>
&nbsp;                        poolStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        listener,
&nbsp;                        installationListener,
&nbsp;                        circularityLock,
&nbsp;                        new Transformation.SimpleMatcher(ignoreMatcher, transformations),
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener);
<b class="fc">&nbsp;                ResettableClassFileTransformer classFileTransformer = transformerDecorator.decorate(makeRaw(installation.getListener(),</b>
<b class="fc">&nbsp;                        installation.getInstallationListener(),</b>
<b class="fc">&nbsp;                        installation.getResubmissionEnforcer()));</b>
<b class="fc">&nbsp;                installation.getInstallationListener().onBeforeInstall(instrumentation, classFileTransformer);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    warmupStrategy.apply(classFileTransformer,</b>
&nbsp;                            locationStrategy,
&nbsp;                            redefinitionStrategy,
&nbsp;                            circularityLock,
<b class="fc">&nbsp;                            installation.getInstallationListener());</b>
<b class="fc">&nbsp;                    handler.onBeforeRegistration(instrumentation);</b>
<b class="fc">&nbsp;                    if (handler.onRegistration(classFileTransformer)) {</b>
<b class="fc">&nbsp;                        if (redefinitionStrategy.isRetransforming()) {</b>
<b class="fc">&nbsp;                            DISPATCHER.addTransformer(instrumentation, classFileTransformer, true);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            instrumentation.addTransformer(classFileTransformer);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    handler.onAfterRegistration(instrumentation);</b>
<b class="fc">&nbsp;                    nativeMethodStrategy.apply(instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                    lambdaInstrumentationStrategy.apply(byteBuddy, instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                    redefinitionStrategy.apply(instrumentation,</b>
&nbsp;                            poolStrategy,
&nbsp;                            locationStrategy,
&nbsp;                            descriptionStrategy,
&nbsp;                            fallbackStrategy,
&nbsp;                            redefinitionDiscoveryStrategy,
&nbsp;                            lambdaInstrumentationStrategy,
<b class="fc">&nbsp;                            installation.getListener(),</b>
&nbsp;                            redefinitionListener,
&nbsp;                            matcher,
&nbsp;                            redefinitionBatchAllocator,
&nbsp;                            circularityLock);
<b class="fc">&nbsp;                } catch (@MaybeNull Throwable throwable) {</b>
<b class="fc">&nbsp;                    throwable = installation.getInstallationListener().onError(instrumentation, classFileTransformer, throwable);</b>
<b class="fc">&nbsp;                    if (throwable != null) {</b>
<b class="fc">&nbsp;                        instrumentation.removeTransformer(classFileTransformer);</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Could not install class file transformer&quot;, throwable);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                installation.getInstallationListener().onInstall(instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                return classFileTransformer;</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                circularityLock.release();</b>
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for interacting with the instrumentation API.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.instrument.Instrumentation&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the supplied instrumentation instance supports setting native method prefixes.
&nbsp;             *
&nbsp;             * @param instrumentation The instrumentation instance to use.
&nbsp;             * @return {@code true} if the supplied instrumentation instance supports native method prefixes.
&nbsp;             */
&nbsp;            @JavaDispatcher.Defaults
&nbsp;            boolean isNativeMethodPrefixSupported(Instrumentation instrumentation);
&nbsp;
&nbsp;            /**
&nbsp;             * Sets a native method prefix for the supplied class file transformer.
&nbsp;             *
&nbsp;             * @param instrumentation      The instrumentation instance to use.
&nbsp;             * @param classFileTransformer The class file transformer for which the prefix is set.
&nbsp;             * @param prefix               The prefix to set.
&nbsp;             */
&nbsp;            void setNativeMethodPrefix(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, String prefix);
&nbsp;
&nbsp;            /**
&nbsp;             * Adds a class file transformer to an instrumentation instance.
&nbsp;             *
&nbsp;             * @param instrumentation      The instrumentation instance to use for registration.
&nbsp;             * @param classFileTransformer The class file transformer to register.
&nbsp;             * @param canRetransform       {@code true} if the class file transformer is capable of retransformation.
&nbsp;             */
&nbsp;            void addTransformer(Instrumentation instrumentation, ClassFileTransformer classFileTransformer, boolean canRetransform);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy for determining if a native method name prefix should be used when rebasing methods.
&nbsp;         */
&nbsp;        protected interface NativeMethodStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the method name transformer for this strategy.
&nbsp;             *
&nbsp;             * @return A method name transformer for this strategy.
&nbsp;             */
&nbsp;            MethodNameTransformer resolve();
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this native method strategy.
&nbsp;             *
&nbsp;             * @param instrumentation      The instrumentation to apply this strategy upon.
&nbsp;             * @param classFileTransformer The class file transformer being registered.
&nbsp;             */
&nbsp;            void apply(Instrumentation instrumentation, ClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;            /**
&nbsp;             * A native method strategy that suffixes method names with a random suffix and disables native method rebasement.
&nbsp;             */
<b class="fc">&nbsp;            enum Disabled implements NativeMethodStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodNameTransformer resolve() {
<b class="fc">&nbsp;                    return MethodNameTransformer.Suffixing.withRandomSuffix();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(Instrumentation instrumentation, ClassFileTransformer classFileTransformer) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A native method strategy that prefixes method names with a fixed value for supporting rebasing of native methods.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForPrefix implements NativeMethodStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method name prefix.
&nbsp;                 */
&nbsp;                private final String prefix;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new name prefixing native method strategy.
&nbsp;                 *
&nbsp;                 * @param prefix The method name prefix.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForPrefix(String prefix) {</b>
<b class="fc">&nbsp;                    this.prefix = prefix;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new native method strategy for prefixing method names.
&nbsp;                 *
&nbsp;                 * @param prefix The method name prefix.
&nbsp;                 * @return An appropriate native method strategy.
&nbsp;                 */
&nbsp;                protected static NativeMethodStrategy of(String prefix) {
<b class="fc">&nbsp;                    if (prefix.length() == 0) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;A method name prefix must not be the empty string&quot;);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new ForPrefix(prefix);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodNameTransformer resolve() {
<b class="fc">&nbsp;                    return new MethodNameTransformer.Prefixing(prefix);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(Instrumentation instrumentation, ClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                    if (!DISPATCHER.isNativeMethodPrefixSupported(instrumentation)) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;A prefix for native methods is not supported: &quot; + instrumentation);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    DISPATCHER.setNativeMethodPrefix(instrumentation, classFileTransformer, prefix);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy to warm up a {@link ClassFileTransformer} before using it to eagerly load classes and to avoid
&nbsp;         * circularity errors when classes are loaded during actual transformation for the first time.
&nbsp;         */
&nbsp;        protected interface WarmupStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this warm up strategy.
&nbsp;             *
&nbsp;             * @param classFileTransformer The class file transformer to warm up.
&nbsp;             * @param locationStrategy     The location strategy to use.
&nbsp;             * @param redefinitionStrategy The redefinition strategy being used.
&nbsp;             * @param circularityLock      The circularity lock to use.
&nbsp;             * @param listener             The listener to notify over warmup events.
&nbsp;             */
&nbsp;            void apply(ResettableClassFileTransformer classFileTransformer,
&nbsp;                       LocationStrategy locationStrategy,
&nbsp;                       RedefinitionStrategy redefinitionStrategy,
&nbsp;                       CircularityLock circularityLock,
&nbsp;                       InstallationListener listener);
&nbsp;
&nbsp;            /**
&nbsp;             * Adds the provided types to this warmup strategy.
&nbsp;             *
&nbsp;             * @param types The types to add.
&nbsp;             * @return An appropriate warmup strategy.
&nbsp;             */
&nbsp;            WarmupStrategy with(Collection&lt;Class&lt;?&gt;&gt; types);
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational warmup strategy.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements WarmupStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ResettableClassFileTransformer classFileTransformer,
&nbsp;                                  LocationStrategy locationStrategy,
&nbsp;                                  RedefinitionStrategy redefinitionStrategy,
&nbsp;                                  CircularityLock circularityLock,
&nbsp;                                  InstallationListener listener) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WarmupStrategy with(Collection&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    return new Enabled(new LinkedHashSet&lt;Class&lt;?&gt;&gt;(types));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An enabled warmup strategy.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Enabled implements WarmupStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for invoking a {@link ClassFileTransformer} when the module system is available.
&nbsp;                 */
<b class="fc">&nbsp;                private static final Dispatcher DISPATCHER = Default.doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The types to warm up.
&nbsp;                 */
&nbsp;                private final Set&lt;Class&lt;?&gt;&gt; types;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new enabled warmup strategy.
&nbsp;                 *
&nbsp;                 * @param types The types to warm up.
&nbsp;                 */
<b class="fc">&nbsp;                protected Enabled(Set&lt;Class&lt;?&gt;&gt; types) {</b>
<b class="fc">&nbsp;                    this.types = types;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void apply(ResettableClassFileTransformer classFileTransformer,
&nbsp;                                  LocationStrategy locationStrategy,
&nbsp;                                  RedefinitionStrategy redefinitionStrategy,
&nbsp;                                  CircularityLock circularityLock,
&nbsp;                                  InstallationListener listener) {
<b class="fc">&nbsp;                    listener.onBeforeWarmUp(types, classFileTransformer);</b>
<b class="fc">&nbsp;                    boolean transformed = false;</b>
<b class="fc">&nbsp;                    Map&lt;Class&lt;?&gt;, byte[]&gt; results = new LinkedHashMap&lt;Class&lt;?&gt;, byte[]&gt;();</b>
<b class="fc">&nbsp;                    for (Class&lt;?&gt; type : types) {</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            JavaModule module = JavaModule.ofType(type);</b>
<b class="fc">&nbsp;                            byte[] binaryRepresentation = locationStrategy.classFileLocator(type.getClassLoader(), module)</b>
<b class="fc">&nbsp;                                    .locate(type.getName())</b>
<b class="fc">&nbsp;                                    .resolve();</b>
<b class="fc">&nbsp;                            circularityLock.release();</b>
&nbsp;                            try {
&nbsp;                                byte[] result;
<b class="fc">&nbsp;                                if (module == null) {</b>
<b class="nc">&nbsp;                                    result = classFileTransformer.transform(type.getClassLoader(),</b>
<b class="nc">&nbsp;                                            Type.getInternalName(type),</b>
<b class="nc">&nbsp;                                            NOT_PREVIOUSLY_DEFINED,</b>
<b class="nc">&nbsp;                                            type.getProtectionDomain(),</b>
&nbsp;                                            binaryRepresentation);
<b class="nc">&nbsp;                                    transformed |= result != null;</b>
<b class="nc">&nbsp;                                    if (redefinitionStrategy.isEnabled()) {</b>
<b class="nc">&nbsp;                                        result = classFileTransformer.transform(type.getClassLoader(),</b>
<b class="nc">&nbsp;                                                Type.getInternalName(type),</b>
&nbsp;                                                type,
<b class="nc">&nbsp;                                                type.getProtectionDomain(),</b>
&nbsp;                                                binaryRepresentation);
<b class="nc">&nbsp;                                        transformed |= result != null;</b>
&nbsp;                                    }
&nbsp;                                } else {
<b class="fc">&nbsp;                                    result = DISPATCHER.transform(classFileTransformer,</b>
<b class="fc">&nbsp;                                            module.unwrap(),</b>
<b class="fc">&nbsp;                                            type.getClassLoader(),</b>
<b class="fc">&nbsp;                                            Type.getInternalName(type),</b>
<b class="fc">&nbsp;                                            NOT_PREVIOUSLY_DEFINED,</b>
<b class="fc">&nbsp;                                            type.getProtectionDomain(),</b>
&nbsp;                                            binaryRepresentation);
<b class="fc">&nbsp;                                    transformed |= result != null;</b>
<b class="fc">&nbsp;                                    if (redefinitionStrategy.isEnabled()) {</b>
<b class="fc">&nbsp;                                        result = DISPATCHER.transform(classFileTransformer,</b>
<b class="fc">&nbsp;                                                module.unwrap(),</b>
<b class="fc">&nbsp;                                                type.getClassLoader(),</b>
<b class="fc">&nbsp;                                                Type.getInternalName(type),</b>
&nbsp;                                                type,
<b class="fc">&nbsp;                                                type.getProtectionDomain(),</b>
&nbsp;                                                binaryRepresentation);
<b class="fc">&nbsp;                                        transformed |= result != null;</b>
&nbsp;                                    }
&nbsp;                                }
<b class="fc">&nbsp;                                results.put(type, result);</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                circularityLock.acquire();</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                            listener.onWarmUpError(type, classFileTransformer, throwable);</b>
<b class="fc">&nbsp;                            results.put(type, NO_TRANSFORMATION);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    listener.onAfterWarmUp(results, classFileTransformer, transformed);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WarmupStrategy with(Collection&lt;Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    Set&lt;Class&lt;?&gt;&gt; combined = new LinkedHashSet&lt;Class&lt;?&gt;&gt;(this.types);</b>
<b class="fc">&nbsp;                    combined.addAll(types);</b>
<b class="fc">&nbsp;                    return new Enabled(combined);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher to interact with a {@link ClassFileTransformer} when the module system is active.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.instrument.ClassFileTransformer&quot;)
&nbsp;                protected interface Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Transforms a class.
&nbsp;                     *
&nbsp;                     * @param target               The transformer to use for transformation.
&nbsp;                     * @param module               The Java module of the transformed class.
&nbsp;                     * @param classLoader          The class loader of the transformed class or {@code null} if loaded by the boot loader.
&nbsp;                     * @param name                 The internal name of the transformed class.
&nbsp;                     * @param classBeingRedefined  The class being redefined or {@code null} if not a retransformation.
&nbsp;                     * @param protectionDomain     The class&#39;s protection domain or {@code null} if not available.
&nbsp;                     * @param binaryRepresentation The class&#39;s binary representation.
&nbsp;                     * @return The transformed class file or {@code null} if untransformed.
&nbsp;                     * @throws IllegalClassFormatException If the class file cannot be generated.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    byte[] transform(ClassFileTransformer target,
&nbsp;                                     @MaybeNull @JavaDispatcher.Proxied(&quot;java.lang.Module&quot;) Object module,
&nbsp;                                     @MaybeNull ClassLoader classLoader,
&nbsp;                                     String name,
&nbsp;                                     @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                     @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                     byte[] binaryRepresentation) throws IllegalClassFormatException;
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A transformation to apply.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        protected static class Transformation {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a type should not be ignored.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final byte[] NONE = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The matcher to identify types for transformation.
&nbsp;             */
&nbsp;            private final RawMatcher matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of transformers to apply.
&nbsp;             */
&nbsp;            private final List&lt;Transformer&gt; transformers;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this transformation is terminal.
&nbsp;             */
&nbsp;            private final boolean terminal;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new transformation.
&nbsp;             *
&nbsp;             * @param matcher      The matcher to identify types eligable for transformation.
&nbsp;             * @param transformers A list of transformers to apply.
&nbsp;             * @param terminal     Indicates that this transformation is terminal.
&nbsp;             */
<b class="fc">&nbsp;            protected Transformation(RawMatcher matcher, List&lt;Transformer&gt; transformers, boolean terminal) {</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.transformers = transformers;</b>
<b class="fc">&nbsp;                this.terminal = terminal;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the matcher to identify types for transformation.
&nbsp;             *
&nbsp;             * @return The matcher to identify types for transformation.
&nbsp;             */
&nbsp;            protected RawMatcher getMatcher() {
<b class="fc">&nbsp;                return matcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a list of transformers to apply.
&nbsp;             *
&nbsp;             * @return A list of transformers to apply.
&nbsp;             */
&nbsp;            protected List&lt;Transformer&gt; getTransformers() {
<b class="fc">&nbsp;                return transformers;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if this transformation is terminal.
&nbsp;             *
&nbsp;             * @return {@code true} if this transformation is terminal.
&nbsp;             */
&nbsp;            protected boolean isTerminal() {
<b class="fc">&nbsp;                return terminal;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher that matches any type that is touched by a transformer without being ignored.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class SimpleMatcher implements RawMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Identifies types that should not be instrumented.
&nbsp;                 */
&nbsp;                private final RawMatcher ignoreMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The transformations to apply on non-ignored types.
&nbsp;                 */
&nbsp;                private final List&lt;Transformation&gt; transformations;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new simple matcher.
&nbsp;                 *
&nbsp;                 * @param ignoreMatcher   Identifies types that should not be instrumented.
&nbsp;                 * @param transformations The transformations to apply on non-ignored types.
&nbsp;                 */
<b class="fc">&nbsp;                protected SimpleMatcher(RawMatcher ignoreMatcher, List&lt;Transformation&gt; transformations) {</b>
<b class="fc">&nbsp;                    this.ignoreMatcher = ignoreMatcher;</b>
<b class="fc">&nbsp;                    this.transformations = transformations;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(TypeDescription typeDescription,
&nbsp;                                       @MaybeNull ClassLoader classLoader,
&nbsp;                                       @MaybeNull JavaModule module,
&nbsp;                                       @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                       @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    if (ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (Transformation transformation : transformations) {</b>
<b class="fc">&nbsp;                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher that considers the differential of two transformers&#39; transformations.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class DifferentialMatcher implements RawMatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Identifies types that should not be instrumented.
&nbsp;                 */
&nbsp;                private final RawMatcher ignoreMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The transformations to apply on non-ignored types.
&nbsp;                 */
&nbsp;                private final List&lt;Transformation&gt; transformations;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file transformer representing the differential.
&nbsp;                 */
&nbsp;                private final ResettableClassFileTransformer classFileTransformer;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new differential matcher.
&nbsp;                 *
&nbsp;                 * @param ignoreMatcher        Identifies types that should not be instrumented.
&nbsp;                 * @param transformations      The transformations to apply on non-ignored types.
&nbsp;                 * @param classFileTransformer The class file transformer representing the differential.
&nbsp;                 */
&nbsp;                protected DifferentialMatcher(RawMatcher ignoreMatcher,
&nbsp;                                              List&lt;Transformation&gt; transformations,
<b class="fc">&nbsp;                                              ResettableClassFileTransformer classFileTransformer) {</b>
<b class="fc">&nbsp;                    this.ignoreMatcher = ignoreMatcher;</b>
<b class="fc">&nbsp;                    this.transformations = transformations;</b>
<b class="fc">&nbsp;                    this.classFileTransformer = classFileTransformer;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean matches(TypeDescription typeDescription,
&nbsp;                                       @MaybeNull ClassLoader classLoader,
&nbsp;                                       @MaybeNull JavaModule module,
&nbsp;                                       @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                       @MaybeNull ProtectionDomain protectionDomain) {
<b class="fc">&nbsp;                    Iterator&lt;Transformer&gt; iterator = classFileTransformer.iterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);</b>
<b class="fc">&nbsp;                    if (ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="nc">&nbsp;                        return iterator.hasNext();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (Transformation transformation : transformations) {</b>
<b class="fc">&nbsp;                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                            for (Transformer transformer : transformation.getTransformers()) {</b>
<b class="fc">&nbsp;                                if (!iterator.hasNext() || !iterator.next().equals(transformer)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return iterator.hasNext();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An iterator over a list of transformations that match a raw matcher specification.
&nbsp;             */
&nbsp;            protected static class TransformerIterator implements Iterator&lt;Transformer&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the matched type.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s class loader.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final ClassLoader classLoader;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s module.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final JavaModule module;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class being redefined or {@code null} if the type was not previously loaded.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final Class&lt;?&gt; classBeingRedefined;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s protection domain or {@code null} if not available.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;                /**
&nbsp;                 * An iterator over the remaining transformations that were not yet considered.
&nbsp;                 */
&nbsp;                private final Iterator&lt;Transformation&gt; transformations;
&nbsp;
&nbsp;                /**
&nbsp;                 * An iterator over the currently matched transformers.
&nbsp;                 */
&nbsp;                private Iterator&lt;Transformer&gt; transformers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new iterator.
&nbsp;                 *
&nbsp;                 * @param typeDescription     A description of the matched type.
&nbsp;                 * @param classLoader         The type&#39;s class loader.
&nbsp;                 * @param module              The type&#39;s module.
&nbsp;                 * @param classBeingRedefined The class being redefined or {@code null} if the type was not previously loaded.
&nbsp;                 * @param protectionDomain    The type&#39;s protection domain or {@code null} if not available.
&nbsp;                 * @param transformations     The matched transformations.
&nbsp;                 */
&nbsp;                protected TransformerIterator(TypeDescription typeDescription,
&nbsp;                                              @MaybeNull ClassLoader classLoader,
&nbsp;                                              @MaybeNull JavaModule module,
&nbsp;                                              @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                              @MaybeNull ProtectionDomain protectionDomain,
<b class="nc">&nbsp;                                              List&lt;Transformation&gt; transformations) {</b>
<b class="nc">&nbsp;                    this.typeDescription = typeDescription;</b>
<b class="nc">&nbsp;                    this.classLoader = classLoader;</b>
<b class="nc">&nbsp;                    this.module = module;</b>
<b class="nc">&nbsp;                    this.classBeingRedefined = classBeingRedefined;</b>
<b class="nc">&nbsp;                    this.protectionDomain = protectionDomain;</b>
<b class="nc">&nbsp;                    this.transformations = transformations.iterator();</b>
<b class="nc">&nbsp;                    transformers = Collections.&lt;Transformer&gt;emptySet().iterator();</b>
<b class="nc">&nbsp;                    while (!transformers.hasNext() &amp;&amp; this.transformations.hasNext()) {</b>
<b class="nc">&nbsp;                        Transformation transformation = this.transformations.next();</b>
<b class="nc">&nbsp;                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="nc">&nbsp;                            transformers = transformation.getTransformers().iterator();</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean hasNext() {
<b class="nc">&nbsp;                    return transformers.hasNext();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Transformer next() {
&nbsp;                    try {
<b class="nc">&nbsp;                        return transformers.next();</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        while (!transformers.hasNext() &amp;&amp; transformations.hasNext()) {</b>
<b class="nc">&nbsp;                            Transformation transformation = transformations.next();</b>
<b class="nc">&nbsp;                            if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="nc">&nbsp;                                transformers = transformation.getTransformers().iterator();</b>
&nbsp;                            }
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void remove() {
<b class="nc">&nbsp;                    throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link java.lang.instrument.ClassFileTransformer} that implements the enclosing agent builder&#39;s
&nbsp;         * configuration.
&nbsp;         */
<b class="fc">&nbsp;        protected static class ExecutingTransformer extends ResettableClassFileTransformer.AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ClassFileTransformer} that supports the features of the current VM.
&nbsp;             */
<b class="fc">&nbsp;            protected static final Factory FACTORY = Default.doPrivileged(Factory.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The Byte Buddy instance to be used.
&nbsp;             */
&nbsp;            private final ByteBuddy byteBuddy;
&nbsp;
&nbsp;            /**
&nbsp;             * The pool strategy to use.
&nbsp;             */
&nbsp;            private final PoolStrategy poolStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The definition handler to use.
&nbsp;             */
&nbsp;            private final TypeStrategy typeStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The listener to notify on transformations.
&nbsp;             */
&nbsp;            private final Listener listener;
&nbsp;
&nbsp;            /**
&nbsp;             * The native method strategy to apply.
&nbsp;             */
&nbsp;            private final NativeMethodStrategy nativeMethodStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The initialization strategy to use for transformed types.
&nbsp;             */
&nbsp;            private final InitializationStrategy initializationStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The injection strategy to use.
&nbsp;             */
&nbsp;            private final InjectionStrategy injectionStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The lambda instrumentation strategy to use.
&nbsp;             */
&nbsp;            private final LambdaInstrumentationStrategy lambdaInstrumentationStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The description strategy for resolving type descriptions for types.
&nbsp;             */
&nbsp;            private final DescriptionStrategy descriptionStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The location strategy to use.
&nbsp;             */
&nbsp;            private final LocationStrategy locationStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * A class file locator for locating globally available types.
&nbsp;             */
&nbsp;            private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;            /**
&nbsp;             * The fallback strategy to use.
&nbsp;             */
&nbsp;            private final FallbackStrategy fallbackStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The class file buffer strategy to use.
&nbsp;             */
&nbsp;            private final ClassFileBufferStrategy classFileBufferStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The installation listener to notify.
&nbsp;             */
&nbsp;            private final InstallationListener installationListener;
&nbsp;
&nbsp;            /**
&nbsp;             * Identifies types that should not be instrumented.
&nbsp;             */
&nbsp;            private final RawMatcher ignoreMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The resubmission enforcer to use.
&nbsp;             */
&nbsp;            private final RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer;
&nbsp;
&nbsp;            /**
&nbsp;             * The transformations to apply on non-ignored types.
&nbsp;             */
&nbsp;            private final List&lt;Transformation&gt; transformations;
&nbsp;
&nbsp;            /**
&nbsp;             * A lock that prevents circular class transformations.
&nbsp;             */
&nbsp;            private final CircularityLock circularityLock;
&nbsp;
&nbsp;            /**
&nbsp;             * The access control context to use for loading classes or {@code null} if the
&nbsp;             * access controller is not available on the current VM.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final Object accessControlContext;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new class file transformer.
&nbsp;             *
&nbsp;             * @param byteBuddy                     The Byte Buddy instance to be used.
&nbsp;             * @param listener                      The listener to notify on transformations.
&nbsp;             * @param poolStrategy                  The pool strategy to use.
&nbsp;             * @param typeStrategy                  The definition handler to use.
&nbsp;             * @param locationStrategy              The location strategy to use.
&nbsp;             * @param classFileLocator              A class file locator for locating globally available types.
&nbsp;             * @param nativeMethodStrategy          The native method strategy to apply.
&nbsp;             * @param initializationStrategy        The initialization strategy to use for transformed types.
&nbsp;             * @param injectionStrategy             The injection strategy to use.
&nbsp;             * @param lambdaInstrumentationStrategy The lambda instrumentation strategy to use.
&nbsp;             * @param descriptionStrategy           The description strategy for resolving type descriptions for types.
&nbsp;             * @param fallbackStrategy              The fallback strategy to use.
&nbsp;             * @param installationListener          The installation listener to notify.
&nbsp;             * @param classFileBufferStrategy       The class file buffer strategy to use.
&nbsp;             * @param ignoreMatcher                 Identifies types that should not be instrumented.
&nbsp;             * @param resubmissionEnforcer          The resubmission enforcer to use.
&nbsp;             * @param transformations               The transformations to apply on non-ignored types.
&nbsp;             * @param circularityLock               The circularity lock to use.
&nbsp;             */
&nbsp;            public ExecutingTransformer(ByteBuddy byteBuddy,
&nbsp;                                        Listener listener,
&nbsp;                                        PoolStrategy poolStrategy,
&nbsp;                                        TypeStrategy typeStrategy,
&nbsp;                                        LocationStrategy locationStrategy,
&nbsp;                                        ClassFileLocator classFileLocator,
&nbsp;                                        NativeMethodStrategy nativeMethodStrategy,
&nbsp;                                        InitializationStrategy initializationStrategy,
&nbsp;                                        InjectionStrategy injectionStrategy,
&nbsp;                                        LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                                        DescriptionStrategy descriptionStrategy,
&nbsp;                                        FallbackStrategy fallbackStrategy,
&nbsp;                                        ClassFileBufferStrategy classFileBufferStrategy,
&nbsp;                                        InstallationListener installationListener,
&nbsp;                                        RawMatcher ignoreMatcher,
&nbsp;                                        RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer,
&nbsp;                                        List&lt;Transformation&gt; transformations,
<b class="fc">&nbsp;                                        CircularityLock circularityLock) {</b>
<b class="fc">&nbsp;                this.byteBuddy = byteBuddy;</b>
<b class="fc">&nbsp;                this.typeStrategy = typeStrategy;</b>
<b class="fc">&nbsp;                this.poolStrategy = poolStrategy;</b>
<b class="fc">&nbsp;                this.locationStrategy = locationStrategy;</b>
<b class="fc">&nbsp;                this.classFileLocator = classFileLocator;</b>
<b class="fc">&nbsp;                this.listener = listener;</b>
<b class="fc">&nbsp;                this.nativeMethodStrategy = nativeMethodStrategy;</b>
<b class="fc">&nbsp;                this.initializationStrategy = initializationStrategy;</b>
<b class="fc">&nbsp;                this.injectionStrategy = injectionStrategy;</b>
<b class="fc">&nbsp;                this.lambdaInstrumentationStrategy = lambdaInstrumentationStrategy;</b>
<b class="fc">&nbsp;                this.descriptionStrategy = descriptionStrategy;</b>
<b class="fc">&nbsp;                this.fallbackStrategy = fallbackStrategy;</b>
<b class="fc">&nbsp;                this.classFileBufferStrategy = classFileBufferStrategy;</b>
<b class="fc">&nbsp;                this.installationListener = installationListener;</b>
<b class="fc">&nbsp;                this.ignoreMatcher = ignoreMatcher;</b>
<b class="fc">&nbsp;                this.resubmissionEnforcer = resubmissionEnforcer;</b>
<b class="fc">&nbsp;                this.transformations = transformations;</b>
<b class="fc">&nbsp;                this.circularityLock = circularityLock;</b>
<b class="fc">&nbsp;                accessControlContext = getContext();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A proxy for {@code java.security.AccessController#getContext} that is activated if available.
&nbsp;             *
&nbsp;             * @return The current access control context or {@code null} if the current VM does not support it.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @AccessControllerPlugin.Enhance
&nbsp;            private static Object getContext() {
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;             *
&nbsp;             * @param action  The action to execute from a privileged context.
&nbsp;             * @param context The access control context or {@code null} if the current VM does not support it.
&nbsp;             * @param &lt;T&gt;     The type of the action&#39;s resolved value.
&nbsp;             * @return The action&#39;s resolved value.
&nbsp;             */
&nbsp;            @AccessControllerPlugin.Enhance
&nbsp;            private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action, @MaybeNull @SuppressWarnings(&quot;unused&quot;) Object context) {
<b class="fc">&nbsp;                return action.run();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public byte[] transform(@MaybeNull ClassLoader classLoader,
&nbsp;                                    @MaybeNull String internalTypeName,
&nbsp;                                    @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                    @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                    byte[] binaryRepresentation) {
<b class="fc">&nbsp;                if (circularityLock.acquire()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return doPrivileged(new LegacyVmDispatcher(classLoader,</b>
&nbsp;                                internalTypeName,
&nbsp;                                classBeingRedefined,
&nbsp;                                protectionDomain,
&nbsp;                                binaryRepresentation), accessControlContext);
&nbsp;                    } finally {
<b class="fc">&nbsp;                        circularityLock.release();</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return NO_TRANSFORMATION;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies a transformation for a class that was captured by this {@link ClassFileTransformer}. Invoking this method
&nbsp;             * allows to process module information which is available since Java 9.
&nbsp;             *
&nbsp;             * @param rawModule            The instrumented class&#39;s Java {@code java.lang.Module}.
&nbsp;             * @param classLoader          The type&#39;s class loader or {@code null} if the type is loaded by the bootstrap loader.
&nbsp;             * @param internalTypeName     The internal name of the instrumented class.
&nbsp;             * @param classBeingRedefined  The loaded {@link Class} being redefined or {@code null} if no such class exists.
&nbsp;             * @param protectionDomain     The instrumented type&#39;s protection domain or {@code null} if not available.
&nbsp;             * @param binaryRepresentation The class file of the instrumented class in its current state.
&nbsp;             * @return The transformed class file or an empty byte array if this transformer does not apply an instrumentation.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            protected byte[] transform(Object rawModule,
&nbsp;                                       @MaybeNull ClassLoader classLoader,
&nbsp;                                       @MaybeNull String internalTypeName,
&nbsp;                                       @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                       @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                       byte[] binaryRepresentation) {
<b class="fc">&nbsp;                if (circularityLock.acquire()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return doPrivileged(new Java9CapableVmDispatcher(rawModule,</b>
&nbsp;                                classLoader,
&nbsp;                                internalTypeName,
&nbsp;                                classBeingRedefined,
&nbsp;                                protectionDomain,
&nbsp;                                binaryRepresentation), accessControlContext);
&nbsp;                    } finally {
<b class="fc">&nbsp;                        circularityLock.release();</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return NO_TRANSFORMATION;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies a transformation for a class that was captured by this {@link ClassFileTransformer}.
&nbsp;             *
&nbsp;             * @param module               The instrumented class&#39;s Java module in its wrapped form or {@code null} if the current VM does not support modules.
&nbsp;             * @param classLoader          The instrumented class&#39;s class loader.
&nbsp;             * @param internalTypeName     The internal name of the instrumented class.
&nbsp;             * @param classBeingRedefined  The loaded {@link Class} being redefined or {@code null} if no such class exists.
&nbsp;             * @param protectionDomain     The instrumented type&#39;s protection domain or {@code null} if not available.
&nbsp;             * @param binaryRepresentation The class file of the instrumented class in its current state.
&nbsp;             * @return The transformed class file or an empty byte array if this transformer does not apply an instrumentation.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private byte[] transform(@MaybeNull JavaModule module,
&nbsp;                                     @MaybeNull ClassLoader classLoader,
&nbsp;                                     @MaybeNull String internalTypeName,
&nbsp;                                     @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                     @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                     byte[] binaryRepresentation) {
<b class="fc">&nbsp;                if (internalTypeName == null || !lambdaInstrumentationStrategy.isInstrumented(classBeingRedefined)) {</b>
<b class="nc">&nbsp;                    return NO_TRANSFORMATION;</b>
&nbsp;                }
<b class="fc">&nbsp;                String name = internalTypeName.replace(&#39;/&#39;, &#39;.&#39;);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    if (resubmissionEnforcer.isEnforced(name, classLoader, module, classBeingRedefined)) {</b>
<b class="nc">&nbsp;                        return NO_TRANSFORMATION;</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (Throwable throwable) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        listener.onDiscovery(name, classLoader, module, classBeingRedefined != null);</b>
&nbsp;                    } finally {
<b class="nc">&nbsp;                        listener.onError(name, classLoader, module, classBeingRedefined != null, throwable);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Failed transformation of &quot; + name, throwable);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;                try {
<b class="fc">&nbsp;                    listener.onDiscovery(name, classLoader, module, classBeingRedefined != null);</b>
<b class="fc">&nbsp;                    ClassFileLocator classFileLocator = new ClassFileLocator.Compound(classFileBufferStrategy.resolve(name,</b>
&nbsp;                            binaryRepresentation,
&nbsp;                            classLoader,
&nbsp;                            module,
<b class="fc">&nbsp;                            protectionDomain), this.classFileLocator, locationStrategy.classFileLocator(classLoader, module));</b>
<b class="fc">&nbsp;                    TypePool typePool = classFileBufferStrategy.typePool(poolStrategy, classFileLocator, classLoader, name);</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        return doTransform(module, classLoader, name, classBeingRedefined, classBeingRedefined != null, protectionDomain, typePool, classFileLocator);</b>
<b class="fc">&nbsp;                    } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                        if (classBeingRedefined != null &amp;&amp; descriptionStrategy.isLoadedFirst() &amp;&amp; fallbackStrategy.isFallback(classBeingRedefined, throwable)) {</b>
<b class="fc">&nbsp;                            return doTransform(module, classLoader, name, NOT_PREVIOUSLY_DEFINED, Listener.LOADED, protectionDomain, typePool, classFileLocator);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            throw throwable;</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                    listener.onError(name, classLoader, module, classBeingRedefined != null, throwable);</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Failed transformation of &quot; + name, throwable);</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    listener.onComplete(name, classLoader, module, classBeingRedefined != null);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Applies a transformation for a class that was captured by this {@link ClassFileTransformer}.
&nbsp;             *
&nbsp;             * @param module              The instrumented class&#39;s Java module in its wrapped form or {@code null} if the current VM does not support modules.
&nbsp;             * @param classLoader         The instrumented class&#39;s class loader.
&nbsp;             * @param name                The binary name of the instrumented class.
&nbsp;             * @param classBeingRedefined The loaded {@link Class} being redefined or {@code null} if no such class exists.
&nbsp;             * @param loaded              {@code true} if the instrumented type is loaded.
&nbsp;             * @param protectionDomain    The instrumented type&#39;s protection domain or {@code null} if not available.
&nbsp;             * @param typePool            The type pool to use.
&nbsp;             * @param classFileLocator    The class file locator to use.
&nbsp;             * @return The transformed class file or an empty byte array if this transformer does not apply an instrumentation.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private byte[] doTransform(@MaybeNull JavaModule module,
&nbsp;                                       @MaybeNull ClassLoader classLoader,
&nbsp;                                       String name,
&nbsp;                                       @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                       boolean loaded,
&nbsp;                                       @MaybeNull ProtectionDomain protectionDomain,
&nbsp;                                       TypePool typePool,
&nbsp;                                       ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                TypeDescription typeDescription = descriptionStrategy.apply(name, classBeingRedefined, typePool, circularityLock, classLoader, module);</b>
<b class="fc">&nbsp;                List&lt;Transformer&gt; transformers = new ArrayList&lt;Transformer&gt;();</b>
<b class="fc">&nbsp;                if (!ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                    for (Transformation transformation : transformations) {</b>
<b class="fc">&nbsp;                        if (transformation.getMatcher().matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)) {</b>
<b class="fc">&nbsp;                            transformers.addAll(transformation.getTransformers());</b>
<b class="fc">&nbsp;                            if (transformation.isTerminal()) {</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                if (transformers.isEmpty()) {</b>
<b class="fc">&nbsp;                    listener.onIgnored(typeDescription, classLoader, module, loaded);</b>
<b class="fc">&nbsp;                    return Transformation.NONE;</b>
&nbsp;                }
<b class="fc">&nbsp;                DynamicType.Builder&lt;?&gt; builder = typeStrategy.builder(typeDescription,</b>
&nbsp;                        byteBuddy,
&nbsp;                        classFileLocator,
<b class="fc">&nbsp;                        nativeMethodStrategy.resolve(),</b>
&nbsp;                        classLoader,
&nbsp;                        module,
&nbsp;                        protectionDomain);
<b class="fc">&nbsp;                InitializationStrategy.Dispatcher dispatcher = initializationStrategy.dispatcher();</b>
<b class="fc">&nbsp;                for (Transformer transformer : transformers) {</b>
<b class="fc">&nbsp;                    builder = transformer.transform(builder, typeDescription, classLoader, module, protectionDomain);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                DynamicType.Unloaded&lt;?&gt; dynamicType = dispatcher.apply(builder).make(TypeResolutionStrategy.Disabled.INSTANCE, typePool);</b>
<b class="fc">&nbsp;                dispatcher.register(dynamicType, classLoader, protectionDomain, injectionStrategy);</b>
<b class="fc">&nbsp;                listener.onTransformation(typeDescription, classLoader, module, loaded, dynamicType);</b>
<b class="fc">&nbsp;                return dynamicType.getBytes();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;Transformer&gt; iterator(TypeDescription typeDescription,
&nbsp;                                                  @MaybeNull ClassLoader classLoader,
&nbsp;                                                  @MaybeNull JavaModule module,
&nbsp;                                                  @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                                  @MaybeNull ProtectionDomain protectionDomain) {
<b class="nc">&nbsp;                return ignoreMatcher.matches(typeDescription, classLoader, module, classBeingRedefined, protectionDomain)</b>
<b class="nc">&nbsp;                        ? Collections.&lt;Transformer&gt;emptySet().iterator()</b>
<b class="nc">&nbsp;                        : new Transformation.TransformerIterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain, transformations);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public synchronized boolean reset(Instrumentation instrumentation,
&nbsp;                                              ResettableClassFileTransformer classFileTransformer,
&nbsp;                                              RedefinitionStrategy redefinitionStrategy,
&nbsp;                                              RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                                              RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                                              RedefinitionStrategy.Listener redefinitionListener) {
<b class="fc">&nbsp;                if (instrumentation.removeTransformer(classFileTransformer)) {</b>
<b class="fc">&nbsp;                    redefinitionStrategy.apply(instrumentation,</b>
&nbsp;                            poolStrategy,
&nbsp;                            locationStrategy,
&nbsp;                            descriptionStrategy,
&nbsp;                            fallbackStrategy,
&nbsp;                            redefinitionDiscoveryStrategy,
&nbsp;                            lambdaInstrumentationStrategy,
&nbsp;                            Listener.NoOp.INSTANCE,
&nbsp;                            redefinitionListener,
&nbsp;                            new Transformation.SimpleMatcher(ignoreMatcher, transformations),
&nbsp;                            redefinitionBatchAllocator,
&nbsp;                            CircularityLock.Inactive.INSTANCE);
<b class="fc">&nbsp;                    installationListener.onReset(instrumentation, classFileTransformer);</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /* does not implement hashCode and equals in order to align with identity treatment of the JVM */
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ClassFileTransformer} for the current VM.
&nbsp;             */
&nbsp;            protected interface Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new class file transformer for the current VM.
&nbsp;                 *
&nbsp;                 * @param byteBuddy                     The Byte Buddy instance to be used.
&nbsp;                 * @param listener                      The listener to notify on transformations.
&nbsp;                 * @param poolStrategy                  The pool strategy to use.
&nbsp;                 * @param typeStrategy                  The definition handler to use.
&nbsp;                 * @param locationStrategy              The location strategy to use.
&nbsp;                 * @param classFileLocator              A class file locator for locating globally available types.
&nbsp;                 * @param nativeMethodStrategy          The native method strategy to apply.
&nbsp;                 * @param initializationStrategy        The initialization strategy to use for transformed types.
&nbsp;                 * @param injectionStrategy             The injection strategy to use.
&nbsp;                 * @param lambdaInstrumentationStrategy The lambda instrumentation strategy to use.
&nbsp;                 * @param descriptionStrategy           The description strategy for resolving type descriptions for types.
&nbsp;                 * @param fallbackStrategy              The fallback strategy to use.
&nbsp;                 * @param classFileBufferStrategy       The class file buffer strategy to use.
&nbsp;                 * @param installationListener          The installation listener to notify.
&nbsp;                 * @param ignoreMatcher                 Identifies types that should not be instrumented.
&nbsp;                 * @param resubmissionEnforcer          The resubmission enforcer to use.
&nbsp;                 * @param transformations               The transformations to apply on non-ignored types.
&nbsp;                 * @param circularityLock               The circularity lock to use.
&nbsp;                 * @return A class file transformer for the current VM that supports the API of the current VM.
&nbsp;                 */
&nbsp;                ResettableClassFileTransformer make(ByteBuddy byteBuddy,
&nbsp;                                                    Listener listener,
&nbsp;                                                    PoolStrategy poolStrategy,
&nbsp;                                                    TypeStrategy typeStrategy,
&nbsp;                                                    LocationStrategy locationStrategy,
&nbsp;                                                    ClassFileLocator classFileLocator,
&nbsp;                                                    NativeMethodStrategy nativeMethodStrategy,
&nbsp;                                                    InitializationStrategy initializationStrategy,
&nbsp;                                                    InjectionStrategy injectionStrategy,
&nbsp;                                                    LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                                                    DescriptionStrategy descriptionStrategy,
&nbsp;                                                    FallbackStrategy fallbackStrategy,
&nbsp;                                                    ClassFileBufferStrategy classFileBufferStrategy,
&nbsp;                                                    InstallationListener installationListener,
&nbsp;                                                    RawMatcher ignoreMatcher,
&nbsp;                                                    RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer,
&nbsp;                                                    List&lt;Transformation&gt; transformations,
&nbsp;                                                    CircularityLock circularityLock);
&nbsp;
&nbsp;                /**
&nbsp;                 * An action to create an implementation of {@link ExecutingTransformer} that support Java 9 modules.
&nbsp;                 */
<b class="fc">&nbsp;                enum CreationAction implements PrivilegedAction&lt;Factory&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                    public Factory run() {
&nbsp;                        try {
<b class="fc">&nbsp;                            return new Factory.ForJava9CapableVm(new ByteBuddy()</b>
<b class="fc">&nbsp;                                    .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                                    .subclass(ExecutingTransformer.class)</b>
<b class="fc">&nbsp;                                    .name(ExecutingTransformer.class.getName() + &quot;$ByteBuddy$ModuleSupport&quot;)</b>
<b class="fc">&nbsp;                                    .method(named(&quot;transform&quot;).and(takesArgument(0, JavaType.MODULE.load())))</b>
<b class="fc">&nbsp;                                    .intercept(MethodCall.invoke(ExecutingTransformer.class.getDeclaredMethod(&quot;transform&quot;,</b>
&nbsp;                                            Object.class,
&nbsp;                                            ClassLoader.class,
&nbsp;                                            String.class,
&nbsp;                                            Class.class,
&nbsp;                                            ProtectionDomain.class,
<b class="fc">&nbsp;                                            byte[].class)).onSuper().withAllArguments())</b>
<b class="fc">&nbsp;                                    .make()</b>
<b class="fc">&nbsp;                                    .load(ExecutingTransformer.class.getClassLoader(),</b>
<b class="fc">&nbsp;                                            ClassLoadingStrategy.Default.WRAPPER_PERSISTENT.with(ExecutingTransformer.class.getProtectionDomain()))</b>
<b class="fc">&nbsp;                                    .getLoaded()</b>
<b class="fc">&nbsp;                                    .getDeclaredConstructor(ByteBuddy.class,</b>
&nbsp;                                            Listener.class,
&nbsp;                                            PoolStrategy.class,
&nbsp;                                            TypeStrategy.class,
&nbsp;                                            LocationStrategy.class,
&nbsp;                                            ClassFileLocator.class,
&nbsp;                                            NativeMethodStrategy.class,
&nbsp;                                            InitializationStrategy.class,
&nbsp;                                            InjectionStrategy.class,
&nbsp;                                            LambdaInstrumentationStrategy.class,
&nbsp;                                            DescriptionStrategy.class,
&nbsp;                                            FallbackStrategy.class,
&nbsp;                                            ClassFileBufferStrategy.class,
&nbsp;                                            InstallationListener.class,
&nbsp;                                            RawMatcher.class,
&nbsp;                                            RedefinitionStrategy.ResubmissionEnforcer.class,
&nbsp;                                            List.class,
&nbsp;                                            CircularityLock.class));
<b class="nc">&nbsp;                        } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                            return Factory.ForLegacyVm.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a class file transformer on a JVM that supports the {@code java.lang.Module} API to override
&nbsp;                 * the newly added method of the {@link ClassFileTransformer} to capture an instrumented class&#39;s module.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForJava9CapableVm implements Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A constructor for creating a {@link ClassFileTransformer} that overrides the newly added method for extracting
&nbsp;                     * the {@code java.lang.Module} of an instrumented class.
&nbsp;                     */
&nbsp;                    private final Constructor&lt;? extends ResettableClassFileTransformer&gt; executingTransformer;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a class file transformer factory for a Java 9 capable VM.
&nbsp;                     *
&nbsp;                     * @param executingTransformer A constructor for creating a {@link ClassFileTransformer} that overrides the newly added
&nbsp;                     *                             method for extracting the {@code java.lang.Module} of an instrumented class.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForJava9CapableVm(Constructor&lt;? extends ResettableClassFileTransformer&gt; executingTransformer) {</b>
<b class="fc">&nbsp;                        this.executingTransformer = executingTransformer;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ResettableClassFileTransformer make(ByteBuddy byteBuddy,
&nbsp;                                                               Listener listener,
&nbsp;                                                               PoolStrategy poolStrategy,
&nbsp;                                                               TypeStrategy typeStrategy,
&nbsp;                                                               LocationStrategy locationStrategy,
&nbsp;                                                               ClassFileLocator classFileLocator,
&nbsp;                                                               NativeMethodStrategy nativeMethodStrategy,
&nbsp;                                                               InitializationStrategy initializationStrategy,
&nbsp;                                                               InjectionStrategy injectionStrategy,
&nbsp;                                                               LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                                                               DescriptionStrategy descriptionStrategy,
&nbsp;                                                               FallbackStrategy fallbackStrategy,
&nbsp;                                                               ClassFileBufferStrategy classFileBufferStrategy,
&nbsp;                                                               InstallationListener installationListener,
&nbsp;                                                               RawMatcher ignoreMatcher,
&nbsp;                                                               RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer,
&nbsp;                                                               List&lt;Transformation&gt; transformations,
&nbsp;                                                               CircularityLock circularityLock) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return executingTransformer.newInstance(byteBuddy,</b>
&nbsp;                                    listener,
&nbsp;                                    poolStrategy,
&nbsp;                                    typeStrategy,
&nbsp;                                    locationStrategy,
&nbsp;                                    classFileLocator,
&nbsp;                                    nativeMethodStrategy,
&nbsp;                                    initializationStrategy,
&nbsp;                                    injectionStrategy,
&nbsp;                                    lambdaInstrumentationStrategy,
&nbsp;                                    descriptionStrategy,
&nbsp;                                    fallbackStrategy,
&nbsp;                                    classFileBufferStrategy,
&nbsp;                                    installationListener,
&nbsp;                                    ignoreMatcher,
&nbsp;                                    resubmissionEnforcer,
&nbsp;                                    transformations,
&nbsp;                                    circularityLock);
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access &quot; + executingTransformer, exception);</b>
<b class="nc">&nbsp;                        } catch (InstantiationException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot instantiate &quot; + executingTransformer.getDeclaringClass(), exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke &quot; + executingTransformer, exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a {@link ClassFileTransformer} on a VM that does not support the {@code java.lang.Module} API.
&nbsp;                 */
<b class="nc">&nbsp;                enum ForLegacyVm implements Factory {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ResettableClassFileTransformer make(ByteBuddy byteBuddy,
&nbsp;                                                               Listener listener,
&nbsp;                                                               PoolStrategy poolStrategy,
&nbsp;                                                               TypeStrategy typeStrategy,
&nbsp;                                                               LocationStrategy locationStrategy,
&nbsp;                                                               ClassFileLocator classFileLocator,
&nbsp;                                                               NativeMethodStrategy nativeMethodStrategy,
&nbsp;                                                               InitializationStrategy initializationStrategy,
&nbsp;                                                               InjectionStrategy injectionStrategy,
&nbsp;                                                               LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                                                               DescriptionStrategy descriptionStrategy,
&nbsp;                                                               FallbackStrategy fallbackStrategy,
&nbsp;                                                               ClassFileBufferStrategy classFileBufferStrategy,
&nbsp;                                                               InstallationListener installationListener,
&nbsp;                                                               RawMatcher ignoreMatcher,
&nbsp;                                                               RedefinitionStrategy.ResubmissionEnforcer resubmissionEnforcer,
&nbsp;                                                               List&lt;Transformation&gt; transformations,
&nbsp;                                                               CircularityLock circularityLock) {
<b class="nc">&nbsp;                        return new ExecutingTransformer(byteBuddy,</b>
&nbsp;                                listener,
&nbsp;                                poolStrategy,
&nbsp;                                typeStrategy,
&nbsp;                                locationStrategy,
&nbsp;                                classFileLocator,
&nbsp;                                nativeMethodStrategy,
&nbsp;                                initializationStrategy,
&nbsp;                                injectionStrategy,
&nbsp;                                lambdaInstrumentationStrategy,
&nbsp;                                descriptionStrategy,
&nbsp;                                fallbackStrategy,
&nbsp;                                classFileBufferStrategy,
&nbsp;                                installationListener,
&nbsp;                                ignoreMatcher,
&nbsp;                                resubmissionEnforcer,
&nbsp;                                transformations,
&nbsp;                                circularityLock);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A privileged action for transforming a class on a JVM prior to Java 9.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class LegacyVmDispatcher implements PrivilegedAction&lt;byte[]&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s class loader or {@code null} if the bootstrap class loader is represented.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final ClassLoader classLoader;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s internal name or {@code null} if no such name exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final String internalTypeName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class being redefined or {@code null} if no such class exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Class&lt;?&gt; classBeingRedefined;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s protection domain or {@code null} if not available.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s binary representation.
&nbsp;                 */
&nbsp;                private final byte[] binaryRepresentation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new type transformation dispatcher.
&nbsp;                 *
&nbsp;                 * @param classLoader          The type&#39;s class loader or {@code null} if the bootstrap class loader is represented.
&nbsp;                 * @param internalTypeName     The type&#39;s internal name or {@code null} if no such name exists.
&nbsp;                 * @param classBeingRedefined  The class being redefined or {@code null} if no such class exists.
&nbsp;                 * @param protectionDomain     The type&#39;s protection domain or {@code null} if not available.
&nbsp;                 * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;                 */
&nbsp;                protected LegacyVmDispatcher(@MaybeNull ClassLoader classLoader,
&nbsp;                                             @MaybeNull String internalTypeName,
&nbsp;                                             @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                             @MaybeNull ProtectionDomain protectionDomain,
<b class="fc">&nbsp;                                             byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;                    this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                    this.internalTypeName = internalTypeName;</b>
<b class="fc">&nbsp;                    this.classBeingRedefined = classBeingRedefined;</b>
<b class="fc">&nbsp;                    this.protectionDomain = protectionDomain;</b>
<b class="fc">&nbsp;                    this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public byte[] run() {
<b class="fc">&nbsp;                    return transform(JavaModule.UNSUPPORTED,</b>
&nbsp;                            classLoader,
&nbsp;                            internalTypeName,
&nbsp;                            classBeingRedefined,
&nbsp;                            protectionDomain,
&nbsp;                            binaryRepresentation);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A privileged action for transforming a class on a JVM that supports modules.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;            protected class Java9CapableVmDispatcher implements PrivilegedAction&lt;byte[]&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s {@code java.lang.Module}.
&nbsp;                 */
&nbsp;                private final Object rawModule;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s class loader or {@code null} if the type is loaded by the bootstrap loader.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final ClassLoader classLoader;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s internal name or {@code null} if no such name exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final String internalTypeName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class being redefined or {@code null} if no such class exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Class&lt;?&gt; classBeingRedefined;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s protection domain or {@code null} if not available.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final ProtectionDomain protectionDomain;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s binary representation.
&nbsp;                 */
&nbsp;                private final byte[] binaryRepresentation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new legacy dispatcher.
&nbsp;                 *
&nbsp;                 * @param rawModule            The type&#39;s {@code java.lang.Module}.
&nbsp;                 * @param classLoader          The type&#39;s class loader or {@code null} if the type is loaded by the bootstrap loader.
&nbsp;                 * @param internalTypeName     The type&#39;s internal name or {@code null} if no such name exists.
&nbsp;                 * @param classBeingRedefined  The class being redefined or {@code null} if no such class exists.
&nbsp;                 * @param protectionDomain     The type&#39;s protection domain or {@code null} if not available.
&nbsp;                 * @param binaryRepresentation The type&#39;s binary representation.
&nbsp;                 */
&nbsp;                protected Java9CapableVmDispatcher(Object rawModule,
&nbsp;                                                   @MaybeNull ClassLoader classLoader,
&nbsp;                                                   @MaybeNull String internalTypeName,
&nbsp;                                                   @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                                   @MaybeNull ProtectionDomain protectionDomain,
<b class="fc">&nbsp;                                                   byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;                    this.rawModule = rawModule;</b>
<b class="fc">&nbsp;                    this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                    this.internalTypeName = internalTypeName;</b>
<b class="fc">&nbsp;                    this.classBeingRedefined = classBeingRedefined;</b>
<b class="fc">&nbsp;                    this.protectionDomain = protectionDomain;</b>
<b class="fc">&nbsp;                    this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public byte[] run() {
<b class="fc">&nbsp;                    return transform(JavaModule.of(rawModule),</b>
&nbsp;                            classLoader,
&nbsp;                            internalTypeName,
&nbsp;                            classBeingRedefined,
&nbsp;                            protectionDomain,
&nbsp;                            binaryRepresentation);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract implementation of an agent builder that delegates all invocation to another instance.
&nbsp;         */
<b class="fc">&nbsp;        protected abstract static class Delegator implements AgentBuilder {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Materializes the currently described {@link net.bytebuddy.agent.builder.AgentBuilder}.
&nbsp;             *
&nbsp;             * @return An agent builder that represents the currently described entry of this instance.
&nbsp;             */
&nbsp;            protected abstract AgentBuilder materialize();
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(ByteBuddy byteBuddy) {
<b class="nc">&nbsp;                return materialize().with(byteBuddy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(Listener listener) {
<b class="nc">&nbsp;                return materialize().with(listener);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(CircularityLock circularityLock) {
<b class="nc">&nbsp;                return materialize().with(circularityLock);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(TypeStrategy typeStrategy) {
<b class="nc">&nbsp;                return materialize().with(typeStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(PoolStrategy poolStrategy) {
<b class="nc">&nbsp;                return materialize().with(poolStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(LocationStrategy locationStrategy) {
<b class="nc">&nbsp;                return materialize().with(locationStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;                return materialize().with(classFileLocator);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(InitializationStrategy initializationStrategy) {
<b class="nc">&nbsp;                return materialize().with(initializationStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RedefinitionListenable.WithoutBatchStrategy with(RedefinitionStrategy redefinitionStrategy) {
<b class="nc">&nbsp;                return materialize().with(redefinitionStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(LambdaInstrumentationStrategy lambdaInstrumentationStrategy) {
<b class="nc">&nbsp;                return materialize().with(lambdaInstrumentationStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(DescriptionStrategy descriptionStrategy) {
<b class="nc">&nbsp;                return materialize().with(descriptionStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(FallbackStrategy fallbackStrategy) {
<b class="nc">&nbsp;                return materialize().with(fallbackStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(ClassFileBufferStrategy classFileBufferStrategy) {
<b class="nc">&nbsp;                return materialize().with(classFileBufferStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(InstallationListener installationListener) {
<b class="nc">&nbsp;                return materialize().with(installationListener);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(InjectionStrategy injectionStrategy) {
<b class="nc">&nbsp;                return materialize().with(injectionStrategy);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder with(TransformerDecorator transformerDecorator) {
<b class="nc">&nbsp;                return materialize().with(transformerDecorator);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder enableNativeMethodPrefix(String prefix) {
<b class="nc">&nbsp;                return materialize().enableNativeMethodPrefix(prefix);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder disableNativeMethodPrefix() {
<b class="nc">&nbsp;                return materialize().disableNativeMethodPrefix();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder disableClassFormatChanges() {
<b class="nc">&nbsp;                return materialize().disableClassFormatChanges();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder warmUp(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;                return materialize().warmUp(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder warmUp(Collection&lt;Class&lt;?&gt;&gt; types) {
<b class="nc">&nbsp;                return materialize().warmUp(types);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Class&lt;?&gt;... type) {
<b class="nc">&nbsp;                return materialize().assureReadEdgeTo(instrumentation, type);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, JavaModule... module) {
<b class="nc">&nbsp;                return materialize().assureReadEdgeTo(instrumentation, module);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder assureReadEdgeTo(Instrumentation instrumentation, Collection&lt;? extends JavaModule&gt; modules) {
<b class="nc">&nbsp;                return materialize().assureReadEdgeTo(instrumentation, modules);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Class&lt;?&gt;... type) {
<b class="nc">&nbsp;                return materialize().assureReadEdgeFromAndTo(instrumentation, type);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, JavaModule... module) {
<b class="nc">&nbsp;                return materialize().assureReadEdgeFromAndTo(instrumentation, module);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder assureReadEdgeFromAndTo(Instrumentation instrumentation, Collection&lt;? extends JavaModule&gt; modules) {
<b class="nc">&nbsp;                return materialize().assureReadEdgeFromAndTo(instrumentation, modules);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="fc">&nbsp;                return materialize().type(typeMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="fc">&nbsp;                return materialize().type(typeMatcher, classLoaderMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Identified.Narrowable type(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                                              ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                              ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="nc">&nbsp;                return materialize().type(typeMatcher, classLoaderMatcher, moduleMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Identified.Narrowable type(RawMatcher matcher) {
<b class="fc">&nbsp;                return materialize().type(matcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; ignoredTypes) {
<b class="nc">&nbsp;                return materialize().ignore(ignoredTypes);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; ignoredTypes, ElementMatcher&lt;? super ClassLoader&gt; ignoredClassLoaders) {
<b class="nc">&nbsp;                return materialize().ignore(ignoredTypes, ignoredClassLoaders);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Ignored ignore(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                                  ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                  ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="nc">&nbsp;                return materialize().ignore(typeMatcher, classLoaderMatcher, moduleMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Ignored ignore(RawMatcher rawMatcher) {
<b class="nc">&nbsp;                return materialize().ignore(rawMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ClassFileTransformer makeRaw() {
<b class="nc">&nbsp;                return materialize().makeRaw();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer installOn(Instrumentation instrumentation) {
<b class="fc">&nbsp;                return materialize().installOn(instrumentation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer installOnByteBuddyAgent() {
<b class="fc">&nbsp;                return materialize().installOnByteBuddyAgent();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                return materialize().patchOn(instrumentation, classFileTransformer);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher) {
<b class="nc">&nbsp;                return materialize().patchOn(instrumentation, classFileTransformer, differentialMatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
<b class="nc">&nbsp;                return materialize().patchOn(instrumentation, classFileTransformer, patchMode);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer patchOn(Instrumentation instrumentation, ResettableClassFileTransformer classFileTransformer, RawMatcher differentialMatcher, PatchMode patchMode) {
<b class="nc">&nbsp;                return materialize().patchOn(instrumentation, classFileTransformer, differentialMatcher, patchMode);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer) {
<b class="nc">&nbsp;                return materialize().patchOnByteBuddyAgent(classFileTransformer);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer patchOnByteBuddyAgent(ResettableClassFileTransformer classFileTransformer, PatchMode patchMode) {
<b class="nc">&nbsp;                return materialize().patchOnByteBuddyAgent(classFileTransformer, patchMode);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of a matchable.
&nbsp;             *
&nbsp;             * @param &lt;S&gt; The type that is produced by chaining a matcher.
&nbsp;             */
<b class="fc">&nbsp;            protected abstract static class Matchable&lt;S extends AgentBuilder.Matchable&lt;S&gt;&gt; extends Delegator implements AgentBuilder.Matchable&lt;S&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public S and(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="fc">&nbsp;                    return and(typeMatcher, any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public S and(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="fc">&nbsp;                    return and(typeMatcher, classLoaderMatcher, any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public S and(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                             ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                             ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="fc">&nbsp;                    return and(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public S or(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {
<b class="fc">&nbsp;                    return or(typeMatcher, any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public S or(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher, ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="fc">&nbsp;                    return or(typeMatcher, classLoaderMatcher, any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public S or(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher,
&nbsp;                            ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                            ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="fc">&nbsp;                    return or(new RawMatcher.ForElementMatchers(typeMatcher, classLoaderMatcher, moduleMatcher));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A delegator transformer for further precising what types to ignore.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Ignoring extends Delegator.Matchable&lt;Ignored&gt; implements Ignored {
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for identifying types that should not be instrumented.
&nbsp;             */
&nbsp;            private final RawMatcher rawMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new agent builder for further specifying what types to ignore.
&nbsp;             *
&nbsp;             * @param rawMatcher A matcher for identifying types that should not be instrumented.
&nbsp;             */
<b class="fc">&nbsp;            protected Ignoring(RawMatcher rawMatcher) {</b>
<b class="fc">&nbsp;                this.rawMatcher = rawMatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected AgentBuilder materialize() {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        listener,
&nbsp;                        circularityLock,
&nbsp;                        poolStrategy,
&nbsp;                        typeStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        nativeMethodStrategy,
&nbsp;                        warmupStrategy,
&nbsp;                        transformerDecorator,
&nbsp;                        initializationStrategy,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener,
&nbsp;                        redefinitionResubmissionStrategy,
&nbsp;                        injectionStrategy,
&nbsp;                        lambdaInstrumentationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        classFileBufferStrategy,
&nbsp;                        installationListener,
&nbsp;                        rawMatcher,
&nbsp;                        transformations);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Ignored and(RawMatcher rawMatcher) {
<b class="fc">&nbsp;                return new Ignoring(new RawMatcher.Conjunction(this.rawMatcher, rawMatcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Ignored or(RawMatcher rawMatcher) {
<b class="fc">&nbsp;                return new Ignoring(new RawMatcher.Disjunction(this.rawMatcher, rawMatcher));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A helper class that describes a {@link net.bytebuddy.agent.builder.AgentBuilder.Default} after supplying
&nbsp;         * a {@link net.bytebuddy.agent.builder.AgentBuilder.RawMatcher} such that one or several
&nbsp;         * {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer}s can be supplied.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;        protected class Transforming extends Delegator.Matchable&lt;Identified.Narrowable&gt; implements Identified.Extendable, Identified.Narrowable {
&nbsp;
&nbsp;            /**
&nbsp;             * The supplied raw matcher.
&nbsp;             */
&nbsp;            private final RawMatcher rawMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The supplied transformer.
&nbsp;             */
&nbsp;            private final List&lt;Transformer&gt; transformers;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this transformer is a terminal transformation.
&nbsp;             */
&nbsp;            private final boolean terminal;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new matched default agent builder.
&nbsp;             *
&nbsp;             * @param rawMatcher   The supplied raw matcher.
&nbsp;             * @param transformers The transformers to apply.
&nbsp;             * @param terminal     {@code true} if this transformer is a terminal transformation.
&nbsp;             */
<b class="fc">&nbsp;            protected Transforming(RawMatcher rawMatcher, List&lt;Transformer&gt; transformers, boolean terminal) {</b>
<b class="fc">&nbsp;                this.rawMatcher = rawMatcher;</b>
<b class="fc">&nbsp;                this.transformers = transformers;</b>
<b class="fc">&nbsp;                this.terminal = terminal;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected AgentBuilder materialize() {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        listener,
&nbsp;                        circularityLock,
&nbsp;                        poolStrategy,
&nbsp;                        typeStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        nativeMethodStrategy,
&nbsp;                        warmupStrategy,
&nbsp;                        transformerDecorator,
&nbsp;                        initializationStrategy,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener,
&nbsp;                        redefinitionResubmissionStrategy,
&nbsp;                        injectionStrategy,
&nbsp;                        lambdaInstrumentationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        classFileBufferStrategy,
&nbsp;                        installationListener,
&nbsp;                        ignoreMatcher,
<b class="fc">&nbsp;                        CompoundList.of(transformations, new Transformation(rawMatcher, transformers, terminal)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Identified.Extendable transform(Transformer transformer) {
<b class="fc">&nbsp;                return new Transforming(rawMatcher, CompoundList.of(this.transformers, transformer), terminal);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AgentBuilder asTerminalTransformation() {
<b class="nc">&nbsp;                return new Transforming(rawMatcher, transformers, true);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Narrowable and(RawMatcher rawMatcher) {
<b class="fc">&nbsp;                return new Transforming(new RawMatcher.Conjunction(this.rawMatcher, rawMatcher), transformers, terminal);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Narrowable or(RawMatcher rawMatcher) {
<b class="fc">&nbsp;                return new Transforming(new RawMatcher.Disjunction(this.rawMatcher, rawMatcher), transformers, terminal);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation of a default agent builder that allows for refinement of the redefinition strategy.
&nbsp;         */
&nbsp;        protected static class Redefining extends Default implements RedefinitionListenable.WithoutBatchStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default agent builder that allows for refinement of the redefinition strategy.
&nbsp;             *
&nbsp;             * @param byteBuddy                        The Byte Buddy instance to be used.
&nbsp;             * @param listener                         The listener to notify on transformations.
&nbsp;             * @param circularityLock                  The circularity lock to use.
&nbsp;             * @param poolStrategy                     The pool strategy to use.
&nbsp;             * @param typeStrategy                     The definition handler to use.
&nbsp;             * @param locationStrategy                 The location strategy to use.
&nbsp;             * @param classFileLocator                 A class file locator to be used for additional lookup of globally available types.
&nbsp;             * @param nativeMethodStrategy             The native method strategy to apply.
&nbsp;             * @param warmupStrategy                   The warmup strategy to use.
&nbsp;             * @param transformerDecorator             A decorator to wrap the created class file transformer.
&nbsp;             * @param initializationStrategy           The initialization strategy to use for transformed types.
&nbsp;             * @param redefinitionStrategy             The redefinition strategy to apply.
&nbsp;             * @param redefinitionDiscoveryStrategy    The discovery strategy for loaded types to be redefined.
&nbsp;             * @param redefinitionBatchAllocator       The batch allocator for the redefinition strategy to apply.
&nbsp;             * @param redefinitionListener             The redefinition listener for the redefinition strategy to apply.
&nbsp;             * @param redefinitionResubmissionStrategy The resubmission strategy to apply.
&nbsp;             * @param injectionStrategy                The injection strategy to use.
&nbsp;             * @param lambdaInstrumentationStrategy    A strategy to determine of the {@code LambdaMetafactory} should be instrumented to allow for the
&nbsp;             *                                         instrumentation of classes that represent lambda expressions.
&nbsp;             * @param descriptionStrategy              The description strategy for resolving type descriptions for types.
&nbsp;             * @param fallbackStrategy                 The fallback strategy to apply.
&nbsp;             * @param classFileBufferStrategy          The class file buffer strategy to use.
&nbsp;             * @param installationListener             The installation listener to notify.
&nbsp;             * @param ignoreMatcher                    Identifies types that should not be instrumented.
&nbsp;             * @param transformations                  The transformations to apply on non-ignored types.
&nbsp;             */
&nbsp;            protected Redefining(ByteBuddy byteBuddy,
&nbsp;                                 Listener listener,
&nbsp;                                 CircularityLock circularityLock,
&nbsp;                                 PoolStrategy poolStrategy,
&nbsp;                                 TypeStrategy typeStrategy,
&nbsp;                                 LocationStrategy locationStrategy,
&nbsp;                                 ClassFileLocator classFileLocator,
&nbsp;                                 NativeMethodStrategy nativeMethodStrategy,
&nbsp;                                 WarmupStrategy warmupStrategy,
&nbsp;                                 TransformerDecorator transformerDecorator,
&nbsp;                                 InitializationStrategy initializationStrategy,
&nbsp;                                 RedefinitionStrategy redefinitionStrategy,
&nbsp;                                 RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                                 RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                                 RedefinitionStrategy.Listener redefinitionListener,
&nbsp;                                 RedefinitionStrategy.ResubmissionStrategy redefinitionResubmissionStrategy,
&nbsp;                                 InjectionStrategy injectionStrategy,
&nbsp;                                 LambdaInstrumentationStrategy lambdaInstrumentationStrategy,
&nbsp;                                 DescriptionStrategy descriptionStrategy,
&nbsp;                                 FallbackStrategy fallbackStrategy,
&nbsp;                                 ClassFileBufferStrategy classFileBufferStrategy,
&nbsp;                                 InstallationListener installationListener,
&nbsp;                                 RawMatcher ignoreMatcher,
&nbsp;                                 List&lt;Transformation&gt; transformations) {
<b class="fc">&nbsp;                super(byteBuddy,</b>
&nbsp;                        listener,
&nbsp;                        circularityLock,
&nbsp;                        poolStrategy,
&nbsp;                        typeStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        nativeMethodStrategy,
&nbsp;                        warmupStrategy,
&nbsp;                        transformerDecorator,
&nbsp;                        initializationStrategy,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener,
&nbsp;                        redefinitionResubmissionStrategy,
&nbsp;                        injectionStrategy,
&nbsp;                        lambdaInstrumentationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        classFileBufferStrategy,
&nbsp;                        installationListener,
&nbsp;                        ignoreMatcher,
&nbsp;                        transformations);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public WithImplicitDiscoveryStrategy with(RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator) {
<b class="fc">&nbsp;                if (!redefinitionStrategy.isEnabled()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set redefinition batch allocator when redefinition is disabled&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Redefining(byteBuddy,</b>
&nbsp;                        listener,
&nbsp;                        circularityLock,
&nbsp;                        poolStrategy,
&nbsp;                        typeStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        nativeMethodStrategy,
&nbsp;                        warmupStrategy,
&nbsp;                        transformerDecorator,
&nbsp;                        initializationStrategy,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener,
&nbsp;                        redefinitionResubmissionStrategy,
&nbsp;                        injectionStrategy,
&nbsp;                        lambdaInstrumentationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        classFileBufferStrategy,
&nbsp;                        installationListener,
&nbsp;                        ignoreMatcher,
&nbsp;                        transformations);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RedefinitionListenable redefineOnly(Class&lt;?&gt;... type) {
<b class="nc">&nbsp;                return with(new RedefinitionStrategy.DiscoveryStrategy.Explicit(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RedefinitionListenable with(RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy) {
<b class="fc">&nbsp;                if (!redefinitionStrategy.isEnabled()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set redefinition discovery strategy when redefinition is disabled&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Redefining(byteBuddy,</b>
&nbsp;                        listener,
&nbsp;                        circularityLock,
&nbsp;                        poolStrategy,
&nbsp;                        typeStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        nativeMethodStrategy,
&nbsp;                        warmupStrategy,
&nbsp;                        transformerDecorator,
&nbsp;                        initializationStrategy,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener,
&nbsp;                        redefinitionResubmissionStrategy,
&nbsp;                        injectionStrategy,
&nbsp;                        lambdaInstrumentationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        classFileBufferStrategy,
&nbsp;                        installationListener,
&nbsp;                        ignoreMatcher,
&nbsp;                        transformations);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RedefinitionListenable with(RedefinitionStrategy.Listener redefinitionListener) {
<b class="fc">&nbsp;                if (!redefinitionStrategy.isEnabled()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot set redefinition listener when redefinition is disabled&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Redefining(byteBuddy,</b>
&nbsp;                        listener,
&nbsp;                        circularityLock,
&nbsp;                        poolStrategy,
&nbsp;                        typeStrategy,
&nbsp;                        locationStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        nativeMethodStrategy,
&nbsp;                        warmupStrategy,
&nbsp;                        transformerDecorator,
&nbsp;                        initializationStrategy,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        new RedefinitionStrategy.Listener.Compound(this.redefinitionListener, redefinitionListener),
&nbsp;                        redefinitionResubmissionStrategy,
&nbsp;                        injectionStrategy,
&nbsp;                        lambdaInstrumentationStrategy,
&nbsp;                        descriptionStrategy,
&nbsp;                        fallbackStrategy,
&nbsp;                        classFileBufferStrategy,
&nbsp;                        installationListener,
&nbsp;                        ignoreMatcher,
&nbsp;                        transformations);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public WithoutResubmissionSpecification withResubmission(RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler) {
<b class="fc">&nbsp;                if (!redefinitionStrategy.isEnabled()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot enable resubmission when redefinition is disabled&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new WithResubmission(resubmissionScheduler,</b>
&nbsp;                        ResubmissionOnErrorMatcher.Trivial.NON_MATCHING,
&nbsp;                        ResubmissionImmediateMatcher.Trivial.NON_MATCHING);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A delegator that applies a resubmission.
&nbsp;             */
&nbsp;            protected class WithResubmission extends Delegator implements WithResubmissionSpecification {
&nbsp;
&nbsp;                /**
&nbsp;                 * The resubmission scheduler to use.
&nbsp;                 */
&nbsp;                private final RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler;
&nbsp;
&nbsp;                /**
&nbsp;                 * A matcher to determine resubmissions on errors.
&nbsp;                 */
&nbsp;                private final ResubmissionOnErrorMatcher resubmissionOnErrorMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * A matcher to determine resubmissions without errors.
&nbsp;                 */
&nbsp;                private final ResubmissionImmediateMatcher resubmissionImmediateMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new delegator that applies resubmissions.
&nbsp;                 *
&nbsp;                 * @param resubmissionScheduler        The resubmission scheduler to use.
&nbsp;                 * @param resubmissionOnErrorMatcher   A matcher to determine resubmissions on errors.
&nbsp;                 * @param resubmissionImmediateMatcher A matcher to determine resubmissions without errors.
&nbsp;                 */
&nbsp;                protected WithResubmission(RedefinitionStrategy.ResubmissionScheduler resubmissionScheduler,
&nbsp;                                           ResubmissionOnErrorMatcher resubmissionOnErrorMatcher,
<b class="nc">&nbsp;                                           ResubmissionImmediateMatcher resubmissionImmediateMatcher) {</b>
<b class="nc">&nbsp;                    this.resubmissionScheduler = resubmissionScheduler;</b>
<b class="nc">&nbsp;                    this.resubmissionOnErrorMatcher = resubmissionOnErrorMatcher;</b>
<b class="nc">&nbsp;                    this.resubmissionImmediateMatcher = resubmissionImmediateMatcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AgentBuilder materialize() {
<b class="nc">&nbsp;                    return new Default(byteBuddy,</b>
&nbsp;                            listener,
&nbsp;                            circularityLock,
&nbsp;                            poolStrategy,
&nbsp;                            typeStrategy,
&nbsp;                            locationStrategy,
&nbsp;                            classFileLocator,
&nbsp;                            nativeMethodStrategy,
&nbsp;                            warmupStrategy,
&nbsp;                            transformerDecorator,
&nbsp;                            initializationStrategy,
&nbsp;                            redefinitionStrategy,
&nbsp;                            redefinitionDiscoveryStrategy,
&nbsp;                            redefinitionBatchAllocator,
&nbsp;                            redefinitionListener,
&nbsp;                            new RedefinitionStrategy.ResubmissionStrategy.Enabled(resubmissionScheduler, resubmissionOnErrorMatcher, resubmissionImmediateMatcher),
&nbsp;                            injectionStrategy,
&nbsp;                            lambdaInstrumentationStrategy,
&nbsp;                            descriptionStrategy,
&nbsp;                            fallbackStrategy,
&nbsp;                            classFileBufferStrategy,
&nbsp;                            installationListener,
&nbsp;                            ignoreMatcher,
&nbsp;                            transformations);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitOnError() {
<b class="nc">&nbsp;                    return resubmitOnError(ElementMatchers.&lt;Throwable&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher) {
<b class="nc">&nbsp;                    return resubmitOnError(exceptionMatcher, ElementMatchers.&lt;String&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                                                     ElementMatcher&lt;String&gt; typeNameMatcher) {
<b class="nc">&nbsp;                    return resubmitOnError(exceptionMatcher, typeNameMatcher, ElementMatchers.&lt;ClassLoader&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                                                     ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                                     ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="nc">&nbsp;                    return resubmitOnError(exceptionMatcher, typeNameMatcher, classLoaderMatcher, ElementMatchers.&lt;JavaModule&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitOnError(ElementMatcher&lt;? super Throwable&gt; exceptionMatcher,
&nbsp;                                                                     ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                                     ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                                                     ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="nc">&nbsp;                    return resubmitOnError(new ResubmissionOnErrorMatcher.ForElementMatchers(exceptionMatcher, typeNameMatcher, classLoaderMatcher, moduleMatcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitOnError(ResubmissionOnErrorMatcher matcher) {
<b class="nc">&nbsp;                    return new WithResubmission(resubmissionScheduler,</b>
&nbsp;                            new ResubmissionOnErrorMatcher.Disjunction(resubmissionOnErrorMatcher, matcher),
&nbsp;                            resubmissionImmediateMatcher);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitImmediate() {
<b class="nc">&nbsp;                    return resubmitImmediate(ElementMatchers.&lt;String&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitImmediate(ElementMatcher&lt;String&gt; typeNameMatcher) {
<b class="nc">&nbsp;                    return resubmitImmediate(typeNameMatcher, ElementMatchers.&lt;ClassLoader&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitImmediate(ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                                       ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher) {
<b class="nc">&nbsp;                    return resubmitImmediate(typeNameMatcher, classLoaderMatcher, ElementMatchers.&lt;JavaModule&gt;any());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitImmediate(ElementMatcher&lt;String&gt; typeNameMatcher,
&nbsp;                                                                       ElementMatcher&lt;? super ClassLoader&gt; classLoaderMatcher,
&nbsp;                                                                       ElementMatcher&lt;? super JavaModule&gt; moduleMatcher) {
<b class="nc">&nbsp;                    return resubmitImmediate(new ResubmissionImmediateMatcher.ForElementMatchers(typeNameMatcher, classLoaderMatcher, moduleMatcher));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public WithResubmissionSpecification resubmitImmediate(ResubmissionImmediateMatcher matcher) {
<b class="nc">&nbsp;                    return new WithResubmission(resubmissionScheduler,</b>
&nbsp;                            resubmissionOnErrorMatcher,
&nbsp;                            new ResubmissionImmediateMatcher.Disjunction(resubmissionImmediateMatcher, matcher));
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
