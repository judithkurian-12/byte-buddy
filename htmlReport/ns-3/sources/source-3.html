


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ResettableClassFileTransformer</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.agent.builder</a>
</div>

<h1>Coverage Summary for Class: ResettableClassFileTransformer (net.bytebuddy.agent.builder)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$MockitoMock$523857678</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$MockitoMock$523857678$auxiliary$3x1FEmUV</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$MockitoMock$523857678$auxiliary$DU4sa0wg</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$MockitoMock$523857678$auxiliary$o4rsMM69</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$MockitoMock$523857678$auxiliary$TbXqN7iG</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$Substitutable</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$Substitutable$MockitoMock$458399386</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$Substitutable$MockitoMock$458399386$auxiliary$E7NvIEzY</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$Substitutable$MockitoMock$458399386$auxiliary$ilEN9Ili</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$Substitutable$MockitoMock$458399386$auxiliary$vKBwLRQV</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$Substitutable$MockitoMock$458399386$auxiliary$vrTaXP8Y</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation$Substitutable</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (8/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation$Substitutable$ByteBuddy$ModuleSupport</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation$Substitutable$Factory</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation$Substitutable$Factory$CreationAction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (15/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation$Substitutable$Factory$ForJava9CapableVm</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (3/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ResettableClassFileTransformer$WithDelegation$Substitutable$Factory$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    64.3%
  </span>
  <span class="absValue">
    (18/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.2%
  </span>
  <span class="absValue">
    (34/53)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.agent.builder;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.implementation.MethodCall;
&nbsp;import net.bytebuddy.utility.JavaModule;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.lang.instrument.ClassFileTransformer;
&nbsp;import java.lang.instrument.IllegalClassFormatException;
&nbsp;import java.lang.instrument.Instrumentation;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.security.ProtectionDomain;
&nbsp;import java.util.Iterator;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.takesArgument;
&nbsp;
&nbsp;/**
&nbsp; * A class file transformer that can reset its transformation.
&nbsp; */
&nbsp;public interface ResettableClassFileTransformer extends ClassFileTransformer {
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an iterator over the transformers that are applied for a given type.
&nbsp;     *
&nbsp;     * @param typeDescription     A description of a type.
&nbsp;     * @param classLoader         The type&#39;s class loader or {@code null} if the boot loader.
&nbsp;     * @param module              The type&#39;s module or {@code null} if the module system is not supported by the current VM.
&nbsp;     * @param classBeingRedefined The class being redefined or {@code null} if the type is not yet loaded.
&nbsp;     * @param protectionDomain    The type&#39;s protection domain or {@code null} if not available.
&nbsp;     * @return An iterator over the transformers that are applied by this class file transformer if the given type is discovered.
&nbsp;     */
&nbsp;    Iterator&lt;AgentBuilder.Transformer&gt; iterator(TypeDescription typeDescription,
&nbsp;                                                @MaybeNull ClassLoader classLoader,
&nbsp;                                                @MaybeNull JavaModule module,
&nbsp;                                                @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                                @MaybeNull ProtectionDomain protectionDomain);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation      The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy The redefinition to apply.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation            The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy       The redefinition to apply.
&nbsp;     * @param redefinitionBatchAllocator The batch allocator to use.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation               The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy          The redefinition to apply.
&nbsp;     * @param redefinitionDiscoveryStrategy The discovery strategy for the types to reset.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation               The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy          The redefinition to apply.
&nbsp;     * @param redefinitionDiscoveryStrategy The discovery strategy for the types to reset.
&nbsp;     * @param redefinitionBatchAllocator    The batch allocator to use.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                  AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation               The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy          The redefinition to apply.
&nbsp;     * @param redefinitionDiscoveryStrategy The discovery strategy for the types to reset.
&nbsp;     * @param redefinitionListener          The redefinition listener to apply.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation            The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy       The redefinition to apply.
&nbsp;     * @param redefinitionBatchAllocator The batch allocator to use.
&nbsp;     * @param redefinitionListener       The redefinition listener to apply.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;overloads&quot;)
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                  AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation               The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param redefinitionStrategy          The redefinition to apply.
&nbsp;     * @param redefinitionDiscoveryStrategy The discovery strategy for the types to reset.
&nbsp;     * @param redefinitionBatchAllocator    The batch allocator to use.
&nbsp;     * @param redefinitionListener          The redefinition listener to apply.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                  AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Deregisters this class file transformer and redefines any transformed class to its state without this
&nbsp;     * class file transformer applied, if the supplied redefinition strategy is enabled. If it is not enabled,
&nbsp;     * only the {@link net.bytebuddy.agent.builder.AgentBuilder.InstallationListener} is informed about the
&nbsp;     * resetting without undoing any code changes.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A reset class file transformer should not be reinstalled. Instead, the {@link AgentBuilder}
&nbsp;     * which built the transformer should be asked to install a new transformer.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Most JVMs do not support changes of a class&#39;s structure after a class was already
&nbsp;     * loaded. Therefore, it is typically required that this class file transformer was built while enabling
&nbsp;     * {@link AgentBuilder#disableClassFormatChanges()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @param instrumentation               The instrumentation instance from which to deregister the transformer.
&nbsp;     * @param classFileTransformer          The actual class file transformer to deregister which might be {@code this} instance or any wrapper.
&nbsp;     * @param redefinitionStrategy          The redefinition to apply.
&nbsp;     * @param redefinitionDiscoveryStrategy The discovery strategy for the types to reset.
&nbsp;     * @param redefinitionBatchAllocator    The batch allocator to use.
&nbsp;     * @param redefinitionListener          The redefinition listener to apply.
&nbsp;     * @return {@code true} if a reset was applied and this transformer was not previously removed.
&nbsp;     */
&nbsp;    boolean reset(Instrumentation instrumentation,
&nbsp;                  ResettableClassFileTransformer classFileTransformer,
&nbsp;                  AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                  AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                  AgentBuilder.RedefinitionStrategy.Listener redefinitionListener);
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link ResettableClassFileTransformer} which allows for substitution the actual class file transformer without
&nbsp;     * changes in the order of the transformer chain.
&nbsp;     */
&nbsp;    interface Substitutable extends ResettableClassFileTransformer {
&nbsp;
&nbsp;        /**
&nbsp;         * Substitutes the current class file transformer.
&nbsp;         *
&nbsp;         * @param classFileTransformer The class file transformer to use.
&nbsp;         */
&nbsp;        void substitute(ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the underlying non-substitutable class file transformer.
&nbsp;         *
&nbsp;         * @return The underlying non-substitutable class file transformer.
&nbsp;         */
&nbsp;        ResettableClassFileTransformer unwrap();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a {@link ResettableClassFileTransformer}.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase implements ResettableClassFileTransformer {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation, AgentBuilder.RedefinitionStrategy redefinitionStrategy) {
<b class="fc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    redefinitionStrategy,
&nbsp;                    AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator) {
<b class="fc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    AgentBuilder.RedefinitionStrategy.Listener.NoOp.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy) {
<b class="nc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    AgentBuilder.RedefinitionStrategy.Listener.NoOp.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                             AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy) {
<b class="nc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    AgentBuilder.RedefinitionStrategy.Listener.NoOp.INSTANCE);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
<b class="nc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    AgentBuilder.RedefinitionStrategy.BatchAllocator.ForTotal.INSTANCE,
&nbsp;                    redefinitionListener);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                             AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
<b class="fc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    redefinitionStrategy,
&nbsp;                    AgentBuilder.RedefinitionStrategy.DiscoveryStrategy.SinglePass.INSTANCE,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                             AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
<b class="fc">&nbsp;            return reset(instrumentation,</b>
&nbsp;                    this,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements a resettable class file transformer that allows for the delegation of a transformation. Typically implemented
&nbsp;     * when using a {@link net.bytebuddy.agent.builder.AgentBuilder.TransformerDecorator}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    abstract class WithDelegation extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The class file transformer to delegate to.
&nbsp;         */
&nbsp;        protected final ResettableClassFileTransformer classFileTransformer;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new delegating resettable class file transformer.
&nbsp;         *
&nbsp;         * @param classFileTransformer The class file transformer to delegate to.
&nbsp;         */
<b class="fc">&nbsp;        protected WithDelegation(ResettableClassFileTransformer classFileTransformer) {</b>
<b class="fc">&nbsp;            this.classFileTransformer = classFileTransformer;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Iterator&lt;AgentBuilder.Transformer&gt; iterator(TypeDescription typeDescription,
&nbsp;                                                           @MaybeNull ClassLoader classLoader,
&nbsp;                                                           @MaybeNull JavaModule module,
&nbsp;                                                           @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                                           @MaybeNull ProtectionDomain protectionDomain) {
<b class="nc">&nbsp;            return classFileTransformer.iterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean reset(Instrumentation instrumentation,
&nbsp;                             ResettableClassFileTransformer classFileTransformer,
&nbsp;                             AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                             AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                             AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
<b class="fc">&nbsp;            return this.classFileTransformer.reset(instrumentation,</b>
&nbsp;                    classFileTransformer,
&nbsp;                    redefinitionStrategy,
&nbsp;                    redefinitionDiscoveryStrategy,
&nbsp;                    redefinitionBatchAllocator,
&nbsp;                    redefinitionListener);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A standard implementation of a substitutable {@link ResettableClassFileTransformer}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Substitutable extends AbstractBase implements ResettableClassFileTransformer.Substitutable {
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for invoking the correct transformer method.
&nbsp;             */
<b class="fc">&nbsp;            private static final Factory DISPATCHER = doPrivileged(Factory.CreationAction.INSTANCE);</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The class file transformer to delegate to.
&nbsp;             */
&nbsp;            protected volatile ResettableClassFileTransformer classFileTransformer;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new delegating resettable class file transformer.
&nbsp;             *
&nbsp;             * @param classFileTransformer The class file transformer to delegate to.
&nbsp;             */
<b class="fc">&nbsp;            protected Substitutable(ResettableClassFileTransformer classFileTransformer) {</b>
<b class="fc">&nbsp;                this.classFileTransformer = classFileTransformer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;             *
&nbsp;             * @param action The action to execute from a privileged context.
&nbsp;             * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;             * @return The action&#39;s resolved value.
&nbsp;             */
&nbsp;            @AccessControllerPlugin.Enhance
&nbsp;            private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;                return action.run();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new substitutable class file transformer of another class file transformer.
&nbsp;             *
&nbsp;             * @param classFileTransformer The class file transformer to wrap.
&nbsp;             * @return A substitutable version of the supplied class file transformer.
&nbsp;             */
&nbsp;            public static Substitutable of(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                return DISPATCHER.make(classFileTransformer);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void substitute(ResettableClassFileTransformer classFileTransformer) {
<b class="fc">&nbsp;                while (classFileTransformer instanceof Substitutable) {</b>
<b class="nc">&nbsp;                    classFileTransformer = ((Substitutable) classFileTransformer).unwrap();</b>
&nbsp;                }
<b class="fc">&nbsp;                this.classFileTransformer = classFileTransformer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ResettableClassFileTransformer unwrap() {
<b class="nc">&nbsp;                return classFileTransformer;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;AgentBuilder.Transformer&gt; iterator(TypeDescription typeDescription,
&nbsp;                                                               @MaybeNull ClassLoader classLoader,
&nbsp;                                                               @MaybeNull JavaModule module,
&nbsp;                                                               @MaybeNull Class&lt;?&gt; classBeingRedefined,
&nbsp;                                                               @MaybeNull ProtectionDomain protectionDomain) {
<b class="nc">&nbsp;                return classFileTransformer.iterator(typeDescription, classLoader, module, classBeingRedefined, protectionDomain);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean reset(Instrumentation instrumentation,
&nbsp;                                 ResettableClassFileTransformer classFileTransformer,
&nbsp;                                 AgentBuilder.RedefinitionStrategy redefinitionStrategy,
&nbsp;                                 AgentBuilder.RedefinitionStrategy.DiscoveryStrategy redefinitionDiscoveryStrategy,
&nbsp;                                 AgentBuilder.RedefinitionStrategy.BatchAllocator redefinitionBatchAllocator,
&nbsp;                                 AgentBuilder.RedefinitionStrategy.Listener redefinitionListener) {
<b class="nc">&nbsp;                return this.classFileTransformer.reset(instrumentation,</b>
&nbsp;                        classFileTransformer,
&nbsp;                        redefinitionStrategy,
&nbsp;                        redefinitionDiscoveryStrategy,
&nbsp;                        redefinitionBatchAllocator,
&nbsp;                        redefinitionListener);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public byte[] transform(ClassLoader classLoader, String internalName, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] binaryRepresentation) throws IllegalClassFormatException {
<b class="fc">&nbsp;                return classFileTransformer.transform(classLoader, internalName, classBeingRedefined, protectionDomain, binaryRepresentation);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a subclass of {@link WithDelegation.Substitutable} that supports the module system, if available.
&nbsp;             */
&nbsp;            interface Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new substitutable class file transformer.
&nbsp;                 *
&nbsp;                 * @param classFileTransformer The class file transformer to wrap.
&nbsp;                 * @return The wrapping class file transformer.
&nbsp;                 */
&nbsp;                Substitutable make(ResettableClassFileTransformer classFileTransformer);
&nbsp;
&nbsp;                /**
&nbsp;                 * An action to create a suitable factory.
&nbsp;                 */
<b class="fc">&nbsp;                enum CreationAction implements PrivilegedAction&lt;Factory&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should not be rethrown but trigger a fallback.&quot;)
&nbsp;                    public Factory run() {
&nbsp;                        try {
<b class="fc">&nbsp;                            return new ForJava9CapableVm(new ByteBuddy()</b>
<b class="fc">&nbsp;                                    .with(TypeValidation.DISABLED)</b>
<b class="fc">&nbsp;                                    .subclass(WithDelegation.Substitutable.class)</b>
<b class="fc">&nbsp;                                    .name(WithDelegation.Substitutable.class.getName() + &quot;$ByteBuddy$ModuleSupport&quot;)</b>
<b class="fc">&nbsp;                                    .method(named(&quot;transform&quot;).and(takesArgument(0, JavaType.MODULE.load())))</b>
<b class="fc">&nbsp;                                    .intercept(MethodCall.invoke(ClassFileTransformer.class.getDeclaredMethod(&quot;transform&quot;,</b>
<b class="fc">&nbsp;                                            JavaType.MODULE.load(),</b>
&nbsp;                                            ClassLoader.class,
&nbsp;                                            String.class,
&nbsp;                                            Class.class,
&nbsp;                                            ProtectionDomain.class,
<b class="fc">&nbsp;                                            byte[].class)).onField(&quot;classFileTransformer&quot;).withAllArguments())</b>
<b class="fc">&nbsp;                                    .make()</b>
<b class="fc">&nbsp;                                    .load(WithDelegation.Substitutable.class.getClassLoader(),</b>
<b class="fc">&nbsp;                                            ClassLoadingStrategy.Default.WRAPPER_PERSISTENT.with(WithDelegation.Substitutable.class.getProtectionDomain()))</b>
<b class="fc">&nbsp;                                    .getLoaded()</b>
<b class="fc">&nbsp;                                    .getDeclaredConstructor(ResettableClassFileTransformer.class));</b>
<b class="nc">&nbsp;                        } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                            return ForLegacyVm.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for creating a substitutable class file transformer when the module system is supported.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForJava9CapableVm implements Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The constructor to invoke.
&nbsp;                     */
&nbsp;                    private final Constructor&lt;? extends Substitutable&gt; substitutable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new Java 9 capable factory.
&nbsp;                     *
&nbsp;                     * @param substitutable The constructor to invoke.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForJava9CapableVm(Constructor&lt;? extends Substitutable&gt; substitutable) {</b>
<b class="fc">&nbsp;                        this.substitutable = substitutable;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Substitutable make(ResettableClassFileTransformer classFileTransformer) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return substitutable.newInstance(classFileTransformer);</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access &quot; + substitutable, exception);</b>
<b class="nc">&nbsp;                        } catch (InstantiationException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot instantiate &quot; + substitutable.getDeclaringClass(), exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke &quot; + substitutable, exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a substitutable class file transformer when the module system is not supported.
&nbsp;                 */
<b class="nc">&nbsp;                enum ForLegacyVm implements Factory {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Substitutable make(ResettableClassFileTransformer classFileTransformer) {
<b class="nc">&nbsp;                        return new WithDelegation.Substitutable(classFileTransformer);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
