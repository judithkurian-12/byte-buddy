


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AndroidClassLoadingStrategy</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.android</a>
</div>

<h1>Coverage Summary for Class: AndroidClassLoadingStrategy (net.bytebuddy.android)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AndroidClassLoadingStrategy</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.5%
  </span>
  <span class="absValue">
    (31/39)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$Conversion</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$Conversion$MockitoMock$1334956293</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$Conversion$MockitoMock$1334956293$auxiliary$27HClBAd</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$Conversion$MockitoMock$1334956293$auxiliary$iKeeLdp5</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.8%
  </span>
  <span class="absValue">
    (11/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler$Conversion</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler$Dispatcher$ForApi26LevelCompatibleVm</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    41.7%
  </span>
  <span class="absValue">
    (5/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler$Dispatcher$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$ForSdkCompiler$Dispatcher$Unavailable</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$MockitoMock$1245759988</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$MockitoMock$1245759988$auxiliary$jQscl5Rf</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$DexProcessor$MockitoMock$1245759988$auxiliary$MsjcvQFc</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$FileProcessor</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$FileProcessor$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$FileProcessor$ForReadOnlyClassFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$Injecting</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    29.2%
  </span>
  <span class="absValue">
    (7/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$Injecting$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$Injecting$Dispatcher$ForAndroidPVm</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.9%
  </span>
  <span class="absValue">
    (1/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$Injecting$Dispatcher$ForLegacyVm</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AndroidClassLoadingStrategy$Wrapping</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    47.6%
  </span>
  <span class="absValue">
    (20/42)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    43%
  </span>
  <span class="absValue">
    (74/172)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.android;
&nbsp;
&nbsp;import android.annotation.TargetApi;
&nbsp;import android.os.Build;
&nbsp;import com.android.dx.cf.direct.DirectClassFile;
&nbsp;import com.android.dx.cf.direct.StdAttributeFactory;
&nbsp;import com.android.dx.dex.DexOptions;
&nbsp;import com.android.dx.dex.cf.CfOptions;
&nbsp;import com.android.dx.dex.cf.CfTranslator;
&nbsp;import com.android.dx.dex.file.ClassDefItem;
&nbsp;import com.android.dx.dex.file.DexFile;
&nbsp;import dalvik.system.BaseDexClassLoader;
&nbsp;import dalvik.system.DexClassLoader;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.utility.RandomString;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FileOutputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.OutputStream;
&nbsp;import java.io.Writer;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import java.util.logging.Logger;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * A class loading strategy that allows to load a dynamically created class at the runtime of an Android
&nbsp; * application. For this, a {@link dalvik.system.DexClassLoader} is used under the covers.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * This class loader requires to write files to the file system which are then processed by the Android VM. It is
&nbsp; * &lt;b&gt;not&lt;/b&gt; permitted by Android&#39;s security checks to store these files in a shared folder where they could be
&nbsp; * manipulated by a third application what would break Android&#39;s sandbox model. An example for a forbidden storage
&nbsp; * would therefore be the external storage. Instead, the class loading application must either supply a designated
&nbsp; * directory, such as by creating a directory using {@code android.content.Context#getDir(String, int)} with specifying
&nbsp; * {@code android.content.Context#MODE_PRIVATE} visibility for the created folder or by using the
&nbsp; * {@code getCodeCacheDir} directory which is exposed for Android API versions 21 or higher.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * By default, this Android {@link net.bytebuddy.dynamic.loading.ClassLoadingStrategy} uses the Android SDK&#39;s dex compiler in
&nbsp; * &lt;i&gt;version 1.7&lt;/i&gt; which requires the Java class files in version {@link net.bytebuddy.ClassFileVersion#JAVA_V6} as
&nbsp; * its input. This version is slightly outdated but newer versions are not available in Maven Central which is why this
&nbsp; * outdated version is included with this class loading strategy. Newer version can however be easily adapted by
&nbsp; * implementing the methods of a {@link net.bytebuddy.android.AndroidClassLoadingStrategy.DexProcessor} to
&nbsp; * appropriately delegate to the newer dex compiler. In case that the dex compiler&#39;s API was not altered, it would
&nbsp; * even be sufficient to include the newer dex compiler to the Android application&#39;s build path while also excluding
&nbsp; * the version that ships with this class loading strategy. While most parts of the Android SDK&#39;s components are
&nbsp; * licensed under the &lt;i&gt;Apache 2.0 license&lt;/i&gt;, please also note
&nbsp; * &lt;a href=&quot;https://developer.android.com/sdk/terms.html&quot;&gt;their terms and conditions&lt;/a&gt;.
&nbsp; * &lt;/p&gt;
&nbsp; */
<b class="nc">&nbsp;public abstract class AndroidClassLoadingStrategy implements ClassLoadingStrategy&lt;ClassLoader&gt; {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the dex file that the {@link dalvik.system.DexClassLoader} expects to find inside of a jar file
&nbsp;     * that is handed to it as its argument.
&nbsp;     */
&nbsp;    private static final String DEX_CLASS_FILE = &quot;classes.dex&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The file name extension of a jar file.
&nbsp;     */
&nbsp;    private static final String JAR_FILE_EXTENSION = &quot;.jar&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * A value for a {@link dalvik.system.DexClassLoader} to indicate that the library path is empty.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final String EMPTY_LIBRARY_PATH = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A processor for files before adding them to a dex file.
&nbsp;     */
&nbsp;    private static final FileProcessor FILE_PROCESSOR;
&nbsp;
&nbsp;    /*
&nbsp;     * Resolves the file processor.
&nbsp;     */
&nbsp;    static {
&nbsp;        FileProcessor fileProcessor;
&nbsp;        try {
<b class="fc">&nbsp;            fileProcessor = new FileProcessor.ForReadOnlyClassFile(</b>
<b class="fc">&nbsp;                    Class.forName(&quot;java.nio.file.Files&quot;).getMethod(&quot;setPosixFilePermissions&quot;,</b>
<b class="fc">&nbsp;                            Class.forName(&quot;java.nio.file.Path&quot;),</b>
&nbsp;                            Set.class),
<b class="fc">&nbsp;                    File.class.getMethod(&quot;toPath&quot;),</b>
<b class="fc">&nbsp;                    Collections.singleton(Class.forName(&quot;java.nio.file.attribute.PosixFilePermission&quot;)</b>
<b class="fc">&nbsp;                            .getMethod(&quot;valueOf&quot;, String.class)</b>
<b class="fc">&nbsp;                            .invoke(null, &quot;OWNER_READ&quot;)));</b>
<b class="nc">&nbsp;        } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;            fileProcessor = FileProcessor.Disabled.INSTANCE;</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        FILE_PROCESSOR = fileProcessor;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The dex creator to be used by this Android class loading strategy.
&nbsp;     */
&nbsp;    private final DexProcessor dexProcessor;
&nbsp;
&nbsp;    /**
&nbsp;     * A directory that is &lt;b&gt;not shared with other applications&lt;/b&gt; to be used for storing generated classes and
&nbsp;     * their processed forms.
&nbsp;     */
&nbsp;    protected final File privateDirectory;
&nbsp;
&nbsp;    /**
&nbsp;     * A generator for random string values.
&nbsp;     */
&nbsp;    protected final RandomString randomString;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new Android class loading strategy that uses the given folder for storing classes. The directory is not cleared
&nbsp;     * by Byte Buddy after the application terminates. This remains the responsibility of the user.
&nbsp;     *
&nbsp;     * @param privateDirectory A directory that is &lt;b&gt;not shared with other applications&lt;/b&gt; to be used for storing
&nbsp;     *                         generated classes and their processed forms.
&nbsp;     * @param dexProcessor     The dex processor to be used for creating a dex file out of Java files.
&nbsp;     */
<b class="fc">&nbsp;    protected AndroidClassLoadingStrategy(File privateDirectory, DexProcessor dexProcessor) {</b>
<b class="fc">&nbsp;        if (!privateDirectory.isDirectory()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;Not a directory &quot; + privateDirectory);</b>
&nbsp;        }
<b class="fc">&nbsp;        this.privateDirectory = privateDirectory;</b>
<b class="fc">&nbsp;        this.dexProcessor = dexProcessor;</b>
<b class="fc">&nbsp;        randomString = new RandomString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Map&lt;TypeDescription, Class&lt;?&gt;&gt; load(@MaybeNull ClassLoader classLoader, Map&lt;TypeDescription, byte[]&gt; types) {
<b class="fc">&nbsp;        DexProcessor.Conversion conversion = dexProcessor.create();</b>
<b class="fc">&nbsp;        for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : types.entrySet()) {</b>
<b class="fc">&nbsp;            conversion.register(entry.getKey().getName(), entry.getValue());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        File jar = new File(privateDirectory, randomString.nextString() + JAR_FILE_EXTENSION);</b>
&nbsp;        try {
<b class="fc">&nbsp;            if (!jar.createNewFile()) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot create &quot; + jar);</b>
&nbsp;            }
<b class="fc">&nbsp;            JarOutputStream outputStream = new JarOutputStream(new FileOutputStream(jar));</b>
&nbsp;            try {
<b class="fc">&nbsp;                outputStream.putNextEntry(new JarEntry(DEX_CLASS_FILE));</b>
<b class="fc">&nbsp;                conversion.drainTo(outputStream);</b>
<b class="fc">&nbsp;                outputStream.closeEntry();</b>
&nbsp;            } finally {
<b class="fc">&nbsp;                outputStream.close();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            FILE_PROCESSOR.accept(jar);</b>
<b class="fc">&nbsp;            return doLoad(classLoader, types.keySet(), jar);</b>
<b class="nc">&nbsp;        } catch (IOException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot write to zip file &quot; + jar, exception);</b>
&nbsp;        } finally {
<b class="fc">&nbsp;            if (!jar.delete()) {</b>
<b class="nc">&nbsp;                Logger.getLogger(&quot;net.bytebuddy&quot;).warning(&quot;Could not delete &quot; + jar);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies the actual class loading.
&nbsp;     *
&nbsp;     * @param classLoader      The target class loader.
&nbsp;     * @param typeDescriptions Descriptions of the loaded types.
&nbsp;     * @param jar              A jar file containing the supplied types as dex files.
&nbsp;     * @return A mapping of all type descriptions to their loaded types.
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    protected abstract Map&lt;TypeDescription, Class&lt;?&gt;&gt; doLoad(@MaybeNull ClassLoader classLoader, Set&lt;TypeDescription&gt; typeDescriptions, File jar) throws IOException;
&nbsp;
&nbsp;    /**
&nbsp;     * A processor for files that are added to a dex file.
&nbsp;     */
&nbsp;    protected interface FileProcessor {
&nbsp;
&nbsp;        /**
&nbsp;         * Accepts a file for processing.
&nbsp;         *
&nbsp;         * @param file The file to process.
&nbsp;         */
&nbsp;        void accept(File file);
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational file processor.
&nbsp;         */
<b class="nc">&nbsp;        enum Disabled implements FileProcessor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="nc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void accept(File file) {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A file processor that marks a file as read-only.
&nbsp;         */
&nbsp;        class ForReadOnlyClassFile implements FileProcessor {
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.nio.file.Files#setPosixFilePermissions} method.
&nbsp;             */
&nbsp;            private final Method setPosixFilePermissions;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@code java.io.File#toPath} method.
&nbsp;             */
&nbsp;            private final Method toPath;
&nbsp;
&nbsp;            /**
&nbsp;             * The set of permissions to set.
&nbsp;             */
&nbsp;            private final Set&lt;?&gt; permissions;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new file processor for a read only file.
&nbsp;             *
&nbsp;             * @param setPosixFilePermissions The {@code java.nio.file.Files#setPosixFilePermissions} method.
&nbsp;             * @param toPath                  The {@code java.io.File#toPath} method.
&nbsp;             * @param permissions             The set of {java.nio.file.attribute.FilePermission} to set.
&nbsp;             */
<b class="fc">&nbsp;            protected ForReadOnlyClassFile(Method setPosixFilePermissions, Method toPath, Set&lt;?&gt; permissions) {</b>
<b class="fc">&nbsp;                this.setPosixFilePermissions = setPosixFilePermissions;</b>
<b class="fc">&nbsp;                this.toPath = toPath;</b>
<b class="fc">&nbsp;                this.permissions = permissions;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void accept(File file) {
&nbsp;                try {
<b class="fc">&nbsp;                    setPosixFilePermissions.invoke(null, toPath.invoke(file), permissions);</b>
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access file system permissions&quot;, exception);</b>
<b class="fc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                    if (!(exception.getTargetException() instanceof UnsupportedOperationException)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke file system permissions method&quot;, exception.getTargetException());</b>
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dex processor is responsible for converting a collection of Java class files into a Android dex file.
&nbsp;     */
&nbsp;    public interface DexProcessor {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new conversion process which allows to store several Java class files in the created dex
&nbsp;         * file before writing this dex file to a specified {@link java.io.OutputStream}.
&nbsp;         *
&nbsp;         * @return A mutable conversion process.
&nbsp;         */
&nbsp;        Conversion create();
&nbsp;
&nbsp;        /**
&nbsp;         * Represents an ongoing conversion of several Java class files into an Android dex file.
&nbsp;         */
&nbsp;        interface Conversion {
&nbsp;
&nbsp;            /**
&nbsp;             * Adds a Java class to the generated dex file.
&nbsp;             *
&nbsp;             * @param name                 The binary name of the Java class.
&nbsp;             * @param binaryRepresentation The binary representation of this class.
&nbsp;             */
&nbsp;            void register(String name, byte[] binaryRepresentation);
&nbsp;
&nbsp;            /**
&nbsp;             * Writes an Android dex file containing all registered Java classes to the provided output stream.
&nbsp;             *
&nbsp;             * @param outputStream The output stream to write the generated dex file to.
&nbsp;             * @throws IOException If an error occurs while writing the file.
&nbsp;             */
&nbsp;            void drainTo(OutputStream outputStream) throws IOException;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation of a dex processor based on the Android SDK&#39;s &lt;i&gt;dx.jar&lt;/i&gt; with an API that is
&nbsp;         * compatible to version 1.7.
&nbsp;         */
<b class="fc">&nbsp;        class ForSdkCompiler implements DexProcessor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An API version for a DEX file that ensures compatibility to the underlying compiler.
&nbsp;             */
&nbsp;            private static final int DEX_COMPATIBLE_API_VERSION = 13;
&nbsp;
&nbsp;            /**
&nbsp;             * The dispatcher for translating a dex file.
&nbsp;             */
&nbsp;            private static final Dispatcher DISPATCHER;
&nbsp;
&nbsp;            /*
&nbsp;             * Resolves the dispatcher for class file translations.
&nbsp;             */
&nbsp;            static {
&nbsp;                Dispatcher dispatcher;
&nbsp;                try {
<b class="fc">&nbsp;                    Class&lt;?&gt; dxContextType = Class.forName(&quot;com.android.dx.command.dexer.DxContext&quot;);</b>
<b class="fc">&nbsp;                    dispatcher = new Dispatcher.ForApi26LevelCompatibleVm(CfTranslator.class.getMethod(&quot;translate&quot;,</b>
&nbsp;                            dxContextType,
&nbsp;                            DirectClassFile.class,
&nbsp;                            byte[].class,
&nbsp;                            CfOptions.class,
&nbsp;                            DexOptions.class,
<b class="fc">&nbsp;                            DexFile.class), dxContextType.getConstructor());</b>
<b class="nc">&nbsp;                } catch (Throwable ignored) {</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        dispatcher = new Dispatcher.ForLegacyVm(CfTranslator.class.getMethod(&quot;translate&quot;,</b>
&nbsp;                                DirectClassFile.class,
&nbsp;                                byte[].class,
&nbsp;                                CfOptions.class,
&nbsp;                                DexOptions.class,
<b class="nc">&nbsp;                                DexFile.class), DexOptions.class.getField(&quot;minSdkVersion&quot;));</b>
<b class="nc">&nbsp;                    } catch (Throwable suppressed) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            dispatcher = new Dispatcher.ForLegacyVm(CfTranslator.class.getMethod(&quot;translate&quot;,</b>
&nbsp;                                    DirectClassFile.class,
&nbsp;                                    byte[].class,
&nbsp;                                    CfOptions.class,
&nbsp;                                    DexOptions.class,
<b class="nc">&nbsp;                                    DexFile.class), DexOptions.class.getField(&quot;targetApiLevel&quot;));</b>
<b class="nc">&nbsp;                        } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                            dispatcher = new Dispatcher.Unavailable(throwable.getMessage());</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                DISPATCHER = dispatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a default dex processor that ensures API version compatibility.
&nbsp;             *
&nbsp;             * @return A dex processor using an SDK compiler that ensures compatibility.
&nbsp;             */
&nbsp;            protected static DexProcessor makeDefault() {
<b class="nc">&nbsp;                DexOptions dexOptions = new DexOptions();</b>
<b class="nc">&nbsp;                DISPATCHER.setTargetApi(dexOptions, DEX_COMPATIBLE_API_VERSION);</b>
<b class="nc">&nbsp;                return new ForSdkCompiler(dexOptions, new CfOptions());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The file name extension of a Java class file.
&nbsp;             */
&nbsp;            private static final String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a dex file should be written without providing a human readable output.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final Writer NO_PRINT_OUTPUT = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that the dex file creation should not be verbose.
&nbsp;             */
&nbsp;            private static final boolean NOT_VERBOSE = false;
&nbsp;
&nbsp;            /**
&nbsp;             * The dex file options to be applied when converting a Java class file.
&nbsp;             */
&nbsp;            private final DexOptions dexFileOptions;
&nbsp;
&nbsp;            /**
&nbsp;             * The dex compiler options to be applied when converting a Java class file.
&nbsp;             */
&nbsp;            private final CfOptions dexCompilerOptions;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new Android SDK dex compiler-based dex processor.
&nbsp;             *
&nbsp;             * @param dexFileOptions     The dex file options to apply.
&nbsp;             * @param dexCompilerOptions The dex compiler options to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForSdkCompiler(DexOptions dexFileOptions, CfOptions dexCompilerOptions) {</b>
<b class="fc">&nbsp;                this.dexFileOptions = dexFileOptions;</b>
<b class="fc">&nbsp;                this.dexCompilerOptions = dexCompilerOptions;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public DexProcessor.Conversion create() {
<b class="fc">&nbsp;                return new Conversion(new DexFile(dexFileOptions));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a to-dex-file-conversion of a
&nbsp;             * {@link net.bytebuddy.android.AndroidClassLoadingStrategy.DexProcessor.ForSdkCompiler}.
&nbsp;             */
&nbsp;            protected class Conversion implements DexProcessor.Conversion {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates non-strict parsing of a class file.
&nbsp;                 */
&nbsp;                private static final boolean NON_STRICT = false;
&nbsp;
&nbsp;                /**
&nbsp;                 * The dex file that is created by this conversion.
&nbsp;                 */
&nbsp;                private final DexFile dexFile;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new ongoing to-dex-file conversion.
&nbsp;                 *
&nbsp;                 * @param dexFile The dex file that is created by this conversion.
&nbsp;                 */
<b class="fc">&nbsp;                protected Conversion(DexFile dexFile) {</b>
<b class="fc">&nbsp;                    this.dexFile = dexFile;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void register(String name, byte[] binaryRepresentation) {
<b class="fc">&nbsp;                    DirectClassFile directClassFile = new DirectClassFile(binaryRepresentation,</b>
<b class="fc">&nbsp;                            name.replace(&#39;.&#39;, &#39;/&#39;) + CLASS_FILE_EXTENSION,</b>
&nbsp;                            NON_STRICT);
<b class="fc">&nbsp;                    directClassFile.setAttributeFactory(new StdAttributeFactory());</b>
<b class="fc">&nbsp;                    dexFile.add(DISPATCHER.translate(directClassFile,</b>
&nbsp;                            binaryRepresentation,
<b class="fc">&nbsp;                            dexCompilerOptions,</b>
<b class="fc">&nbsp;                            dexFileOptions,</b>
<b class="fc">&nbsp;                            new DexFile(dexFileOptions)));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void drainTo(OutputStream outputStream) throws IOException {
<b class="fc">&nbsp;                    dexFile.writeTo(outputStream, NO_PRINT_OUTPUT, NOT_VERBOSE);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for translating a direct class file.
&nbsp;             */
&nbsp;            protected interface Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new class file definition.
&nbsp;                 *
&nbsp;                 * @param directClassFile      The direct class file to translate.
&nbsp;                 * @param binaryRepresentation The file&#39;s binary representation.
&nbsp;                 * @param dexCompilerOptions   The dex compiler options.
&nbsp;                 * @param dexFileOptions       The dex file options.
&nbsp;                 * @param dexFile              The dex file.
&nbsp;                 * @return The translated class file definition.
&nbsp;                 */
&nbsp;                ClassDefItem translate(DirectClassFile directClassFile,
&nbsp;                                       byte[] binaryRepresentation,
&nbsp;                                       CfOptions dexCompilerOptions,
&nbsp;                                       DexOptions dexFileOptions,
&nbsp;                                       DexFile dexFile);
&nbsp;
&nbsp;                /**
&nbsp;                 * Sets the target API level if available.
&nbsp;                 *
&nbsp;                 * @param dexOptions     The dex options to set the api version for
&nbsp;                 * @param targetApiLevel The target API level.
&nbsp;                 */
&nbsp;                void setTargetApi(DexOptions dexOptions, int targetApiLevel);
&nbsp;
&nbsp;                /**
&nbsp;                 * An unavailable dispatcher.
&nbsp;                 */
&nbsp;                class Unavailable implements Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A message explaining why the dispatcher is unavailable.
&nbsp;                     */
&nbsp;                    private final String message;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new unavailable dispatcher.
&nbsp;                     *
&nbsp;                     * @param message A message explaining why the dispatcher is unavailable.
&nbsp;                     */
<b class="nc">&nbsp;                    protected Unavailable(String message) {</b>
<b class="nc">&nbsp;                        this.message = message;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassDefItem translate(DirectClassFile directClassFile,
&nbsp;                                                  byte[] binaryRepresentation,
&nbsp;                                                  CfOptions dexCompilerOptions,
&nbsp;                                                  DexOptions dexFileOptions,
&nbsp;                                                  DexFile dexFile) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not resolve dispatcher: &quot; + message);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void setTargetApi(DexOptions dexOptions, int targetApiLevel) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not resolve dispatcher: &quot; + message);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for a lagacy Android VM.
&nbsp;                 */
&nbsp;                class ForLegacyVm implements Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code CfTranslator#translate(DirectClassFile, byte[], CfOptions, DexOptions, DexFile)} method.
&nbsp;                     */
&nbsp;                    private final Method translate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code DexOptions#targetApiLevel} field.
&nbsp;                     */
&nbsp;                    private final Field targetApi;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new dispatcher.
&nbsp;                     *
&nbsp;                     * @param translate The {@code CfTranslator#translate(DirectClassFile, byte[], CfOptions, DexOptions, DexFile)} method.
&nbsp;                     * @param targetApi The {@code DexOptions#targetApiLevel} field.
&nbsp;                     */
<b class="nc">&nbsp;                    protected ForLegacyVm(Method translate, Field targetApi) {</b>
<b class="nc">&nbsp;                        this.translate = translate;</b>
<b class="nc">&nbsp;                        this.targetApi = targetApi;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassDefItem translate(DirectClassFile directClassFile,
&nbsp;                                                  byte[] binaryRepresentation,
&nbsp;                                                  CfOptions dexCompilerOptions,
&nbsp;                                                  DexOptions dexFileOptions,
&nbsp;                                                  DexFile dexFile) {
&nbsp;                        try {
<b class="nc">&nbsp;                            return (ClassDefItem) translate.invoke(null,</b>
&nbsp;                                    directClassFile,
&nbsp;                                    binaryRepresentation,
&nbsp;                                    dexCompilerOptions,
&nbsp;                                    dexFileOptions,
&nbsp;                                    dexFile);
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access an Android dex file translation method&quot;, exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke Android dex file translation method&quot;, exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void setTargetApi(DexOptions dexOptions, int targetApiLevel) {
&nbsp;                        try {
<b class="nc">&nbsp;                            targetApi.set(dexOptions, targetApiLevel);</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access an Android dex file translation method&quot;, exception);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for an Android VM with API level 26 or higher.
&nbsp;                 */
&nbsp;                class ForApi26LevelCompatibleVm implements Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code CfTranslator#translate(DxContext, DirectClassFile, byte[], CfOptions, DexOptions, DexFile)} method.
&nbsp;                     */
&nbsp;                    private final Method translate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@code com.android.dx.command.dexer.DxContext#DxContext()} constructor.
&nbsp;                     */
&nbsp;                    private final Constructor&lt;?&gt; dxContext;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new dispatcher.
&nbsp;                     *
&nbsp;                     * @param translate The {@code CfTranslator#translate(DxContext, DirectClassFile, byte[], CfOptions, DexOptions, DexFile)} method.
&nbsp;                     * @param dxContext The {@code com.android.dx.command.dexer.DxContext#DxContext()} constructor.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForApi26LevelCompatibleVm(Method translate, Constructor&lt;?&gt; dxContext) {</b>
<b class="fc">&nbsp;                        this.translate = translate;</b>
<b class="fc">&nbsp;                        this.dxContext = dxContext;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassDefItem translate(DirectClassFile directClassFile,
&nbsp;                                                  byte[] binaryRepresentation,
&nbsp;                                                  CfOptions dexCompilerOptions,
&nbsp;                                                  DexOptions dexFileOptions,
&nbsp;                                                  DexFile dexFile) {
&nbsp;                        try {
<b class="fc">&nbsp;                            return (ClassDefItem) translate.invoke(null,</b>
<b class="fc">&nbsp;                                    dxContext.newInstance(),</b>
&nbsp;                                    directClassFile,
&nbsp;                                    binaryRepresentation,
&nbsp;                                    dexCompilerOptions,
&nbsp;                                    dexFileOptions,
&nbsp;                                    dexFile);
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access an Android dex file translation method&quot;, exception);</b>
<b class="nc">&nbsp;                        } catch (InstantiationException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot instantiate dex context&quot;, exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke Android dex file translation method&quot;, exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void setTargetApi(DexOptions dexOptions, int targetApiLevel) {
&nbsp;                        /* do nothing */
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An Android class loading strategy that creates a wrapper class loader that loads any type.
&nbsp;     */
&nbsp;    @TargetApi(Build.VERSION_CODES.CUPCAKE)
&nbsp;    public static class Wrapping extends AndroidClassLoadingStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new wrapping class loading strategy for Android that uses the default SDK-compiler based dex processor.
&nbsp;         *
&nbsp;         * @param privateDirectory A directory that is &lt;b&gt;not shared with other applications&lt;/b&gt; to be used for storing
&nbsp;         *                         generated classes and their processed forms.
&nbsp;         */
&nbsp;        public Wrapping(File privateDirectory) {
<b class="nc">&nbsp;            this(privateDirectory, DexProcessor.ForSdkCompiler.makeDefault());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new wrapping class loading strategy for Android.
&nbsp;         *
&nbsp;         * @param privateDirectory A directory that is &lt;b&gt;not shared with other applications&lt;/b&gt; to be used for storing
&nbsp;         *                         generated classes and their processed forms.
&nbsp;         * @param dexProcessor     The dex processor to be used for creating a dex file out of Java files.
&nbsp;         */
&nbsp;        public Wrapping(File privateDirectory, DexProcessor dexProcessor) {
<b class="nc">&nbsp;            super(privateDirectory, dexProcessor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;Android discourages the use of access controllers&quot;)
&nbsp;        protected Map&lt;TypeDescription, Class&lt;?&gt;&gt; doLoad(@MaybeNull ClassLoader classLoader, Set&lt;TypeDescription&gt; typeDescriptions, File jar) {
<b class="nc">&nbsp;            ClassLoader dexClassLoader = new DexClassLoader(jar.getAbsolutePath(), privateDirectory.getAbsolutePath(), EMPTY_LIBRARY_PATH, classLoader);</b>
<b class="nc">&nbsp;            Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes = new HashMap&lt;TypeDescription, Class&lt;?&gt;&gt;();</b>
<b class="nc">&nbsp;            for (TypeDescription typeDescription : typeDescriptions) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    loadedTypes.put(typeDescription, Class.forName(typeDescription.getName(), false, dexClassLoader));</b>
<b class="nc">&nbsp;                } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot load &quot; + typeDescription, exception);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return loadedTypes;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An Android class loading strategy that injects types into the target class loader.
&nbsp;     */
&nbsp;    @TargetApi(Build.VERSION_CODES.CUPCAKE)
&nbsp;    public static class Injecting extends AndroidClassLoadingStrategy {
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to use for loading a dex file.
&nbsp;         */
&nbsp;        private static final Dispatcher DISPATCHER;
&nbsp;
&nbsp;        /*
&nbsp;         * Creates a dispatcher to use for loading a dex file.
&nbsp;         */
&nbsp;        static {
&nbsp;            Dispatcher dispatcher;
&nbsp;            try {
<b class="fc">&nbsp;                dispatcher = new Dispatcher.ForAndroidPVm(BaseDexClassLoader.class.getMethod(&quot;addDexPath&quot;, String.class, boolean.class));</b>
<b class="fc">&nbsp;            } catch (Throwable ignored) {</b>
<b class="fc">&nbsp;                dispatcher = Dispatcher.ForLegacyVm.INSTANCE;</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;            DISPATCHER = dispatcher;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new injecting class loading strategy for Android that uses the default SDK-compiler based dex processor.
&nbsp;         *
&nbsp;         * @param privateDirectory A directory that is &lt;b&gt;not shared with other applications&lt;/b&gt; to be used for storing
&nbsp;         *                         generated classes and their processed forms.
&nbsp;         */
&nbsp;        public Injecting(File privateDirectory) {
<b class="nc">&nbsp;            this(privateDirectory, DexProcessor.ForSdkCompiler.makeDefault());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new injecting class loading strategy for Android.
&nbsp;         *
&nbsp;         * @param privateDirectory A directory that is &lt;b&gt;not shared with other applications&lt;/b&gt; to be used for storing
&nbsp;         *                         generated classes and their processed forms.
&nbsp;         * @param dexProcessor     The dex processor to be used for creating a dex file out of Java files.
&nbsp;         */
&nbsp;        public Injecting(File privateDirectory, DexProcessor dexProcessor) {
<b class="fc">&nbsp;            super(privateDirectory, dexProcessor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Map&lt;TypeDescription, Class&lt;?&gt;&gt; load(@MaybeNull ClassLoader classLoader, Map&lt;TypeDescription, byte[]&gt; types) {
<b class="fc">&nbsp;            if (classLoader == null) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot inject classes into the bootstrap class loader on Android&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return super.load(classLoader, types);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        protected Map&lt;TypeDescription, Class&lt;?&gt;&gt; doLoad(@MaybeNull ClassLoader classLoader, Set&lt;TypeDescription&gt; typeDescriptions, File jar) throws IOException {
<b class="nc">&nbsp;            dalvik.system.DexFile dexFile = DISPATCHER.loadDex(privateDirectory, jar, classLoader, randomString);</b>
&nbsp;            try {
<b class="nc">&nbsp;                Map&lt;TypeDescription, Class&lt;?&gt;&gt; loadedTypes = new HashMap&lt;TypeDescription, Class&lt;?&gt;&gt;();</b>
<b class="nc">&nbsp;                for (TypeDescription typeDescription : typeDescriptions) {</b>
<b class="nc">&nbsp;                    synchronized (classLoader) { // Guaranteed to be non-null by check in &#39;load&#39; method.</b>
<b class="nc">&nbsp;                        Class&lt;?&gt; type = DISPATCHER.loadClass(dexFile, classLoader, typeDescription);</b>
<b class="nc">&nbsp;                        if (type == null) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Could not load &quot; + typeDescription);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        loadedTypes.put(typeDescription, type);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return loadedTypes;</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                if (dexFile != null) {</b>
<b class="nc">&nbsp;                    dexFile.close();</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for loading a dex file.
&nbsp;         */
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Loads a dex file.
&nbsp;             *
&nbsp;             * @param privateDirectory The private directory to use if required.
&nbsp;             * @param jar              The jar to load.
&nbsp;             * @param classLoader      The class loader to inject into.
&nbsp;             * @param randomString     The random string to use.
&nbsp;             * @return The created {@link dalvik.system.DexFile} or {@code null} if no such file is created.
&nbsp;             * @throws IOException If an I/O exception is thrown.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            dalvik.system.DexFile loadDex(File privateDirectory, File jar, @MaybeNull ClassLoader classLoader, RandomString randomString) throws IOException;
&nbsp;
&nbsp;            /**
&nbsp;             * Loads a class.
&nbsp;             *
&nbsp;             * @param dexFile         The dex file to process if any was created.
&nbsp;             * @param classLoader     The class loader to load the class from.
&nbsp;             * @param typeDescription The type to load.
&nbsp;             * @return The loaded class.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Class&lt;?&gt; loadClass(dalvik.system.DexFile dexFile, @MaybeNull ClassLoader classLoader, TypeDescription typeDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for legacy VMs that allow {@link dalvik.system.DexFile#loadDex(String, String, int)}.
&nbsp;             */
<b class="fc">&nbsp;            enum ForLegacyVm implements Dispatcher {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A constant indicating the use of no flags.
&nbsp;                 */
&nbsp;                private static final int NO_FLAGS = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * A file extension used for holding Android&#39;s optimized data.
&nbsp;                 */
&nbsp;                private static final String EXTENSION = &quot;.data&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public dalvik.system.DexFile loadDex(File privateDirectory,
&nbsp;                                                     File jar,
&nbsp;                                                     @MaybeNull ClassLoader classLoader,
&nbsp;                                                     RandomString randomString) throws IOException {
<b class="nc">&nbsp;                    return dalvik.system.DexFile.loadDex(jar.getAbsolutePath(),</b>
<b class="nc">&nbsp;                            new File(privateDirectory.getAbsolutePath(), randomString.nextString() + EXTENSION).getAbsolutePath(),</b>
&nbsp;                            NO_FLAGS);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Class&lt;?&gt; loadClass(dalvik.system.DexFile dexFile, @MaybeNull ClassLoader classLoader, TypeDescription typeDescription) {
<b class="nc">&nbsp;                    return dexFile.loadClass(typeDescription.getName(), classLoader);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for an Android P VM that uses the reflection-only method {@code addDexPath} of {@link DexClassLoader}.
&nbsp;             */
&nbsp;            class ForAndroidPVm implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates that this dispatcher does not return a {@link dalvik.system.DexFile} instance.
&nbsp;                 */
&nbsp;                @AlwaysNull
<b class="fc">&nbsp;                private static final dalvik.system.DexFile NO_RETURN_VALUE = null;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code BaseDexClassLoader#addDexPath(String, boolean)} method.
&nbsp;                 */
&nbsp;                private final Method addDexPath;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new Android P-compatible dispatcher for loading a dex file.
&nbsp;                 *
&nbsp;                 * @param addDexPath The {@code BaseDexClassLoader#addDexPath(String, boolean)} method.
&nbsp;                 */
<b class="nc">&nbsp;                protected ForAndroidPVm(Method addDexPath) {</b>
<b class="nc">&nbsp;                    this.addDexPath = addDexPath;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public dalvik.system.DexFile loadDex(File privateDirectory,
&nbsp;                                                     File jar,
&nbsp;                                                     @MaybeNull ClassLoader classLoader,
&nbsp;                                                     RandomString randomString) throws IOException {
<b class="nc">&nbsp;                    if (!(classLoader instanceof BaseDexClassLoader)) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;On Android P, a class injection can only be applied to BaseDexClassLoader: &quot; + classLoader);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="nc">&nbsp;                        addDexPath.invoke(classLoader, jar.getAbsolutePath(), true);</b>
<b class="nc">&nbsp;                        return NO_RETURN_VALUE;</b>
<b class="nc">&nbsp;                    } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access BaseDexClassLoader#addDexPath(String, boolean)&quot;, exception);</b>
<b class="nc">&nbsp;                    } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                        Throwable cause = exception.getTargetException();</b>
<b class="nc">&nbsp;                        if (cause instanceof IOException) {</b>
<b class="nc">&nbsp;                            throw (IOException) cause;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke BaseDexClassLoader#addDexPath(String, boolean)&quot;, cause);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; loadClass(@MaybeNull dalvik.system.DexFile dexFile, @MaybeNull ClassLoader classLoader, TypeDescription typeDescription) {
&nbsp;                    try {
<b class="nc">&nbsp;                        return Class.forName(typeDescription.getName(), false, classLoader);</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Could not locate &quot; + typeDescription, exception);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
