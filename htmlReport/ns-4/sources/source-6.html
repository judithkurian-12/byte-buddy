


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MemberSubstitution</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.asm</a>
</div>

<h1>Coverage Summary for Class: MemberSubstitution (net.bytebuddy.asm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MemberSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.4%
  </span>
  <span class="absValue">
    (19/22)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MemberSubstitution$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$AllArguments</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Argument</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Current</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$FieldGetterHandle</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$FieldSetterHandle</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$FieldValue</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Origin</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$Binding</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$Binding$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$Binding$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$Factory</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$Factory$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$ForElementMatchers</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$ForElementMatchers$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$ForFirstBinding</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$InvocationType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Replacement$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    40%
  </span>
  <span class="absValue">
    (2/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$SelfCallHandle</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Source</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Source$1</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Source$2</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (18/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Source$Value</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$StubValue</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$SubstitutingMethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.4%
  </span>
  <span class="absValue">
    (102/118)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$SubstitutingMethodVisitor$LocalVariableTracingMethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.2%
  </span>
  <span class="absValue">
    (25/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Factory</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$Factory</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForArgumentLoading</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForArgumentSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (14/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForArgumentSubstitution$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForAssignment</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForAssignment$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (21/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$BootstrapArgumentResolver</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$BootstrapArgumentResolver$Factory</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$BootstrapArgumentResolver$ForDefaultValues</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$BootstrapArgumentResolver$ForDefaultValues$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$BootstrapArgumentResolver$ForDefaultValues$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.8%
  </span>
  <span class="absValue">
    (11/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$BootstrapArgumentResolver$Resolved</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$Factory</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$ForDynamicInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$ForDynamicInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$ForDynamicInvocation$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$ForRegularInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$ForRegularInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Dispatcher$Resolved</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (30/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$Factory</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$Factory$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$Factory$Simple</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$Factory$WithParameterSupportOnly</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForAllArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForAllArguments$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForAllArguments$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (18/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForArgument$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (14/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForArgument$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForCurrent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForCurrent$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForCurrent$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.4%
  </span>
  <span class="absValue">
    (14/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField$Resolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForField$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Access</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Access$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Access$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Resolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Unresolved$GetterFactory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Unresolved$SetterFactory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForFieldHandle$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (24/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$4</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForOrigin$Sort$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForSelfCallHandle</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForSelfCallHandle$Bound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (16/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForSelfCallHandle$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForSelfCallHandle$Unbound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation$OfAnnotationProperty</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation$OfDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation$OfDynamicInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.5%
  </span>
  <span class="absValue">
    (13/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation$OfSerializedConstant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStackManipulation$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStubValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStubValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForStubValue$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForThisReference</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForThisReference$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (11/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$ForThisReference$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$Resolved</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$OffsetMapping$Resolved$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForDelegation$WithCustomMapping</td>
<td class="coverageStat">
  <span class="percent">
    48.6%
  </span>
  <span class="absValue">
    (18/37)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    64.2%
  </span>
  <span class="absValue">
    (43/67)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForField$Read</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForField$Read$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForField$Write</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (10/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForField$Write$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.3%
  </span>
  <span class="absValue">
    (16/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$ForInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$OfOriginalExpression</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (28/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$Resolution</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Chain$Step$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Factory</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForFieldAccess</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.5%
  </span>
  <span class="absValue">
    (19/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForFieldAccess$FieldResolver</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForFieldAccess$FieldResolver$ForElementMatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForFieldAccess$FieldResolver$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForFieldAccess$OfGivenField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForFieldAccess$OfMatchedField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation$MethodResolver</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation$MethodResolver$Matching</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation$MethodResolver$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation$OfGivenMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation$OfInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForMethodInvocation$OfMatchedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$ForValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Substitution$Stubbing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$This</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$TypePoolResolver</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$TypePoolResolver$ForClassFileLocator</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$TypePoolResolver$ForExplicitPool</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$TypePoolResolver$OfImplicitPool</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$Unused</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$WithoutSpecification</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$WithoutSpecification$ForMatchedByteCodeElement</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$WithoutSpecification$ForMatchedField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MemberSubstitution$WithoutSpecification$ForMatchedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    82.1%
  </span>
  <span class="absValue">
    (363/442)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.5%
  </span>
  <span class="absValue">
    (1101/1334)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.asm;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.bytecode.*;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.*;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.*;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.visitor.LocalVariableAwareMethodVisitor;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Type;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * Substitutes field access, method invocations or constructor calls within a method&#39;s body.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: This substitution must not be used to match constructor calls to an instrumented class&#39;s super constructor invocation from
&nbsp; * within a constructor. Matching such constructors will result in an invalid stack and a verification error.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: This visitor will compute the required stack size on a best effort basis. For allocating an optimal stack size, ASM needs
&nbsp; * to be configured to compute the stack size.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Important&lt;/b&gt;: This component relies on using a {@link TypePool} for locating types within method bodies. Within a redefinition
&nbsp; * or a rebasement, this type pool normally resolved correctly by Byte Buddy. When subclassing a type, the type pool must be set
&nbsp; * explicitly, using {@link net.bytebuddy.dynamic.DynamicType.Builder#make(TypePool)} or any similar method. It is however not normally
&nbsp; * necessary to use this component when subclassing a type where methods are only defined explicitly.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class MemberSubstitution implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper {
&nbsp;
&nbsp;    /**
&nbsp;     * The index of the this reference within a non-static method.
&nbsp;     */
&nbsp;    protected static final int THIS_REFERENCE = 0;
&nbsp;
&nbsp;    /**
&nbsp;     * The method graph compiler to use.
&nbsp;     */
&nbsp;    private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;    /**
&nbsp;     * The type pool resolver to use.
&nbsp;     */
&nbsp;    private final TypePoolResolver typePoolResolver;
&nbsp;
&nbsp;    /**
&nbsp;     * {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;     */
&nbsp;    private final boolean strict;
&nbsp;
&nbsp;    /**
&nbsp;     * {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;     */
&nbsp;    private final boolean failIfNoMatch;
&nbsp;
&nbsp;    /**
&nbsp;     * The replacement factory to use.
&nbsp;     */
&nbsp;    private final Replacement.Factory replacementFactory;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a default member substitution.
&nbsp;     *
&nbsp;     * @param strict {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;     */
&nbsp;    protected MemberSubstitution(boolean strict) {
<b class="fc">&nbsp;        this(MethodGraph.Compiler.DEFAULT, TypePoolResolver.OfImplicitPool.INSTANCE, strict, false, Replacement.NoOp.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new member substitution.
&nbsp;     *
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @param typePoolResolver    The type pool resolver to use.
&nbsp;     * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;     * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;     * @param replacementFactory  The replacement factory to use.
&nbsp;     */
&nbsp;    protected MemberSubstitution(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                 TypePoolResolver typePoolResolver,
&nbsp;                                 boolean strict,
&nbsp;                                 boolean failIfNoMatch,
<b class="fc">&nbsp;                                 Replacement.Factory replacementFactory) {</b>
<b class="fc">&nbsp;        this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;        this.typePoolResolver = typePoolResolver;</b>
<b class="fc">&nbsp;        this.failIfNoMatch = failIfNoMatch;</b>
<b class="fc">&nbsp;        this.strict = strict;</b>
<b class="fc">&nbsp;        this.replacementFactory = replacementFactory;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a member substitution that requires the resolution of all fields and methods that are referenced within a method body. Doing so,
&nbsp;     * this component raises an exception if any member cannot be resolved what makes this component unusable when facing optional types.
&nbsp;     *
&nbsp;     * @return A strict member substitution.
&nbsp;     */
&nbsp;    public static MemberSubstitution strict() {
<b class="fc">&nbsp;        return new MemberSubstitution(true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a member substitution that skips any unresolvable fields or methods that are referenced within a method body. Using a relaxed
&nbsp;     * member substitution, methods containing optional types are supported. In the process, it is however possible that misconfigurations
&nbsp;     * of this component remain undiscovered.
&nbsp;     *
&nbsp;     * @return A relaxed member substitution.
&nbsp;     */
&nbsp;    public static MemberSubstitution relaxed() {
<b class="fc">&nbsp;        return new MemberSubstitution(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Substitutes any interaction with a field or method that matches the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to determine what access to byte code elements to substitute.
&nbsp;     * @return A specification that allows to determine how to substitute any interaction with byte code elements that match the supplied matcher.
&nbsp;     */
&nbsp;    public WithoutSpecification element(ElementMatcher&lt;? super ByteCodeElement.Member&gt; matcher) {
<b class="nc">&nbsp;        return new WithoutSpecification.ForMatchedByteCodeElement(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Substitutes any field access that matches the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to determine what fields to substitute.
&nbsp;     * @return A specification that allows to determine how to substitute any field access that match the supplied matcher.
&nbsp;     */
&nbsp;    public WithoutSpecification.ForMatchedField field(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;        return new WithoutSpecification.ForMatchedField(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Substitutes any method invocation that matches the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to determine what methods to substitute.
&nbsp;     * @return A specification that allows to determine how to substitute any method invocations that match the supplied matcher.
&nbsp;     */
&nbsp;    public WithoutSpecification.ForMatchedMethod method(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;        return new WithoutSpecification.ForMatchedMethod(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Substitutes any constructor invocation that matches the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to determine what constructors to substitute.
&nbsp;     * @return A specification that allows to determine how to substitute any constructor invocations that match the supplied matcher.
&nbsp;     */
&nbsp;    public WithoutSpecification constructor(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;        return invokable(isConstructor().and(matcher));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Substitutes any method or constructor invocation that matches the given matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to determine what method or constructors to substitute.
&nbsp;     * @return A specification that allows to determine how to substitute any constructor invocations that match the supplied matcher.
&nbsp;     */
&nbsp;    public WithoutSpecification invokable(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;        return new WithoutSpecification.ForMatchedMethod(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies the use of a specific method graph compiler for the resolution of virtual methods.
&nbsp;     *
&nbsp;     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;     * @return A new member substitution that is equal to this but uses the specified method graph compiler.
&nbsp;     */
&nbsp;    public MemberSubstitution with(MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;        return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies a type pool resolver to be used for locating members.
&nbsp;     *
&nbsp;     * @param typePoolResolver The type pool resolver to use.
&nbsp;     * @return A new instance of this member substitution that uses the supplied type pool resolver.
&nbsp;     */
&nbsp;    public MemberSubstitution with(TypePoolResolver typePoolResolver) {
<b class="nc">&nbsp;        return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies if this substitution should fail if applied on a method without a match.
&nbsp;     * @param failIfNoMatch {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;     * @return A new instance of this member substitution that fails if applied on a method without a match.
&nbsp;     */
&nbsp;    public MemberSubstitution failIfNoMatch(boolean failIfNoMatch) {
<b class="fc">&nbsp;        return new MemberSubstitution(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Applies this member substitution to any method that matches the supplied matcher.
&nbsp;     *
&nbsp;     * @param matcher The matcher to determine this substitutions application.
&nbsp;     * @return An ASM visitor wrapper that applies all specified substitutions for any matched method.
&nbsp;     */
&nbsp;    public AsmVisitorWrapper.ForDeclaredMethods on(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;        return new AsmVisitorWrapper.ForDeclaredMethods().invokable(matcher, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public MethodVisitor wrap(TypeDescription instrumentedType,
&nbsp;                              MethodDescription instrumentedMethod,
&nbsp;                              MethodVisitor methodVisitor,
&nbsp;                              Implementation.Context implementationContext,
&nbsp;                              TypePool typePool,
&nbsp;                              int writerFlags,
&nbsp;                              int readerFlags) {
<b class="fc">&nbsp;        typePool = typePoolResolver.resolve(instrumentedType, instrumentedMethod, typePool);</b>
<b class="fc">&nbsp;        return new SubstitutingMethodVisitor(methodVisitor,</b>
&nbsp;                instrumentedType,
&nbsp;                instrumentedMethod,
&nbsp;                methodGraphCompiler,
&nbsp;                strict,
&nbsp;                failIfNoMatch,
<b class="fc">&nbsp;                replacementFactory.make(instrumentedType, instrumentedMethod, typePool),</b>
&nbsp;                implementationContext,
&nbsp;                typePool,
<b class="fc">&nbsp;                implementationContext.getClassFileVersion().isAtLeast(ClassFileVersion.JAVA_V11));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A member substitution that lacks a specification for how to substitute the matched members references within a method body.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public abstract static class WithoutSpecification {
&nbsp;
&nbsp;        /**
&nbsp;         * The method graph compiler to use.
&nbsp;         */
&nbsp;        protected final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;        /**
&nbsp;         * The type pool resolver to use.
&nbsp;         */
&nbsp;        protected final TypePoolResolver typePoolResolver;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;         */
&nbsp;        protected final boolean strict;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;         */
&nbsp;        protected final boolean failIfNoMatch;
&nbsp;
&nbsp;        /**
&nbsp;         * The replacement factory to use for creating substitutions.
&nbsp;         */
&nbsp;        protected final Replacement.Factory replacementFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new member substitution that requires a specification for how to perform a substitution.
&nbsp;         *
&nbsp;         * @param methodGraphCompiler The method graph compiler to use.
&nbsp;         * @param typePoolResolver    The type pool resolver to use.
&nbsp;         * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;         * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;         * @param replacementFactory  The replacement factory to use for creating substitutions.
&nbsp;         */
&nbsp;        protected WithoutSpecification(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                       TypePoolResolver typePoolResolver,
&nbsp;                                       boolean strict,
&nbsp;                                       boolean failIfNoMatch,
<b class="fc">&nbsp;                                       Replacement.Factory replacementFactory) {</b>
<b class="fc">&nbsp;            this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;            this.typePoolResolver = typePoolResolver;</b>
<b class="fc">&nbsp;            this.strict = strict;</b>
<b class="fc">&nbsp;            this.failIfNoMatch = failIfNoMatch;</b>
<b class="fc">&nbsp;            this.replacementFactory = replacementFactory;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Subs any interaction with a matched byte code element. Any value read from the element will be replaced with the stubbed
&nbsp;         * value&#39;s default, i.e. {@code null} for reference types and the specific {@code 0} value for primitive types. Any written
&nbsp;         * value will simply be discarded.
&nbsp;         *
&nbsp;         * @return A member substitution that stubs any interaction with a matched byte code element.
&nbsp;         */
&nbsp;        public MemberSubstitution stub() {
<b class="fc">&nbsp;            return replaceWith(Substitution.Stubbing.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces any interaction with a matched byte code element with the provided compile-time constant.
&nbsp;         *
&nbsp;         * @param value The compile-time constant to set.
&nbsp;         * @return A member substitution that replaces any interaction with the supplied compile-time constant.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithConstant(Object value) {
<b class="fc">&nbsp;            ConstantValue constant = ConstantValue.Simple.wrap(value);</b>
<b class="fc">&nbsp;            return replaceWith(new Substitution.ForValue(constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Replaces any interaction with a matched byte code element by an interaction with the specified field. If a field
&nbsp;         * is replacing a method or constructor invocation, it is treated as if it was a field getter or setter respectively.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * A replacement can only be applied if the field is compatible to the original byte code element, i.e. consumes an
&nbsp;         * instance of the declaring type if it is not {@code static} as an argument and consumes or produces an instance of
&nbsp;         * the field&#39;s type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param field The field to access instead of interacting with any of the matched byte code elements.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an access of the specified field.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWith(Field field) {
<b class="fc">&nbsp;            return replaceWith(new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Replaces any interaction with a matched byte code element by an interaction with the specified field. If a field
&nbsp;         * is replacing a method or constructor invocation, it is treated as if it was a field getter or setter respectively.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * A replacement can only be applied if the field is compatible to the original byte code element, i.e. consumes an
&nbsp;         * instance of the declaring type if it is not {@code static} as an argument and consumes or produces an instance of
&nbsp;         * the field&#39;s type.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param fieldDescription The field to access instead of interacting with any of the matched byte code elements.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an access of the specified field.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWith(FieldDescription fieldDescription) {
<b class="fc">&nbsp;            return replaceWith(new Substitution.ForFieldAccess.OfGivenField(fieldDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces any interaction with a matched byte code element with a non-static field access on the first
&nbsp;         * parameter of the matched element. When matching a non-static field access or method invocation, the
&nbsp;         * substituted field is located on the same receiver type as the original access. For static access, the
&nbsp;         * first argument is used as a receiver.
&nbsp;         *
&nbsp;         * @param matcher A matcher for locating a field on the original interaction&#39;s receiver type.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an access of the matched field.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithField(ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;            return replaceWith(new Substitution.ForFieldAccess.OfMatchedField(matcher));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Replaces any interaction with a matched byte code element by an invocation of the specified method. If a method
&nbsp;         * is replacing a field access, it is treated as if it was replacing an invocation of the field&#39;s getter or setter respectively.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * A replacement can only be applied if the method is compatible to the original byte code element, i.e. consumes compatible
&nbsp;         * arguments and returns a compatible value. If the method is not {@code static}, it is treated as if {@code this} was an implicit
&nbsp;         * first argument.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param method The method to invoke instead of interacting with any of the matched byte code elements.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an invocation of the specified method.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWith(Method method) {
<b class="fc">&nbsp;            return replaceWith(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Replaces any interaction with a matched byte code element by an invocation of the specified method. If a method
&nbsp;         * is replacing a field access, it is treated as if it was replacing an invocation of the field&#39;s getter or setter respectively.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * A replacement can only be applied if the method is compatible to the original byte code element, i.e. consumes compatible
&nbsp;         * arguments and returns a compatible value. If the method is not {@code static}, it is treated as if {@code this} was an implicit
&nbsp;         * first argument.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: It is not allowed to specify a constructor or the static type initializer as a replacement.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param methodDescription The method to invoke instead of interacting with any of the matched byte code elements.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an invocation of the specified method.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWith(MethodDescription methodDescription) {
<b class="fc">&nbsp;            if (!methodDescription.isMethod()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Cannot use &quot; + methodDescription + &quot; as a replacement&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return replaceWith(new Substitution.ForMethodInvocation.OfGivenMethod(methodDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces any interaction with a matched byte code element with a non-static method access on the first
&nbsp;         * parameter of the matched element. When matching a non-static field access or method invocation, the
&nbsp;         * substituted method is located on the same receiver type as the original access. For static access, the
&nbsp;         * first argument is used as a receiver.
&nbsp;         *
&nbsp;         * @param matcher A matcher for locating a method on the original interaction&#39;s receiver type.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an access of the matched method.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithMethod(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;            return replaceWithMethod(matcher, methodGraphCompiler);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces any interaction with a matched byte code element with a non-static method access on the first
&nbsp;         * parameter of the matched element. When matching a non-static field access or method invocation, the
&nbsp;         * substituted method is located on the same receiver type as the original access. For static access, the
&nbsp;         * first argument is used as a receiver.
&nbsp;         *
&nbsp;         * @param matcher             A matcher for locating a method on the original interaction&#39;s receiver type.
&nbsp;         * @param methodGraphCompiler The method graph compiler to use for locating a method.
&nbsp;         * @return A member substitution that replaces any matched byte code element with an access of the matched method.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithMethod(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            return replaceWith(new Substitution.ForMethodInvocation.OfMatchedMethod(matcher, methodGraphCompiler));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces any interaction with a matched byte code element with an invocation of the instrumented
&nbsp;         * method. This can cause an infinite recursive call if the arguments to the method are not altered.
&nbsp;         *
&nbsp;         * @return A member substitution that replaces any matched byte code element with an invocation of the
&nbsp;         * instrumented method.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithInstrumentedMethod() {
<b class="fc">&nbsp;            return replaceWith(Substitution.ForMethodInvocation.OfInstrumentedMethod.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the matched byte code elements with a chain of substitutions that can operate on the same values as the substituted element. This is a
&nbsp;         * shortcut for creating a substitution chain with a default assigner.
&nbsp;         *
&nbsp;         * @param step The steps to apply for a substitution.
&nbsp;         * @return A member substitution that replaces any matched byte code element with the provided substitution chain.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithChain(Substitution.Chain.Step.Factory... step) {
<b class="fc">&nbsp;            return replaceWithChain(Arrays.asList(step));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the matched byte code elements with a chain of substitutions that can operate on the same values as the substituted element. This is a
&nbsp;         * shortcut for creating a substitution chain with a default assigner.
&nbsp;         *
&nbsp;         * @param steps The steps to apply for a substitution.
&nbsp;         * @return A member substitution that replaces any matched byte code element with the provided substitution chain.
&nbsp;         */
&nbsp;        public MemberSubstitution replaceWithChain(List&lt;? extends Substitution.Chain.Step.Factory&gt; steps) {
<b class="fc">&nbsp;            return replaceWith(Substitution.Chain.withDefaultAssigner().executing(steps));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces any interaction with the supplied substitution.
&nbsp;         *
&nbsp;         * @param factory The substitution factory to use for creating the applied substitution.
&nbsp;         * @return A member substitution that replaces any matched byte code element with the supplied substitution.
&nbsp;         */
&nbsp;        public abstract MemberSubstitution replaceWith(Substitution.Factory factory);
&nbsp;
&nbsp;        /**
&nbsp;         * Describes a member substitution that requires a specification for how to replace a byte code element.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ForMatchedByteCodeElement extends WithoutSpecification {
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for any byte code elements that should be substituted.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super ByteCodeElement.Member&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new member substitution for a matched byte code element that requires a specification for how to perform a substitution.
&nbsp;             *
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param typePoolResolver    The type pool resolver to use.
&nbsp;             * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;             * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;             * @param replacementFactory  The replacement factory to use.
&nbsp;             * @param matcher             A matcher for any byte code elements that should be substituted.
&nbsp;             */
&nbsp;            protected ForMatchedByteCodeElement(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                                TypePoolResolver typePoolResolver,
&nbsp;                                                boolean strict,
&nbsp;                                                boolean failIfNoMatch,
&nbsp;                                                Replacement.Factory replacementFactory,
&nbsp;                                                ElementMatcher&lt;? super ByteCodeElement.Member&gt; matcher) {
<b class="nc">&nbsp;                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);</b>
<b class="nc">&nbsp;                this.matcher = matcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MemberSubstitution replaceWith(Substitution.Factory substitutionFactory) {
<b class="nc">&nbsp;                return new MemberSubstitution(methodGraphCompiler,</b>
&nbsp;                        typePoolResolver,
&nbsp;                        strict,
&nbsp;                        failIfNoMatch,
<b class="nc">&nbsp;                        new Replacement.Factory.Compound(this.replacementFactory, Replacement.ForElementMatchers.Factory.of(matcher, substitutionFactory)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes a member substitution that requires a specification for how to replace a field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class ForMatchedField extends WithoutSpecification {
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for any field that should be substituted.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if read access to a field should be substituted.
&nbsp;             */
&nbsp;            private final boolean matchRead;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if write access to a field should be substituted.
&nbsp;             */
&nbsp;            private final boolean matchWrite;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new member substitution for a matched field that requires a specification for how to perform a substitution.
&nbsp;             *
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param typePoolResolver    The type pool resolver to use.
&nbsp;             * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;             * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;             * @param replacementFactory  The replacement factory to use.
&nbsp;             * @param matcher             A matcher for any field that should be substituted.
&nbsp;             */
&nbsp;            protected ForMatchedField(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                      TypePoolResolver typePoolResolver,
&nbsp;                                      boolean strict,
&nbsp;                                      boolean failIfNoMatch,
&nbsp;                                      Replacement.Factory replacementFactory,
&nbsp;                                      ElementMatcher&lt;? super FieldDescription&gt; matcher) {
<b class="fc">&nbsp;                this(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, true, true);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new member substitution for a matched field that requires a specification for how to perform a substitution.
&nbsp;             *
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param typePoolResolver    The type pool resolver to use.
&nbsp;             * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;             * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;             * @param replacementFactory  The replacement factory to use.
&nbsp;             * @param matcher             A matcher for any field that should be substituted.
&nbsp;             * @param matchRead           {@code true} if read access to a field should be substituted.
&nbsp;             * @param matchWrite          {@code true} if write access to a field should be substituted.
&nbsp;             */
&nbsp;            protected ForMatchedField(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                      TypePoolResolver typePoolResolver,
&nbsp;                                      boolean strict,
&nbsp;                                      boolean failIfNoMatch,
&nbsp;                                      Replacement.Factory replacementFactory,
&nbsp;                                      ElementMatcher&lt;? super FieldDescription&gt; matcher,
&nbsp;                                      boolean matchRead,
&nbsp;                                      boolean matchWrite) {
<b class="fc">&nbsp;                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.matchRead = matchRead;</b>
<b class="fc">&nbsp;                this.matchWrite = matchWrite;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * When invoked, only read access of the previously matched field is substituted.
&nbsp;             *
&nbsp;             * @return This instance with the limitation that only read access to the matched field is substituted.
&nbsp;             */
&nbsp;            public WithoutSpecification onRead() {
<b class="fc">&nbsp;                return new ForMatchedField(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, true, false);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * When invoked, only write access of the previously matched field is substituted.
&nbsp;             *
&nbsp;             * @return This instance with the limitation that only write access to the matched field is substituted.
&nbsp;             */
&nbsp;            public WithoutSpecification onWrite() {
<b class="fc">&nbsp;                return new ForMatchedField(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, false, true);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MemberSubstitution replaceWith(Substitution.Factory substitutionFactory) {
<b class="fc">&nbsp;                return new MemberSubstitution(methodGraphCompiler,</b>
&nbsp;                        typePoolResolver,
&nbsp;                        strict,
&nbsp;                        failIfNoMatch,
<b class="fc">&nbsp;                        new Replacement.Factory.Compound(this.replacementFactory, Replacement.ForElementMatchers.Factory.ofField(matcher, matchRead, matchWrite, substitutionFactory)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes a member substitution that requires a specification for how to replace a method or constructor.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class ForMatchedMethod extends WithoutSpecification {
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for any method or constructor that should be substituted.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this specification includes virtual invocations.
&nbsp;             */
&nbsp;            private final boolean includeVirtualCalls;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this specification includes {@code super} invocations.
&nbsp;             */
&nbsp;            private final boolean includeSuperCalls;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new member substitution for a matched method that requires a specification for how to perform a substitution.
&nbsp;             *
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param typePoolResolver    The type pool resolver to use.
&nbsp;             * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;             * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;             * @param replacementFactory  The replacement factory to use.
&nbsp;             * @param matcher             A matcher for any method or constructor that should be substituted.
&nbsp;             */
&nbsp;            protected ForMatchedMethod(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                       TypePoolResolver typePoolResolver,
&nbsp;                                       boolean strict,
&nbsp;                                       boolean failIfNoMatch,
&nbsp;                                       Replacement.Factory replacementFactory,
&nbsp;                                       ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;                this(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory, matcher, true, true);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new member substitution for a matched method that requires a specification for how to perform a substitution.
&nbsp;             *
&nbsp;             * @param methodGraphCompiler The method graph compiler to use.
&nbsp;             * @param typePoolResolver    The type pool resolver to use.
&nbsp;             * @param strict              {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;             * @param failIfNoMatch       {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;             * @param replacementFactory  The replacement factory to use.
&nbsp;             * @param matcher             A matcher for any method or constructor that should be substituted.
&nbsp;             * @param includeVirtualCalls {@code true} if this specification includes virtual invocations.
&nbsp;             * @param includeSuperCalls   {@code true} if this specification includes {@code super} invocations.
&nbsp;             */
&nbsp;            protected ForMatchedMethod(MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                       TypePoolResolver typePoolResolver,
&nbsp;                                       boolean strict,
&nbsp;                                       boolean failIfNoMatch,
&nbsp;                                       Replacement.Factory replacementFactory,
&nbsp;                                       ElementMatcher&lt;? super MethodDescription&gt; matcher,
&nbsp;                                       boolean includeVirtualCalls,
&nbsp;                                       boolean includeSuperCalls) {
<b class="fc">&nbsp;                super(methodGraphCompiler, typePoolResolver, strict, failIfNoMatch, replacementFactory);</b>
<b class="fc">&nbsp;                this.matcher = matcher;</b>
<b class="fc">&nbsp;                this.includeVirtualCalls = includeVirtualCalls;</b>
<b class="fc">&nbsp;                this.includeSuperCalls = includeSuperCalls;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Limits the substituted method calls to method calls that invoke a method virtually (as opposed to a {@code super} invocation).
&nbsp;             *
&nbsp;             * @return This specification where only virtual methods are matched if they are not invoked as a virtual call.
&nbsp;             */
&nbsp;            public WithoutSpecification onVirtualCall() {
<b class="fc">&nbsp;                return new ForMatchedMethod(methodGraphCompiler,</b>
&nbsp;                        typePoolResolver,
&nbsp;                        strict,
&nbsp;                        failIfNoMatch,
&nbsp;                        replacementFactory,
<b class="fc">&nbsp;                        isVirtual().and(matcher),</b>
&nbsp;                        true,
&nbsp;                        false);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Limits the substituted method calls to method calls that invoke a method as a {@code super} call.
&nbsp;             *
&nbsp;             * @return This specification where only virtual methods are matched if they are not invoked as a super call.
&nbsp;             */
&nbsp;            public WithoutSpecification onSuperCall() {
<b class="fc">&nbsp;                return new ForMatchedMethod(methodGraphCompiler,</b>
&nbsp;                        typePoolResolver,
&nbsp;                        strict,
&nbsp;                        failIfNoMatch,
&nbsp;                        replacementFactory,
<b class="fc">&nbsp;                        isVirtual().and(matcher),</b>
&nbsp;                        false,
&nbsp;                        true);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MemberSubstitution replaceWith(Substitution.Factory substitutionFactory) {
<b class="fc">&nbsp;                return new MemberSubstitution(methodGraphCompiler,</b>
&nbsp;                        typePoolResolver,
&nbsp;                        strict,
&nbsp;                        failIfNoMatch,
<b class="fc">&nbsp;                        new Replacement.Factory.Compound(this.replacementFactory, Replacement.ForElementMatchers.Factory.ofMethod(matcher, includeVirtualCalls, includeSuperCalls, substitutionFactory)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type pool resolver is responsible for resolving a {@link TypePool} for locating substituted members.
&nbsp;     */
&nbsp;    public interface TypePoolResolver {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a type pool to use for locating substituted members.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param typePool           The type pool implicit to the instrumentation.
&nbsp;         * @return The type pool to use.
&nbsp;         */
&nbsp;        TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the implicit type pool.
&nbsp;         */
<b class="fc">&nbsp;        enum OfImplicitPool implements TypePoolResolver {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                return typePool;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type pool resolver that returns a specific type pool.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForExplicitPool implements TypePoolResolver {
&nbsp;
&nbsp;            /**
&nbsp;             * The type pool to return.
&nbsp;             */
&nbsp;            private final TypePool typePool;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a resolver for an explicit type pool.
&nbsp;             *
&nbsp;             * @param typePool The type pool to return.
&nbsp;             */
<b class="nc">&nbsp;            public ForExplicitPool(TypePool typePool) {</b>
<b class="nc">&nbsp;                this.typePool = typePool;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="nc">&nbsp;                return this.typePool;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type pool resolver that resolves the implicit pool but additionally checks another class file locator.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForClassFileLocator implements TypePoolResolver {
&nbsp;
&nbsp;            /**
&nbsp;             * The class file locator to use.
&nbsp;             */
&nbsp;            private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;            /**
&nbsp;             * The reader mode to apply.
&nbsp;             */
&nbsp;            private final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type pool resolver for a class file locator as a supplement of the implicit type pool.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             */
&nbsp;            public ForClassFileLocator(ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;                this(classFileLocator, TypePool.Default.ReaderMode.FAST);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type pool resolver for a class file locator as a supplement of the implicit type pool.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             * @param readerMode       The reader mode to apply.
&nbsp;             */
<b class="nc">&nbsp;            public ForClassFileLocator(ClassFileLocator classFileLocator, TypePool.Default.ReaderMode readerMode) {</b>
<b class="nc">&nbsp;                this.classFileLocator = classFileLocator;</b>
<b class="nc">&nbsp;                this.readerMode = readerMode;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new type pool resolver that supplements the supplied class loader to the implicit type pool.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to use as a supplement which can be {@code null} to represent the bootstrap loader.
&nbsp;             * @return An appropriate type pool resolver.
&nbsp;             */
&nbsp;            public static TypePoolResolver of(@MaybeNull ClassLoader classLoader) {
<b class="nc">&nbsp;                return new ForClassFileLocator(ClassFileLocator.ForClassLoader.of(classLoader));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypePool resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="nc">&nbsp;                return new TypePool.Default(new TypePool.CacheProvider.Simple(), classFileLocator, readerMode, typePool);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A substitution replaces or enhances an interaction with a field or method within an instrumented method.
&nbsp;     */
&nbsp;    public interface Substitution {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this substitution into a stack manipulation.
&nbsp;         *
&nbsp;         * @param receiver          The target type on which a member is accessed.
&nbsp;         * @param original          The field, method or constructor that is substituted.
&nbsp;         * @param parameters        All parameters that serve as input to this access.
&nbsp;         * @param result            The result that is expected from the interaction or {@code void} if no result is expected.
&nbsp;         * @param methodHandle      A method handle describing the substituted expression.
&nbsp;         * @param stackManipulation The original byte code expression that is being executed.
&nbsp;         * @param freeOffset        The first free offset of the local variable array that can be used for storing values.
&nbsp;         * @return A stack manipulation that represents the access.
&nbsp;         */
&nbsp;        StackManipulation resolve(TypeDescription receiver,
&nbsp;                                  ByteCodeElement.Member original,
&nbsp;                                  TypeList.Generic parameters,
&nbsp;                                  TypeDescription.Generic result,
&nbsp;                                  JavaConstant.MethodHandle methodHandle,
&nbsp;                                  StackManipulation stackManipulation,
&nbsp;                                  int freeOffset);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a substitution for an instrumented method.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a substitution for an instrumented method.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param typePool           The type pool being used.
&nbsp;             * @return The substitution to apply within the instrumented method.
&nbsp;             */
&nbsp;            Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A substitution that drops any field or method access and returns the expected return
&nbsp;         * type&#39;s default value, i.e {@code null} or zero for primitive types.
&nbsp;         */
<b class="fc">&nbsp;        enum Stubbing implements Substitution, Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(parameters.size());</b>
<b class="fc">&nbsp;                for (int index = parameters.size() - 1; index &gt;= 0; index--) {</b>
<b class="fc">&nbsp;                    stackManipulations.add(Removal.of(parameters.get(index)));</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(CompoundList.of(stackManipulations, DefaultValue.of(result.asErasure())));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A substitution that loads a fixed value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForValue implements Substitution, Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to load the value that represents the substitution.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the represented stack manipulation.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new substitution for loading a constant value.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation to load the value that represents the substitution.
&nbsp;             * @param typeDescription   The type of the represented stack manipulation.
&nbsp;             */
<b class="fc">&nbsp;            public ForValue(StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription receiver,
&nbsp;                                             ByteCodeElement.Member original,
&nbsp;                                             TypeList.Generic parameters,
&nbsp;                                             TypeDescription.Generic result,
&nbsp;                                             JavaConstant.MethodHandle methodHandle,
&nbsp;                                             StackManipulation stackManipulation,
&nbsp;                                             int freeOffset) {
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(parameters.size());</b>
<b class="fc">&nbsp;                for (int index = parameters.size() - 1; index &gt;= 0; index--) {</b>
<b class="fc">&nbsp;                    stackManipulations.add(Removal.of(parameters.get(index)));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!typeDescription.asErasure().isAssignableTo(result.asErasure())) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + typeDescription + &quot; to &quot; + result);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new StackManipulation.Compound(CompoundList.of(stackManipulations, this.stackManipulation));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A substitution with a field access.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForFieldAccess implements Substitution {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * A resolver to locate the field to access.
&nbsp;             */
&nbsp;            private final FieldResolver fieldResolver;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new substitution with a field access.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param fieldResolver    A resolver to locate the field to access.
&nbsp;             */
<b class="fc">&nbsp;            public ForFieldAccess(TypeDescription instrumentedType, FieldResolver fieldResolver) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.fieldResolver = fieldResolver;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;            public StackManipulation resolve(TypeDescription receiver,
&nbsp;                                             ByteCodeElement.Member original,
&nbsp;                                             TypeList.Generic parameters,
&nbsp;                                             TypeDescription.Generic result,
&nbsp;                                             JavaConstant.MethodHandle methodHandle,
&nbsp;                                             StackManipulation stackManipulation,
&nbsp;                                             int freeOffset) {
<b class="fc">&nbsp;                FieldDescription fieldDescription = fieldResolver.resolve(receiver, original, parameters, result);</b>
<b class="fc">&nbsp;                if (!fieldDescription.isAccessibleTo(instrumentedType)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; cannot access &quot; + fieldDescription);</b>
<b class="fc">&nbsp;                } else if (result.represents(void.class)) {</b>
<b class="fc">&nbsp;                    if (parameters.size() != (fieldDescription.isStatic() ? 1 : 2)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot set &quot; + fieldDescription + &quot; with &quot; + parameters);</b>
<b class="fc">&nbsp;                    } else if (!fieldDescription.isStatic() &amp;&amp; !parameters.get(0).asErasure().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot set &quot; + fieldDescription + &quot; on &quot; + parameters.get(0));</b>
<b class="fc">&nbsp;                    } else if (!parameters.get(fieldDescription.isStatic() ? 0 : 1).asErasure().isAssignableTo(fieldDescription.getType().asErasure())) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot set &quot; + fieldDescription + &quot; to &quot; + parameters.get(fieldDescription.isStatic() ? 0 : 1));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return FieldAccess.forField(fieldDescription).write();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    if (parameters.size() != (fieldDescription.isStatic() ? 0 : 1)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot set &quot; + fieldDescription + &quot; with &quot; + parameters);</b>
<b class="fc">&nbsp;                    } else if (!fieldDescription.isStatic() &amp;&amp; !parameters.get(0).asErasure().isAssignableTo(fieldDescription.getDeclaringType().asErasure())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot get &quot; + fieldDescription + &quot; on &quot; + parameters.get(0));</b>
<b class="fc">&nbsp;                    } else if (!fieldDescription.getType().asErasure().isAssignableTo(result.asErasure())) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot get &quot; + fieldDescription + &quot; as &quot; + result);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return FieldAccess.forField(fieldDescription).read();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method resolver for locating a field for a substitute.
&nbsp;             */
&nbsp;            public interface FieldResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the field to substitute with.
&nbsp;                 *
&nbsp;                 * @param receiver   The target type on which a member is accessed.
&nbsp;                 * @param original   The target field, method or constructor that is substituted,
&nbsp;                 * @param parameters All parameters that serve as input to this access.
&nbsp;                 * @param result     The result that is expected from the interaction or {@code void} if no result is expected.
&nbsp;                 * @return The field to substitute with.
&nbsp;                 */
&nbsp;                FieldDescription resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result);
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple field resolver that returns a specific field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simple implements FieldResolver {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field to access.
&nbsp;                     */
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a simple field resolver.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field to access.
&nbsp;                     */
<b class="fc">&nbsp;                    public Simple(FieldDescription fieldDescription) {</b>
<b class="fc">&nbsp;                        this.fieldDescription = fieldDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDescription resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result) {
<b class="fc">&nbsp;                        return fieldDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A field matcher that resolves a non-static field on the first parameter type of the substituted member usage.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForElementMatcher implements FieldResolver {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The matcher to use for locating the field to substitute with.
&nbsp;                     */
&nbsp;                    private final ElementMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new field resolver that locates a field on the receiver type using a matcher.
&nbsp;                     *
&nbsp;                     * @param instrumentedType The instrumented type.
&nbsp;                     * @param matcher          The matcher to use for locating the field to substitute with.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForElementMatcher(TypeDescription instrumentedType, ElementMatcher&lt;? super FieldDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public FieldDescription resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result) {
<b class="fc">&nbsp;                        if (parameters.isEmpty()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot substitute parameterless instruction with &quot; + original);</b>
<b class="fc">&nbsp;                        } else if (parameters.get(0).isPrimitive() || parameters.get(0).isArray()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot access field on primitive or array type for &quot; + original);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        TypeDefinition current = parameters.get(0).accept(new TypeDescription.Generic.Visitor.Substitutor.ForReplacement(instrumentedType));</b>
&nbsp;                        do {
<b class="fc">&nbsp;                            FieldList&lt;?&gt; fields = current.getDeclaredFields().filter(not(isStatic()).&lt;FieldDescription&gt;and(isVisibleTo(instrumentedType)).and(matcher));</b>
<b class="fc">&nbsp;                            if (fields.size() == 1) {</b>
<b class="fc">&nbsp;                                return fields.getOnly();</b>
<b class="fc">&nbsp;                            } else if (fields.size() &gt; 1) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Ambiguous field location of &quot; + fields);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            current = current.getSuperClass();</b>
<b class="fc">&nbsp;                        } while (current != null);</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot locate field matching &quot; + matcher + &quot; on &quot; + receiver);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a substitution that substitutes with a given field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfGivenField implements Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field to substitute with.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory that substitues with a given field.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The field to substitute with.
&nbsp;                 */
<b class="fc">&nbsp;                public OfGivenField(FieldDescription fieldDescription) {</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    return new ForFieldAccess(instrumentedType, new FieldResolver.Simple(fieldDescription));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a substitution that locates a field on the receiver type using a matcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfMatchedField implements Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher to apply.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super FieldDescription&gt; matcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new substitution factory that locates a field by applying a matcher on the receiver type.
&nbsp;                 *
&nbsp;                 * @param matcher The matcher to apply.
&nbsp;                 */
<b class="fc">&nbsp;                public OfMatchedField(ElementMatcher&lt;? super FieldDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                    this.matcher = matcher;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    return new ForFieldAccess(instrumentedType, new FieldResolver.ForElementMatcher(instrumentedType, matcher));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A substitution with a method invocation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForMethodInvocation implements Substitution {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            private final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The method resolver to use.
&nbsp;             */
&nbsp;            private final MethodResolver methodResolver;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method-resolving substitution.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param methodResolver   The method resolver to use.
&nbsp;             */
<b class="fc">&nbsp;            public ForMethodInvocation(TypeDescription instrumentedType, MethodResolver methodResolver) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.methodResolver = methodResolver;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription receiver,
&nbsp;                                             ByteCodeElement.Member original,
&nbsp;                                             TypeList.Generic parameters,
&nbsp;                                             TypeDescription.Generic result,
&nbsp;                                             JavaConstant.MethodHandle methodHandle,
&nbsp;                                             StackManipulation stackManipulation,
&nbsp;                                             int freeOffset) {
<b class="fc">&nbsp;                MethodDescription methodDescription = methodResolver.resolve(receiver, original, parameters, result);</b>
<b class="fc">&nbsp;                if (!methodDescription.isAccessibleTo(instrumentedType)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(instrumentedType + &quot; cannot access &quot; + methodDescription);</b>
&nbsp;                }
<b class="fc">&nbsp;                TypeList.Generic mapped = methodDescription.isStatic()</b>
<b class="fc">&nbsp;                        ? methodDescription.getParameters().asTypeList()</b>
<b class="fc">&nbsp;                        : new TypeList.Generic.Explicit(CompoundList.of(methodDescription.getDeclaringType(), methodDescription.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;                if (!methodDescription.getReturnType().asErasure().isAssignableTo(result.asErasure())) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign return value of &quot; + methodDescription + &quot; to &quot; + result);</b>
<b class="fc">&nbsp;                } else if (mapped.size() != parameters.size()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + methodDescription + &quot; on &quot; + parameters.size() + &quot; parameters&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                for (int index = 0; index &lt; mapped.size(); index++) {</b>
<b class="fc">&nbsp;                    if (!parameters.get(index).asErasure().isAssignableTo(mapped.get(index).asErasure())) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot invoke &quot; + methodDescription + &quot; on parameter &quot; + index + &quot; of type &quot; + parameters.get(index));</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return methodDescription.isVirtual() ? MethodInvocation.invoke(methodDescription).virtual(mapped.get(THIS_REFERENCE).asErasure()) : MethodInvocation.invoke(methodDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method resolver for locating a method for a substitute.
&nbsp;             */
&nbsp;            public interface MethodResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the method to substitute with.
&nbsp;                 *
&nbsp;                 * @param receiver   The target type on which a member is accessed.
&nbsp;                 * @param original   The target field, method or constructor that is substituted,
&nbsp;                 * @param parameters All parameters that serve as input to this access.
&nbsp;                 * @param result     The result that is expected from the interaction or {@code void} if no result is expected.
&nbsp;                 * @return The field to substitute with.
&nbsp;                 */
&nbsp;                MethodDescription resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result);
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple method resolver that returns a given method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simple implements MethodResolver {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method to substitute with.
&nbsp;                     */
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple method resolver.
&nbsp;                     *
&nbsp;                     * @param methodDescription The method to substitute with.
&nbsp;                     */
<b class="fc">&nbsp;                    public Simple(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                        this.methodDescription = methodDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result) {
<b class="fc">&nbsp;                        return methodDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A method resolver that locates a non-static method by locating it from the receiver type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Matching implements MethodResolver {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method graph compiler to use.
&nbsp;                     */
&nbsp;                    private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The matcher to use for locating the method to substitute with.
&nbsp;                     */
&nbsp;                    private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new matching method resolver.
&nbsp;                     *
&nbsp;                     * @param instrumentedType    The instrumented type.
&nbsp;                     * @param methodGraphCompiler The method graph compiler to use.
&nbsp;                     * @param matcher             The matcher to use for locating the method to substitute with.
&nbsp;                     */
<b class="fc">&nbsp;                    public Matching(TypeDescription instrumentedType, MethodGraph.Compiler methodGraphCompiler, ElementMatcher&lt;? super MethodDescription&gt; matcher) {</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                        this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public MethodDescription resolve(TypeDescription receiver, ByteCodeElement.Member original, TypeList.Generic parameters, TypeDescription.Generic result) {
<b class="fc">&nbsp;                        if (parameters.isEmpty()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot substitute parameterless instruction with &quot; + original);</b>
<b class="fc">&nbsp;                        } else if (parameters.get(0).isPrimitive() || parameters.get(0).isArray()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot invoke method on primitive or array type for &quot; + original);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        TypeDefinition typeDefinition = parameters.get(0).accept(new TypeDescription.Generic.Visitor.Substitutor.ForReplacement(instrumentedType));</b>
<b class="fc">&nbsp;                        List&lt;MethodDescription&gt; candidates = CompoundList.&lt;MethodDescription&gt;of(methodGraphCompiler.compile(typeDefinition, instrumentedType).listNodes()</b>
<b class="fc">&nbsp;                                .asMethodList()</b>
<b class="fc">&nbsp;                                .filter(matcher), typeDefinition.getDeclaredMethods().filter(isPrivate().&lt;MethodDescription&gt;and(isVisibleTo(instrumentedType)).and(matcher)));</b>
<b class="fc">&nbsp;                        if (candidates.size() == 1) {</b>
<b class="fc">&nbsp;                            return candidates.get(0);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Not exactly one method that matches &quot; + matcher + &quot;: &quot; + candidates);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a substitution that invokes the instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            enum OfInstrumentedMethod implements Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    return new ForMethodInvocation(instrumentedType, new MethodResolver.Simple(instrumentedMethod));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a substitution that invokes a given method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfGivenMethod implements Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method to invoke.
&nbsp;                 */
&nbsp;                private final MethodDescription methodDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for a substitution that invokes a given method.
&nbsp;                 *
&nbsp;                 * @param methodDescription The method to invoke.
&nbsp;                 */
<b class="fc">&nbsp;                public OfGivenMethod(MethodDescription methodDescription) {</b>
<b class="fc">&nbsp;                    this.methodDescription = methodDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    return new ForMethodInvocation(instrumentedType, new MethodResolver.Simple(methodDescription));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a substitution that locates a method on the receiver type using a matcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfMatchedMethod implements Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The matcher for locating the method to substitute with.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super MethodDescription&gt; matcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method graph compiler to use.
&nbsp;                 */
&nbsp;                private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for a substitution that locates a method on the receiver type.
&nbsp;                 *
&nbsp;                 * @param matcher             The matcher for locating the method to substitute with.
&nbsp;                 * @param methodGraphCompiler The method graph compiler to use.
&nbsp;                 */
<b class="fc">&nbsp;                public OfMatchedMethod(ElementMatcher&lt;? super MethodDescription&gt; matcher, MethodGraph.Compiler methodGraphCompiler) {</b>
<b class="fc">&nbsp;                    this.matcher = matcher;</b>
<b class="fc">&nbsp;                    this.methodGraphCompiler = methodGraphCompiler;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    return new ForMethodInvocation(instrumentedType, new MethodResolver.Matching(instrumentedType, methodGraphCompiler, matcher));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A substitution chain allows for chaining multiple substitution steps for a byte code element being replaced.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Chain implements Substitution {
&nbsp;
&nbsp;            /**
&nbsp;             * The assigner to use.
&nbsp;             */
&nbsp;            private final Assigner assigner;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing of the assignment to use.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * The substitution steps to apply.
&nbsp;             */
&nbsp;            private final List&lt;Step&gt; steps;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new substitution chain.
&nbsp;             *
&nbsp;             * @param assigner The assigner to use.
&nbsp;             * @param typing   The typing of the assignment to use.
&nbsp;             * @param steps    The substitution steps to apply.
&nbsp;             */
<b class="fc">&nbsp;            protected Chain(Assigner assigner, Assigner.Typing typing, List&lt;Step&gt; steps) {</b>
<b class="fc">&nbsp;                this.assigner = assigner;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
<b class="fc">&nbsp;                this.steps = steps;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new substitution chain that uses a default assigner and static typing.
&nbsp;             *
&nbsp;             * @return A new substitution chain.
&nbsp;             */
&nbsp;            public static Chain.Factory withDefaultAssigner() {
<b class="fc">&nbsp;                return with(Assigner.DEFAULT, Assigner.Typing.STATIC);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new substitution chain.
&nbsp;             *
&nbsp;             * @param assigner The assigner to use.
&nbsp;             * @param typing   The typing of the assignment to use.
&nbsp;             * @return A new substitution chain.
&nbsp;             */
&nbsp;            public static Chain.Factory with(Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                return new Chain.Factory(assigner, typing, Collections.&lt;Step.Factory&gt;emptyList());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription receiver,
&nbsp;                                             ByteCodeElement.Member original,
&nbsp;                                             TypeList.Generic parameters,
&nbsp;                                             TypeDescription.Generic result,
&nbsp;                                             JavaConstant.MethodHandle methodHandle,
&nbsp;                                             StackManipulation stackManipulation,
&nbsp;                                             int freeOffset) {
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(1</b>
<b class="fc">&nbsp;                        + parameters.size() + steps.size() * 2</b>
<b class="fc">&nbsp;                        + (result.represents(void.class) ? 0 : 2));</b>
<b class="fc">&nbsp;                Map&lt;Integer, Integer&gt; offsets = new HashMap&lt;Integer, Integer&gt;();</b>
<b class="fc">&nbsp;                for (int index = parameters.size() - 1; index &gt;= 0; index--) {</b>
<b class="fc">&nbsp;                    stackManipulations.add(MethodVariableAccess.of(parameters.get(index)).storeAt(freeOffset));</b>
<b class="fc">&nbsp;                    offsets.put(index, freeOffset);</b>
<b class="fc">&nbsp;                    freeOffset += parameters.get(index).getStackSize().getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                stackManipulations.add(DefaultValue.of(result));</b>
<b class="fc">&nbsp;                TypeDescription.Generic current = result;</b>
<b class="fc">&nbsp;                for (Step step : steps) {</b>
<b class="fc">&nbsp;                    Step.Resolution resolution = step.resolve(receiver, original, parameters, result, methodHandle, stackManipulation, current, offsets, freeOffset);</b>
<b class="fc">&nbsp;                    stackManipulations.add(resolution.getStackManipulation());</b>
<b class="fc">&nbsp;                    current = resolution.getResultType();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                StackManipulation assignment = assigner.assign(current, result, typing);</b>
<b class="fc">&nbsp;                if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Failed to assign &quot; + current + &quot; to &quot; + result);</b>
&nbsp;                }
<b class="fc">&nbsp;                stackManipulations.add(assignment);</b>
<b class="fc">&nbsp;                return new StackManipulation.Compound(stackManipulations);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a step of a substitution chain.
&nbsp;             */
&nbsp;            public interface Step {
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves this step of a substitution chain.
&nbsp;                 *
&nbsp;                 * @param receiver          The target result type of the substitution.
&nbsp;                 * @param original          The byte code element that is currently substituted.
&nbsp;                 * @param parameters        The parameters of the substituted element.
&nbsp;                 * @param result            The resulting type of the substituted element.
&nbsp;                 * @param methodHandle      A method handle of the stackManipulation invocation that is being substituted.
&nbsp;                 * @param stackManipulation The byte code instruction that is being substituted.
&nbsp;                 * @param current           The current type of the applied substitution that is the top element on the operand stack.
&nbsp;                 * @param offsets           The arguments of the substituted byte code element mapped to their local variable offsets.
&nbsp;                 * @param freeOffset        The first free offset in the local variable array.
&nbsp;                 * @return A resolved substitution step for the supplied inputs.
&nbsp;                 */
&nbsp;                Resolution resolve(TypeDescription receiver,
&nbsp;                                   ByteCodeElement.Member original,
&nbsp;                                   TypeList.Generic parameters,
&nbsp;                                   TypeDescription.Generic result,
&nbsp;                                   JavaConstant.MethodHandle methodHandle,
&nbsp;                                   StackManipulation stackManipulation,
&nbsp;                                   TypeDescription.Generic current,
&nbsp;                                   Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                   int freeOffset);
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved substitution step.
&nbsp;                 */
&nbsp;                interface Resolution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the stack manipulation to apply the substitution.
&nbsp;                     *
&nbsp;                     * @return The stack manipulation to apply the substitution.
&nbsp;                     */
&nbsp;                    StackManipulation getStackManipulation();
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the resulting type of the substitution or {@code void} if no resulting value is applied.
&nbsp;                     *
&nbsp;                     * @return The resulting type of the substitution or {@code void} if no resulting value is applied.
&nbsp;                     */
&nbsp;                    TypeDescription.Generic getResultType();
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a substitution for an instrumented method.
&nbsp;                 */
&nbsp;                interface Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a substitution step for an instrumented method.
&nbsp;                     *
&nbsp;                     * @param assigner           The assigner to use.
&nbsp;                     * @param typing             The typing to use.
&nbsp;                     * @param instrumentedType   The instrumented type.
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @return The substitution step to apply.
&nbsp;                     */
&nbsp;                    Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A step that executes the original method invocation or field access.
&nbsp;                 */
<b class="fc">&nbsp;                enum OfOriginalExpression implements Step, Factory {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
&nbsp;                        List&lt;StackManipulation&gt; stackManipulations;
<b class="fc">&nbsp;                        if (original instanceof MethodDescription &amp;&amp; ((MethodDescription) original).isConstructor()) {</b>
<b class="fc">&nbsp;                            stackManipulations = new ArrayList&lt;StackManipulation&gt;(parameters.size() + 4);</b>
<b class="fc">&nbsp;                            stackManipulations.add(Removal.of(current));</b>
<b class="fc">&nbsp;                            stackManipulations.add(TypeCreation.of(original.getDeclaringType().asErasure()));</b>
<b class="fc">&nbsp;                            stackManipulations.add(Duplication.SINGLE);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            stackManipulations = new ArrayList&lt;StackManipulation&gt;(parameters.size() + 4);</b>
<b class="fc">&nbsp;                            stackManipulations.add(Removal.of(current));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (int index = 0; index &lt; parameters.size(); index++) {</b>
<b class="fc">&nbsp;                            stackManipulations.add(MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index)));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if (original instanceof MethodDescription) {</b>
<b class="fc">&nbsp;                            stackManipulations.add(stackManipulation);</b>
<b class="fc">&nbsp;                            return new Simple(new StackManipulation.Compound(stackManipulations), ((MethodDescription) original).isConstructor()</b>
<b class="fc">&nbsp;                                    ? original.getDeclaringType().asGenericType()</b>
<b class="nc">&nbsp;                                    : ((MethodDescription) original).getReturnType());</b>
<b class="fc">&nbsp;                        } else if (original instanceof FieldDescription) {</b>
<b class="fc">&nbsp;                            if (original.isStatic()) {</b>
<b class="fc">&nbsp;                                if (parameters.isEmpty()) {</b>
<b class="fc">&nbsp;                                    stackManipulations.add(stackManipulation);</b>
<b class="fc">&nbsp;                                    return new Simple(new StackManipulation.Compound(stackManipulations), ((FieldDescription) original).getType());</b>
&nbsp;                                } else /* if (parameters.size() == 1) */ {
<b class="fc">&nbsp;                                    stackManipulations.add(stackManipulation);</b>
<b class="fc">&nbsp;                                    return new Simple(new StackManipulation.Compound(stackManipulations), TypeDefinition.Sort.describe(void.class));</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="fc">&nbsp;                                if (parameters.size() == 1) {</b>
<b class="fc">&nbsp;                                    stackManipulations.add(FieldAccess.forField((FieldDescription) original).read());</b>
<b class="fc">&nbsp;                                    return new Simple(new StackManipulation.Compound(stackManipulations), ((FieldDescription) original).getType());</b>
&nbsp;                                } else /* if (parameters.size() == 2) */ {
<b class="fc">&nbsp;                                    stackManipulations.add(FieldAccess.forField((FieldDescription) original).write());</b>
<b class="fc">&nbsp;                                    return new Simple(new StackManipulation.Compound(stackManipulations), TypeDefinition.Sort.describe(void.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalArgumentException(&quot;Unexpected target type: &quot; + original);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return this;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple substitution step within a substitution chain.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simple implements Step, Resolution, Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack manipulation to apply.
&nbsp;                     */
&nbsp;                    private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The resulting type of applying the stack manipulation.
&nbsp;                     */
&nbsp;                    private final TypeDescription.Generic resultType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple substitution step.
&nbsp;                     *
&nbsp;                     * @param stackManipulation The stack manipulation to apply.
&nbsp;                     * @param resultType        The resulting type of applying the stack manipulation.
&nbsp;                     */
&nbsp;                    public Simple(StackManipulation stackManipulation, Type resultType) {
<b class="fc">&nbsp;                        this(stackManipulation, TypeDefinition.Sort.describe(resultType));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple substitution step.
&nbsp;                     *
&nbsp;                     * @param stackManipulation The stack manipulation to apply.
&nbsp;                     * @param resultType        The resulting type of applying the stack manipulation.
&nbsp;                     */
<b class="fc">&nbsp;                    public Simple(StackManipulation stackManipulation, TypeDescription.Generic resultType) {</b>
<b class="fc">&nbsp;                        this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                        this.resultType = resultType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a compile-time constant as the next step value.
&nbsp;                     *
&nbsp;                     * @param value The compile-time constant to resolve.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory of(Object value) {
<b class="fc">&nbsp;                        ConstantValue constant = ConstantValue.Simple.wrap(value);</b>
<b class="fc">&nbsp;                        return new Simple(constant.toStackManipulation(), constant.getTypeDescription().asGenericType());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return this;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        return receiver.represents(void.class)</b>
<b class="nc">&nbsp;                                ? this</b>
<b class="fc">&nbsp;                                : new Simple(new StackManipulation.Compound(Removal.of(current), this.stackManipulation), resultType);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation getStackManipulation() {
<b class="fc">&nbsp;                        return stackManipulation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription.Generic getResultType() {
<b class="fc">&nbsp;                        return resultType;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A step within a substitution chain that converts the current type to the expected return type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForAssignment implements Step {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The result type or {@code null} if the type of the substitution result should be targeted.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                    private final TypeDescription.Generic result;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The assigner to use.
&nbsp;                     */
&nbsp;                    private final Assigner assigner;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a step for a type assignment.
&nbsp;                     *
&nbsp;                     * @param result   The result type or {@code null} if the type of the substitution result should be targeted.
&nbsp;                     * @param assigner The assigner to use.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForAssignment(@MaybeNull TypeDescription.Generic result, Assigner assigner) {</b>
<b class="fc">&nbsp;                        this.result = result;</b>
<b class="fc">&nbsp;                        this.assigner = assigner;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a step factory that casts the current stack top value to the specified type.
&nbsp;                     *
&nbsp;                     * @param type The type that should be cast to.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory castTo(Type type) {
<b class="fc">&nbsp;                        return new Factory(TypeDefinition.Sort.describe(type));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a step factory that casts the current stack top value to the specified type.
&nbsp;                     *
&nbsp;                     * @param typeDescription The description of the type that should be cast to.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory castTo(TypeDescription.Generic typeDescription) {
<b class="nc">&nbsp;                        return new Factory(typeDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a step factory that casts the current stack top value to the expected return value.
&nbsp;                     *
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory castToSubstitutionResult() {
<b class="fc">&nbsp;                        return new Factory(null);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        StackManipulation assignment = assigner.assign(current, this.result == null ? result : this.result, Assigner.Typing.DYNAMIC);</b>
<b class="fc">&nbsp;                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Failed to assign &quot; + current + &quot; to &quot; + (this.result == null ? result : this.result));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Simple(assignment, this.result == null ? result : this.result);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A factory for creating a step for a dynamic type assignment.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Factory implements Step.Factory {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The result type or {@code null} if the type of the substitution result should be targeted.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                        private final TypeDescription.Generic result;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new factory for a step that applies a type assignment.
&nbsp;                         *
&nbsp;                         * @param result The result type or {@code null} if the type of the substitution result should be targeted.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Factory(@MaybeNull TypeDescription.Generic result) {</b>
<b class="fc">&nbsp;                            this.result = result;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                            return new ForAssignment(result, assigner);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A step that substitutes an argument of a given index with a compatible type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForArgumentSubstitution implements Step {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack manipulation that loads the substituted argument.
&nbsp;                     */
&nbsp;                    private final StackManipulation substitution;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type of the substituted argument.
&nbsp;                     */
&nbsp;                    private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the argument to substitute.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The assigner to use for assigning the argument.
&nbsp;                     */
&nbsp;                    private final Assigner assigner;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The typing to use for the argument assignment.
&nbsp;                     */
&nbsp;                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an argument substitution step.
&nbsp;                     *
&nbsp;                     * @param substitution    The stack manipulation that loads the substituted argument.
&nbsp;                     * @param typeDescription The type of the substituted argument.
&nbsp;                     * @param index           The index of the argument to substitute.
&nbsp;                     * @param assigner        The assigner to use for assigning the argument.
&nbsp;                     * @param typing          The typing to use for the argument assignment.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForArgumentSubstitution(StackManipulation substitution, TypeDescription.Generic typeDescription, int index, Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                        this.substitution = substitution;</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
<b class="fc">&nbsp;                        this.assigner = assigner;</b>
<b class="fc">&nbsp;                        this.typing = typing;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a step substitution factory for a compile-time constant to replace an argument value at a given index.
&nbsp;                     *
&nbsp;                     * @param value The compile-time constant to replace.
&nbsp;                     * @param index The index of the substituted argument.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory of(Object value, int index) {
<b class="fc">&nbsp;                        if (index &lt; 0) {</b>
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;Index cannot be negative: &quot; + index);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        ConstantValue constant = ConstantValue.Simple.wrap(value);</b>
<b class="fc">&nbsp;                        return new Factory(constant.toStackManipulation(), constant.getTypeDescription().asGenericType(), index);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        if (index &gt;= parameters.size()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(original + &quot; has not &quot; + index + &quot; arguments&quot;);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        StackManipulation assignment = assigner.assign(typeDescription, parameters.get(index), typing);</b>
<b class="fc">&nbsp;                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + typeDescription + &quot; to &quot; + parameters.get(index));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Simple(new StackManipulation.Compound(substitution, assignment, MethodVariableAccess.of(parameters.get(index)).storeAt(offsets.get(index))), current);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A factory to create an argument substitution step.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Factory implements Step.Factory {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The stack manipulation that loads the substituted argument.
&nbsp;                         */
&nbsp;                        private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type of the substituted argument.
&nbsp;                         */
&nbsp;                        private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The index of the argument to substitute.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for an argument substitution step.
&nbsp;                         *
&nbsp;                         * @param stackManipulation The stack manipulation that loads the substituted argument.
&nbsp;                         * @param type              The type of the substituted argument.
&nbsp;                         * @param index             The index of the argument to substitute.
&nbsp;                         */
&nbsp;                        public Factory(StackManipulation stackManipulation, Type type, int index) {
<b class="nc">&nbsp;                            this(stackManipulation, TypeDefinition.Sort.describe(type), index);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for an argument substitution step.
&nbsp;                         *
&nbsp;                         * @param stackManipulation The stack manipulation that loads the substituted argument.
&nbsp;                         * @param typeDescription   The type of the substituted argument.
&nbsp;                         * @param index             The index of the argument to substitute.
&nbsp;                         */
<b class="fc">&nbsp;                        public Factory(StackManipulation stackManipulation, TypeDescription.Generic typeDescription, int index) {</b>
<b class="fc">&nbsp;                            this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                            this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                            this.index = index;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                            return new ForArgumentSubstitution(stackManipulation, typeDescription, index, assigner, typing);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A step that loads an argument to a method as the current chain value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForArgumentLoading implements Step, Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the argument to substitute.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an argument loading step.
&nbsp;                     *
&nbsp;                     * @param index The index of the argument to load.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForArgumentLoading(int index) {</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return this;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        if (index &gt;= parameters.size()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(original + &quot; has not &quot; + index + &quot; arguments&quot;);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Simple(new StackManipulation.Compound(Removal.of(current), MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index))), parameters.get(index));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a step for a field access.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                abstract class ForField implements Step {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field description accessed in this step.
&nbsp;                     */
&nbsp;                    protected final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The assigner to use.
&nbsp;                     */
&nbsp;                    protected final Assigner assigner;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The typing to use when assigning.
&nbsp;                     */
&nbsp;                    protected final Assigner.Typing typing;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new step for a field access.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field description accessed in this step.
&nbsp;                     * @param assigner         The assigner to use.
&nbsp;                     * @param typing           The typing to use when assigning.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForField(FieldDescription fieldDescription, Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                        this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                        this.assigner = assigner;</b>
<b class="fc">&nbsp;                        this.typing = typing;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Field description always has declaring type.&quot;)
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(2);</b>
<b class="fc">&nbsp;                        if (fieldDescription.isStatic()) {</b>
<b class="fc">&nbsp;                            stackManipulations.add(Removal.of(current));</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            StackManipulation assignment = assigner.assign(current, fieldDescription.getDeclaringType().asGenericType(), typing);</b>
<b class="fc">&nbsp;                            if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot assign &quot; + current + &quot; to &quot; + fieldDescription.getDeclaringType());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            stackManipulations.add(assignment);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return doResolve(original, parameters, offsets, new StackManipulation.Compound(stackManipulations));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Completes the resolution.
&nbsp;                     *
&nbsp;                     * @param original          The byte code element that is currently substituted.
&nbsp;                     * @param parameters        The parameters of the substituted element.
&nbsp;                     * @param offsets           The arguments of the substituted byte code element mapped to their local variable offsets.
&nbsp;                     * @param stackManipulation A stack manipulation to prepare the field access.
&nbsp;                     * @return A resolved substitution step for the supplied inputs.
&nbsp;                     */
&nbsp;                    protected abstract Resolution doResolve(ByteCodeElement.Member original, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, StackManipulation stackManipulation);
&nbsp;
&nbsp;                    /**
&nbsp;                     * A step for reading a field.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Read extends ForField {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a step for reading a field.
&nbsp;                         *
&nbsp;                         * @param fieldDescription A description of the field being read.
&nbsp;                         * @param assigner         The assigner to use.
&nbsp;                         * @param typing           The typing to use when assigning.
&nbsp;                         */
&nbsp;                        protected Read(FieldDescription fieldDescription, Assigner assigner, Assigner.Typing typing) {
<b class="fc">&nbsp;                            super(fieldDescription, assigner, typing);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        protected Resolution doResolve(ByteCodeElement.Member original, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, StackManipulation stackManipulation) {
<b class="fc">&nbsp;                            return new Simple(new StackManipulation.Compound(stackManipulation, FieldAccess.forField(fieldDescription).read()), fieldDescription.getType());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A factory for creating a field read step in a chain.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        public static class Factory implements Step.Factory {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A description of the field being read.
&nbsp;                             */
&nbsp;                            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a factory for a step reading a field.
&nbsp;                             *
&nbsp;                             * @param field The field being read.
&nbsp;                             */
&nbsp;                            public Factory(Field field) {
<b class="fc">&nbsp;                                this(new FieldDescription.ForLoadedField(field));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a factory for a step reading a field.
&nbsp;                             *
&nbsp;                             * @param fieldDescription A description of the field being read.
&nbsp;                             */
<b class="fc">&nbsp;                            public Factory(FieldDescription fieldDescription) {</b>
<b class="fc">&nbsp;                                this.fieldDescription = fieldDescription;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new Read(fieldDescription, assigner, typing);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A step for writing to a field.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Write extends ForField {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The index of the parameter being accessed. If the targeted element is a non-static method, is increased by one.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a step for writing to a field.
&nbsp;                         *
&nbsp;                         * @param fieldDescription A description of the field to write to.
&nbsp;                         * @param assigner         The assigner to use.
&nbsp;                         * @param typing           The typing to use when assigning.
&nbsp;                         * @param index            The index of the parameter being accessed. If the targeted element is a non-static method, is increased by one.
&nbsp;                         */
&nbsp;                        protected Write(FieldDescription fieldDescription, Assigner assigner, Assigner.Typing typing, int index) {
<b class="fc">&nbsp;                            super(fieldDescription, assigner, typing);</b>
<b class="fc">&nbsp;                            this.index = index;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        protected Resolution doResolve(ByteCodeElement.Member original, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, StackManipulation stackManipulation) {
<b class="fc">&nbsp;                            int index = ((original.getModifiers() &amp; Opcodes.ACC_STATIC) == 0)</b>
<b class="fc">&nbsp;                                    &amp;&amp; !(original instanceof MethodDescription</b>
<b class="nc">&nbsp;                                    &amp;&amp; ((MethodDescription) original).isConstructor()) ? this.index + 1 : this.index;</b>
<b class="fc">&nbsp;                            if (index &gt;= parameters.size()) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(original + &quot; does not define an argument with index &quot; + index);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            StackManipulation assignment = assigner.assign(parameters.get(index), fieldDescription.getType(), typing);</b>
<b class="fc">&nbsp;                            if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot write &quot; + parameters.get(index) + &quot; to &quot; + fieldDescription);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return new Simple(new StackManipulation.Compound(stackManipulation,</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.of(parameters.get(index)).loadFrom(offsets.get(index)),</b>
&nbsp;                                    assignment,
<b class="fc">&nbsp;                                    FieldAccess.forField(fieldDescription).write()), TypeDefinition.Sort.describe(void.class));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A factory for creating a step to write to a field.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        public static class Factory implements Step.Factory {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A description of the field to write to.
&nbsp;                             */
&nbsp;                            private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The index of the parameter being accessed. If the targeted element is a non-static method, is increased by one.
&nbsp;                             */
&nbsp;                            private final int index;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a factory for writing to a field.
&nbsp;                             *
&nbsp;                             * @param field The field to write to.
&nbsp;                             * @param index The index of the parameter being accessed. If the targeted element is a non-static method, is increased by one.
&nbsp;                             */
&nbsp;                            public Factory(Field field, int index) {
<b class="fc">&nbsp;                                this(new FieldDescription.ForLoadedField(field), index);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a factory for writing to a field.
&nbsp;                             *
&nbsp;                             * @param fieldDescription A description of the field to write to.
&nbsp;                             * @param index            The index of the parameter being accessed. If the targeted element is a non-static method, is increased by one.
&nbsp;                             */
<b class="fc">&nbsp;                            public Factory(FieldDescription fieldDescription, int index) {</b>
<b class="fc">&nbsp;                                this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                                this.index = index;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new Write(fieldDescription, assigner, typing, index);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A step for invoking a method or constructor. If non-static, a method is invoked upon a the current stack argument of the chain.
&nbsp;                 * Arguments are loaded from the intercepted byte code element with a possibility of substitution.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForInvocation implements Step {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The invoked method or constructor.
&nbsp;                     */
&nbsp;                    private final MethodDescription methodDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of substituted parameter indices. For targets that are non-static methods, the targeted index is increased by one.
&nbsp;                     */
&nbsp;                    private final Map&lt;Integer, Integer&gt; substitutions;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The assigner to use.
&nbsp;                     */
&nbsp;                    private final Assigner assigner;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The typing to use when assigning.
&nbsp;                     */
&nbsp;                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new step of an invocation.
&nbsp;                     *
&nbsp;                     * @param methodDescription The invoked method or constructor.
&nbsp;                     * @param substitutions     A mapping of substituted parameter indices. For targets that are non-static methods, the targeted index is increased by one.
&nbsp;                     * @param assigner          The assigner to use.
&nbsp;                     * @param typing            The typing to use when assigning.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForInvocation(MethodDescription methodDescription, Map&lt;Integer, Integer&gt; substitutions, Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                        this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                        this.substitutions = substitutions;</b>
<b class="fc">&nbsp;                        this.assigner = assigner;</b>
<b class="fc">&nbsp;                        this.typing = typing;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(3 + parameters.size() * 2);</b>
<b class="fc">&nbsp;                        if (methodDescription.isStatic()) {</b>
<b class="fc">&nbsp;                            stackManipulations.add(Removal.of(current));</b>
<b class="fc">&nbsp;                        } else if (methodDescription.isConstructor()) {</b>
<b class="nc">&nbsp;                            stackManipulations.add(Removal.of(current));</b>
<b class="nc">&nbsp;                            stackManipulations.add(TypeCreation.of(methodDescription.getDeclaringType().asErasure()));</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            StackManipulation assignment = assigner.assign(current, methodDescription.getDeclaringType().asGenericType(), typing);</b>
<b class="fc">&nbsp;                            if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot assign &quot; + current + &quot; to &quot; + methodDescription.getDeclaringType());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            stackManipulations.add(assignment);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        boolean shift = ((original.getModifiers() &amp; Opcodes.ACC_STATIC) == 0) &amp;&amp; !(original instanceof MethodDescription &amp;&amp; ((MethodDescription) original).isConstructor());</b>
<b class="fc">&nbsp;                        for (int index = 0; index &lt; methodDescription.getParameters().size(); index++) {</b>
<b class="nc">&nbsp;                            int substitution = substitutions.containsKey(index + (shift ? 1 : 0)) ? substitutions.get(index + (shift ? 1 : 0)) : index + (shift ? 1 : 0);</b>
<b class="nc">&nbsp;                            if (substitution &gt;= parameters.size()) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(original + &quot; does not support an index &quot; + substitution);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            stackManipulations.add(MethodVariableAccess.of(parameters.get(substitution)).loadFrom(offsets.get(substitution)));</b>
<b class="nc">&nbsp;                            StackManipulation assignment = assigner.assign(parameters.get(substitution), methodDescription.getParameters().get(index).getType(), typing);</b>
<b class="nc">&nbsp;                            if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Cannot assign parameter with &quot; + index + &quot; of type &quot; + parameters.get(substitution) + &quot; to &quot; + methodDescription);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            stackManipulations.add(assignment);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        stackManipulations.add(MethodInvocation.invoke(methodDescription));</b>
<b class="fc">&nbsp;                        return new Simple(new StackManipulation.Compound(stackManipulations), methodDescription.getReturnType());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A factory to create a step for a method invocation.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Factory implements Step.Factory {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The invoked method or constructor.
&nbsp;                         */
&nbsp;                        private final MethodDescription methodDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of substituted parameter indices. For targets that are non-static methods, the targeted index is increased by one.
&nbsp;                         */
&nbsp;                        private final Map&lt;Integer, Integer&gt; substitutions;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for a method invocation without parameter substitutions.
&nbsp;                         *
&nbsp;                         * @param method The invoked method.
&nbsp;                         */
&nbsp;                        public Factory(Method method) {
<b class="fc">&nbsp;                            this(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for a method invocation without parameter substitutions.
&nbsp;                         *
&nbsp;                         * @param constructor The constructor.
&nbsp;                         */
&nbsp;                        public Factory(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;                            this(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for a method invocation without parameter substitutions.
&nbsp;                         *
&nbsp;                         * @param methodDescription The invoked method or constructor.
&nbsp;                         */
&nbsp;                        public Factory(MethodDescription methodDescription) {
<b class="fc">&nbsp;                            this(methodDescription, Collections.&lt;Integer, Integer&gt;emptyMap());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for a method invocation.
&nbsp;                         *
&nbsp;                         * @param methodDescription The invoked method or constructor.
&nbsp;                         * @param substitutions     A mapping of substituted parameter indices. For targets that are non-static methods,
&nbsp;                         *                          the targeted index is increased by one.
&nbsp;                         */
<b class="fc">&nbsp;                        public Factory(MethodDescription methodDescription, Map&lt;Integer, Integer&gt; substitutions) {</b>
<b class="fc">&nbsp;                            this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                            this.substitutions = substitutions;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                            return new ForInvocation(methodDescription, substitutions, assigner, typing);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A step that invokes a delegation method based on annotations on the parameters of the targeted method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                class ForDelegation implements Step {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type on top of the stack after the delegation is complete.
&nbsp;                     */
&nbsp;                    private final TypeDescription.Generic returned;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The dispatcher to use.
&nbsp;                     */
&nbsp;                    private final Dispatcher.Resolved dispatcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of offset mappings to execute prior to delegation.
&nbsp;                     */
&nbsp;                    private final List&lt;OffsetMapping.Resolved&gt; offsetMappings;
&nbsp;
&nbsp;                    /**
&nbsp;                     * @param returned       The type on top of the stack after the delegation is complete.
&nbsp;                     * @param dispatcher     The dispatcher to use.
&nbsp;                     * @param offsetMappings A list of offset mappings to execute prior to delegation.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForDelegation(TypeDescription.Generic returned, Dispatcher.Resolved dispatcher, List&lt;OffsetMapping.Resolved&gt; offsetMappings) {</b>
<b class="fc">&nbsp;                        this.returned = returned;</b>
<b class="fc">&nbsp;                        this.dispatcher = dispatcher;</b>
<b class="fc">&nbsp;                        this.offsetMappings = offsetMappings;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a delegating step factory for the supplied method.
&nbsp;                     *
&nbsp;                     * @param method The method to delegate to.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory to(Method method) {
<b class="fc">&nbsp;                        return to(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a delegating step factory for the supplied constructor.
&nbsp;                     *
&nbsp;                     * @param constructor The constructor to delegate to.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory to(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;                        return to(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a delegating step factory for the supplied method description..
&nbsp;                     *
&nbsp;                     * @param methodDescription A description of the method or constructor to delegate to.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    public static Step.Factory to(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                        if (methodDescription.isTypeInitializer()) {</b>
<b class="nc">&nbsp;                            throw new IllegalArgumentException(&quot;Cannot delegate to a type initializer: &quot; + methodDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return to(methodDescription, Dispatcher.ForRegularInvocation.Factory.INSTANCE, Collections.&lt;OffsetMapping.Factory&lt;?&gt;&gt;emptyList());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an appropriate step factory for the given delegate method, dispatcher factory and user factories.
&nbsp;                     *
&nbsp;                     * @param delegate          A description of the method or constructor to delegate to.
&nbsp;                     * @param dispatcherFactory The dispatcher factory to use.
&nbsp;                     * @param userFactories     Factories for custom annotation bindings.
&nbsp;                     * @return An appropriate step factory.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                    private static Step.Factory to(MethodDescription.InDefinedShape delegate, Dispatcher.Factory dispatcherFactory, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories) {
<b class="fc">&nbsp;                        if (delegate.isTypeInitializer()) {</b>
<b class="nc">&nbsp;                            throw new IllegalArgumentException(&quot;Cannot delegate to type initializer: &quot; + delegate);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Factory(delegate, dispatcherFactory.make(delegate), CompoundList.of(Arrays.asList(</b>
&nbsp;                                OffsetMapping.ForArgument.Factory.INSTANCE,
&nbsp;                                OffsetMapping.ForThisReference.Factory.INSTANCE,
&nbsp;                                OffsetMapping.ForAllArguments.Factory.INSTANCE,
&nbsp;                                OffsetMapping.ForSelfCallHandle.Factory.INSTANCE,
&nbsp;                                OffsetMapping.ForField.Unresolved.Factory.INSTANCE,
&nbsp;                                OffsetMapping.ForFieldHandle.Unresolved.GetterFactory.INSTANCE,
&nbsp;                                OffsetMapping.ForFieldHandle.Unresolved.SetterFactory.INSTANCE,
&nbsp;                                OffsetMapping.ForOrigin.Factory.INSTANCE,
&nbsp;                                OffsetMapping.ForStubValue.Factory.INSTANCE,
&nbsp;                                new OffsetMapping.ForStackManipulation.OfDefaultValue&lt;Unused&gt;(Unused.class),
&nbsp;                                OffsetMapping.ForCurrent.Factory.INSTANCE), userFactories));
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a builder for creating a {@link ForDelegation} with custom configuration.
&nbsp;                     *
&nbsp;                     * @return A bulder for creating a custom delegator.
&nbsp;                     */
&nbsp;                    public static WithCustomMapping withCustomMapping() {
<b class="fc">&nbsp;                        return new WithCustomMapping(Dispatcher.ForRegularInvocation.Factory.INSTANCE, Collections.&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt;emptyMap());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(TypeDescription receiver,
&nbsp;                                              ByteCodeElement.Member original,
&nbsp;                                              TypeList.Generic parameters,
&nbsp;                                              TypeDescription.Generic result,
&nbsp;                                              JavaConstant.MethodHandle methodHandle,
&nbsp;                                              StackManipulation stackManipulation,
&nbsp;                                              TypeDescription.Generic current,
&nbsp;                                              Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                              int freeOffset) {
<b class="fc">&nbsp;                        List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(offsetMappings.size() + 3);</b>
<b class="fc">&nbsp;                        stackManipulations.add(current.represents(void.class)</b>
<b class="fc">&nbsp;                                ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                : MethodVariableAccess.of(current).storeAt(freeOffset));</b>
<b class="fc">&nbsp;                        stackManipulations.add(dispatcher.initialize());</b>
<b class="fc">&nbsp;                        for (OffsetMapping.Resolved offsetMapping : offsetMappings) {</b>
<b class="fc">&nbsp;                            stackManipulations.add(offsetMapping.apply(receiver, original, parameters, result, current, methodHandle, offsets, freeOffset));</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        stackManipulations.add(dispatcher.apply(receiver, original, methodHandle));</b>
<b class="fc">&nbsp;                        return new Simple(new StackManipulation.Compound(stackManipulations), returned);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A factory for creating a delegating step during a member substitution.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class Factory implements Step.Factory {
&nbsp;
&nbsp;                        /**
&nbsp;                         * A description of the method or constructor to delegate to.
&nbsp;                         */
&nbsp;                        private final MethodDescription.InDefinedShape delegate;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The dispatcher to use for invoking the delegate.
&nbsp;                         */
&nbsp;                        private final Dispatcher dispatcher;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The offset mappings to use.
&nbsp;                         */
&nbsp;                        private final List&lt;OffsetMapping&gt; offsetMappings;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new factory for a delegating step.
&nbsp;                         *
&nbsp;                         * @param delegate   A description of the method or constructor to delegate to.
&nbsp;                         * @param dispatcher The dispatcher to use for invoking the delegate.
&nbsp;                         * @param factories  The dispatcher to use for invoking the delegate.
&nbsp;                         */
<b class="fc">&nbsp;                        protected Factory(MethodDescription.InDefinedShape delegate, Dispatcher dispatcher, List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories) {</b>
<b class="fc">&nbsp;                            Map&lt;TypeDescription, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings = new HashMap&lt;TypeDescription, OffsetMapping.Factory&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                            for (OffsetMapping.Factory&lt;?&gt; factory : factories) {</b>
<b class="fc">&nbsp;                                offsetMappings.put(net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(factory.getAnnotationType()), factory);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            this.offsetMappings = new ArrayList&lt;OffsetMapping&gt;(factories.size());</b>
<b class="fc">&nbsp;                            if (delegate.isMethod() &amp;&amp; !delegate.isStatic()) {</b>
<b class="fc">&nbsp;                                OffsetMapping offsetMapping = null;</b>
<b class="fc">&nbsp;                                for (AnnotationDescription annotationDescription : delegate.getDeclaredAnnotations()) {</b>
<b class="nc">&nbsp;                                    OffsetMapping.Factory&lt;?&gt; factory = offsetMappings.get(annotationDescription.getAnnotationType());</b>
<b class="nc">&nbsp;                                    if (factory != null) {</b>
<b class="nc">&nbsp;                                        @SuppressWarnings(&quot;unchecked&quot;) OffsetMapping current = factory.make(delegate, (AnnotationDescription.Loadable) annotationDescription.prepare(factory.getAnnotationType()));</b>
<b class="nc">&nbsp;                                        if (offsetMapping == null) {</b>
<b class="nc">&nbsp;                                            offsetMapping = current;</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            throw new IllegalStateException(delegate + &quot; is bound to both &quot; + current + &quot; and &quot; + offsetMapping);</b>
&nbsp;                                        }
&nbsp;                                    }
<b class="nc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                this.offsetMappings.add(offsetMapping == null</b>
<b class="fc">&nbsp;                                        ? new OffsetMapping.ForThisReference(delegate.getDeclaringType().asGenericType(), null, Source.SUBSTITUTED_ELEMENT, false)</b>
<b class="nc">&nbsp;                                        : offsetMapping);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (int index = 0; index &lt; delegate.getParameters().size(); index++) {</b>
<b class="fc">&nbsp;                                ParameterDescription.InDefinedShape parameterDescription = delegate.getParameters().get(index);</b>
<b class="fc">&nbsp;                                OffsetMapping offsetMapping = null;</b>
<b class="fc">&nbsp;                                for (AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                                    OffsetMapping.Factory&lt;?&gt; factory = offsetMappings.get(annotationDescription.getAnnotationType());</b>
<b class="fc">&nbsp;                                    if (factory != null) {</b>
<b class="fc">&nbsp;                                        @SuppressWarnings(&quot;unchecked&quot;) OffsetMapping current = factory.make(parameterDescription, (AnnotationDescription.Loadable) annotationDescription.prepare(factory.getAnnotationType()));</b>
<b class="fc">&nbsp;                                        if (offsetMapping == null) {</b>
<b class="fc">&nbsp;                                            offsetMapping = current;</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            throw new IllegalStateException(parameterDescription + &quot; is bound to both &quot; + current + &quot; and &quot; + offsetMapping);</b>
&nbsp;                                        }
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                this.offsetMappings.add(offsetMapping == null</b>
<b class="nc">&nbsp;                                        ? new OffsetMapping.ForArgument(parameterDescription.getType(), index, null, Source.SUBSTITUTED_ELEMENT, false)</b>
<b class="fc">&nbsp;                                        : offsetMapping);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            this.delegate = delegate;</b>
<b class="fc">&nbsp;                            this.dispatcher = dispatcher;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Step make(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                            List&lt;OffsetMapping.Resolved&gt; targets = new ArrayList&lt;OffsetMapping.Resolved&gt;(offsetMappings.size());</b>
<b class="fc">&nbsp;                            for (OffsetMapping offsetMapping : offsetMappings) {</b>
<b class="fc">&nbsp;                                targets.add(offsetMapping.resolve(assigner, typing, instrumentedType, instrumentedMethod));</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return new ForDelegation(delegate.getReturnType(), dispatcher.resolve(instrumentedType, instrumentedMethod), targets);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An offset mapping for binding a parameter or dispatch target for the method or constructor that is delegated to.
&nbsp;                     */
&nbsp;                    public interface OffsetMapping {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves an offset mapping for a given instrumented method.
&nbsp;                         *
&nbsp;                         * @param assigner           The assigner to use.
&nbsp;                         * @param typing             The typing to use if no explicit typing is specified.
&nbsp;                         * @param instrumentedType   The instrumented type.
&nbsp;                         * @param instrumentedMethod The instrumented method.
&nbsp;                         * @return A resolved version of this offset mapping.
&nbsp;                         */
&nbsp;                        OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that was resolved for a given instrumented type and method.
&nbsp;                         */
&nbsp;                        interface Resolved {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Applies this offset mapping.
&nbsp;                             *
&nbsp;                             * @param receiver     The target type of the invoked delegate.
&nbsp;                             * @param original     The substituted element.
&nbsp;                             * @param parameters   The parameters that are supplied to the substituted expression.
&nbsp;                             * @param result       The resulting type of the substituted expression.
&nbsp;                             * @param current      The type of the value that was produced by the previous step in the substitution chain.
&nbsp;                             * @param methodHandle A method handle that represents the substituted element.
&nbsp;                             * @param offsets      The offsets of the supplied parameters.
&nbsp;                             * @param offset       The offset of the value that was produced by the previous step.
&nbsp;                             * @return An appropriate stack manipulation.
&nbsp;                             */
&nbsp;                            StackManipulation apply(TypeDescription receiver,
&nbsp;                                                    ByteCodeElement.Member original,
&nbsp;                                                    TypeList.Generic parameters,
&nbsp;                                                    TypeDescription.Generic result,
&nbsp;                                                    TypeDescription.Generic current,
&nbsp;                                                    JavaConstant.MethodHandle methodHandle,
&nbsp;                                                    Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                    int offset);
&nbsp;
&nbsp;                            /**
&nbsp;                             * An offset mapping that loads a stack manipulation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            class ForStackManipulation implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The stack manipulation to load.
&nbsp;                                 */
&nbsp;                                private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved offset mapping for a stack manipulation.
&nbsp;                                 *
&nbsp;                                 * @param stackManipulation The stack manipulation to load.
&nbsp;                                 */
<b class="fc">&nbsp;                                public ForStackManipulation(StackManipulation stackManipulation) {</b>
<b class="fc">&nbsp;                                    this.stackManipulation = stackManipulation;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    return stackManipulation;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A factory for creating an offset mapping based on an annotation on a parameter, method or constructor.
&nbsp;                         *
&nbsp;                         * @param &lt;T&gt; The type of the annotation.
&nbsp;                         */
&nbsp;                        interface Factory&lt;T extends Annotation&gt; {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Returns the type of the annotation for this factory.
&nbsp;                             *
&nbsp;                             * @return The type of the annotation for this factory.
&nbsp;                             */
&nbsp;                            Class&lt;T&gt; getAnnotationType();
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping for an annotation that was found on a non-static method.
&nbsp;                             *
&nbsp;                             * @param target     The method that is the delegated to.
&nbsp;                             * @param annotation The annotation that was found on the method.
&nbsp;                             * @return An appropriate offset mapping.
&nbsp;                             */
&nbsp;                            OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation);
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping for a parameter of the method or constructor that is the delegation target.
&nbsp;                             *
&nbsp;                             * @param target     The parameter that is bound to an expression.
&nbsp;                             * @param annotation The annotation that was found on the parameter.
&nbsp;                             * @return An appropriate offset mapping.
&nbsp;                             */
&nbsp;                            OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation);
&nbsp;
&nbsp;                            /**
&nbsp;                             * An abstract base implementation of a factory for an offset mapping.
&nbsp;                             *
&nbsp;                             * @param &lt;S&gt; The type of the represented annotation.
&nbsp;                             */
<b class="fc">&nbsp;                            abstract class AbstractBase&lt;S extends Annotation&gt; implements OffsetMapping.Factory&lt;S&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;S&gt; annotation) {
<b class="nc">&nbsp;                                    return make(target.getDeclaringType().asGenericType(), annotation);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;S&gt; annotation) {
<b class="fc">&nbsp;                                    return make(target.getType(), annotation);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Returns an offset mapping for the bound method target or parameter.
&nbsp;                                 *
&nbsp;                                 * @param target     The declaring type of a non-static method or a parameter type.
&nbsp;                                 * @param annotation The annotation that was found on the method or parameter.
&nbsp;                                 * @return An appropriate offset mapping.
&nbsp;                                 */
&nbsp;                                protected abstract OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;S&gt; annotation);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for an offset mapping that does not support binding a method target.
&nbsp;                             *
&nbsp;                             * @param &lt;S&gt; The type of the represented annotation.
&nbsp;                             */
<b class="nc">&nbsp;                            abstract class WithParameterSupportOnly&lt;S extends Annotation&gt; implements OffsetMapping.Factory&lt;S&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;S&gt; annotation) {
<b class="nc">&nbsp;                                    throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A simple factory for an offset mapping.
&nbsp;                             *
&nbsp;                             * @param &lt;S&gt; The type of the represented annotation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            class Simple&lt;S extends Annotation&gt; extends OffsetMapping.Factory.AbstractBase&lt;S&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type of the bound annotation.
&nbsp;                                 */
&nbsp;                                private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The offset mapping to return.
&nbsp;                                 */
&nbsp;                                private final OffsetMapping offsetMapping;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a simple factory for an offset mapping.
&nbsp;                                 *
&nbsp;                                 * @param annotationType The type of the bound annotation.
&nbsp;                                 * @param offsetMapping  The offset mapping to return.
&nbsp;                                 */
<b class="nc">&nbsp;                                public Simple(Class&lt;S&gt; annotationType, OffsetMapping offsetMapping) {</b>
<b class="nc">&nbsp;                                    this.annotationType = annotationType;</b>
<b class="nc">&nbsp;                                    this.offsetMapping = offsetMapping;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;S&gt; getAnnotationType() {
<b class="nc">&nbsp;                                    return annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;S&gt; annotation) {
<b class="nc">&nbsp;                                    return offsetMapping;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that resolves a given stack manipulation.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForStackManipulation implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The stack manipulation to apply.
&nbsp;                             */
&nbsp;                            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type of the value that is produced by the stack manipulation.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type of the parameter or method target that is bound by this mapping.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new offset mapping for a stack manipulation.
&nbsp;                             *
&nbsp;                             * @param stackManipulation The stack manipulation to apply.
&nbsp;                             * @param typeDescription   The type of the value that is produced by the stack manipulation.
&nbsp;                             * @param targetType        The type of the parameter or method target that is bound by this mapping.
&nbsp;                             */
<b class="fc">&nbsp;                            public ForStackManipulation(StackManipulation stackManipulation, TypeDescription.Generic typeDescription, TypeDescription.Generic targetType) {</b>
<b class="fc">&nbsp;                                this.targetType = targetType;</b>
<b class="fc">&nbsp;                                this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                                this.typeDescription = typeDescription;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Resolves an offset mapping that binds the provided annotation type to a given constant value.
&nbsp;                             *
&nbsp;                             * @param annotationType The annotation type to bind.
&nbsp;                             * @param value          The constant value being bound or {@code null}.
&nbsp;                             * @param &lt;S&gt;            The type of the annotation.
&nbsp;                             * @return An appropriate factory for an offset mapping.
&nbsp;                             */
&nbsp;                            public static &lt;S extends Annotation&gt; OffsetMapping.Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, @MaybeNull Object value) {
<b class="nc">&nbsp;                                return value == null</b>
<b class="nc">&nbsp;                                        ? new OffsetMapping.ForStackManipulation.OfDefaultValue&lt;S&gt;(annotationType)</b>
<b class="nc">&nbsp;                                        : new OffsetMapping.ForStackManipulation.Factory&lt;S&gt;(annotationType, ConstantValue.Simple.wrap(value));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForStackManipulation.Resolved(assigner, typing, stackManipulation, typeDescription, targetType);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved offset mapping for a stack manipulation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The assigner to use.
&nbsp;                                 */
&nbsp;                                private final Assigner assigner;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The typing to apply.
&nbsp;                                 */
&nbsp;                                private final Assigner.Typing typing;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The stack manipulation to apply.
&nbsp;                                 */
&nbsp;                                private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type of the value that is produced by the stack manipulation.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type of the parameter or method target that is bound by this mapping.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved offset mapping for a given stack manipulation.
&nbsp;                                 *
&nbsp;                                 * @param assigner          The assigner to use.
&nbsp;                                 * @param typing            The typing to apply.
&nbsp;                                 * @param stackManipulation The stack manipulation to apply.
&nbsp;                                 * @param typeDescription   The type of the value that is produced by the stack manipulation.
&nbsp;                                 * @param targetType        The type of the parameter or method target that is bound by this mapping.
&nbsp;                                 */
&nbsp;                                protected Resolved(Assigner assigner,
&nbsp;                                                   Assigner.Typing typing,
&nbsp;                                                   StackManipulation stackManipulation,
&nbsp;                                                   TypeDescription.Generic typeDescription,
<b class="fc">&nbsp;                                                   TypeDescription.Generic targetType) {</b>
<b class="fc">&nbsp;                                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                                    this.typing = typing;</b>
<b class="fc">&nbsp;                                    this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                                    this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                                    this.targetType = targetType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    StackManipulation assignment = assigner.assign(typeDescription, targetType, typing);</b>
<b class="fc">&nbsp;                                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot assign &quot; + typeDescription + &quot; to &quot; + targetType);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new StackManipulation.Compound(stackManipulation, assignment);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory that binds the default value of the annotated parameter, i.e. {@code null} for reference types
&nbsp;                             * or the specific version of {@code 0} for primitive types.
&nbsp;                             *
&nbsp;                             * @param &lt;T&gt; The type of the annotation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class OfDefaultValue&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The annotation type.
&nbsp;                                 */
&nbsp;                                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new factory for binding a default value.
&nbsp;                                 *
&nbsp;                                 * @param annotationType The annotation type.
&nbsp;                                 */
<b class="fc">&nbsp;                                public OfDefaultValue(Class&lt;T&gt; annotationType) {</b>
<b class="fc">&nbsp;                                    this.annotationType = annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="nc">&nbsp;                                    throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="fc">&nbsp;                                    return new ForStackManipulation(DefaultValue.of(target.getType()), target.getType(), target.getType());</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory that binds a given annotation property to the parameter.
&nbsp;                             *
&nbsp;                             * @param &lt;T&gt; The type of the annotation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class OfAnnotationProperty&lt;T extends Annotation&gt; extends OffsetMapping.Factory.WithParameterSupportOnly&lt;T&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The annotation type.
&nbsp;                                 */
&nbsp;                                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The annotation property to resolve.
&nbsp;                                 */
&nbsp;                                private final MethodDescription.InDefinedShape property;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a factory for assigning an annotation property to the annotated parameter.
&nbsp;                                 *
&nbsp;                                 * @param annotationType The annotation type.
&nbsp;                                 * @param property       The annotation property to resolve.
&nbsp;                                 */
<b class="nc">&nbsp;                                protected OfAnnotationProperty(Class&lt;T&gt; annotationType, MethodDescription.InDefinedShape property) {</b>
<b class="nc">&nbsp;                                    this.annotationType = annotationType;</b>
<b class="nc">&nbsp;                                    this.property = property;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Resolves an offset mapping factory where the provided property is assigned to any parameter that
&nbsp;                                 * is annotated with the given annotation.
&nbsp;                                 *
&nbsp;                                 * @param annotationType The annotation type.
&nbsp;                                 * @param property       The name of the property on the
&nbsp;                                 * @param &lt;S&gt;            The type of the annotation from which the property is read.
&nbsp;                                 * @return An appropriate factory for an offset mapping.
&nbsp;                                 */
&nbsp;                                public static &lt;S extends Annotation&gt; OffsetMapping.Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, String property) {
<b class="nc">&nbsp;                                    if (!annotationType.isAnnotation()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + annotationType);</b>
&nbsp;                                    }
&nbsp;                                    try {
<b class="nc">&nbsp;                                        return new ForStackManipulation.OfAnnotationProperty&lt;S&gt;(annotationType, new MethodDescription.ForLoadedMethod(annotationType.getMethod(property)));</b>
<b class="nc">&nbsp;                                    } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(&quot;Cannot find a property &quot; + property + &quot; on &quot; + annotationType, exception);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;T&gt; getAnnotationType() {
<b class="nc">&nbsp;                                    return annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="nc">&nbsp;                                    ConstantValue value = ConstantValue.Simple.wrapOrNull(annotation.getValue(property).resolve());</b>
<b class="nc">&nbsp;                                    if (value == null) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Not a constant value property: &quot; + property);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    return new ForStackManipulation(value.toStackManipulation(), value.getTypeDescription().asGenericType(), target.getType());</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Assigns a value to the annotated parameter that is deserialized from a given input.
&nbsp;                             *
&nbsp;                             * @param &lt;T&gt; The type of the annotation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class OfSerializedConstant&lt;T extends Annotation&gt; extends OffsetMapping.Factory.AbstractBase&lt;T&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The annotation type.
&nbsp;                                 */
&nbsp;                                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A stack manipulation that represents the deserialization.
&nbsp;                                 */
&nbsp;                                private final StackManipulation deserialization;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A description of the type that is returned as a result of the deserialization.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a factory that creates an offset mapping for a value that is deserialized.
&nbsp;                                 *
&nbsp;                                 * @param annotationType  The annotation type.
&nbsp;                                 * @param deserialization A stack manipulation that represents the deserialization.
&nbsp;                                 * @param typeDescription A description of the type that is returned as a result of the deserialization.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected OfSerializedConstant(Class&lt;T&gt; annotationType, StackManipulation deserialization, TypeDescription.Generic typeDescription) {</b>
<b class="fc">&nbsp;                                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                                    this.deserialization = deserialization;</b>
<b class="fc">&nbsp;                                    this.typeDescription = typeDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a factory for an offset mapping that deserializes a given value that is then assigned to the annotated parameter or used as a method target.
&nbsp;                                 *
&nbsp;                                 * @param type       The annotation type.
&nbsp;                                 * @param value      The serialized value.
&nbsp;                                 * @param targetType The type of the value that is deserialized.
&nbsp;                                 * @param &lt;S&gt;        The type of the annotation.
&nbsp;                                 * @param &lt;U&gt;        The type of the serialized value.
&nbsp;                                 * @return An appropriate factory for an offset mapping.
&nbsp;                                 */
&nbsp;                                public static &lt;S extends Annotation, U extends Serializable&gt; OffsetMapping.Factory&lt;S&gt; of(Class&lt;S&gt; type, U value, Class&lt;? super U&gt; targetType) {
<b class="fc">&nbsp;                                    if (!targetType.isInstance(value)) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(value + &quot; is no instance of &quot; + targetType);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new ForStackManipulation.OfSerializedConstant&lt;S&gt;(type, SerializedConstant.of(value), net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(targetType).asGenericType());</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="fc">&nbsp;                                    return new ForStackManipulation(deserialization, typeDescription, target);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory that invokes a method dynamically and assignes the result to the annotated parameter.
&nbsp;                             *
&nbsp;                             * @param &lt;T&gt; The type of the annotation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class OfDynamicInvocation&lt;T extends Annotation&gt; extends OffsetMapping.Factory.AbstractBase&lt;T&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The annotation type.
&nbsp;                                 */
&nbsp;                                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The bootstrap method to use.
&nbsp;                                 */
&nbsp;                                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The constants to provide to the bootstrap method.
&nbsp;                                 */
&nbsp;                                private final List&lt;? extends JavaConstant&gt; arguments;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a factory for an offset mapping that assigns the result of a dynamic method invocation.
&nbsp;                                 *
&nbsp;                                 * @param annotationType  The annotation type.
&nbsp;                                 * @param bootstrapMethod The bootstrap method to use.
&nbsp;                                 * @param arguments       The constants to provide to the bootstrap method.
&nbsp;                                 */
<b class="fc">&nbsp;                                public OfDynamicInvocation(Class&lt;T&gt; annotationType, MethodDescription.InDefinedShape bootstrapMethod, List&lt;? extends JavaConstant&gt; arguments) {</b>
<b class="fc">&nbsp;                                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                                    this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                                    this.arguments = arguments;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="fc">&nbsp;                                    if (!target.isInterface()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(target + &quot; is not an interface&quot;);</b>
<b class="fc">&nbsp;                                    } else if (!target.getInterfaces().isEmpty()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(target + &quot; must not extend other interfaces&quot;);</b>
<b class="fc">&nbsp;                                    } else if (!target.isPublic()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(target + &quot; is mot public&quot;);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    MethodList&lt;?&gt; methodCandidates = target.getDeclaredMethods().filter(isAbstract());</b>
<b class="fc">&nbsp;                                    if (methodCandidates.size() != 1) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(target + &quot; must declare exactly one abstract method&quot;);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new OffsetMapping.ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(),</b>
<b class="fc">&nbsp;                                            target.asErasure(),</b>
<b class="fc">&nbsp;                                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
&nbsp;                                            arguments), target, target);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory to produce an offset mapping based upon a stack manipulation..
&nbsp;                             *
&nbsp;                             * @param &lt;T&gt; The type of the annotation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class Factory&lt;T extends Annotation&gt; extends OffsetMapping.Factory.AbstractBase&lt;T&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The annotation type.
&nbsp;                                 */
&nbsp;                                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The stack manipulation that produces the assigned value.
&nbsp;                                 */
&nbsp;                                private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type of the value that is produced by the stack manipulation.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a factory for a given constant value.
&nbsp;                                 *
&nbsp;                                 * @param annotationType The value to assign to the parameter.
&nbsp;                                 * @param value          The value that is bound.
&nbsp;                                 */
&nbsp;                                public Factory(Class&lt;T&gt; annotationType, ConstantValue value) {
<b class="nc">&nbsp;                                    this(annotationType, value.toStackManipulation(), value.getTypeDescription().asGenericType());</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a factory for a given stack manipulation.
&nbsp;                                 *
&nbsp;                                 * @param annotationType    The value to assign to the parameter.
&nbsp;                                 * @param stackManipulation The stack manipulation that produces the assigned value.
&nbsp;                                 * @param typeDescription   The type of the value that is produced by the stack manipulation.
&nbsp;                                 */
<b class="nc">&nbsp;                                public Factory(Class&lt;T&gt; annotationType, StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {</b>
<b class="nc">&nbsp;                                    this.annotationType = annotationType;</b>
<b class="nc">&nbsp;                                    this.stackManipulation = stackManipulation;</b>
<b class="nc">&nbsp;                                    this.typeDescription = typeDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;T&gt; getAnnotationType() {
<b class="nc">&nbsp;                                    return annotationType;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="nc">&nbsp;                                    return new ForStackManipulation(stackManipulation, typeDescription, target);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that assigns an argument of either the instrumented
&nbsp;                         * method or the substituted expression.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForArgument implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * A description of the targeted type.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The index of the parameter.
&nbsp;                             */
&nbsp;                            private final int index;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The typing to use or {@code null} if the global typing setting should be applied.
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            private final Assigner.Typing typing;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The source providing the argument.
&nbsp;                             */
&nbsp;                            private final Source source;
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@code true} if {@code null} or a primitive {@code 0} should be assigned to the parameter
&nbsp;                             * if the provided index is not available.
&nbsp;                             */
&nbsp;                            private final boolean optional;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new offset mapping for an argument to either the substituted expression or the instrumented method.
&nbsp;                             *
&nbsp;                             * @param targetType A description of the targeted type.
&nbsp;                             * @param index      The index of the parameter.
&nbsp;                             * @param typing     The typing to use or {@code null} if the global typing setting should be applied.
&nbsp;                             * @param source     The source providing the argument.
&nbsp;                             * @param optional   {@code true} if {@code null} or a primitive {@code 0} should be assigned to the parameter
&nbsp;                             *                   if the provided index is not available.
&nbsp;                             */
<b class="fc">&nbsp;                            public ForArgument(TypeDescription.Generic targetType, int index, @MaybeNull Assigner.Typing typing, Source source, boolean optional) {</b>
<b class="fc">&nbsp;                                this.targetType = targetType;</b>
<b class="fc">&nbsp;                                this.index = index;</b>
<b class="fc">&nbsp;                                this.typing = typing;</b>
<b class="fc">&nbsp;                                this.source = source;</b>
<b class="fc">&nbsp;                                this.optional = optional;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForArgument.Resolved(targetType, index, this.typing == null ? typing : this.typing, source, optional, assigner, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating an offset mapping for a parameter value of either the instrumented
&nbsp;                             * method or the substituted element.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;Argument&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link Argument#value()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ARGUMENT_VALUE;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link Argument#typing()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ARGUMENT_TYPING;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link Argument#source()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ARGUMENT_SOURCE;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link Argument#optional()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ARGUMENT_OPTIONAL;
&nbsp;
&nbsp;                                /*
&nbsp;                                 * Resolves all annotation properties.
&nbsp;                                 */
&nbsp;                                static {
<b class="fc">&nbsp;                                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(Argument.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                    ARGUMENT_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ARGUMENT_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ARGUMENT_SOURCE = methods.filter(named(&quot;source&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ARGUMENT_OPTIONAL = methods.filter(named(&quot;optional&quot;)).getOnly();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;Argument&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return Argument.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Argument&gt; annotation) {
<b class="nc">&nbsp;                                    return new ForArgument(target.getDeclaringType().asGenericType(),</b>
<b class="nc">&nbsp;                                            annotation.getValue(ARGUMENT_VALUE).resolve(Integer.class),</b>
<b class="nc">&nbsp;                                            annotation.getValue(ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="nc">&nbsp;                                            annotation.getValue(ARGUMENT_SOURCE).resolve(EnumerationDescription.class).load(Source.class),</b>
<b class="nc">&nbsp;                                            annotation.getValue(ARGUMENT_OPTIONAL).resolve(Boolean.class));</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Argument&gt; annotation) {
<b class="fc">&nbsp;                                    int index = annotation.getValue(ARGUMENT_VALUE).resolve(Integer.class);</b>
<b class="fc">&nbsp;                                    if (index &lt; 0) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot assign negative parameter index &quot; + index + &quot; for &quot; + target);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new ForArgument(target.getType(),</b>
&nbsp;                                            index,
<b class="fc">&nbsp;                                            annotation.getValue(ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ARGUMENT_SOURCE).resolve(EnumerationDescription.class).load(Source.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ARGUMENT_OPTIONAL).resolve(Boolean.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved offset mapping to the parameter of either the instrumented method or
&nbsp;                             * the substituted element.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The targeted type.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The index of the parameter.
&nbsp;                                 */
&nbsp;                                private final int index;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The typing to use when assigning.
&nbsp;                                 */
&nbsp;                                private final Assigner.Typing typing;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the argument.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@code true} if {@code null} or a primitive {@code 0} should be assigned to the parameter
&nbsp;                                 * if the provided index is not available.
&nbsp;                                 */
&nbsp;                                private final boolean optional;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The assigner to use.
&nbsp;                                 */
&nbsp;                                private final Assigner assigner;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved offset mapping for assigning a parameter.
&nbsp;                                 *
&nbsp;                                 * @param targetType         The targeted type.
&nbsp;                                 * @param index              The index of the parameter.
&nbsp;                                 * @param typing             The typing to use when assigning.
&nbsp;                                 * @param source             The source providing the argument.
&nbsp;                                 * @param optional           {@code true} if {@code null} or a primitive {@code 0} should be assigned
&nbsp;                                 *                           to the parameter if the provided index is not available.
&nbsp;                                 * @param assigner           The assigner to use.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
&nbsp;                                protected Resolved(TypeDescription.Generic targetType,
&nbsp;                                                   int index,
&nbsp;                                                   Assigner.Typing typing,
&nbsp;                                                   Source source,
&nbsp;                                                   boolean optional,
&nbsp;                                                   Assigner assigner,
<b class="fc">&nbsp;                                                   MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.targetType = targetType;</b>
<b class="fc">&nbsp;                                    this.index = index;</b>
<b class="fc">&nbsp;                                    this.typing = typing;</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.optional = optional;</b>
<b class="fc">&nbsp;                                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    Source.Value value = source.argument(index, parameters, offsets, original, instrumentedMethod);</b>
<b class="fc">&nbsp;                                    if (value != null) {</b>
<b class="fc">&nbsp;                                        StackManipulation assignment = assigner.assign(value.getTypeDescription(), targetType, typing);</b>
<b class="fc">&nbsp;                                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Cannot assign &quot; + value.getTypeDescription() + &quot; to &quot; + targetType);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        return new StackManipulation.Compound(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()), assignment);</b>
<b class="fc">&nbsp;                                    } else if (optional) {</b>
<b class="fc">&nbsp;                                        return DefaultValue.of(targetType);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;No argument with index &quot; + index + &quot; available for &quot; + original);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that assigns the {@code this} reference.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForThisReference implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The targeted type.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The typing to use or {@code null} if implicit typing.
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            private final Assigner.Typing typing;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The source providing the reference.
&nbsp;                             */
&nbsp;                            private final Source source;
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@code true} if {@code null} or a primitive {@code 0} should be assigned to the parameter
&nbsp;                             * if no {@code this} reference is available.
&nbsp;                             */
&nbsp;                            private final boolean optional;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping that resolves the {@code this} reference.
&nbsp;                             *
&nbsp;                             * @param targetType The targeted type.
&nbsp;                             * @param typing     The typing to use or {@code null} if implicit typing.
&nbsp;                             * @param source     The source providing the reference.
&nbsp;                             * @param optional   {@code true} if {@code null} or a primitive {@code 0} should be assigned
&nbsp;                             *                   to the parameter if no {@code this} reference is available.
&nbsp;                             */
<b class="fc">&nbsp;                            public ForThisReference(TypeDescription.Generic targetType, @MaybeNull Assigner.Typing typing, Source source, boolean optional) {</b>
<b class="fc">&nbsp;                                this.targetType = targetType;</b>
<b class="fc">&nbsp;                                this.typing = typing;</b>
<b class="fc">&nbsp;                                this.source = source;</b>
<b class="fc">&nbsp;                                this.optional = optional;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public ForThisReference.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForThisReference.Resolved(targetType, this.typing == null ? typing : this.typing, source, optional, assigner, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved offset mapping for resolving the {@code this} reference.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The targeted type.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The typing to use..
&nbsp;                                 */
&nbsp;                                private final Assigner.Typing typing;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the reference.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@code true} if {@code null} or a primitive {@code 0} should be assigned to the parameter
&nbsp;                                 * if no {@code this} reference is available.
&nbsp;                                 */
&nbsp;                                private final boolean optional;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The assigner to use.
&nbsp;                                 */
&nbsp;                                private final Assigner assigner;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved offset mapping for assigning the {@code this} reference.
&nbsp;                                 *
&nbsp;                                 * @param targetType         The targeted type.
&nbsp;                                 * @param typing             The typing to use.
&nbsp;                                 * @param source             The source providing the reference.
&nbsp;                                 * @param optional           {@code true} if {@code null} or a primitive {@code 0} should be assigned
&nbsp;                                 *                           to the parameter if no {@code this} reference is available.
&nbsp;                                 * @param assigner           The assigner to use.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
&nbsp;                                protected Resolved(TypeDescription.Generic targetType,
&nbsp;                                                   Assigner.Typing typing,
&nbsp;                                                   Source source,
&nbsp;                                                   boolean optional,
&nbsp;                                                   Assigner assigner,
<b class="fc">&nbsp;                                                   MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.targetType = targetType;</b>
<b class="fc">&nbsp;                                    this.typing = typing;</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.optional = optional;</b>
<b class="fc">&nbsp;                                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    Source.Value value = source.self(parameters, offsets, original, instrumentedMethod);</b>
<b class="fc">&nbsp;                                    if (value != null) {</b>
<b class="fc">&nbsp;                                        StackManipulation assignment = assigner.assign(value.getTypeDescription(), targetType, typing);</b>
<b class="fc">&nbsp;                                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Cannot assign &quot; + value.getTypeDescription() + &quot; to &quot; + targetType);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        return new StackManipulation.Compound(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()), assignment);</b>
<b class="fc">&nbsp;                                    } else if (optional) {</b>
<b class="fc">&nbsp;                                        return DefaultValue.of(targetType);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;No this reference available for &quot; + original);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating an offset mapping for binding a {@link This} reference.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;This&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link This#typing()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape THIS_TYPING;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link This#source()} reference.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape THIS_SOURCE;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link This#optional()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape THIS_OPTIONAL;
&nbsp;
&nbsp;                                /*
&nbsp;                                 * Resolves the annotation properties.
&nbsp;                                 */
&nbsp;                                static {
<b class="fc">&nbsp;                                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = net.bytebuddy.description.type.TypeDescription.ForLoadedType.of(This.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                    THIS_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    THIS_SOURCE = methods.filter(named(&quot;source&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    THIS_OPTIONAL = methods.filter(named(&quot;optional&quot;)).getOnly();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;This&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return This.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;This&gt; annotation) {
<b class="nc">&nbsp;                                    return new ForThisReference(target.getDeclaringType().asGenericType(),</b>
<b class="nc">&nbsp;                                            annotation.getValue(THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="nc">&nbsp;                                            annotation.getValue(THIS_SOURCE).resolve(EnumerationDescription.class).load(Source.class),</b>
<b class="nc">&nbsp;                                            annotation.getValue(THIS_OPTIONAL).resolve(Boolean.class));</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;This&gt; annotation) {
<b class="fc">&nbsp;                                    return new ForThisReference(target.getType(),</b>
<b class="fc">&nbsp;                                            annotation.getValue(THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(THIS_SOURCE).resolve(EnumerationDescription.class).load(Source.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(THIS_OPTIONAL).resolve(Boolean.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that assigns an array containing all arguments to the annotated parameter.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForAllArguments implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The component type of the annotated parameter.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic targetComponentType;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The typing to use or {@code null} if implicit typing.
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            private final Assigner.Typing typing;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The source providing the reference.
&nbsp;                             */
&nbsp;                            private final Source source;
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@code true} if the {@code this} reference should be included in the created array, if available.
&nbsp;                             */
&nbsp;                            private final boolean includeSelf;
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@code true} if {@code null} should be assigned to the parameter if no arguments are available.
&nbsp;                             */
&nbsp;                            private final boolean nullIfEmpty;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new offset mapping for an array containing all supplied arguments.
&nbsp;                             *
&nbsp;                             * @param targetComponentType The component type of the annotated parameter.
&nbsp;                             * @param typing              The typing to use or {@code null} if implicit typing.
&nbsp;                             * @param source              The source providing the reference.
&nbsp;                             * @param includeSelf         {@code true} if the {@code this} reference should be included in the created array, if available.
&nbsp;                             * @param nullIfEmpty         {@code true} if {@code null} should be assigned to the parameter if no arguments are available.
&nbsp;                             */
<b class="fc">&nbsp;                            public ForAllArguments(TypeDescription.Generic targetComponentType, @MaybeNull Assigner.Typing typing, Source source, boolean includeSelf, boolean nullIfEmpty) {</b>
<b class="fc">&nbsp;                                this.targetComponentType = targetComponentType;</b>
<b class="fc">&nbsp;                                this.typing = typing;</b>
<b class="fc">&nbsp;                                this.source = source;</b>
<b class="fc">&nbsp;                                this.includeSelf = includeSelf;</b>
<b class="fc">&nbsp;                                this.nullIfEmpty = nullIfEmpty;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForAllArguments.Resolved(targetComponentType, this.typing == null ? typing : this.typing, source, includeSelf, nullIfEmpty, assigner, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating an offset mapping containing all supplies arguments.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;AllArguments&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link AllArguments#typing()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_TYPING;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link AllArguments#source()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_SOURCE;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link AllArguments#includeSelf()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_INCLUDE_SELF;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link AllArguments#nullIfEmpty()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_NULL_IF_EMPTY;
&nbsp;
&nbsp;                                /*
&nbsp;                                 * Resolves all annotation properties.
&nbsp;                                 */
&nbsp;                                static {
<b class="fc">&nbsp;                                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(AllArguments.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                    ALL_ARGUMENTS_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ALL_ARGUMENTS_SOURCE = methods.filter(named(&quot;source&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ALL_ARGUMENTS_INCLUDE_SELF = methods.filter(named(&quot;includeSelf&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ALL_ARGUMENTS_NULL_IF_EMPTY = methods.filter(named(&quot;nullIfEmpty&quot;)).getOnly();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;AllArguments&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return AllArguments.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;AllArguments&gt; annotation) {
<b class="nc">&nbsp;                                    throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;AllArguments&gt; annotation) {
<b class="fc">&nbsp;                                    if (!target.getType().isArray()) {</b>
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;Expected array as parameter type for &quot; + target);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new ForAllArguments(target.getType().getComponentType(),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ALL_ARGUMENTS_SOURCE).resolve(EnumerationDescription.class).load(Source.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ALL_ARGUMENTS_INCLUDE_SELF).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ALL_ARGUMENTS_NULL_IF_EMPTY).resolve(Boolean.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolves offset mapping for an array containing all arguments.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The component type of the annotated parameter.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic targetComponentType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The typing to use.
&nbsp;                                 */
&nbsp;                                private final Assigner.Typing typing;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the reference.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@code true} if the {@code this} reference should be included in the created array, if available.
&nbsp;                                 */
&nbsp;                                private final boolean includeSelf;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@code true} if {@code null} should be assigned to the parameter if no arguments are available.
&nbsp;                                 */
&nbsp;                                private final boolean nullIfEmpty;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The assigner to use.
&nbsp;                                 */
&nbsp;                                private final Assigner assigner;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved version for an offset mapping of all arguments.
&nbsp;                                 *
&nbsp;                                 * @param targetComponentType The component type of the annotated parameter.
&nbsp;                                 * @param typing              The typing to use.
&nbsp;                                 * @param source              The source providing the reference.
&nbsp;                                 * @param includeSelf         {@code true} if the {@code this} reference should be included in the created array, if available.
&nbsp;                                 * @param nullIfEmpty         {@code true} if {@code null} should be assigned to the parameter if no arguments are available.
&nbsp;                                 * @param assigner            The assigner to use.
&nbsp;                                 * @param instrumentedMethod  The instrumented method.
&nbsp;                                 */
&nbsp;                                protected Resolved(TypeDescription.Generic targetComponentType,
&nbsp;                                                   Assigner.Typing typing,
&nbsp;                                                   Source source,
&nbsp;                                                   boolean includeSelf,
&nbsp;                                                   boolean nullIfEmpty,
&nbsp;                                                   Assigner assigner,
<b class="fc">&nbsp;                                                   MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.targetComponentType = targetComponentType;</b>
<b class="fc">&nbsp;                                    this.typing = typing;</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.includeSelf = includeSelf;</b>
<b class="fc">&nbsp;                                    this.nullIfEmpty = nullIfEmpty;</b>
<b class="fc">&nbsp;                                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    List&lt;Source.Value&gt; values = source.arguments(includeSelf, parameters, offsets, original, instrumentedMethod);</b>
<b class="fc">&nbsp;                                    if (nullIfEmpty &amp;&amp; values.isEmpty()) {</b>
<b class="fc">&nbsp;                                        return NullConstant.INSTANCE;</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;();</b>
<b class="fc">&nbsp;                                        for (Source.Value value : values) {</b>
<b class="fc">&nbsp;                                            StackManipulation assignment = assigner.assign(value.getTypeDescription(), targetComponentType, typing);</b>
<b class="fc">&nbsp;                                            if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                                throw new IllegalStateException(&quot;Cannot assign &quot; + value.getTypeDescription() + &quot; to &quot; + targetComponentType);</b>
&nbsp;                                            }
<b class="fc">&nbsp;                                            stackManipulations.add(new StackManipulation.Compound(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()), assignment));</b>
<b class="fc">&nbsp;                                        }</b>
<b class="fc">&nbsp;                                        return ArrayFactory.forType(targetComponentType).withValues(stackManipulations);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping resolving a method handle to invoke the original expression or the instrumented method.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForSelfCallHandle implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The source providing the reference.
&nbsp;                             */
&nbsp;                            private final Source source;
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@code true} if the handle should be bound to the original arguments.
&nbsp;                             */
&nbsp;                            private final boolean bound;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a new offset mapping for a self call handle.
&nbsp;                             *
&nbsp;                             * @param source The source providing the reference.
&nbsp;                             * @param bound  {@code true} if the handle should be bound to the original arguments.
&nbsp;                             */
<b class="fc">&nbsp;                            public ForSelfCallHandle(Source source, boolean bound) {</b>
<b class="fc">&nbsp;                                this.source = source;</b>
<b class="fc">&nbsp;                                this.bound = bound;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return bound ? new ForSelfCallHandle.Bound(source, instrumentedMethod) : new ForSelfCallHandle.Unbound(source, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating an offset mapping for binding a self call handle.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;SelfCallHandle&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link SelfCallHandle#source()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_SOURCE;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link SelfCallHandle#bound()} property.
&nbsp;                                 */
&nbsp;                                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_BOUND;
&nbsp;
&nbsp;                                /*
&nbsp;                                 * Resolves all annotation properties.
&nbsp;                                 */
&nbsp;                                static {
<b class="fc">&nbsp;                                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(SelfCallHandle.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                    ALL_ARGUMENTS_SOURCE = methods.filter(named(&quot;source&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                    ALL_ARGUMENTS_BOUND = methods.filter(named(&quot;bound&quot;)).getOnly();</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;SelfCallHandle&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return SelfCallHandle.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;SelfCallHandle&gt; annotation) {
<b class="nc">&nbsp;                                    throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;SelfCallHandle&gt; annotation) {
<b class="fc">&nbsp;                                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new ForSelfCallHandle(</b>
<b class="fc">&nbsp;                                            annotation.getValue(ALL_ARGUMENTS_SOURCE).resolve(EnumerationDescription.class).load(Source.class),</b>
<b class="fc">&nbsp;                                            annotation.getValue(ALL_ARGUMENTS_BOUND).resolve(Boolean.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Resolves a bound self call handle for an offset mapping.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Bound implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the reference.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates an offset mapping for a bound version of a self call handle.
&nbsp;                                 *
&nbsp;                                 * @param source             The source providing the reference.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Bound(Source source, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    Source.Value dispatched = source.self(parameters, offsets, original, instrumentedMethod);</b>
<b class="fc">&nbsp;                                    List&lt;Source.Value&gt; values = source.arguments(false, parameters, offsets, original, instrumentedMethod);</b>
<b class="fc">&nbsp;                                    List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(1 + (values.size()</b>
<b class="fc">&nbsp;                                            + (dispatched == null ? 0 : 2))</b>
<b class="fc">&nbsp;                                            + (values.isEmpty() ? 0 : 1));</b>
<b class="fc">&nbsp;                                    stackManipulations.add(source.handle(methodHandle, instrumentedMethod).toStackManipulation());</b>
<b class="fc">&nbsp;                                    if (dispatched != null) {</b>
<b class="fc">&nbsp;                                        stackManipulations.add(MethodVariableAccess.of(dispatched.getTypeDescription()).loadFrom(dispatched.getOffset()));</b>
<b class="fc">&nbsp;                                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token(&quot;bindTo&quot;,</b>
&nbsp;                                                Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                                JavaType.METHOD_HANDLE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                                new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class))))));</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    if (!values.isEmpty()) {</b>
<b class="nc">&nbsp;                                        for (Source.Value value : values) {</b>
<b class="nc">&nbsp;                                            stackManipulations.add(MethodVariableAccess.of(value.getTypeDescription()).loadFrom(value.getOffset()));</b>
<b class="nc">&nbsp;                                        }</b>
<b class="nc">&nbsp;                                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLES.getTypeStub(), new MethodDescription.Token(&quot;insertArguments&quot;,</b>
&nbsp;                                                Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
<b class="nc">&nbsp;                                                JavaType.METHOD_HANDLE.getTypeStub().asGenericType(),</b>
<b class="nc">&nbsp;                                                new TypeList.Generic.Explicit(JavaType.METHOD_HANDLE.getTypeStub(), TypeDefinition.Sort.describe(int.class), TypeDefinition.Sort.describe(Object[].class))))));</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new StackManipulation.Compound(stackManipulations);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Resolves an unbound self call handle for an offset mapping.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Unbound implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the reference.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates an offset mapping for an unbound version of a self call handle.
&nbsp;                                 *
&nbsp;                                 * @param source             The source providing the reference.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Unbound(Source source, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    return source.handle(methodHandle, instrumentedMethod).toStackManipulation();</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping for a field value.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                        abstract class ForField implements OffsetMapping {</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * The {@link FieldValue#value()} property.
&nbsp;                             */
&nbsp;                            private static final MethodDescription.InDefinedShape FIELD_VALUE_VALUE;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The {@link FieldValue#declaringType()} property.
&nbsp;                             */
&nbsp;                            private static final MethodDescription.InDefinedShape FIELD_VALUE_DECLARING_TYPE;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The {@link FieldValue#typing()} property.
&nbsp;                             */
&nbsp;                            private static final MethodDescription.InDefinedShape FIELD_VALUE_TYPING;
&nbsp;
&nbsp;                            /*
&nbsp;                             * Resolves all annotation properties.
&nbsp;                             */
&nbsp;                            static {
<b class="fc">&nbsp;                                MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(FieldValue.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                FIELD_VALUE_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                FIELD_VALUE_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                FIELD_VALUE_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A description of the targeted type.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic target;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The typing to use or {@code null} if implicit typing.
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            private final Assigner.Typing typing;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping for a field value.
&nbsp;                             *
&nbsp;                             * @param target A description of the targeted type.
&nbsp;                             * @param typing The typing to use or {@code null} if implicit typing.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForField(TypeDescription.Generic target, @MaybeNull Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                                this.target = target;</b>
<b class="fc">&nbsp;                                this.typing = typing;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Cannot access non-static field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                StackManipulation assignment = assigner.assign(fieldDescription.getType(), target, this.typing == null ? typing : this.typing);</b>
<b class="fc">&nbsp;                                if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription + &quot; to &quot; + target);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                return new OffsetMapping.Resolved.ForStackManipulation(new StackManipulation.Compound(fieldDescription.isStatic()</b>
<b class="nc">&nbsp;                                        ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                                        : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), assignment));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Resolves a description of the field being accessed.
&nbsp;                             *
&nbsp;                             * @param instrumentedType   The instrumented type.
&nbsp;                             * @param instrumentedMethod The instrumented method.
&nbsp;                             * @return A description of the field being accessed.
&nbsp;                             */
&nbsp;                            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;                            /**
&nbsp;                             * An offset mapping for an unresolved field value.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public abstract static class Unresolved extends ForField {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Indicates that the name of the field should be inferred from the instrumented method&#39;s name as a bean property.
&nbsp;                                 */
&nbsp;                                protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The name of the field being accessed or an empty string if the name of the field should be inferred.
&nbsp;                                 */
&nbsp;                                private final String name;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates an offset mapping for the value of an unresolved field.
&nbsp;                                 *
&nbsp;                                 * @param target A description of the targeted type.
&nbsp;                                 * @param typing The typing to use.
&nbsp;                                 * @param name   The name of the field being accessed or an empty string if the name of the field should be inferred.
&nbsp;                                 */
&nbsp;                                protected Unresolved(TypeDescription.Generic target, Assigner.Typing typing, String name) {
<b class="fc">&nbsp;                                    super(target, typing);</b>
<b class="fc">&nbsp;                                    this.name = name;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                    FieldLocator locator = fieldLocator(instrumentedType);</b>
<b class="fc">&nbsp;                                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY)</b>
<b class="fc">&nbsp;                                            ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod)</b>
<b class="fc">&nbsp;                                            : locator.locate(name);</b>
<b class="fc">&nbsp;                                    if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot locate field named &quot; + name + &quot; for &quot; + instrumentedType);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        return resolution.getField();</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a field locator for the instrumented type.
&nbsp;                                 *
&nbsp;                                 * @param instrumentedType The instrumented type.
&nbsp;                                 * @return An appropriate field locator.
&nbsp;                                 */
&nbsp;                                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
&nbsp;
&nbsp;                                /**
&nbsp;                                 * An offset mapping for an unresolved field with an implicit declaring type.
&nbsp;                                 */
&nbsp;                                public static class WithImplicitType extends Unresolved {
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates an offset mapping for an unresolved field value with an implicit declaring type.
&nbsp;                                     *
&nbsp;                                     * @param target     A description of the targeted type.
&nbsp;                                     * @param annotation The annotation describing the access.
&nbsp;                                     */
&nbsp;                                    protected WithImplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation) {
<b class="fc">&nbsp;                                        this(target,</b>
<b class="fc">&nbsp;                                                annotation.getValue(FIELD_VALUE_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                                annotation.getValue(FIELD_VALUE_VALUE).resolve(String.class));</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates an offset mapping for the value of an unresolved field with an implicit declaring type.
&nbsp;                                     *
&nbsp;                                     * @param target A description of the targeted type.
&nbsp;                                     * @param typing The typing to use.
&nbsp;                                     * @param name   The name of the field being accessed or an empty string if the name of the field should be inferred.
&nbsp;                                     */
&nbsp;                                    public WithImplicitType(TypeDescription.Generic target, Assigner.Typing typing, String name) {
<b class="fc">&nbsp;                                        super(target, typing, name);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                                        return new FieldLocator.ForClassHierarchy(instrumentedType);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * An offset mapping for an unresolved field value with an explicit declaring type.
&nbsp;                                 */
&nbsp;                                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                                public static class WithExplicitType extends Unresolved {
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The field&#39;s declaring type.
&nbsp;                                     */
&nbsp;                                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates an offset mapping for the value of an unresolved field with an explicit declaring type.
&nbsp;                                     *
&nbsp;                                     * @param target        A description of the targeted type.
&nbsp;                                     * @param annotation    The annotation describing the field access.
&nbsp;                                     * @param declaringType The field&#39;s declaring type.
&nbsp;                                     */
&nbsp;                                    protected WithExplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation, TypeDescription declaringType) {
<b class="fc">&nbsp;                                        this(target,</b>
<b class="fc">&nbsp;                                                annotation.getValue(FIELD_VALUE_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                                annotation.getValue(FIELD_VALUE_VALUE).resolve(String.class),</b>
&nbsp;                                                declaringType);
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates an offset mapping for the value of an unresolved field with an explicit declaring type.
&nbsp;                                     *
&nbsp;                                     * @param target        A description of the targeted type.
&nbsp;                                     * @param typing        The typing to use.
&nbsp;                                     * @param name          The name of the field being accessed or an empty string if the name of the field should be inferred.
&nbsp;                                     * @param declaringType The field&#39;s declaring type.
&nbsp;                                     */
&nbsp;                                    public WithExplicitType(TypeDescription.Generic target, Assigner.Typing typing, String name, TypeDescription declaringType) {
<b class="fc">&nbsp;                                        super(target, typing, name);</b>
<b class="fc">&nbsp;                                        this.declaringType = declaringType;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                                        if (!declaringType.represents(TargetType.class) &amp;&amp; !instrumentedType.isAssignableTo(declaringType)) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(declaringType + &quot; is no super type of &quot; + instrumentedType);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A factory for creating an offset mapping for a field value.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected enum Factory implements OffsetMapping.Factory&lt;FieldValue&gt; {</b>
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The singleton instance.
&nbsp;                                     */
<b class="fc">&nbsp;                                    INSTANCE;</b>
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public Class&lt;FieldValue&gt; getAnnotationType() {
<b class="fc">&nbsp;                                        return FieldValue.class;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation) {
<b class="nc">&nbsp;                                        TypeDescription declaringType = annotation.getValue(FIELD_VALUE_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="nc">&nbsp;                                        return declaringType.represents(void.class)</b>
<b class="nc">&nbsp;                                                ? new Unresolved.WithImplicitType(target.getDeclaringType().asGenericType(), annotation)</b>
<b class="nc">&nbsp;                                                : new Unresolved.WithExplicitType(target.getDeclaringType().asGenericType(), annotation, declaringType);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation) {
<b class="fc">&nbsp;                                        TypeDescription declaringType = annotation.getValue(FIELD_VALUE_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                                        return declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                                                ? new Unresolved.WithImplicitType(target.getType(), annotation)</b>
<b class="fc">&nbsp;                                                : new Unresolved.WithExplicitType(target.getType(), annotation, declaringType);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An offset mapping for a resolved field access.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class Resolved extends ForField {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A description of the field being accessed.
&nbsp;                                 */
&nbsp;                                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved offset mapping for a field access.
&nbsp;                                 *
&nbsp;                                 * @param target           A description of the targeted type.
&nbsp;                                 * @param typing           The typing to use or {@code null} if implicit typing.
&nbsp;                                 * @param fieldDescription A description of the field accessed.
&nbsp;                                 */
&nbsp;                                public Resolved(TypeDescription.Generic target, Assigner.Typing typing, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                                    super(target, typing);</b>
<b class="fc">&nbsp;                                    this.fieldDescription = fieldDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                    if (!fieldDescription.isStatic() &amp;&amp; !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(fieldDescription + &quot; is no member of &quot; + instrumentedType);</b>
<b class="fc">&nbsp;                                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return fieldDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A factory for creating a resolved offset mapping of a field value.
&nbsp;                                 *
&nbsp;                                 * @param &lt;T&gt; The type of the annotation.
&nbsp;                                 */
&nbsp;                                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                                public static class Factory&lt;T extends Annotation&gt; extends OffsetMapping.Factory.AbstractBase&lt;T&gt; {
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The annotation type.
&nbsp;                                     */
&nbsp;                                    private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The field being accessed.
&nbsp;                                     */
&nbsp;                                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The typing to use.
&nbsp;                                     */
&nbsp;                                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates a factory for reading a given field.
&nbsp;                                     *
&nbsp;                                     * @param annotationType   The annotation type.
&nbsp;                                     * @param fieldDescription The field being accessed.
&nbsp;                                     */
&nbsp;                                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                                        this(annotationType, fieldDescription, Assigner.Typing.STATIC);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates a factory for reading a given field.
&nbsp;                                     *
&nbsp;                                     * @param annotationType   The annotation type.
&nbsp;                                     * @param fieldDescription The field being accessed.
&nbsp;                                     * @param typing           The typing to use.
&nbsp;                                     */
<b class="fc">&nbsp;                                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                                        this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                                        this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                                        this.typing = typing;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                                        return annotationType;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected OffsetMapping make(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="fc">&nbsp;                                        return new ForField.Resolved(target, typing, fieldDescription);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping for a method handle representing a field getter or setter.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        abstract class ForFieldHandle implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type of access to the field.
&nbsp;                             */
&nbsp;                            private final Access access;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping for a field getter or setter.
&nbsp;                             *
&nbsp;                             * @param access The type of access to the field.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForFieldHandle(Access access) {</b>
<b class="fc">&nbsp;                                this.access = access;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Cannot access non-static field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                if (fieldDescription.isStatic()) {</b>
<b class="nc">&nbsp;                                    return new OffsetMapping.Resolved.ForStackManipulation(access.resolve(fieldDescription.asDefined()).toStackManipulation());</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    return new OffsetMapping.Resolved.ForStackManipulation(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                            access.resolve(fieldDescription.asDefined()).toStackManipulation(), MethodVariableAccess.REFERENCE.loadFrom(THIS_REFERENCE),</b>
<b class="fc">&nbsp;                                            MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token(&quot;bindTo&quot;,</b>
&nbsp;                                                    Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                                    JavaType.METHOD_HANDLE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                                    new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class)))))));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Resolves a description of the field being accessed.
&nbsp;                             *
&nbsp;                             * @param instrumentedType   The instrumented type.
&nbsp;                             * @param instrumentedMethod The instrumented method.
&nbsp;                             * @return A description of the field being accessed.
&nbsp;                             */
&nbsp;                            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type of access to the field.
&nbsp;                             */
<b class="fc">&nbsp;                            public enum Access {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Describes a field getter.
&nbsp;                                 */
<b class="fc">&nbsp;                                GETTER {</b>
&nbsp;                                    @Override
&nbsp;                                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
<b class="fc">&nbsp;                                        return JavaConstant.MethodHandle.ofGetter(fieldDescription);</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Describes a field setter.
&nbsp;                                 */
<b class="fc">&nbsp;                                SETTER {</b>
&nbsp;                                    @Override
&nbsp;                                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
<b class="fc">&nbsp;                                        return JavaConstant.MethodHandle.ofSetter(fieldDescription);</b>
&nbsp;                                    }
&nbsp;                                };
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Resolves a handle for the represented field access.
&nbsp;                                 *
&nbsp;                                 * @param fieldDescription The field that is being accessed.
&nbsp;                                 * @return An appropriate method handle.
&nbsp;                                 */
&nbsp;                                protected abstract JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An offset mapping for an unresolved field handle.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public abstract static class Unresolved extends ForFieldHandle {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Indicates that the field&#39;s name should be resolved as a bean property.
&nbsp;                                 */
&nbsp;                                protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The name of the field or an empty string if the name should be resolved from the instrumented method.
&nbsp;                                 */
&nbsp;                                private final String name;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates an offset mapping for an unresolved field handle.
&nbsp;                                 *
&nbsp;                                 * @param access The type of access to the field.
&nbsp;                                 * @param name   The name of the field or an empty string if the name should be resolved from the instrumented method.
&nbsp;                                 */
&nbsp;                                public Unresolved(Access access, String name) {
<b class="fc">&nbsp;                                    super(access);</b>
<b class="fc">&nbsp;                                    this.name = name;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                    FieldLocator locator = fieldLocator(instrumentedType);</b>
<b class="fc">&nbsp;                                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY)</b>
<b class="fc">&nbsp;                                            ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod)</b>
<b class="fc">&nbsp;                                            : locator.locate(name);</b>
<b class="fc">&nbsp;                                    if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot locate field named &quot; + name + &quot; for &quot; + instrumentedType);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        return resolution.getField();</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Resolves a field locator for the instrumented type.
&nbsp;                                 *
&nbsp;                                 * @param instrumentedType The instrumented type.
&nbsp;                                 * @return Returns an appropriate field locator.
&nbsp;                                 */
&nbsp;                                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
&nbsp;
&nbsp;                                /**
&nbsp;                                 * An offset mapping for an unresolved field handle with an implicit declaring type.
&nbsp;                                 */
&nbsp;                                public static class WithImplicitType extends Unresolved {
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates an offset mapping for an unresolved field handle with an implicit declaring type.
&nbsp;                                     *
&nbsp;                                     * @param access The type of access to the field.
&nbsp;                                     * @param name   The name of the field or an empty string if the name should be resolved from the instrumented method.
&nbsp;                                     */
&nbsp;                                    public WithImplicitType(Access access, String name) {
<b class="fc">&nbsp;                                        super(access, name);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                                        return new FieldLocator.ForClassHierarchy(instrumentedType);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * An offset mapping for an unresolved field handle with an explicit declaring type.
&nbsp;                                 */
&nbsp;                                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                                public static class WithExplicitType extends Unresolved {
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The field&#39;s declaring type.
&nbsp;                                     */
&nbsp;                                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates an offset mapping for an unresolved field handle with an explicit declaring type.
&nbsp;                                     *
&nbsp;                                     * @param access        The type of access to the field.
&nbsp;                                     * @param name          The name of the field or an empty string if the name should be resolved from the instrumented method.
&nbsp;                                     * @param declaringType The field&#39;s declaring type.
&nbsp;                                     */
&nbsp;                                    public WithExplicitType(Access access, String name, TypeDescription declaringType) {
<b class="fc">&nbsp;                                        super(access, name);</b>
<b class="fc">&nbsp;                                        this.declaringType = declaringType;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                                        if (!declaringType.represents(TargetType.class) &amp;&amp; !instrumentedType.isAssignableTo(declaringType)) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(declaringType + &quot; is no super type of &quot; + instrumentedType);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A factory for creating a method handle representing a getter for the targeted field.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected enum GetterFactory implements OffsetMapping.Factory&lt;FieldGetterHandle&gt; {</b>
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The singleton instance.
&nbsp;                                     */
<b class="fc">&nbsp;                                    INSTANCE;</b>
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The {@link FieldGetterHandle#value()} method.
&nbsp;                                     */
&nbsp;                                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_VALUE;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The {@link FieldGetterHandle#declaringType()} method.
&nbsp;                                     */
&nbsp;                                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                                    /*
&nbsp;                                     * Resolves all annotation properties.
&nbsp;                                     */
&nbsp;                                    static {
<b class="fc">&nbsp;                                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(FieldGetterHandle.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                        FIELD_GETTER_HANDLE_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                        FIELD_GETTER_HANDLE_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public Class&lt;FieldGetterHandle&gt; getAnnotationType() {
<b class="fc">&nbsp;                                        return FieldGetterHandle.class;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldGetterHandle&gt; annotation) {
<b class="nc">&nbsp;                                        throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldGetterHandle&gt; annotation) {
<b class="fc">&nbsp;                                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        TypeDescription declaringType = annotation.getValue(FIELD_GETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                                        return declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                                                ? new ForFieldHandle.Unresolved.WithImplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class))</b>
<b class="fc">&nbsp;                                                : new ForFieldHandle.Unresolved.WithExplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class), declaringType);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A factory for creating a method handle representing a setter for the targeted field.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected enum SetterFactory implements OffsetMapping.Factory&lt;FieldSetterHandle&gt; {</b>
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The singleton instance.
&nbsp;                                     */
<b class="fc">&nbsp;                                    INSTANCE;</b>
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The {@link FieldGetterHandle#value()} method.
&nbsp;                                     */
&nbsp;                                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_VALUE;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The {@link FieldGetterHandle#declaringType()} method.
&nbsp;                                     */
&nbsp;                                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                                    /*
&nbsp;                                     * Resolves the annotation properties.
&nbsp;                                     */
&nbsp;                                    static {
<b class="fc">&nbsp;                                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(FieldSetterHandle.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                                        FIELD_SETTER_HANDLE_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                                        FIELD_SETTER_HANDLE_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public Class&lt;FieldSetterHandle&gt; getAnnotationType() {
<b class="fc">&nbsp;                                        return FieldSetterHandle.class;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldSetterHandle&gt; annotation) {
<b class="nc">&nbsp;                                        throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;FieldSetterHandle&gt; annotation) {
<b class="fc">&nbsp;                                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        TypeDescription declaringType = annotation.getValue(FIELD_SETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                                        return declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                                                ? new ForFieldHandle.Unresolved.WithImplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class))</b>
<b class="fc">&nbsp;                                                : new ForFieldHandle.Unresolved.WithExplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class), declaringType);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * An offset mapping for a resolved field handle.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            public static class Resolved extends OffsetMapping.ForFieldHandle {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The field that is being accessed.
&nbsp;                                 */
&nbsp;                                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved mapping for a field access handle.
&nbsp;                                 *
&nbsp;                                 * @param access           The type of access.
&nbsp;                                 * @param fieldDescription The field that is being accessed.
&nbsp;                                 */
&nbsp;                                public Resolved(Access access, FieldDescription fieldDescription) {
<b class="nc">&nbsp;                                    super(access);</b>
<b class="nc">&nbsp;                                    this.fieldDescription = fieldDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                @Override
&nbsp;                                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                                    if (!fieldDescription.isStatic() &amp;&amp; !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(fieldDescription + &quot; is no member of &quot; + instrumentedType);</b>
<b class="nc">&nbsp;                                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
&nbsp;                                    }
<b class="nc">&nbsp;                                    return fieldDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A factory to create an offset mapping for a resolved field handle.
&nbsp;                                 *
&nbsp;                                 * @param &lt;T&gt; The type of the annotation.
&nbsp;                                 */
&nbsp;                                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                                public static class Factory&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The annotation type.
&nbsp;                                     */
&nbsp;                                    private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The field being accessed.
&nbsp;                                     */
&nbsp;                                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * The type of access.
&nbsp;                                     */
&nbsp;                                    private final Access access;
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * Creates a new factory for a field access handle.
&nbsp;                                     *
&nbsp;                                     * @param annotationType   The annotation type.
&nbsp;                                     * @param fieldDescription The field being accessed.
&nbsp;                                     * @param access           The type of access.
&nbsp;                                     */
<b class="nc">&nbsp;                                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription, Access access) {</b>
<b class="nc">&nbsp;                                        this.annotationType = annotationType;</b>
<b class="nc">&nbsp;                                        this.fieldDescription = fieldDescription;</b>
<b class="nc">&nbsp;                                        this.access = access;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public Class&lt;T&gt; getAnnotationType() {
<b class="nc">&nbsp;                                        return annotationType;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="nc">&nbsp;                                        throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    /**
&nbsp;                                     * {@inheritDoc}
&nbsp;                                     */
&nbsp;                                    public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation) {
<b class="nc">&nbsp;                                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                                        }
<b class="nc">&nbsp;                                        return new ForFieldHandle.Resolved(access, fieldDescription);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping for describing a representation of the substituted element or the instrumented method.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForOrigin implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The sort of the origin representation.
&nbsp;                             */
&nbsp;                            private final Sort sort;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The source providing the reference.
&nbsp;                             */
&nbsp;                            private final Source source;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping a representation of the substituted element or instrumented method.
&nbsp;                             *
&nbsp;                             * @param sort   The sort of the origin representation.
&nbsp;                             * @param source The source providing the reference.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForOrigin(Sort sort, Source source) {</b>
<b class="fc">&nbsp;                                this.sort = sort;</b>
<b class="fc">&nbsp;                                this.source = source;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForOrigin.Resolved(sort, source, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * The sort of the origin expression.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Sort {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@link Method}.
&nbsp;                                 */
<b class="fc">&nbsp;                                METHOD {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return original instanceof MethodDescription &amp;&amp; ((MethodDescription) original).isMethod();</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="fc">&nbsp;                                        return MethodConstant.of(((MethodDescription) original).asDefined());</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@link Constructor}.
&nbsp;                                 */
<b class="fc">&nbsp;                                CONSTRUCTOR {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="nc">&nbsp;                                        return original instanceof MethodDescription &amp;&amp; ((MethodDescription) original).isConstructor();</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="nc">&nbsp;                                        return MethodConstant.of(((MethodDescription) original).asDefined());</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@link Field}.
&nbsp;                                 */
<b class="fc">&nbsp;                                FIELD {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return original instanceof FieldDescription;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="fc">&nbsp;                                        return new FieldConstant(((FieldDescription) original).asDefined());</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@code java.lang.reflect.Executable}.
&nbsp;                                 */
<b class="fc">&nbsp;                                EXECUTABLE {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="nc">&nbsp;                                        return original instanceof MethodDescription;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="nc">&nbsp;                                        return MethodConstant.of(((MethodDescription) original).asDefined());</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@link Class}.
&nbsp;                                 */
<b class="fc">&nbsp;                                TYPE {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return true;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="fc">&nbsp;                                        return ClassConstant.of(original.getDeclaringType().asErasure());</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@code java.lang.invoke.MethodHandles.Lookup}.
&nbsp;                                 */
<b class="fc">&nbsp;                                LOOKUP {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return true;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="fc">&nbsp;                                        return MethodInvocation.lookup();</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@code java.lang.invoke.MethodHandle}.
&nbsp;                                 */
<b class="fc">&nbsp;                                METHOD_HANDLE {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return true;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
&nbsp;                                        JavaConstant.MethodHandle handle;
<b class="fc">&nbsp;                                        if (original instanceof MethodDescription) {</b>
<b class="fc">&nbsp;                                            handle = JavaConstant.MethodHandle.of(((MethodDescription) original).asDefined());</b>
<b class="fc">&nbsp;                                        } else if (original instanceof FieldDescription) {</b>
<b class="fc">&nbsp;                                            handle = returnType.represents(void.class)</b>
<b class="nc">&nbsp;                                                    ? JavaConstant.MethodHandle.ofSetter(((FieldDescription) original).asDefined())</b>
<b class="fc">&nbsp;                                                    : JavaConstant.MethodHandle.ofGetter(((FieldDescription) original).asDefined());</b>
&nbsp;                                        } else {
<b class="nc">&nbsp;                                            throw new IllegalStateException(&quot;Unexpected byte code element: &quot; + original);</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                        return handle.toStackManipulation();</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as a {@code java.lang.invoke.MethodType}.
&nbsp;                                 */
<b class="fc">&nbsp;                                METHOD_TYPE {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return true;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="fc">&nbsp;                                        return JavaConstant.MethodType.of(returnType, parameterTypes).toStackManipulation();</b>
&nbsp;                                    }
&nbsp;                                },
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Represents the supplied value as its {@link Object#toString()} representation.
&nbsp;                                 */
<b class="fc">&nbsp;                                STRING {</b>
&nbsp;                                    @Override
&nbsp;                                    protected boolean isRepresentable(ByteCodeElement.Member original) {
<b class="fc">&nbsp;                                        return true;</b>
&nbsp;                                    }
&nbsp;
&nbsp;                                    @Override
&nbsp;                                    protected StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType) {
<b class="fc">&nbsp;                                        return new TextConstant(original.toString());</b>
&nbsp;                                    }
&nbsp;                                };
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Checks if the supplied member can be represented by this sort.
&nbsp;                                 *
&nbsp;                                 * @param original The byte code element to check.
&nbsp;                                 * @return {@code true} if the supplied element can be represented.
&nbsp;                                 */
&nbsp;                                protected abstract boolean isRepresentable(ByteCodeElement.Member original);
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a stack manipulation for the supplied byte code element.
&nbsp;                                 *
&nbsp;                                 * @param original       The substituted element.
&nbsp;                                 * @param parameterTypes The parameter types.
&nbsp;                                 * @param returnType     The return type.
&nbsp;                                 * @return A stack manipulation loading the supplied byte code element&#39;s representation onto the stack.
&nbsp;                                 */
&nbsp;                                protected abstract StackManipulation resolve(ByteCodeElement.Member original, List&lt;TypeDescription&gt; parameterTypes, TypeDescription returnType);
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for an offset mapping that describes a representation of the substituted element or instrumented method.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;Origin&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link Origin#source()} property.
&nbsp;                                 */
<b class="fc">&nbsp;                                private static final MethodDescription.InDefinedShape ORIGIN_TYPE = TypeDescription.ForLoadedType.of(Origin.class)</b>
<b class="fc">&nbsp;                                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                        .filter(named(&quot;source&quot;))</b>
<b class="fc">&nbsp;                                        .getOnly();</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;Origin&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return Origin.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Origin&gt; annotation) {
<b class="nc">&nbsp;                                    throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Origin&gt; annotation) {
&nbsp;                                    Sort sort;
<b class="fc">&nbsp;                                    if (target.getType().asErasure().represents(Class.class)) {</b>
<b class="fc">&nbsp;                                        sort = Sort.TYPE;</b>
<b class="fc">&nbsp;                                    } else if (target.getType().asErasure().represents(Method.class)) {</b>
<b class="fc">&nbsp;                                        sort = Sort.METHOD;</b>
<b class="fc">&nbsp;                                    } else if (target.getType().asErasure().represents(Constructor.class)) {</b>
<b class="nc">&nbsp;                                        sort = Sort.CONSTRUCTOR;</b>
<b class="fc">&nbsp;                                    } else if (target.getType().asErasure().represents(Field.class)) {</b>
<b class="fc">&nbsp;                                        sort = Sort.FIELD;</b>
<b class="fc">&nbsp;                                    } else if (JavaType.EXECUTABLE.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="nc">&nbsp;                                        sort = Sort.EXECUTABLE;</b>
<b class="fc">&nbsp;                                    } else if (JavaType.METHOD_HANDLE.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="fc">&nbsp;                                        sort = Sort.METHOD_HANDLE;</b>
<b class="fc">&nbsp;                                    } else if (JavaType.METHOD_TYPE.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="fc">&nbsp;                                        sort = Sort.METHOD_TYPE;</b>
<b class="fc">&nbsp;                                    } else if (JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="fc">&nbsp;                                        sort = Sort.LOOKUP;</b>
<b class="fc">&nbsp;                                    } else if (target.getType().asErasure().isAssignableFrom(String.class)) {</b>
<b class="fc">&nbsp;                                        sort = Sort.STRING;</b>
&nbsp;                                    } else {
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Non-supported type &quot; + target.getType() + &quot; for @Origin annotation&quot;);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new ForOrigin(sort, annotation.getValue(ORIGIN_TYPE).resolve(EnumerationDescription.class).load(Source.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved offset mapping for a representation of the substituted expression or instrumented method.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The sort of the origin representation.
&nbsp;                                 */
&nbsp;                                private final Sort sort;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the reference.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved version of an offset mapping for describing the substituted expression or instrumented method.
&nbsp;                                 *
&nbsp;                                 * @param sort               The sort of the origin representation.
&nbsp;                                 * @param source             The source providing the reference.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Resolved(Sort sort, Source source, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.sort = sort;</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    if (!source.isRepresentable(sort, original, instrumentedMethod)) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot represent &quot; + sort + &quot; for &quot; + source + &quot; in &quot; + instrumentedMethod);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return source.resolve(sort, original, parameters, result, instrumentedMethod);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that assigns a stub value.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForStubValue implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The source providing the reference.
&nbsp;                             */
&nbsp;                            private final Source source;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping for a stub value.
&nbsp;                             *
&nbsp;                             * @param source The source providing the reference.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForStubValue(Source source) {</b>
<b class="fc">&nbsp;                                this.source = source;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new Resolved(source, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved offset mapping for an offset mapping of a stub value.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The source providing the reference.
&nbsp;                                 */
&nbsp;                                private final Source source;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved version of an offset mapping for a stub value.
&nbsp;                                 *
&nbsp;                                 * @param source             The source providing the reference.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Resolved(Source source, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.source = source;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    return DefaultValue.of(source.handle(methodHandle, instrumentedMethod).getReturnType());</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating an offset mapping for a stub value.
&nbsp;                             */
<b class="fc">&nbsp;                            @HashCodeAndEqualsPlugin.Enhance</b>
&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;StubValue&gt; {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link StubValue#source()} property.
&nbsp;                                 */
<b class="fc">&nbsp;                                private static final MethodDescription.InDefinedShape STUB_VALUE_SOURCE = TypeDescription.ForLoadedType.of(StubValue.class)</b>
<b class="fc">&nbsp;                                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                        .filter(named(&quot;source&quot;))</b>
<b class="fc">&nbsp;                                        .getOnly();</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;StubValue&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return StubValue.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;StubValue&gt; annotation) {
<b class="nc">&nbsp;                                    throw new UnsupportedOperationException(&quot;This factory does not support binding a method receiver&quot;);</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;StubValue&gt; annotation) {
<b class="fc">&nbsp;                                    if (!target.getType().represents(Object.class)) {</b>
<b class="fc">&nbsp;                                        throw new IllegalStateException(&quot;Expected &quot; + target + &quot; to declare an Object type&quot;);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new ForStubValue(annotation.getValue(STUB_VALUE_SOURCE).resolve(EnumerationDescription.class).load(Source.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An offset mapping that assigns the value of the previous chain instruction.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForCurrent implements OffsetMapping {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The type of the targeted expression.
&nbsp;                             */
&nbsp;                            private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The typing to use or {@code null} if implicit typing.
&nbsp;                             */
&nbsp;                            @MaybeNull
&nbsp;                            @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                            private final Assigner.Typing typing;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates an offset mapping for the previous chain instruction.
&nbsp;                             *
&nbsp;                             * @param targetType The type of the targeted expression.
&nbsp;                             * @param typing     The typing to use or {@code null} if implicit typing.
&nbsp;                             */
<b class="fc">&nbsp;                            public ForCurrent(TypeDescription.Generic targetType, @MaybeNull Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                                this.targetType = targetType;</b>
<b class="fc">&nbsp;                                this.typing = typing;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public OffsetMapping.Resolved resolve(Assigner assigner, Assigner.Typing typing, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForCurrent.Resolved(targetType, assigner, this.typing == null ? typing : this.typing);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating an offset mapping for assigning the result of the previous chain instruction.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements OffsetMapping.Factory&lt;Current&gt; {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The {@link Current#typing()} property.
&nbsp;                                 */
<b class="fc">&nbsp;                                private static final MethodDescription.InDefinedShape CURRENT_TYPING = TypeDescription.ForLoadedType.of(Current.class)</b>
<b class="fc">&nbsp;                                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                        .filter(named(&quot;typing&quot;))</b>
<b class="fc">&nbsp;                                        .getOnly();</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Class&lt;Current&gt; getAnnotationType() {
<b class="fc">&nbsp;                                    return Current.class;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(MethodDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Current&gt; annotation) {
<b class="nc">&nbsp;                                    return new ForCurrent(target.getDeclaringType().asGenericType(),</b>
<b class="nc">&nbsp;                                            annotation.getValue(CURRENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;Current&gt; annotation) {
<b class="fc">&nbsp;                                    return new ForCurrent(target.getType(), annotation.getValue(CURRENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved offset mapping for assigning the previous chain instruction.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements OffsetMapping.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The type of the targeted expression.
&nbsp;                                 */
&nbsp;                                private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The assigner to use.
&nbsp;                                 */
&nbsp;                                private final Assigner assigner;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The typing to use.
&nbsp;                                 */
&nbsp;                                private final Assigner.Typing typing;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved offset mapping for assigning the previous chain instruction.
&nbsp;                                 *
&nbsp;                                 * @param targetType The type of the targeted expression.
&nbsp;                                 * @param assigner   The assigner to use.
&nbsp;                                 * @param typing     The typing to use.
&nbsp;                                 */
<b class="fc">&nbsp;                                public Resolved(TypeDescription.Generic targetType, Assigner assigner, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                                    this.targetType = targetType;</b>
<b class="fc">&nbsp;                                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                                    this.typing = typing;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver,
&nbsp;                                                               ByteCodeElement.Member original,
&nbsp;                                                               TypeList.Generic parameters,
&nbsp;                                                               TypeDescription.Generic result,
&nbsp;                                                               TypeDescription.Generic current,
&nbsp;                                                               JavaConstant.MethodHandle methodHandle,
&nbsp;                                                               Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                               int offset) {
<b class="fc">&nbsp;                                    StackManipulation assignment = assigner.assign(current, targetType, typing);</b>
<b class="fc">&nbsp;                                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Cannot assign &quot; + current + &quot; to &quot; + targetType);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return new StackManipulation.Compound(MethodVariableAccess.of(current).loadFrom(offset), assignment);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for invoking a delegation method.
&nbsp;                     */
&nbsp;                    protected interface Dispatcher {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves a dispatcher for a given instrumented type and method.
&nbsp;                         *
&nbsp;                         * @param instrumentedType   The instrumented type.
&nbsp;                         * @param instrumentedMethod The instrumented method.
&nbsp;                         * @return A resolved version of this dispatcher.
&nbsp;                         */
&nbsp;                        Dispatcher.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * A dispatcher that has been resolved for a given instrumented type and method.
&nbsp;                         */
&nbsp;                        interface Resolved {
&nbsp;
&nbsp;                            StackManipulation initialize();
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a stack manipulation for a given substitution target.
&nbsp;                             *
&nbsp;                             * @param receiver     The type upon which the substituted element is invoked upon.
&nbsp;                             * @param original     The substituted element.
&nbsp;                             * @param methodHandle A method handle that describes the invocation.
&nbsp;                             * @return A stack manipulation that executes the represented delegation.
&nbsp;                             */
&nbsp;                            StackManipulation apply(TypeDescription receiver, ByteCodeElement.Member original, JavaConstant.MethodHandle methodHandle);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A factory for creating a dispatcher.
&nbsp;                         */
&nbsp;                        interface Factory {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a dispatcher for a given delegation method.
&nbsp;                             *
&nbsp;                             * @param delegate The method or constructor to delegate to.
&nbsp;                             * @return An appropriate dispatcher.
&nbsp;                             */
&nbsp;                            Dispatcher make(MethodDescription.InDefinedShape delegate);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A dispatcher that invokes a delegate method directly.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForRegularInvocation implements Dispatcher, Dispatcher.Resolved {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The delegation method.
&nbsp;                             */
&nbsp;                            private final MethodDescription delegate;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a dispatcher for a regular method invocation.
&nbsp;                             *
&nbsp;                             * @param delegate The delegation method.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForRegularInvocation(MethodDescription delegate) {</b>
<b class="fc">&nbsp;                                this.delegate = delegate;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return this;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public StackManipulation initialize() {
<b class="fc">&nbsp;                                return delegate.isConstructor()</b>
<b class="nc">&nbsp;                                        ? new StackManipulation.Compound(TypeCreation.of(delegate.getDeclaringType().asErasure()), Duplication.SINGLE)</b>
<b class="fc">&nbsp;                                        : StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public StackManipulation apply(TypeDescription receiver, ByteCodeElement.Member original, JavaConstant.MethodHandle methodHandle) {
<b class="fc">&nbsp;                                return MethodInvocation.invoke(delegate);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating a dispatcher for a regular method invocation.
&nbsp;                             */
<b class="fc">&nbsp;                            protected enum Factory implements Dispatcher.Factory {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Dispatcher make(MethodDescription.InDefinedShape delegate) {
<b class="fc">&nbsp;                                    return new ForRegularInvocation(delegate);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A method dispatcher that is using a dynamic method invocation.
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForDynamicInvocation implements Dispatcher {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The bootstrap method.
&nbsp;                             */
&nbsp;                            private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;                            /**
&nbsp;                             * The delegation method.
&nbsp;                             */
&nbsp;                            private final MethodDescription.InDefinedShape delegate;
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolver for supplying arguments to the bootstrap method.
&nbsp;                             */
&nbsp;                            private final BootstrapArgumentResolver resolver;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a dispatcher for a dynamic method invocation.
&nbsp;                             *
&nbsp;                             * @param bootstrapMethod The bootstrap method.
&nbsp;                             * @param delegate        The delegation method.
&nbsp;                             * @param resolver        A resolver for supplying arguments to the bootstrap method.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForDynamicInvocation(MethodDescription.InDefinedShape bootstrapMethod, MethodDescription.InDefinedShape delegate, BootstrapArgumentResolver resolver) {</b>
<b class="fc">&nbsp;                                this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                                this.delegate = delegate;</b>
<b class="fc">&nbsp;                                this.resolver = resolver;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a dispatcher factory for a dynamic method invocation.
&nbsp;                             *
&nbsp;                             * @param bootstrapMethod The bootstrap method.
&nbsp;                             * @param resolverFactory A resolver for supplying arguments to the bootstrap method.
&nbsp;                             * @return An appropriate dispatcher factory.
&nbsp;                             */
&nbsp;                            protected static Dispatcher.Factory of(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="fc">&nbsp;                                if (!bootstrapMethod.isInvokeBootstrap()) {</b>
<b class="nc">&nbsp;                                    throw new IllegalStateException(&quot;Not a bootstrap method: &quot; + bootstrapMethod);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                return new ForDynamicInvocation.Factory(bootstrapMethod, resolverFactory);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Dispatcher.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new ForDynamicInvocation.Resolved(bootstrapMethod, delegate, resolver.resolve(instrumentedType, instrumentedMethod));</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved dispatcher for a dynamically bound method invocation.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements Dispatcher.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The bootstrap method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The delegation target.
&nbsp;                                 */
&nbsp;                                private final MethodDescription.InDefinedShape delegate;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The bootstrap argument resolver to use.
&nbsp;                                 */
&nbsp;                                private final BootstrapArgumentResolver.Resolved resolver;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved dispatcher of a dynamic method dispatcher.
&nbsp;                                 *
&nbsp;                                 * @param bootstrapMethod The bootstrap method.
&nbsp;                                 * @param delegate        The delegation target.
&nbsp;                                 * @param resolver        The bootstrap argument resolver to use.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Resolved(MethodDescription.InDefinedShape bootstrapMethod, MethodDescription.InDefinedShape delegate, BootstrapArgumentResolver.Resolved resolver) {</b>
<b class="fc">&nbsp;                                    this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                                    this.delegate = delegate;</b>
<b class="fc">&nbsp;                                    this.resolver = resolver;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation initialize() {
<b class="fc">&nbsp;                                    return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public StackManipulation apply(TypeDescription receiver, ByteCodeElement.Member original, JavaConstant.MethodHandle methodHandle) {
<b class="fc">&nbsp;                                    List&lt;JavaConstant&gt; constants = resolver.make(receiver, original, methodHandle);</b>
<b class="fc">&nbsp;                                    if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(constants))) {</b>
<b class="nc">&nbsp;                                        throw new IllegalArgumentException(bootstrapMethod + &quot; is not accepting advice bootstrap arguments: &quot; + constants);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    return MethodInvocation.invoke(bootstrapMethod).dynamic(delegate.getInternalName(),</b>
<b class="fc">&nbsp;                                            delegate.getReturnType().asErasure(),</b>
<b class="fc">&nbsp;                                            delegate.getParameters().asTypeList().asErasures(),</b>
&nbsp;                                            constants);
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for a dynamic method invocation of the dispatcher method or constructor.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Factory implements Dispatcher.Factory {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The bootstrap method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * A factory for a bootstrap argument resolver.
&nbsp;                                 */
&nbsp;                                private final BootstrapArgumentResolver.Factory resolverFactory;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new factory for a dispatcher using a dynamic method invocation.
&nbsp;                                 *
&nbsp;                                 * @param bootstrapMethod The bootstrap method.
&nbsp;                                 * @param resolverFactory A factory for a bootstrap argument resolver.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Factory(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {</b>
<b class="fc">&nbsp;                                    this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                                    this.resolverFactory = resolverFactory;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public Dispatcher make(MethodDescription.InDefinedShape delegate) {
<b class="fc">&nbsp;                                    return new ForDynamicInvocation(bootstrapMethod, delegate, resolverFactory.make(delegate));</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A resolver for supplying arguments to a bootstrap method which is binding the delegation method&#39;s invocation.
&nbsp;                     */
&nbsp;                    public interface BootstrapArgumentResolver {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves this resolver for a given instrumented type and method.
&nbsp;                         *
&nbsp;                         * @param instrumentedType   The instrumented type.
&nbsp;                         * @param instrumentedMethod The instrumented method.
&nbsp;                         * @return A resolved version of this argument resolver.
&nbsp;                         */
&nbsp;                        BootstrapArgumentResolver.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;                        /**
&nbsp;                         * A resolved version of a bootstrap argument handler.
&nbsp;                         */
&nbsp;                        interface Resolved {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Returns the constant values to supply to the bootstrap method.
&nbsp;                             *
&nbsp;                             * @param receiver     The type upon which the substituted element is applied.
&nbsp;                             * @param original     The substituted element.
&nbsp;                             * @param methodHandle A method handle that represents the substituted element.
&nbsp;                             * @return A list of constant values to supply to the bootstrap method.
&nbsp;                             */
&nbsp;                            List&lt;JavaConstant&gt; make(TypeDescription receiver, ByteCodeElement.Member original, JavaConstant.MethodHandle methodHandle);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * A factory for a bootstrap argument resolver.
&nbsp;                         */
&nbsp;                        interface Factory {
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a bootstrap argument resolver for a given delegation method.
&nbsp;                             *
&nbsp;                             * @param delegate The method or constructor to which to delegate.
&nbsp;                             * @return An appropriate bootstrap argument resolver.
&nbsp;                             */
&nbsp;                            BootstrapArgumentResolver make(MethodDescription.InDefinedShape delegate);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An implementation that supplies a default set of arguments to a bootstrap method. The arguments are:
&nbsp;                         * &lt;ul&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the target&#39;s internal name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representation of the delegate&#39;s binary class name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} representing the receiver type of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the internal name of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} to the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} describing the instrumented type.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the instrumented method or constructor.&lt;/li&gt;
&nbsp;                         * &lt;/ul&gt;
&nbsp;                         */
&nbsp;                        @HashCodeAndEqualsPlugin.Enhance
&nbsp;                        class ForDefaultValues implements BootstrapArgumentResolver {
&nbsp;
&nbsp;                            /**
&nbsp;                             * The delegation target.
&nbsp;                             */
&nbsp;                            private final MethodDescription.InDefinedShape delegate;
&nbsp;
&nbsp;                            /**
&nbsp;                             * Creates a default bootstrap argument resolver.
&nbsp;                             *
&nbsp;                             * @param delegate The delegation target.
&nbsp;                             */
<b class="fc">&nbsp;                            protected ForDefaultValues(MethodDescription.InDefinedShape delegate) {</b>
<b class="fc">&nbsp;                                this.delegate = delegate;</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public BootstrapArgumentResolver.Resolved resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                                return new Resolved(delegate, instrumentedType, instrumentedMethod);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A resolved default bootstrap argument resolver.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class Resolved implements BootstrapArgumentResolver.Resolved {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The delegation target.
&nbsp;                                 */
&nbsp;                                private final MethodDescription.InDefinedShape delegate;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented type.
&nbsp;                                 */
&nbsp;                                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The instrumented method.
&nbsp;                                 */
&nbsp;                                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a resolved version of a bootstrap argument resolver.
&nbsp;                                 *
&nbsp;                                 * @param delegate           The delegation target.
&nbsp;                                 * @param instrumentedType   The instrumented type.
&nbsp;                                 * @param instrumentedMethod The instrumented method.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected Resolved(MethodDescription.InDefinedShape delegate, TypeDescription instrumentedType, MethodDescription instrumentedMethod) {</b>
<b class="fc">&nbsp;                                    this.delegate = delegate;</b>
<b class="fc">&nbsp;                                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                                    this.instrumentedMethod = instrumentedMethod;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public List&lt;JavaConstant&gt; make(TypeDescription receiver, ByteCodeElement.Member original, JavaConstant.MethodHandle methodHandle) {
<b class="fc">&nbsp;                                    if (instrumentedMethod.isTypeInitializer()) {</b>
<b class="nc">&nbsp;                                        return Arrays.asList(JavaConstant.Simple.ofLoaded(delegate.getDeclaringType().getName()),</b>
<b class="nc">&nbsp;                                                JavaConstant.Simple.of(receiver),</b>
<b class="nc">&nbsp;                                                JavaConstant.Simple.ofLoaded(original.getInternalName()),</b>
&nbsp;                                                methodHandle,
<b class="nc">&nbsp;                                                JavaConstant.Simple.of(instrumentedType),</b>
<b class="nc">&nbsp;                                                JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()));</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        return Arrays.asList(JavaConstant.Simple.ofLoaded(delegate.getDeclaringType().getName()),</b>
<b class="fc">&nbsp;                                                JavaConstant.Simple.of(receiver),</b>
<b class="fc">&nbsp;                                                JavaConstant.Simple.ofLoaded(original.getInternalName()),</b>
&nbsp;                                                methodHandle,
<b class="fc">&nbsp;                                                JavaConstant.Simple.of(instrumentedType),</b>
<b class="fc">&nbsp;                                                JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()),</b>
<b class="fc">&nbsp;                                                JavaConstant.MethodHandle.of(instrumentedMethod.asDefined()));</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A factory for creating a default bootstrap argument resolver.
&nbsp;                             */
<b class="fc">&nbsp;                            public enum Factory implements BootstrapArgumentResolver.Factory {</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The singleton instance.
&nbsp;                                 */
<b class="fc">&nbsp;                                INSTANCE;</b>
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public BootstrapArgumentResolver make(MethodDescription.InDefinedShape delegate) {
<b class="fc">&nbsp;                                    return new ForDefaultValues(delegate);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A factory for a {@link ForDelegation} which allows for a custom configuration.
&nbsp;                     */
&nbsp;                    public static class WithCustomMapping {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The dispatcher factory to use.
&nbsp;                         */
&nbsp;                        private final Dispatcher.Factory dispatcherFactory;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A mapping of offset mapping factories by their respective annotation type.
&nbsp;                         */
&nbsp;                        private final Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a factory for a {@link ForDelegation} with a custom value.
&nbsp;                         *
&nbsp;                         * @param dispatcherFactory The dispatcher factory to use.
&nbsp;                         * @param offsetMappings    A mapping of offset mapping factories by their respective annotation type.
&nbsp;                         */
<b class="fc">&nbsp;                        protected WithCustomMapping(Dispatcher.Factory dispatcherFactory, Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings) {</b>
<b class="fc">&nbsp;                            this.dispatcherFactory = dispatcherFactory;</b>
<b class="fc">&nbsp;                            this.offsetMappings = offsetMappings;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a type constant of the supplied value. Constants can be strings, method handles, method types
&nbsp;                         * and any primitive or the value {@code null}.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param value The value to bind to the annotation or {@code null} to bind the parameter type&#39;s default value.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, @MaybeNull Object value) {
<b class="nc">&nbsp;                            return bind(OffsetMapping.ForStackManipulation.of(type, value));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the value of the supplied field. The field must be visible by the
&nbsp;                         * instrumented type and must be declared by a super type of the instrumented field.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param field The field to bind to this annotation.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Field field) {
<b class="fc">&nbsp;                            return bind(type, new FieldDescription.ForLoadedField(field));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the value of the supplied field. The field must be visible by the
&nbsp;                         * instrumented type and must be declared by a super type of the instrumented field. The binding is defined
&nbsp;                         * as read-only and applied static typing.
&nbsp;                         *
&nbsp;                         * @param type             The type of the annotation being bound.
&nbsp;                         * @param fieldDescription The field to bind to this annotation.
&nbsp;                         * @param &lt;T&gt;              The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                            return bind(new OffsetMapping.ForField.Resolved.Factory&lt;T&gt;(type, fieldDescription));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the supplied type constant.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param value The type constant to bind.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Class&lt;?&gt; value) {
<b class="nc">&nbsp;                            return bind(type, TypeDescription.ForLoadedType.of(value));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the supplied type constant.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param value The type constant to bind.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, TypeDescription value) {
<b class="nc">&nbsp;                            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, ConstantValue.Simple.wrap(value)));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the supplied enumeration constant.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param value The enumeration constant to bind.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Enum&lt;?&gt; value) {
<b class="nc">&nbsp;                            return bind(type, new EnumerationDescription.ForLoadedEnumeration(value));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the supplied enumeration constant.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param value The enumeration constant to bind.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, EnumerationDescription value) {
<b class="nc">&nbsp;                            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, ConstantValue.Simple.wrap(value)));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the supplied fixed value.
&nbsp;                         *
&nbsp;                         * @param type  The type of the annotation being bound.
&nbsp;                         * @param value The value to bind to this annotation.
&nbsp;                         * @param &lt;T&gt;   The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindSerialized(Class&lt;T&gt; type, Serializable value) {
<b class="fc">&nbsp;                            return bindSerialized(type, value, (Class&lt;Serializable&gt;) value.getClass());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the supplied fixed value.
&nbsp;                         *
&nbsp;                         * @param type       The type of the annotation being bound.
&nbsp;                         * @param value      The value to bind to this annotation.
&nbsp;                         * @param targetType The type of {@code value} as which the instance should be treated.
&nbsp;                         * @param &lt;T&gt;        The annotation type.
&nbsp;                         * @param &lt;S&gt;        The type of the serialized instance.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation, S extends Serializable&gt; WithCustomMapping bindSerialized(Class&lt;T&gt; type, S value, Class&lt;? super S&gt; targetType) {
<b class="fc">&nbsp;                            return bind(OffsetMapping.ForStackManipulation.OfSerializedConstant.of(type, value, targetType));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;                         *
&nbsp;                         * @param type     The type of the annotation being bound.
&nbsp;                         * @param property The name of the annotation property to be bound.
&nbsp;                         * @param &lt;T&gt;      The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindProperty(Class&lt;T&gt; type, String property) {
<b class="nc">&nbsp;                            return bind(OffsetMapping.ForStackManipulation.OfAnnotationProperty.of(type, property));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the given Java constant.
&nbsp;                         *
&nbsp;                         * @param type     The type of the annotation being bound.
&nbsp;                         * @param constant The constant value that is bound.
&nbsp;                         * @param &lt;T&gt;      The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, ConstantValue constant) {
<b class="nc">&nbsp;                            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;                         *
&nbsp;                         * @param type              The type of the annotation being bound.
&nbsp;                         * @param stackManipulation The stack manipulation loading the bound value.
&nbsp;                         * @param targetType        The type of the loaded value.
&nbsp;                         * @param &lt;T&gt;               The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, StackManipulation stackManipulation, java.lang.reflect.Type targetType) {
<b class="nc">&nbsp;                            return bind(type, stackManipulation, TypeDefinition.Sort.describe(targetType));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;                         *
&nbsp;                         * @param type              The type of the annotation being bound.
&nbsp;                         * @param stackManipulation The stack manipulation loading the bound value.
&nbsp;                         * @param targetType        The type of the loaded value.
&nbsp;                         * @param &lt;T&gt;               The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, StackManipulation stackManipulation, TypeDescription.Generic targetType) {
<b class="nc">&nbsp;                            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, stackManipulation, targetType));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;                         *
&nbsp;                         * @param type                The type of the annotation being bound.
&nbsp;                         * @param constructor         The constructor being bound as the lambda expression&#39;s implementation.
&nbsp;                         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;                         * @param &lt;T&gt;                 The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Constructor&lt;?&gt; constructor, Class&lt;?&gt; functionalInterface) {
<b class="nc">&nbsp;                            return bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), TypeDescription.ForLoadedType.of(functionalInterface));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;                         *
&nbsp;                         * @param type                The type of the annotation being bound.
&nbsp;                         * @param constructor         The constructor being bound as the lambda expression&#39;s implementation.
&nbsp;                         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;                         * @param methodGraphCompiler The method graph compiler that resolves the functional method of the function interface.
&nbsp;                         * @param &lt;T&gt;                 The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Constructor&lt;?&gt; constructor, Class&lt;?&gt; functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;                            return bindLambda(type, new MethodDescription.ForLoadedConstructor(constructor), TypeDescription.ForLoadedType.of(functionalInterface), methodGraphCompiler);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;                         *
&nbsp;                         * @param type                The type of the annotation being bound.
&nbsp;                         * @param method              The method being bound as the lambda expression&#39;s implementation.
&nbsp;                         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;                         * @param &lt;T&gt;                 The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Method method, Class&lt;?&gt; functionalInterface) {
<b class="fc">&nbsp;                            return bindLambda(type, new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(functionalInterface));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;                         *
&nbsp;                         * @param type                The type of the annotation being bound.
&nbsp;                         * @param method              The method being bound as the lambda expression&#39;s implementation.
&nbsp;                         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;                         * @param methodGraphCompiler The method graph compiler that resolves the functional method of the function interface.
&nbsp;                         * @param &lt;T&gt;                 The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, Method method, Class&lt;?&gt; functionalInterface, MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;                            return bindLambda(type, new MethodDescription.ForLoadedMethod(method), TypeDescription.ForLoadedType.of(functionalInterface), methodGraphCompiler);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;                         *
&nbsp;                         * @param type                The type of the annotation being bound.
&nbsp;                         * @param methodDescription   The method or constructor being bound as the lambda expression&#39;s implementation.
&nbsp;                         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;                         * @param &lt;T&gt;                 The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type, MethodDescription.InDefinedShape methodDescription, TypeDescription functionalInterface) {
<b class="fc">&nbsp;                            return bindLambda(type, methodDescription, functionalInterface, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;                         *
&nbsp;                         * @param type                The type of the annotation being bound.
&nbsp;                         * @param methodDescription   The method or constuctor being bound as the lambda expression&#39;s implementation.
&nbsp;                         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;                         * @param methodGraphCompiler The method graph compiler that resolves the functional method of the function interface.
&nbsp;                         * @param &lt;T&gt;                 The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                                   MethodDescription.InDefinedShape methodDescription,
&nbsp;                                                                                   TypeDescription functionalInterface,
&nbsp;                                                                                   MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;                            if (!functionalInterface.isInterface()) {</b>
<b class="nc">&nbsp;                                throw new IllegalArgumentException(functionalInterface + &quot; is not an interface type&quot;);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            MethodList&lt;?&gt; methods = methodGraphCompiler.compile((TypeDefinition) functionalInterface).listNodes().asMethodList().filter(isAbstract());</b>
<b class="fc">&nbsp;                            if (methods.size() != 1) {</b>
<b class="nc">&nbsp;                                throw new IllegalArgumentException(functionalInterface + &quot; does not define exactly one abstract method: &quot; + methods);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return bindDynamic(type, new MethodDescription.Latent(new TypeDescription.Latent(&quot;java.lang.invoke.LambdaMetafactory&quot;,</b>
&nbsp;                                            Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                            TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)),</b>
&nbsp;                                            &quot;metafactory&quot;,
&nbsp;                                            Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                            Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
<b class="fc">&nbsp;                                            JavaType.CALL_SITE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                            Arrays.asList(</b>
<b class="fc">&nbsp;                                                    new ParameterDescription.Token(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                                    new ParameterDescription.Token(TypeDescription.ForLoadedType.of(String.class).asGenericType()),</b>
<b class="fc">&nbsp;                                                    new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                                    new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                                    new ParameterDescription.Token(JavaType.METHOD_HANDLE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                                    new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType())),</b>
<b class="fc">&nbsp;                                            Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                                            Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                                            AnnotationValue.UNDEFINED,
&nbsp;                                            TypeDescription.Generic.UNDEFINED),
<b class="fc">&nbsp;                                    JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()),</b>
<b class="fc">&nbsp;                                    JavaConstant.MethodHandle.of(methodDescription),</b>
<b class="fc">&nbsp;                                    JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;                         *
&nbsp;                         * @param type            The type of the annotation being bound.
&nbsp;                         * @param bootstrapMethod The bootstrap method returning the call site.
&nbsp;                         * @param constant        The arguments supplied to the bootstrap method.
&nbsp;                         * @param &lt;T&gt;             The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Method bootstrapMethod, Object... constant) {
<b class="fc">&nbsp;                            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;                         *
&nbsp;                         * @param type            The type of the annotation being bound.
&nbsp;                         * @param bootstrapMethod The bootstrap method returning the call site.
&nbsp;                         * @param constants       The arguments supplied to the bootstrap method.
&nbsp;                         * @param &lt;T&gt;             The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Method bootstrapMethod, List&lt;?&gt; constants) {
<b class="fc">&nbsp;                            return bindDynamic(type, new MethodDescription.ForLoadedMethod(bootstrapMethod), constants);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;                         *
&nbsp;                         * @param type            The type of the annotation being bound.
&nbsp;                         * @param bootstrapMethod The bootstrap constructor returning the call site.
&nbsp;                         * @param constant        The arguments supplied to the bootstrap method.
&nbsp;                         * @param &lt;T&gt;             The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Constructor&lt;?&gt; bootstrapMethod, Object... constant) {
<b class="nc">&nbsp;                            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;                         *
&nbsp;                         * @param type            The type of the annotation being bound.
&nbsp;                         * @param bootstrapMethod The bootstrap constructor returning the call site.
&nbsp;                         * @param constants       The arguments supplied to the bootstrap method.
&nbsp;                         * @param &lt;T&gt;             The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Constructor&lt;?&gt; bootstrapMethod, List&lt;?&gt; constants) {
<b class="nc">&nbsp;                            return bindDynamic(type, new MethodDescription.ForLoadedConstructor(bootstrapMethod), constants);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;                         *
&nbsp;                         * @param type            The type of the annotation being bound.
&nbsp;                         * @param bootstrapMethod The bootstrap method or constructor returning the call site.
&nbsp;                         * @param constant        The arguments supplied to the bootstrap method.
&nbsp;                         * @param &lt;T&gt;             The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
<b class="fc">&nbsp;                            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;                         *
&nbsp;                         * @param type            The type of the annotation being bound.
&nbsp;                         * @param bootstrapMethod The bootstrap method or constructor returning the call site.
&nbsp;                         * @param constants       The arguments supplied to the bootstrap method.
&nbsp;                         * @param &lt;T&gt;             The annotation type.
&nbsp;                         * @return A new builder for a delegate that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, MethodDescription.InDefinedShape bootstrapMethod, List&lt;?&gt; constants) {
<b class="fc">&nbsp;                            List&lt;JavaConstant&gt; arguments = JavaConstant.Simple.wrap(constants);</b>
<b class="fc">&nbsp;                            if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(arguments))) {</b>
<b class="nc">&nbsp;                                throw new IllegalArgumentException(&quot;Not a valid bootstrap method &quot; + bootstrapMethod + &quot; for &quot; + arguments);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return bind(new OffsetMapping.ForStackManipulation.OfDynamicInvocation&lt;T&gt;(type, bootstrapMethod, arguments));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;                         *
&nbsp;                         * @param type          The type of the annotation being bound.
&nbsp;                         * @param offsetMapping The offset mapping being bound.
&nbsp;                         * @param &lt;T&gt;           The annotation type.
&nbsp;                         * @return A new builder for a delegation that considers the supplied annotation during binding.
&nbsp;                         */
&nbsp;                        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, OffsetMapping offsetMapping) {
<b class="nc">&nbsp;                            return bind(new OffsetMapping.Factory.Simple&lt;T&gt;(type, offsetMapping));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Binds an annotation to a dynamically computed value. Whenever the {@link ForDelegation} target discovers the given annotation on
&nbsp;                         * a parameter of an advice method, the dynamic value is asked to provide a value that is then assigned to the parameter in question.
&nbsp;                         *
&nbsp;                         * @param offsetMapping The dynamic value that is computed for binding the parameter to a value.
&nbsp;                         * @return A new builder for a delegation that considers the supplied annotation type during binding.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bind(OffsetMapping.Factory&lt;?&gt; offsetMapping) {
<b class="fc">&nbsp;                            Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings = new LinkedHashMap&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt;(this.offsetMappings);</b>
<b class="fc">&nbsp;                            if (!offsetMapping.getAnnotationType().isAnnotation()) {</b>
<b class="nc">&nbsp;                                throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + offsetMapping.getAnnotationType());</b>
<b class="fc">&nbsp;                            } else if (offsetMappings.put(offsetMapping.getAnnotationType(), offsetMapping) != null) {</b>
<b class="nc">&nbsp;                                throw new IllegalArgumentException(&quot;Annotation type already mapped: &quot; + offsetMapping.getAnnotationType());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            return new WithCustomMapping(dispatcherFactory, offsetMappings);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied constructor as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;                         * method arguments are:
&nbsp;                         * &lt;ul&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the constructor&#39;s internal name {@code &lt;init&gt;}.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representation of the delegate&#39;s binary class name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} representing the receiver type of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the internal name of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} to the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} describing the instrumented type.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the instrumented method or constructor.&lt;/li&gt;
&nbsp;                         * &lt;/ul&gt;
&nbsp;                         *
&nbsp;                         * @param constructor The bootstrap constructor.
&nbsp;                         * @return A new builder for a delegation within a member substitution that uses the supplied constructor for bootstrapping.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bootstrap(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;                            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied constructor as a dynamic invocation bootstrap target for delegating advice methods.
&nbsp;                         *
&nbsp;                         * @param constructor     The bootstrap method or constructor.
&nbsp;                         * @param resolverFactory A factory for resolving the arguments to the bootstrap method.
&nbsp;                         * @return A new builder for a delegation within a member substitution that uses the supplied constructor for bootstrapping.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bootstrap(Constructor&lt;?&gt; constructor, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="nc">&nbsp;                            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor), resolverFactory);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied method as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;                         * method arguments are:
&nbsp;                         * &lt;ul&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the method&#39;s name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representation of the delegate&#39;s binary class name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} representing the receiver type of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the internal name of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} to the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} describing the instrumented type.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the instrumented method or constructor.&lt;/li&gt;
&nbsp;                         * &lt;/ul&gt;
&nbsp;                         *
&nbsp;                         * @param method The bootstrap method.
&nbsp;                         * @return A new builder for a delegation within a member substitution that uses the supplied method for bootstrapping.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bootstrap(Method method) {
<b class="fc">&nbsp;                            return bootstrap(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied method as a dynamic invocation bootstrap target for delegating advice methods.
&nbsp;                         *
&nbsp;                         * @param method          The bootstrap method or constructor.
&nbsp;                         * @param resolverFactory A factory for resolving the arguments to the bootstrap method.
&nbsp;                         * @return A new builder for a delegation within a member substitution that uses the supplied method for bootstrapping.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bootstrap(Method method, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="nc">&nbsp;                            return bootstrap(new MethodDescription.ForLoadedMethod(method), resolverFactory);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied method description as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;                         * method arguments are:
&nbsp;                         * &lt;ul&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the target&#39;s internal name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representation of the delegate&#39;s binary class name.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} representing the receiver type of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the internal name of the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} to the substituted element.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link Class} describing the instrumented type.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A {@link String} representing the instrumented method or constructor.&lt;/li&gt;
&nbsp;                         * &lt;li&gt;A method handle of the instrumented method or constructor, only if the instrumented method is not a type initializer.&lt;/li&gt;
&nbsp;                         * &lt;/ul&gt;
&nbsp;                         *
&nbsp;                         * @param bootstrap The bootstrap method or constructor.
&nbsp;                         * @return A new builder for a delegation within a member substitution that uses the supplied method or constructor for bootstrapping.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap) {
<b class="fc">&nbsp;                            return bootstrap(bootstrap, BootstrapArgumentResolver.ForDefaultValues.Factory.INSTANCE);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Defines the supplied method description as a dynamic invocation bootstrap target for delegating advice methods.
&nbsp;                         *
&nbsp;                         * @param bootstrap       The bootstrap method or constructor.
&nbsp;                         * @param resolverFactory A factory for resolving the arguments to the bootstrap method.
&nbsp;                         * @return A new builder for a delegation within a member substitution that uses the supplied method or constructor for bootstrapping.
&nbsp;                         */
&nbsp;                        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="fc">&nbsp;                            return new WithCustomMapping(Dispatcher.ForDynamicInvocation.of(bootstrap, resolverFactory), offsetMappings);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns a delegating step factory for the supplied method.
&nbsp;                         *
&nbsp;                         * @param method The method to delegate to.
&nbsp;                         * @return An appropriate step factory.
&nbsp;                         */
&nbsp;                        public Step.Factory to(Method method) {
<b class="fc">&nbsp;                            return to(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns a delegating step factory for the supplied constructor.
&nbsp;                         *
&nbsp;                         * @param constructor the constructor to delegate to.
&nbsp;                         * @return An appropriate step factory.
&nbsp;                         */
&nbsp;                        public Step.Factory to(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;                            return to(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns a delegating step factory for the supplied method description.
&nbsp;                         *
&nbsp;                         * @param methodDescription A description of the method or constructor to delegate to.
&nbsp;                         * @return An appropriate step factory.
&nbsp;                         */
&nbsp;                        public Step.Factory to(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                            return ForDelegation.to(methodDescription, dispatcherFactory, new ArrayList&lt;OffsetMapping.Factory&lt;?&gt;&gt;(offsetMappings.values()));</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a substitution chain.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Factory implements Substitution.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The assigner to use.
&nbsp;                 */
&nbsp;                private final Assigner assigner;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing of the assignment to use.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * The substitution steps to apply.
&nbsp;                 */
&nbsp;                private final List&lt;Step.Factory&gt; steps;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for a substitution chain.
&nbsp;                 *
&nbsp;                 * @param assigner The assigner to use.
&nbsp;                 * @param typing   The typing of the assignment to use.
&nbsp;                 * @param steps    The substitution steps to apply.
&nbsp;                 */
<b class="fc">&nbsp;                protected Factory(Assigner assigner, Assigner.Typing typing, List&lt;Step.Factory&gt; steps) {</b>
<b class="fc">&nbsp;                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
<b class="fc">&nbsp;                    this.steps = steps;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Substitution make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    if (steps.isEmpty()) {</b>
<b class="fc">&nbsp;                        return Stubbing.INSTANCE;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    List&lt;Step&gt; steps = new ArrayList&lt;Step&gt;(this.steps.size());</b>
<b class="fc">&nbsp;                    for (Step.Factory step : this.steps) {</b>
<b class="fc">&nbsp;                        steps.add(step.make(assigner, typing, instrumentedType, instrumentedMethod));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new Chain(assigner, typing, steps);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends the supplied steps to the substitution chain.
&nbsp;                 *
&nbsp;                 * @param step The steps to append.
&nbsp;                 * @return A new substitution chain that is equal to this substitution chain but with the supplied steps appended.
&nbsp;                 */
&nbsp;                public Factory executing(Step.Factory... step) {
<b class="nc">&nbsp;                    return executing(Arrays.asList(step));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Appends the supplied steps to the substitution chain.
&nbsp;                 *
&nbsp;                 * @param steps The steps to append.
&nbsp;                 * @return A new substitution chain that is equal to this substitution chain but with the supplied steps appended.
&nbsp;                 */
&nbsp;                public Factory executing(List&lt;? extends Step.Factory&gt; steps) {
<b class="fc">&nbsp;                    return new Factory(assigner, typing, CompoundList.of(this.steps, steps));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A replacement combines a {@link Substitution} and a way of choosing if this substitution should be applied for a discovered member.
&nbsp;     */
&nbsp;    protected interface Replacement {
&nbsp;
&nbsp;        /**
&nbsp;         * Binds this replacement for a field that was discovered.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param typeDescription    The type on which the field was read.
&nbsp;         * @param fieldDescription   The field that was discovered.
&nbsp;         * @param writeAccess        {@code true} if this field was written to.
&nbsp;         * @return A binding for the discovered field access.
&nbsp;         */
&nbsp;        Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess);
&nbsp;
&nbsp;        /**
&nbsp;         * Binds this replacement for a field that was discovered.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.FieldDescription
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param typeDescription    The type on which the method was invoked.
&nbsp;         * @param methodDescription  The method that was discovered.
&nbsp;         * @param invocationType     The invocation type for this method.
&nbsp;         * @return A binding for the discovered method invocation.
&nbsp;         */
&nbsp;        Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType);
&nbsp;
&nbsp;        /**
&nbsp;         * A binding for a replacement of a field or method access within another method.
&nbsp;         */
&nbsp;        interface Binding {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if this binding is resolved.
&nbsp;             *
&nbsp;             * @return {@code true} if this binding is resolved.
&nbsp;             */
&nbsp;            boolean isBound();
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a stack manipulation that represents the substitution. This method can only be called for actually bound bindings.
&nbsp;             *
&nbsp;             * @param parameters        The parameters that are accessible to the substitution target.
&nbsp;             * @param result            The result that is expected from the substitution target or {@code void} if none is expected.
&nbsp;             * @param methodHandle      A method handle that represents the original expression that is being substituted.
&nbsp;             * @param stackManipulation The original byte code expression that is being substituted.
&nbsp;             * @param freeOffset        The first offset that can be used for storing local variables.
&nbsp;             * @return A stack manipulation that represents the replacement.
&nbsp;             */
&nbsp;            StackManipulation make(TypeList.Generic parameters,
&nbsp;                                   TypeDescription.Generic result,
&nbsp;                                   JavaConstant.MethodHandle methodHandle,
&nbsp;                                   StackManipulation stackManipulation,
&nbsp;                                   int freeOffset);
&nbsp;
&nbsp;            /**
&nbsp;             * An unresolved binding.
&nbsp;             */
<b class="fc">&nbsp;            enum Unresolved implements Binding {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isBound() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation make(TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve unresolved binding&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A binding that was resolved for an actual substitution.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Resolved implements Binding {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type on which a field or method was accessed.
&nbsp;                 */
&nbsp;                private final TypeDescription receiver;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field or method that was accessed.
&nbsp;                 */
&nbsp;                private final ByteCodeElement.Member original;
&nbsp;
&nbsp;                /**
&nbsp;                 * The substitution to apply.
&nbsp;                 */
&nbsp;                private final Substitution substitution;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resolved binding.
&nbsp;                 *
&nbsp;                 * @param receiver     The type on which a field or method was accessed.
&nbsp;                 * @param original     The field or method that was accessed.
&nbsp;                 * @param substitution The substitution to apply.
&nbsp;                 */
<b class="fc">&nbsp;                protected Resolved(TypeDescription receiver, ByteCodeElement.Member original, Substitution substitution) {</b>
<b class="fc">&nbsp;                    this.receiver = receiver;</b>
<b class="fc">&nbsp;                    this.original = original;</b>
<b class="fc">&nbsp;                    this.substitution = substitution;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isBound() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation make(TypeList.Generic parameters, TypeDescription.Generic result, JavaConstant.MethodHandle methodHandle, StackManipulation stackManipulation, int freeOffset) {
<b class="fc">&nbsp;                    return substitution.resolve(receiver, original, parameters, result, methodHandle, stackManipulation, freeOffset);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a replacement for an instrumented method.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a replacement for an instrumented method.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param typePool           The type pool being used within the member substitution being applied.
&nbsp;             * @return A replacement to use within the supplied instrumented method.
&nbsp;             */
&nbsp;            Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool);
&nbsp;
&nbsp;            /**
&nbsp;             * A compound factory.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Compound implements Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of represented factories.
&nbsp;                 */
&nbsp;                private final List&lt;Factory&gt; factories;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound factory.
&nbsp;                 *
&nbsp;                 * @param factory A list of represented factories.
&nbsp;                 */
&nbsp;                protected Compound(Factory... factory) {
<b class="fc">&nbsp;                    this(Arrays.asList(factory));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound factory.
&nbsp;                 *
&nbsp;                 * @param factories A list of represented factories.
&nbsp;                 */
<b class="fc">&nbsp;                protected Compound(List&lt;? extends Factory&gt; factories) {</b>
<b class="fc">&nbsp;                    this.factories = new ArrayList&lt;Factory&gt;();</b>
<b class="fc">&nbsp;                    for (Factory factory : factories) {</b>
<b class="fc">&nbsp;                        if (factory instanceof Compound) {</b>
<b class="nc">&nbsp;                            this.factories.addAll(((Compound) factory).factories);</b>
<b class="fc">&nbsp;                        } else if (!(factory instanceof NoOp)) {</b>
<b class="fc">&nbsp;                            this.factories.add(factory);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    List&lt;Replacement&gt; replacements = new ArrayList&lt;Replacement&gt;();</b>
<b class="fc">&nbsp;                    for (Factory factory : factories) {</b>
<b class="fc">&nbsp;                        replacements.add(factory.make(instrumentedType, instrumentedMethod, typePool));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new ForFirstBinding(replacements);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes a method invocation type.
&nbsp;         */
<b class="fc">&nbsp;        enum InvocationType {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Describes a virtual method invocation.
&nbsp;             */
<b class="fc">&nbsp;            VIRTUAL,</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Describes a super method invocation.
&nbsp;             */
<b class="fc">&nbsp;            SUPER,</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Describes any method invocation that is not virtual or a super method invocation.
&nbsp;             */
<b class="fc">&nbsp;            OTHER;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an invocation type.
&nbsp;             *
&nbsp;             * @param opcode            The opcode that is used for invoking the method.
&nbsp;             * @param methodDescription The method that is being invoked.
&nbsp;             * @return The invocation type for the method given that opcode.
&nbsp;             */
&nbsp;            protected static InvocationType of(int opcode, MethodDescription methodDescription) {
<b class="fc">&nbsp;                switch (opcode) {</b>
&nbsp;                    case Opcodes.INVOKEVIRTUAL:
&nbsp;                    case Opcodes.INVOKEINTERFACE:
<b class="fc">&nbsp;                        return InvocationType.VIRTUAL;</b>
&nbsp;                    case Opcodes.INVOKESPECIAL:
<b class="fc">&nbsp;                        return methodDescription.isVirtual() ? SUPER : OTHER;</b>
&nbsp;                    default:
<b class="fc">&nbsp;                        return OTHER;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if this invocation type matches the specified inputs.
&nbsp;             *
&nbsp;             * @param includeVirtualCalls {@code true} if a virtual method should be matched.
&nbsp;             * @param includeSuperCalls   {@code true} if a super method call should be matched.
&nbsp;             * @return {@code true} if this invocation type matches the specified parameters.
&nbsp;             */
&nbsp;            protected boolean matches(boolean includeVirtualCalls, boolean includeSuperCalls) {
<b class="fc">&nbsp;                switch (this) {</b>
&nbsp;                    case VIRTUAL:
<b class="fc">&nbsp;                        return includeVirtualCalls;</b>
&nbsp;                    case SUPER:
<b class="fc">&nbsp;                        return includeSuperCalls;</b>
&nbsp;                    default:
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational replacement.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements Replacement, Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Binding bind(TypeDescription instrumentedType,
&nbsp;                                MethodDescription instrumentedMethod,
&nbsp;                                TypeDescription typeDescription,
&nbsp;                                FieldDescription fieldDescription,
&nbsp;                                boolean writeAccess) {
<b class="nc">&nbsp;                return Binding.Unresolved.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Binding bind(TypeDescription instrumentedType,
&nbsp;                                MethodDescription instrumentedMethod,
&nbsp;                                TypeDescription typeDescription,
&nbsp;                                MethodDescription methodDescription,
&nbsp;                                InvocationType invocationType) {
<b class="nc">&nbsp;                return Binding.Unresolved.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A replacement that substitutes a member based on a row of element matchers.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForElementMatchers implements Replacement {
&nbsp;
&nbsp;            /**
&nbsp;             * The field matcher to consider when discovering fields.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super FieldDescription&gt; fieldMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * The method matcher to consider when discovering methods.
&nbsp;             */
&nbsp;            private final ElementMatcher&lt;? super MethodDescription&gt; methodMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if field reading access should be matched.
&nbsp;             */
&nbsp;            private final boolean matchFieldRead;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if field writing access should be matched.
&nbsp;             */
&nbsp;            private final boolean matchFieldWrite;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if virtual method calls should be matched.
&nbsp;             */
&nbsp;            private final boolean includeVirtualCalls;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if super method calls should be matched.
&nbsp;             */
&nbsp;            private final boolean includeSuperCalls;
&nbsp;
&nbsp;            /**
&nbsp;             * The substitution to trigger if a member is matched.
&nbsp;             */
&nbsp;            private final Substitution substitution;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new replacement that triggers a substitution based on a row of matchers.
&nbsp;             *
&nbsp;             * @param fieldMatcher        The field matcher to consider when discovering fields.
&nbsp;             * @param methodMatcher       The method matcher to consider when discovering methods.
&nbsp;             * @param matchFieldRead      {@code true} if field reading access should be matched.
&nbsp;             * @param matchFieldWrite     {@code true} if field writing access should be matched.
&nbsp;             * @param includeVirtualCalls {@code true} if virtual method calls should be matched.
&nbsp;             * @param includeSuperCalls   {@code true} if super method calls should be matched.
&nbsp;             * @param substitution        The substitution to trigger if a member is matched.
&nbsp;             */
&nbsp;            protected ForElementMatchers(ElementMatcher&lt;? super FieldDescription&gt; fieldMatcher,
&nbsp;                                         ElementMatcher&lt;? super MethodDescription&gt; methodMatcher,
&nbsp;                                         boolean matchFieldRead,
&nbsp;                                         boolean matchFieldWrite,
&nbsp;                                         boolean includeVirtualCalls,
&nbsp;                                         boolean includeSuperCalls,
<b class="fc">&nbsp;                                         Substitution substitution) {</b>
<b class="fc">&nbsp;                this.fieldMatcher = fieldMatcher;</b>
<b class="fc">&nbsp;                this.methodMatcher = methodMatcher;</b>
<b class="fc">&nbsp;                this.matchFieldRead = matchFieldRead;</b>
<b class="fc">&nbsp;                this.matchFieldWrite = matchFieldWrite;</b>
<b class="fc">&nbsp;                this.includeVirtualCalls = includeVirtualCalls;</b>
<b class="fc">&nbsp;                this.includeSuperCalls = includeSuperCalls;</b>
<b class="fc">&nbsp;                this.substitution = substitution;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess) {
<b class="fc">&nbsp;                return (writeAccess ? matchFieldWrite : matchFieldRead) &amp;&amp; fieldMatcher.matches(fieldDescription)</b>
<b class="fc">&nbsp;                        ? new Binding.Resolved(typeDescription, fieldDescription, substitution)</b>
<b class="fc">&nbsp;                        : Binding.Unresolved.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType) {
<b class="fc">&nbsp;                return invocationType.matches(includeVirtualCalls, includeSuperCalls) &amp;&amp; methodMatcher.matches(methodDescription)</b>
<b class="fc">&nbsp;                        ? new Binding.Resolved(typeDescription, methodDescription, substitution)</b>
<b class="fc">&nbsp;                        : Binding.Unresolved.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a replacement that chooses members based on a row of element matchers.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements Replacement.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field matcher to consider when discovering fields.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super FieldDescription&gt; fieldMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * The method matcher to consider when discovering methods.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;? super MethodDescription&gt; methodMatcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if field reading access should be matched.
&nbsp;                 */
&nbsp;                private final boolean matchFieldRead;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if field writing access should be matched.
&nbsp;                 */
&nbsp;                private final boolean matchFieldWrite;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if virtual method calls should be matched.
&nbsp;                 */
&nbsp;                private final boolean includeVirtualCalls;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if super method calls should be matched.
&nbsp;                 */
&nbsp;                private final boolean includeSuperCalls;
&nbsp;
&nbsp;                /**
&nbsp;                 * The substitution factory to create a substitution from.
&nbsp;                 */
&nbsp;                private final Substitution.Factory substitutionFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new replacement that triggers a substitution based on a row of matchers.
&nbsp;                 *
&nbsp;                 * @param fieldMatcher        The field matcher to consider when discovering fields.
&nbsp;                 * @param methodMatcher       The method matcher to consider when discovering methods.
&nbsp;                 * @param matchFieldRead      {@code true} if field reading access should be matched.
&nbsp;                 * @param matchFieldWrite     {@code true} if field writing access should be matched.
&nbsp;                 * @param includeVirtualCalls {@code true} if virtual method calls should be matched.
&nbsp;                 * @param includeSuperCalls   {@code true} if super method calls should be matched.
&nbsp;                 * @param substitutionFactory The substitution factory to create a substitution from.
&nbsp;                 */
&nbsp;                protected Factory(ElementMatcher&lt;? super FieldDescription&gt; fieldMatcher,
&nbsp;                                  ElementMatcher&lt;? super MethodDescription&gt; methodMatcher,
&nbsp;                                  boolean matchFieldRead,
&nbsp;                                  boolean matchFieldWrite,
&nbsp;                                  boolean includeVirtualCalls,
&nbsp;                                  boolean includeSuperCalls,
<b class="fc">&nbsp;                                  Substitution.Factory substitutionFactory) {</b>
<b class="fc">&nbsp;                    this.fieldMatcher = fieldMatcher;</b>
<b class="fc">&nbsp;                    this.methodMatcher = methodMatcher;</b>
<b class="fc">&nbsp;                    this.matchFieldRead = matchFieldRead;</b>
<b class="fc">&nbsp;                    this.matchFieldWrite = matchFieldWrite;</b>
<b class="fc">&nbsp;                    this.includeVirtualCalls = includeVirtualCalls;</b>
<b class="fc">&nbsp;                    this.includeSuperCalls = includeSuperCalls;</b>
<b class="fc">&nbsp;                    this.substitutionFactory = substitutionFactory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for applying a substitution on all matched byte code elements for all access types.
&nbsp;                 *
&nbsp;                 * @param matcher The matcher to apply.
&nbsp;                 * @param factory The substitution factory to create a substitution from.
&nbsp;                 * @return An appropriate replacement factory for the supplied matcher and substitution factory.
&nbsp;                 */
&nbsp;                protected static Replacement.Factory of(ElementMatcher&lt;? super ByteCodeElement.Member&gt; matcher, Substitution.Factory factory) {
<b class="nc">&nbsp;                    return new Factory(matcher, matcher, true, true, true, true, factory);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory that only matches field access for given access types.
&nbsp;                 *
&nbsp;                 * @param matcher         The matcher to identify fields for substitution.
&nbsp;                 * @param matchFieldRead  {@code true} if field read access should be matched.
&nbsp;                 * @param matchFieldWrite {@code true} if field write access should be matched.
&nbsp;                 * @param factory         The substitution factory to apply for fields that match the specified criteria.
&nbsp;                 * @return An appropriate replacement factory.
&nbsp;                 */
&nbsp;                protected static Replacement.Factory ofField(ElementMatcher&lt;? super FieldDescription&gt; matcher, boolean matchFieldRead, boolean matchFieldWrite, Substitution.Factory factory) {
<b class="fc">&nbsp;                    return new Factory(matcher, none(), matchFieldRead, matchFieldWrite, false, false, factory);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory that only matches method and constructor invocations for given invocation types.
&nbsp;                 *
&nbsp;                 * @param matcher             The matcher to identify methods and constructors for substitution.
&nbsp;                 * @param includeVirtualCalls {@code true} if virtual method calls should be matched.
&nbsp;                 * @param includeSuperCalls   {@code true} if super method calls should be matched.
&nbsp;                 * @param factory             The substitution factory to apply for methods and constructors that match the specified criteria.
&nbsp;                 * @return An appropriate replacement factory.
&nbsp;                 */
&nbsp;                protected static Replacement.Factory ofMethod(ElementMatcher&lt;? super MethodDescription&gt; matcher, boolean includeVirtualCalls, boolean includeSuperCalls, Substitution.Factory factory) {
<b class="fc">&nbsp;                    return new Factory(none(), matcher, false, false, includeVirtualCalls, includeSuperCalls, factory);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Replacement make(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypePool typePool) {
<b class="fc">&nbsp;                    return new ForElementMatchers(fieldMatcher,</b>
&nbsp;                            methodMatcher,
&nbsp;                            matchFieldRead,
&nbsp;                            matchFieldWrite,
&nbsp;                            includeVirtualCalls,
&nbsp;                            includeSuperCalls,
<b class="fc">&nbsp;                            substitutionFactory.make(instrumentedType, instrumentedMethod, typePool));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A replacement that only resolves the first matching replacement of a list of replacements.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForFirstBinding implements Replacement {
&nbsp;
&nbsp;            /**
&nbsp;             * The list of replacements to consider.
&nbsp;             */
&nbsp;            private final List&lt;? extends Replacement&gt; replacements;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new replacement that triggers the first matching replacement, if any.
&nbsp;             *
&nbsp;             * @param replacements The list of replacements to consider.
&nbsp;             */
<b class="fc">&nbsp;            protected ForFirstBinding(List&lt;? extends Replacement&gt; replacements) {</b>
<b class="fc">&nbsp;                this.replacements = replacements;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, FieldDescription fieldDescription, boolean writeAccess) {
<b class="fc">&nbsp;                for (Replacement replacement : replacements) {</b>
<b class="fc">&nbsp;                    Binding binding = replacement.bind(instrumentedType, instrumentedMethod, typeDescription, fieldDescription, writeAccess);</b>
<b class="fc">&nbsp;                    if (binding.isBound()) {</b>
<b class="fc">&nbsp;                        return binding;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return Binding.Unresolved.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Binding bind(TypeDescription instrumentedType, MethodDescription instrumentedMethod, TypeDescription typeDescription, MethodDescription methodDescription, InvocationType invocationType) {
<b class="fc">&nbsp;                for (Replacement replacement : replacements) {</b>
<b class="fc">&nbsp;                    Binding binding = replacement.bind(instrumentedType, instrumentedMethod, typeDescription, methodDescription, invocationType);</b>
<b class="fc">&nbsp;                    if (binding.isBound()) {</b>
<b class="fc">&nbsp;                        return binding;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return Binding.Unresolved.INSTANCE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method visitor that applies a substitution for matched methods.
&nbsp;     */
<b class="fc">&nbsp;    protected static class SubstitutingMethodVisitor extends LocalVariableAwareMethodVisitor {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented type.
&nbsp;         */
&nbsp;        private final TypeDescription instrumentedType;
&nbsp;
&nbsp;        /**
&nbsp;         * The instrumented method.
&nbsp;         */
&nbsp;        private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The method graph compiler to use.
&nbsp;         */
&nbsp;        private final MethodGraph.Compiler methodGraphCompiler;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;         */
&nbsp;        private final boolean strict;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;         */
&nbsp;        private final boolean failIfNoMatch;
&nbsp;
&nbsp;        /**
&nbsp;         * The replacement to use for creating substitutions.
&nbsp;         */
&nbsp;        private final Replacement replacement;
&nbsp;
&nbsp;        /**
&nbsp;         * The implementation context to use.
&nbsp;         */
&nbsp;        private final Implementation.Context implementationContext;
&nbsp;
&nbsp;        /**
&nbsp;         * The type pool to use.
&nbsp;         */
&nbsp;        private final TypePool typePool;
&nbsp;
&nbsp;        /**
&nbsp;         * If {@code true}, virtual method calls might target private methods in accordance to the nest mate specification.
&nbsp;         */
&nbsp;        private final boolean virtualPrivateCalls;
&nbsp;
&nbsp;        /**
&nbsp;         * An additional buffer for the operand stack that is required.
&nbsp;         */
&nbsp;        private int stackSizeBuffer;
&nbsp;
&nbsp;        /**
&nbsp;         * The minimum amount of local variable array slots that are required to apply substitutions.
&nbsp;         */
&nbsp;        private int localVariableExtension;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if at least one member was substituted during the application of this visitor.
&nbsp;         */
&nbsp;        private boolean matched;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new substituting method visitor.
&nbsp;         *
&nbsp;         * @param methodVisitor         The method visitor to delegate to.
&nbsp;         * @param instrumentedType      The instrumented type.
&nbsp;         * @param instrumentedMethod    The instrumented method.
&nbsp;         * @param methodGraphCompiler   The method graph compiler to use.
&nbsp;         * @param strict                {@code true} if the method processing should be strict where an exception is raised if a member cannot be found.
&nbsp;         * @param failIfNoMatch         {@code true} if the instrumentation should fail if applied to a method without match.
&nbsp;         * @param replacement           The replacement to use for creating substitutions.
&nbsp;         * @param implementationContext The implementation context to use.
&nbsp;         * @param typePool              The type pool to use.
&nbsp;         * @param virtualPrivateCalls   {@code true}, virtual method calls might target private methods in accordance to the nest mate specification.
&nbsp;         */
&nbsp;        protected SubstitutingMethodVisitor(MethodVisitor methodVisitor,
&nbsp;                                            TypeDescription instrumentedType,
&nbsp;                                            MethodDescription instrumentedMethod,
&nbsp;                                            MethodGraph.Compiler methodGraphCompiler,
&nbsp;                                            boolean strict,
&nbsp;                                            boolean failIfNoMatch,
&nbsp;                                            Replacement replacement,
&nbsp;                                            Implementation.Context implementationContext,
&nbsp;                                            TypePool typePool,
&nbsp;                                            boolean virtualPrivateCalls) {
<b class="fc">&nbsp;            super(methodVisitor, instrumentedMethod);</b>
<b class="fc">&nbsp;            this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;            this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;            this.methodGraphCompiler = methodGraphCompiler;</b>
<b class="fc">&nbsp;            this.strict = strict;</b>
<b class="fc">&nbsp;            this.failIfNoMatch = failIfNoMatch;</b>
<b class="fc">&nbsp;            this.replacement = replacement;</b>
<b class="fc">&nbsp;            this.implementationContext = implementationContext;</b>
<b class="fc">&nbsp;            this.typePool = typePool;</b>
<b class="fc">&nbsp;            this.virtualPrivateCalls = virtualPrivateCalls;</b>
<b class="fc">&nbsp;            stackSizeBuffer = 0;</b>
<b class="fc">&nbsp;            localVariableExtension = 0;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void visitFieldInsn(int opcode, String owner, String internalName, String descriptor) {
<b class="fc">&nbsp;            TypePool.Resolution resolution = typePool.describe(owner.replace(&#39;/&#39;, &#39;.&#39;));</b>
<b class="fc">&nbsp;            if (resolution.isResolved()) {</b>
&nbsp;                FieldList&lt;?&gt; candidates;
<b class="fc">&nbsp;                Iterator&lt;TypeDefinition&gt; iterator = resolution.resolve().iterator();</b>
&nbsp;                do {
<b class="fc">&nbsp;                    candidates = iterator.next().getDeclaredFields().filter(strict</b>
<b class="fc">&nbsp;                            ? ElementMatchers.&lt;FieldDescription&gt;named(internalName).and(hasDescriptor(descriptor))</b>
<b class="nc">&nbsp;                            : ElementMatchers.&lt;FieldDescription&gt;failSafe(named(internalName).and(hasDescriptor(descriptor))));</b>
<b class="fc">&nbsp;                } while (iterator.hasNext() &amp;&amp; candidates.isEmpty());</b>
<b class="fc">&nbsp;                if (!candidates.isEmpty()) {</b>
<b class="fc">&nbsp;                    Replacement.Binding binding = replacement.bind(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
<b class="fc">&nbsp;                            resolution.resolve(),</b>
<b class="fc">&nbsp;                            candidates.getOnly(),</b>
&nbsp;                            opcode == Opcodes.PUTFIELD || opcode == Opcodes.PUTSTATIC);
<b class="fc">&nbsp;                    if (binding.isBound()) {</b>
&nbsp;                        TypeList.Generic parameters;
&nbsp;                        TypeDescription.Generic result;
&nbsp;                        boolean read;
<b class="fc">&nbsp;                        switch (opcode) {</b>
&nbsp;                            case Opcodes.PUTFIELD:
<b class="fc">&nbsp;                                parameters = new TypeList.Generic.Explicit(candidates.getOnly().getDeclaringType(), candidates.getOnly().getType());</b>
<b class="fc">&nbsp;                                result = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);</b>
<b class="fc">&nbsp;                                read = false;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.PUTSTATIC:
<b class="fc">&nbsp;                                parameters = new TypeList.Generic.Explicit(candidates.getOnly().getType());</b>
<b class="fc">&nbsp;                                result = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);</b>
<b class="fc">&nbsp;                                read = false;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.GETFIELD:
<b class="fc">&nbsp;                                parameters = new TypeList.Generic.Explicit(candidates.getOnly().getDeclaringType());</b>
<b class="fc">&nbsp;                                result = candidates.getOnly().getType();</b>
<b class="fc">&nbsp;                                read = true;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.GETSTATIC:
<b class="fc">&nbsp;                                parameters = new TypeList.Generic.Empty();</b>
<b class="fc">&nbsp;                                result = candidates.getOnly().getType();</b>
<b class="fc">&nbsp;                                read = true;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            default:
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Unexpected opcode: &quot; + opcode);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        stackSizeBuffer = Math.max(stackSizeBuffer, binding.make(parameters,</b>
&nbsp;                                result,
<b class="fc">&nbsp;                                read</b>
<b class="fc">&nbsp;                                        ? JavaConstant.MethodHandle.ofGetter(candidates.getOnly().asDefined())</b>
<b class="fc">&nbsp;                                        : JavaConstant.MethodHandle.ofSetter(candidates.getOnly().asDefined()),</b>
<b class="fc">&nbsp;                                read</b>
<b class="fc">&nbsp;                                        ? FieldAccess.forField(candidates.getOnly()).read()</b>
<b class="fc">&nbsp;                                        : FieldAccess.forField(candidates.getOnly()).write(),</b>
<b class="fc">&nbsp;                                getFreeOffset()).apply(new LocalVariableTracingMethodVisitor(mv), implementationContext).getMaximalSize());</b>
<b class="fc">&nbsp;                        matched = true;</b>
&nbsp;                        return;
&nbsp;                    }
<b class="fc">&nbsp;                } else if (strict) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not resolve &quot; + owner.replace(&#39;/&#39;, &#39;.&#39;) + &quot;.&quot; + internalName + descriptor + &quot; using &quot; + typePool);</b>
&nbsp;                }
<b class="fc">&nbsp;            } else if (strict) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Could not resolve &quot; + owner.replace(&#39;/&#39;, &#39;.&#39;) + &quot; using &quot; + typePool);</b>
&nbsp;            }
<b class="fc">&nbsp;            super.visitFieldInsn(opcode, owner, internalName, descriptor);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void visitMethodInsn(int opcode, String owner, String internalName, String descriptor, boolean isInterface) {
<b class="fc">&nbsp;            TypePool.Resolution resolution = typePool.describe(owner.replace(&#39;/&#39;, &#39;.&#39;));</b>
<b class="fc">&nbsp;            if (resolution.isResolved()) {</b>
&nbsp;                MethodList&lt;?&gt; candidates;
<b class="fc">&nbsp;                if (opcode == Opcodes.INVOKESPECIAL &amp;&amp; internalName.equals(MethodDescription.CONSTRUCTOR_INTERNAL_NAME)) {</b>
<b class="fc">&nbsp;                    candidates = resolution.resolve().getDeclaredMethods().filter(strict</b>
<b class="fc">&nbsp;                            ? ElementMatchers.&lt;MethodDescription&gt;isConstructor().and(hasDescriptor(descriptor))</b>
<b class="nc">&nbsp;                            : ElementMatchers.&lt;MethodDescription&gt;failSafe(isConstructor().and(hasDescriptor(descriptor))));</b>
<b class="fc">&nbsp;                } else if (opcode == Opcodes.INVOKESTATIC) {</b>
<b class="fc">&nbsp;                    Iterator&lt;TypeDefinition&gt; iterator = resolution.resolve().iterator();</b>
&nbsp;                    do {
<b class="fc">&nbsp;                        candidates = iterator.next().getDeclaredMethods().filter(strict</b>
<b class="fc">&nbsp;                                ? ElementMatchers.&lt;MethodDescription&gt;named(internalName).and(hasDescriptor(descriptor))</b>
<b class="nc">&nbsp;                                : ElementMatchers.&lt;MethodDescription&gt;failSafe(named(internalName).and(hasDescriptor(descriptor))));</b>
<b class="fc">&nbsp;                    } while (iterator.hasNext() &amp;&amp; candidates.isEmpty());</b>
<b class="fc">&nbsp;                } else if (opcode == Opcodes.INVOKESPECIAL) {</b>
<b class="fc">&nbsp;                    candidates = resolution.resolve().getDeclaredMethods().filter(strict</b>
<b class="fc">&nbsp;                            ? ElementMatchers.&lt;MethodDescription&gt;named(internalName).and(hasDescriptor(descriptor))</b>
<b class="nc">&nbsp;                            : ElementMatchers.&lt;MethodDescription&gt;failSafe(named(internalName).and(hasDescriptor(descriptor))));</b>
<b class="fc">&nbsp;                } else if (virtualPrivateCalls) {</b>
<b class="nc">&nbsp;                    candidates = resolution.resolve().getDeclaredMethods().filter(strict</b>
<b class="nc">&nbsp;                            ? ElementMatchers.&lt;MethodDescription&gt;isPrivate().and(not(isStatic())).and(named(internalName).and(hasDescriptor(descriptor)))</b>
<b class="nc">&nbsp;                            : ElementMatchers.&lt;MethodDescription&gt;failSafe(isPrivate().&lt;MethodDescription&gt;and(not(isStatic())).and(named(internalName).and(hasDescriptor(descriptor)))));</b>
<b class="nc">&nbsp;                    if (candidates.isEmpty()) {</b>
<b class="nc">&nbsp;                        candidates = methodGraphCompiler.compile((TypeDefinition) resolution.resolve(), instrumentedType).listNodes().asMethodList().filter(strict</b>
<b class="nc">&nbsp;                                ? ElementMatchers.&lt;MethodDescription&gt;named(internalName).and(hasDescriptor(descriptor))</b>
<b class="nc">&nbsp;                                : ElementMatchers.&lt;MethodDescription&gt;failSafe(named(internalName).and(hasDescriptor(descriptor))));</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    candidates = methodGraphCompiler.compile((TypeDefinition) resolution.resolve(), instrumentedType).listNodes().asMethodList().filter(strict</b>
<b class="fc">&nbsp;                            ? ElementMatchers.&lt;MethodDescription&gt;named(internalName).and(hasDescriptor(descriptor))</b>
<b class="nc">&nbsp;                            : ElementMatchers.&lt;MethodDescription&gt;failSafe(named(internalName).and(hasDescriptor(descriptor))));</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!candidates.isEmpty()) {</b>
<b class="fc">&nbsp;                    Replacement.Binding binding = replacement.bind(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
<b class="fc">&nbsp;                            resolution.resolve(),</b>
<b class="fc">&nbsp;                            candidates.getOnly(),</b>
<b class="fc">&nbsp;                            Replacement.InvocationType.of(opcode, candidates.getOnly()));</b>
<b class="fc">&nbsp;                    if (binding.isBound()) {</b>
<b class="fc">&nbsp;                        StackManipulation.Size size = binding.make(</b>
<b class="fc">&nbsp;                                candidates.getOnly().isStatic() || candidates.getOnly().isConstructor()</b>
<b class="fc">&nbsp;                                        ? candidates.getOnly().getParameters().asTypeList()</b>
<b class="fc">&nbsp;                                        : new TypeList.Generic.Explicit(CompoundList.of(resolution.resolve(), candidates.getOnly().getParameters().asTypeList())),</b>
<b class="fc">&nbsp;                                candidates.getOnly().isConstructor()</b>
<b class="fc">&nbsp;                                        ? candidates.getOnly().getDeclaringType().asGenericType()</b>
<b class="fc">&nbsp;                                        : candidates.getOnly().getReturnType(),</b>
<b class="fc">&nbsp;                                opcode == Opcodes.INVOKESPECIAL &amp;&amp; candidates.getOnly().isMethod() &amp;&amp; !candidates.getOnly().isPrivate()</b>
<b class="fc">&nbsp;                                        ? JavaConstant.MethodHandle.ofSpecial(candidates.getOnly().asDefined(), resolution.resolve())</b>
<b class="fc">&nbsp;                                        : JavaConstant.MethodHandle.of(candidates.getOnly().asDefined()),</b>
<b class="fc">&nbsp;                                opcode == Opcodes.INVOKESPECIAL &amp;&amp; candidates.getOnly().isMethod() &amp;&amp; !candidates.getOnly().isPrivate()</b>
<b class="fc">&nbsp;                                        ? MethodInvocation.invoke(candidates.getOnly()).special(resolution.resolve())</b>
<b class="fc">&nbsp;                                        : MethodInvocation.invoke(candidates.getOnly()), getFreeOffset()).apply(new LocalVariableTracingMethodVisitor(mv), implementationContext);</b>
<b class="fc">&nbsp;                        if (candidates.getOnly().isConstructor()) {</b>
<b class="fc">&nbsp;                            stackSizeBuffer = Math.max(stackSizeBuffer, size.getMaximalSize() + 2);</b>
<b class="fc">&nbsp;                            stackSizeBuffer = Math.max(stackSizeBuffer, new StackManipulation.Compound(Duplication.SINGLE.flipOver(TypeDescription.ForLoadedType.of(Object.class)),</b>
&nbsp;                                    Removal.SINGLE,
&nbsp;                                    Removal.SINGLE,
<b class="fc">&nbsp;                                    Duplication.SINGLE.flipOver(TypeDescription.ForLoadedType.of(Object.class)),</b>
&nbsp;                                    Removal.SINGLE,
<b class="fc">&nbsp;                                    Removal.SINGLE).apply(mv, implementationContext).getMaximalSize() + StackSize.SINGLE.getSize());</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            stackSizeBuffer = Math.max(stackSizeBuffer, size.getMaximalSize());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        matched = true;</b>
&nbsp;                        return;
&nbsp;                    }
<b class="fc">&nbsp;                } else if (strict) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Could not resolve &quot; + owner.replace(&#39;/&#39;, &#39;.&#39;) + &quot;.&quot; + internalName + descriptor + &quot; using &quot; + typePool);</b>
&nbsp;                }
<b class="fc">&nbsp;            } else if (strict) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Could not resolve &quot; + owner.replace(&#39;/&#39;, &#39;.&#39;) + &quot; using &quot; + typePool);</b>
&nbsp;            }
<b class="fc">&nbsp;            super.visitMethodInsn(opcode, owner, internalName, descriptor, isInterface);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void visitMaxs(int stackSize, int localVariableLength) {
<b class="fc">&nbsp;            if (failIfNoMatch &amp;&amp; !matched) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;No substitution found within &quot; + instrumentedMethod + &quot; of &quot; + instrumentedType);</b>
&nbsp;            }
<b class="fc">&nbsp;            super.visitMaxs(stackSize + stackSizeBuffer, Math.max(localVariableExtension, localVariableLength));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method visitor that traces offsets of the local variable array being used.
&nbsp;         */
<b class="fc">&nbsp;        private class LocalVariableTracingMethodVisitor extends MethodVisitor {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new local variable tracing method visitor.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor to delegate to.
&nbsp;             */
<b class="fc">&nbsp;            private LocalVariableTracingMethodVisitor(MethodVisitor methodVisitor) {</b>
<b class="fc">&nbsp;                super(OpenedClassReader.ASM_API, methodVisitor);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;SF_SWITCH_NO_DEFAULT&quot;, justification = &quot;No action required on default option.&quot;)
&nbsp;            public void visitVarInsn(int opcode, int offset) {
<b class="fc">&nbsp;                switch (opcode) {</b>
&nbsp;                    case Opcodes.ISTORE:
&nbsp;                    case Opcodes.FSTORE:
&nbsp;                    case Opcodes.ASTORE:
<b class="fc">&nbsp;                        localVariableExtension = Math.max(localVariableExtension, offset + 1);</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.LSTORE:
&nbsp;                    case Opcodes.DSTORE:
<b class="fc">&nbsp;                        localVariableExtension = Math.max(localVariableExtension, offset + 2);</b>
&nbsp;                        break;
&nbsp;                }
<b class="fc">&nbsp;                super.visitVarInsn(opcode, offset);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the {@code this} reference of the substituted field,
&nbsp;     * method, constructor or of the instrumented method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.This} or
&nbsp;     * {@link net.bytebuddy.asm.Advice.This}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
&nbsp;    public @interface This {
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the {@code this} value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the source that is considered for this annotation which can be either the substituted method,
&nbsp;         * constructor or field, or the instrumented method.
&nbsp;         *
&nbsp;         * @return The source that is considered for this annotation.
&nbsp;         */
&nbsp;        Source source() default Source.SUBSTITUTED_ELEMENT;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the parameter should be assigned {@code null} if no {@code this} parameter is available.
&nbsp;         *
&nbsp;         * @return {@code true} if the value assignment is optional.
&nbsp;         */
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the parameter with index {@link Argument#value()}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.Argument} or
&nbsp;     * {@link net.bytebuddy.asm.Advice.Argument}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
&nbsp;    public @interface Argument {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the index of the parameter that is being assigned.
&nbsp;         *
&nbsp;         * @return The index of the parameter that is being assigned.
&nbsp;         */
&nbsp;        int value();
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the argument.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the source that is considered for this annotation which can be either the substituted method,
&nbsp;         * constructor or field, or the instrumented method.
&nbsp;         *
&nbsp;         * @return The source that is considered for this annotation.
&nbsp;         */
&nbsp;        Source source() default Source.SUBSTITUTED_ELEMENT;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the parameter should be assigned {@code null} if no argument with the specified index is available.
&nbsp;         *
&nbsp;         * @return {@code true} if the value assignment is optional.
&nbsp;         */
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Assigns an array containing all arguments of the targeted element to the annotated parameter. The annotated parameter must
&nbsp;     * be an array type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.AllArguments} or
&nbsp;     * {@link net.bytebuddy.asm.Advice.AllArguments}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface AllArguments {
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the arguments to an array element.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the source that is considered for this annotation which can be either the substituted method,
&nbsp;         * constructor or field, or the instrumented method.
&nbsp;         *
&nbsp;         * @return The source that is considered for this annotation.
&nbsp;         */
&nbsp;        Source source() default Source.SUBSTITUTED_ELEMENT;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the produced array should include the instrumented method&#39;s target reference within the array, if
&nbsp;         * the targeted element is non-static.
&nbsp;         *
&nbsp;         * @return {@code true} if a possible {@code this} reference should be included in the assigned array.
&nbsp;         */
&nbsp;        boolean includeSelf() default false;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if {@code null} should be assigned to the annotated parameter to the annotated parameter.
&nbsp;         *
&nbsp;         * @return {@code true} if {@code null} should be assigned to the annotated parameter to the annotated parameter.
&nbsp;         */
&nbsp;        boolean nullIfEmpty() default false;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should load a {@code java.lang.invoke.MethodHandle} that represents an invocation of
&nbsp;     * the substituted expression or instrumented method. If the current method is virtual, it is bound to the current instance such
&nbsp;     * that the virtual hierarchy is avoided. This annotation cannot be used to acquire a handle on enclosing constructors.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.asm.Advice.SelfCallHandle}. This annotation should
&nbsp;     * be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface SelfCallHandle {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the source that is considered for this annotation which can be either the substituted method,
&nbsp;         * constructor or field, or the instrumented method.
&nbsp;         *
&nbsp;         * @return The source that is considered for this annotation.
&nbsp;         */
&nbsp;        Source source() default Source.SUBSTITUTED_ELEMENT;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the method is bound to the arguments and instance of the represented invocation.
&nbsp;         *
&nbsp;         * @return {@code true} if the handle should be bound to the current arguments.
&nbsp;         */
&nbsp;        boolean bound() default true;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a field in the scope of the instrumented type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Setting {@link FieldValue#value()} is optional. If the value is not set, the field value attempts to bind a setter&#39;s
&nbsp;     * or getter&#39;s field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
&nbsp;     * to be an illegal candidate for binding.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.FieldValue} or
&nbsp;     * {@link net.bytebuddy.asm.Advice.FieldValue}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
&nbsp;    public @interface FieldValue {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the field.
&nbsp;         *
&nbsp;         * @return The name of the field.
&nbsp;         */
&nbsp;        String value() default Substitution.Chain.Step.ForDelegation.OffsetMapping.ForField.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type that declares the field that should be mapped to the annotated parameter. If this property
&nbsp;         * is set to {@code void}, the field is looked up implicitly within the instrumented class&#39;s class hierarchy.
&nbsp;         * The value can also be set to {@link TargetType} in order to look up the type on the instrumented type.
&nbsp;         *
&nbsp;         * @return The type that declares the field, {@code void} if this type should be determined implicitly or
&nbsp;         * {@link TargetType} for the instrumented type.
&nbsp;         */
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the field value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a {@code java.lang.invoke.MethodHandle} representing a field getter.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Setting {@link FieldValue#value()} is optional. If the value is not set, the field value attempts to bind a setter&#39;s
&nbsp;     * or getter&#39;s field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
&nbsp;     * to be an illegal candidate for binding.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.FieldGetterHandle} or
&nbsp;     * {@link net.bytebuddy.asm.Advice.FieldGetterHandle}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface FieldGetterHandle {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the field.
&nbsp;         *
&nbsp;         * @return The name of the field.
&nbsp;         */
&nbsp;        String value() default Substitution.Chain.Step.ForDelegation.OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type that declares the field that should be mapped to the annotated parameter. If this property
&nbsp;         * is set to {@code void}, the field is looked up implicitly within the instrumented class&#39;s class hierarchy.
&nbsp;         * The value can also be set to {@link TargetType} in order to look up the type on the instrumented type.
&nbsp;         *
&nbsp;         * @return The type that declares the field, {@code void} if this type should be determined implicitly or
&nbsp;         * {@link TargetType} for the instrumented type.
&nbsp;         */
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a {@code java.lang.invoke.MethodHandle} representing a field setter.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Setting {@link FieldValue#value()} is optional. If the value is not set, the field value attempts to bind a setter&#39;s
&nbsp;     * or getter&#39;s field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
&nbsp;     * to be an illegal candidate for binding.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.FieldSetterHandle} or
&nbsp;     * {@link net.bytebuddy.asm.Advice.FieldSetterHandle}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface FieldSetterHandle {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the field.
&nbsp;         *
&nbsp;         * @return The name of the field.
&nbsp;         */
&nbsp;        String value() default Substitution.Chain.Step.ForDelegation.OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type that declares the field that should be mapped to the annotated parameter. If this property
&nbsp;         * is set to {@code void}, the field is looked up implicitly within the instrumented class&#39;s class hierarchy.
&nbsp;         * The value can also be set to {@link TargetType} in order to look up the type on the instrumented type.
&nbsp;         *
&nbsp;         * @return The type that declares the field, {@code void} if this type should be determined implicitly or
&nbsp;         * {@link TargetType} for the instrumented type.
&nbsp;         */
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a representation of the substituted element or
&nbsp;     * instrumented method. This representation can be a string representation, a constant representing
&nbsp;     * the {@link Class}, a {@link Method}, {@link Constructor} or {@code java.lang.reflect.Executable}. It can also load
&nbsp;     * a {@code java.lang.invoke.MethodType}, a {@code java.lang.invoke.MethodHandle} or a {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A constant representing a {@link Method} or {@link Constructor} is not cached but is recreated for
&nbsp;     * every delegation.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.Origin} or
&nbsp;     * {@link Advice.Origin}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Origin {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the source that is considered for this annotation which can be either the substituted method,
&nbsp;         * constructor or field, or the instrumented method.
&nbsp;         *
&nbsp;         * @return The source that is considered for this annotation.
&nbsp;         */
&nbsp;        Source source() default Source.SUBSTITUTED_ELEMENT;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should always return a default value (i.e. {@code 0} for numeric values, {@code false}
&nbsp;     * for {@code boolean} types and {@code null} for reference types).
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.Empty} or
&nbsp;     * {@link Advice.Unused}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Unused {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should always return a boxed version of the instrumented method&#39;s return value
&nbsp;     * (i.e. {@code 0} for numeric values, {@code false} for {@code boolean} types and {@code null} for reference types). The annotated
&nbsp;     * parameter must be of type {@link Object}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.StubValue} or
&nbsp;     * {@link Advice.StubValue}. This annotation should be used only in combination with {@link Substitution.Chain.Step.ForDelegation}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface StubValue {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the source that is considered for this annotation which can be either the substituted method,
&nbsp;         * constructor or field, or the instrumented method.
&nbsp;         *
&nbsp;         * @return The source that is considered for this annotation.
&nbsp;         */
&nbsp;        Source source() default Source.SUBSTITUTED_ELEMENT;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that the annotated parameter should be assigned the value of the result that was
&nbsp;     * yielded by the previous chain expression.
&nbsp;     *
&nbsp;     * @see Substitution.Chain.Step.ForDelegation
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target({ElementType.PARAMETER, ElementType.METHOD, ElementType.CONSTRUCTOR})
&nbsp;    public @interface Current {
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the latest stack value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Identifies the source of an instruction that might describe a value of the substituted element
&nbsp;     * or the instrumented method.
&nbsp;     */
<b class="fc">&nbsp;    public enum Source {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that an element should be loaded in context of the substituted method, constructor or field.
&nbsp;         */
<b class="fc">&nbsp;        SUBSTITUTED_ELEMENT {</b>
&nbsp;            @Override
&nbsp;            protected ByteCodeElement.Member element(ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return original;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            protected Source.Value self(TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return original.isStatic()</b>
<b class="fc">&nbsp;                        ? null</b>
<b class="fc">&nbsp;                        : new Source.Value(parameters.get(THIS_REFERENCE), offsets.get(THIS_REFERENCE));</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            protected Source.Value argument(int index, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return index &lt; parameters.size() - (original.isStatic() ? 0 : 1)</b>
<b class="fc">&nbsp;                        ? new Source.Value(parameters.get(index + (original.isStatic() ? 0 : 1)), offsets.get(index + (original.isStatic() ? 0 : 1)))</b>
<b class="fc">&nbsp;                        : null;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;Source.Value&gt; arguments(boolean includesSelf,
&nbsp;                                                   TypeList.Generic parameters,
&nbsp;                                                   Map&lt;Integer, Integer&gt; offsets,
&nbsp;                                                   ByteCodeElement.Member original,
&nbsp;                                                   MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                List&lt;Source.Value&gt; values = new ArrayList&lt;Source.Value&gt;(parameters.size() - (!includesSelf &amp;&amp; !original.isStatic() ? 1 : 0));</b>
<b class="fc">&nbsp;                for (int index = original.isStatic() || includesSelf ? 0 : 1; index &lt; parameters.size(); index++) {</b>
<b class="fc">&nbsp;                    values.add(new Source.Value(parameters.get(index), offsets.get(index)));</b>
&nbsp;                }
<b class="fc">&nbsp;                return values;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected JavaConstant.MethodHandle handle(JavaConstant.MethodHandle methodHandle, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return methodHandle;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected boolean isRepresentable(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return sort.isRepresentable(original);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort,
&nbsp;                                                ByteCodeElement.Member original,
&nbsp;                                                TypeList.Generic parameters,
&nbsp;                                                TypeDescription.Generic result,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return sort.resolve(original, parameters.asErasures(), result.asErasure());</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that an element should be loaded in context of the instrumented method.
&nbsp;         */
<b class="fc">&nbsp;        ENCLOSING_METHOD {</b>
&nbsp;            @Override
&nbsp;            protected ByteCodeElement.Member element(ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return instrumentedMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            protected Source.Value self(TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return instrumentedMethod.isStatic()</b>
<b class="nc">&nbsp;                        ? null</b>
<b class="fc">&nbsp;                        : new Source.Value(instrumentedMethod.getDeclaringType().asGenericType(), THIS_REFERENCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @MaybeNull
&nbsp;            protected Source.Value argument(int index, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (index &lt; instrumentedMethod.getParameters().size()) {</b>
<b class="fc">&nbsp;                    ParameterDescription parameterDescription = instrumentedMethod.getParameters().get(index);</b>
<b class="fc">&nbsp;                    return new Source.Value(parameterDescription.getType(), parameterDescription.getOffset());</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return null;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;Source.Value&gt; arguments(boolean includesSelf, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
&nbsp;                List&lt;Source.Value&gt; values;
<b class="fc">&nbsp;                if (includesSelf &amp;&amp; !instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    values = new ArrayList&lt;Source.Value&gt;(instrumentedMethod.getParameters().size() + 1);</b>
<b class="nc">&nbsp;                    values.add(new Source.Value(instrumentedMethod.getDeclaringType().asGenericType(), THIS_REFERENCE));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    values = new ArrayList&lt;Source.Value&gt;(instrumentedMethod.getParameters().size());</b>
&nbsp;                }
<b class="fc">&nbsp;                for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="fc">&nbsp;                    values.add(new Source.Value(parameterDescription.getType(), parameterDescription.getOffset()));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return values;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected JavaConstant.MethodHandle handle(JavaConstant.MethodHandle methodHandle, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                return JavaConstant.MethodHandle.of(instrumentedMethod.asDefined());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected boolean isRepresentable(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, ByteCodeElement.Member original, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return sort.isRepresentable(instrumentedMethod);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected StackManipulation resolve(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort,
&nbsp;                                                ByteCodeElement.Member original,
&nbsp;                                                TypeList.Generic parameters,
&nbsp;                                                TypeDescription.Generic result,
&nbsp;                                                MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return sort.resolve(instrumentedMethod,</b>
<b class="fc">&nbsp;                        instrumentedMethod.isStatic() || instrumentedMethod.isConstructor()</b>
<b class="nc">&nbsp;                                ? instrumentedMethod.getParameters().asTypeList().asErasures()</b>
<b class="fc">&nbsp;                                : CompoundList.of(instrumentedMethod.getDeclaringType().asErasure(), instrumentedMethod.getParameters().asTypeList().asErasures()),</b>
<b class="fc">&nbsp;                        instrumentedMethod.isConstructor()</b>
<b class="nc">&nbsp;                                ? instrumentedMethod.getDeclaringType().asErasure()</b>
<b class="fc">&nbsp;                                : instrumentedMethod.getReturnType().asErasure());</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the targeted byte code element.
&nbsp;         *
&nbsp;         * @param original           The substituted element.
&nbsp;         * @param instrumentedMethod The instrumented element.
&nbsp;         * @return The byte code element that is represented by this source.
&nbsp;         */
&nbsp;        protected abstract ByteCodeElement.Member element(ByteCodeElement.Member original, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a value representation of the {@code this} reference or {@code null} if no such reference is available.
&nbsp;         *
&nbsp;         * @param parameters         The list of parameters of the substituted element.
&nbsp;         * @param offsets            A mapping of offsets of parameter indices to offsets.
&nbsp;         * @param original           The substituted element.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return A representation of the {@code this} reference or {@code null} if no such reference is available.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected abstract Source.Value self(TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a value representation of the parameter of the specified index or {@code null} if no such parameter is available.
&nbsp;         *
&nbsp;         * @param index              The index of the targeted parameter.
&nbsp;         * @param parameters         The list of parameters of the substituted element.
&nbsp;         * @param offsets            A mapping of offsets of parameter indices to offsets.
&nbsp;         * @param original           The substituted element.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return A representation of the parameter of the specified index or {@code null} if no such parameter is available.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        protected abstract Source.Value argument(int index, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a list of value representation of all parameters.
&nbsp;         *
&nbsp;         * @param includesSelf       {@code true} if the {@code this} reference should be included if available.
&nbsp;         * @param parameters         The list of parameters of the substituted element.
&nbsp;         * @param offsets            A mapping of offsets of parameter indices to offsets.
&nbsp;         * @param original           The substituted element.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return A list of representation of all values of all parameters.
&nbsp;         */
&nbsp;        protected abstract List&lt;Source.Value&gt; arguments(boolean includesSelf, TypeList.Generic parameters, Map&lt;Integer, Integer&gt; offsets, ByteCodeElement.Member original, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a method handle.
&nbsp;         *
&nbsp;         * @param methodHandle       A method handle of the substituted element.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return An appropriate method handle.
&nbsp;         */
&nbsp;        protected abstract JavaConstant.MethodHandle handle(JavaConstant.MethodHandle methodHandle, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Validates if the supplied origin sort is representable.
&nbsp;         *
&nbsp;         * @param sort               The sort of origin.
&nbsp;         * @param original           The substituted element.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return {@code true} if the supplied sort of origin is representable.
&nbsp;         */
&nbsp;        protected abstract boolean isRepresentable(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort, ByteCodeElement.Member original, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a stack manipulation that loads the supplied sort of origin onto the operand stack.
&nbsp;         *
&nbsp;         * @param sort               The sort of origin.
&nbsp;         * @param original           The substituted element.
&nbsp;         * @param parameters         The parameters to the substituted element.
&nbsp;         * @param result             The type upon which the substituted element is invoked.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return A stack manipulation loading the supplied sort of origin onto the operand stack.
&nbsp;         */
&nbsp;        protected abstract StackManipulation resolve(Substitution.Chain.Step.ForDelegation.OffsetMapping.ForOrigin.Sort sort,
&nbsp;                                                     ByteCodeElement.Member original,
&nbsp;                                                     TypeList.Generic parameters,
&nbsp;                                                     TypeDescription.Generic result,
&nbsp;                                                     MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a value that can be loaded from a given offset.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class Value {
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the loaded value.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The offset of the loaded value.
&nbsp;             */
&nbsp;            private final int offset;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a value representation.
&nbsp;             *
&nbsp;             * @param typeDescription The type of the loaded value.
&nbsp;             * @param offset          The offset of the loaded value.
&nbsp;             */
<b class="fc">&nbsp;            protected Value(TypeDescription.Generic typeDescription, int offset) {</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.offset = offset;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the type of the loaded value.
&nbsp;             *
&nbsp;             * @return The type of the loaded value.
&nbsp;             */
&nbsp;            protected TypeDescription.Generic getTypeDescription() {
<b class="fc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the offset of the loaded value.
&nbsp;             *
&nbsp;             * @return The offset of the loaded value.
&nbsp;             */
&nbsp;            protected int getOffset() {
<b class="fc">&nbsp;                return offset;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 15:48</div>
</div>
</body>
</html>
