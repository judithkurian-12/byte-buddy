


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Advice</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.asm</a>
</div>

<h1>Coverage Summary for Class: Advice (net.bytebuddy.asm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">Advice</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (24/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96%
  </span>
  <span class="absValue">
    (96/100)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Advice$1</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92%
  </span>
  <span class="absValue">
    (46/50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (58/58)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice$WithExceptionHandling</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (59/59)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithExitAdvice$WithoutExceptionHandling</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (26/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AdviceVisitor$WithoutExitAdvice</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AllArguments</td>
  </tr>
  <tr>
    <td class="name">Advice$Appender</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Appender$EmulatingMethodVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Argument</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$Factory$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$Factory$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice$Default$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForAdvice$Default$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod$Default</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.7%
  </span>
  <span class="absValue">
    (26/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod$Default$Copying</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ArgumentHandler$ForInstrumentedMethod$Default$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$AsScalar</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (26/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip$Dispatcher$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip$Dispatcher$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip$Dispatcher$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip$Dispatcher$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$DefaultValueSkip$Dispatcher$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ExceptionHandler$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ExceptionHandler$Factory$Enabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ExceptionHandler$Factory$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$Factory</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (6/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85%
  </span>
  <span class="absValue">
    (34/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ForArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ForScalar</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$Handler</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$Handler$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$Handler$Factory$Simple</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToAllArguments</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToAllArguments$Handler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (18/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToAllArguments$Handler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToArguments</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToArguments$Handler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToArguments$Handler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (19/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToArguments$ToArgument</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToFields</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToFields$Handler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.8%
  </span>
  <span class="absValue">
    (24/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToFields$Handler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToFields$ToField</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToReturned</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToReturned$Handler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToReturned$Handler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToThis</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToThis$Handler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (13/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToThis$Handler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToThrown</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToThrown$Handler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$AssignReturned$ToThrown$Handler$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$BootstrapArgumentResolver</td>
  </tr>
  <tr>
    <td class="name">Advice$BootstrapArgumentResolver$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$BootstrapArgumentResolver$ForDefaultValues</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$BootstrapArgumentResolver$ForDefaultValues$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$ForDynamicInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$ForDynamicInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$ForRegularInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Delegator$ForRegularInvocation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (21/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$AdviceMethodWriter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (52/52)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$AdviceMethodWriter$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$AdviceMethodWriter$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (23/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$ForMethodEnter$WithDiscardedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$ForMethodEnter$WithRetainedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$ForMethodExit$WithExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Delegating$Resolved$ForMethodExit$WithoutExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inactive</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (30/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$CodeTranslationVisitor</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (12/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.4%
  </span>
  <span class="absValue">
    (85/90)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (42/42)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner$ExceptionTableCollector</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner$ExceptionTableExtractor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$AdviceMethodInliner$ExceptionTableSubstitutor</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (14/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (31/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$WithDiscardedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodEnter$WithRetainedEnterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (40/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit$WithExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Inlining$Resolved$ForMethodExit$WithoutExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Disabled</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForType$Bound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (38/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$Bound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96%
  </span>
  <span class="absValue">
    (24/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$OfDefault</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$ForValue$OfNonDefault</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Relocation</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$RelocationHandler$Relocation$ForLabel</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (26/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodEnter</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodEnter$MockitoMock$1816463446</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodEnter$MockitoMock$1816463446$auxiliary$TiaasZHA</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodEnter$MockitoMock$1816463446$auxiliary$vB5j4yKJ</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodExit</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodExit$MockitoMock$794688737</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodExit$MockitoMock$794688737$auxiliary$nNynsT9G</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Resolved$ForMethodExit$MockitoMock$794688737$auxiliary$YUUPkOKP</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Bound</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Suppressing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$SuppressionHandler$Suppressing$Bound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (29/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Dispatcher$Unresolved</td>
  </tr>
  <tr>
    <td class="name">Advice$Enter</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$ExceptionHandler$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Exit</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldGetterHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldSetterHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$FieldValue</td>
  </tr>
  <tr>
    <td class="name">Advice$Local</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (14/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default$ForAdvice</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default$WithCopiedArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$Default$WithRetainedArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$ForAdvice</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$ForInstrumentedMethod</td>
  </tr>
  <tr>
    <td class="name">Advice$MethodSizeHandler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$NoExceptionHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$AdviceType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$Illegal</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Factory$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForAllArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.4%
  </span>
  <span class="absValue">
    (41/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForAllArguments$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Resolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.4%
  </span>
  <span class="absValue">
    (17/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForArgument$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForEnterValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForEnterValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForExitValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.2%
  </span>
  <span class="absValue">
    (15/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForExitValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.1%
  </span>
  <span class="absValue">
    (27/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Resolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForField$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (12/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Access</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Access$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Access$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Resolved$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$ReaderFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WithExplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WithImplicitType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForFieldHandle$Unresolved$WriterFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$3</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedMethod$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForInstrumentedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForLocalValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForLocalValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (36/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.2%
  </span>
  <span class="absValue">
    (25/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForConstantValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForDescriptor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForJavaSignature</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    54.5%
  </span>
  <span class="absValue">
    (6/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForMethodName</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForPropertyName</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForReturnTypeName</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForStringRepresentation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForOrigin$Renderer$ForTypeName</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForReturnValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (19/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForReturnValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSelfCallHandle</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSelfCallHandle$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (26/26)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSelfCallHandle$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSelfCallHandle$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSerializedValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForSerializedValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$OfAnnotationProperty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.3%
  </span>
  <span class="absValue">
    (11/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$OfDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStackManipulation$OfDynamicInvocation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    77.8%
  </span>
  <span class="absValue">
    (14/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForStubValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThisReference</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThisReference$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThrowable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (14/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForThrowable$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForUnusedValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$ForUnusedValue$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Sort$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Sort$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$AbstractReadOnlyAdapter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForArray</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForArray$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForArray$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForDefaultValue$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForField$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForField$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForField$WriteOnly</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (8/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForStackManipulation</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (8/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForStackManipulation$Writable</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForVariable$ReadOnly</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OffsetMapping$Target$ForVariable$ReadWrite</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OnDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$OnMethodEnter</td>
  </tr>
  <tr>
    <td class="name">Advice$OnMethodExit</td>
  </tr>
  <tr>
    <td class="name">Advice$OnNonDefaultValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Origin</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$Factory</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$Factory$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$PostProcessor$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$Return</td>
  </tr>
  <tr>
    <td class="name">Advice$SelfCallHandle</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.7%
  </span>
  <span class="absValue">
    (76/77)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$ForAdvice</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.8%
  </span>
  <span class="absValue">
    (56/61)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Initialization</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Initialization$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Initialization$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode$2</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (10/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$TranslationMode$3</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$Trivial</td>
<td class="coverageStat">
  <span class="percent">
    44.4%
  </span>
  <span class="absValue">
    (4/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.3%
  </span>
  <span class="absValue">
    (7/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$WithPreservedArguments</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.8%
  </span>
  <span class="absValue">
    (60/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$WithPreservedArguments$WithArgumentCopy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.3%
  </span>
  <span class="absValue">
    (69/79)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$Default$WithPreservedArguments$WithoutArgumentCopy</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$ForAdvice</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$ForInstrumentedMethod</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$ForPostProcessor</td>
  </tr>
  <tr>
    <td class="name">Advice$StackMapFrameHandler$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (12/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Advice$StubValue</td>
  </tr>
  <tr>
    <td class="name">Advice$This</td>
  </tr>
  <tr>
    <td class="name">Advice$Thrown</td>
  </tr>
  <tr>
    <td class="name">Advice$Unused</td>
  </tr>
  <tr>
    <td class="name">Advice$WithCustomMapping</td>
<td class="coverageStat">
  <span class="percent">
    70.2%
  </span>
  <span class="absValue">
    (33/47)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.7%
  </span>
  <span class="absValue">
    (71/95)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    91.6%
  </span>
  <span class="absValue">
    (770/841)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (2667/2890)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.asm;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.build.RepeatedAnnotationPlugin;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.description.method.ParameterList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.dynamic.scaffold.FieldLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.InstrumentedType;
&nbsp;import net.bytebuddy.dynamic.scaffold.MethodGraph;
&nbsp;import net.bytebuddy.implementation.FieldAccessor;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.SuperMethodCall;
&nbsp;import net.bytebuddy.implementation.bytecode.Addition;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.Removal;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.implementation.bytecode.Throw;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.collection.ArrayFactory;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.ClassConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.DefaultValue;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.IntegerConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.MethodConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.NullConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.constant.SerializedConstant;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.ConstantValue;
&nbsp;import net.bytebuddy.utility.JavaConstant;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.visitor.ExceptionTableSensitiveMethodVisitor;
&nbsp;import net.bytebuddy.utility.visitor.LineNumberPrependingMethodVisitor;
&nbsp;import net.bytebuddy.utility.visitor.StackAwareMethodVisitor;
&nbsp;import org.objectweb.asm.AnnotationVisitor;
&nbsp;import org.objectweb.asm.Attribute;
&nbsp;import org.objectweb.asm.ClassReader;
&nbsp;import org.objectweb.asm.ClassVisitor;
&nbsp;import org.objectweb.asm.ClassWriter;
&nbsp;import org.objectweb.asm.Label;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;import org.objectweb.asm.TypePath;
&nbsp;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.Documented;
&nbsp;import java.lang.annotation.ElementType;
&nbsp;import java.lang.annotation.Retention;
&nbsp;import java.lang.annotation.RetentionPolicy;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.IdentityHashMap;
&nbsp;import java.util.LinkedHashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.SortedMap;
&nbsp;import java.util.TreeMap;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.isAbstract;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.named;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * Advice wrappers copy the code of blueprint methods to be executed before and/or after a matched method. To achieve this, a {@code static}
&nbsp; * method of a class is annotated by {@link OnMethodEnter} and/or {@link OnMethodExit} and provided to an instance of this class.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * A method that is annotated with {@link OnMethodEnter} can annotate its parameters with {@link Argument} where field access to this parameter
&nbsp; * is substituted with access to the specified argument of the instrumented method. Alternatively, a parameter can be annotated by {@link This}
&nbsp; * where the {@code this} reference of the instrumented method is read when the parameter is accessed. This mechanism can also be used to assign a
&nbsp; * new value to the {@code this} reference of an instrumented method. If no annotation is used on a parameter, it is assigned the {@code n}-th
&nbsp; * parameter of the instrumented method for the {@code n}-th parameter of the advice method. All parameters must declare the exact same type as
&nbsp; * the parameters of the instrumented type or the method&#39;s declaring type for the {@link This} reference respectively if they are not marked as
&nbsp; * &lt;i&gt;read-only&lt;/i&gt;. In the latter case, it suffices that a parameter type is a super type of the corresponding type of the instrumented method.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * A method that is annotated with {@link OnMethodExit} can equally annotate its parameters with {@link Argument} and {@link This}. Additionally,
&nbsp; * it can annotate a parameter with {@link Return} to receive the original method&#39;s return value. By reassigning the return value, it is possible
&nbsp; * to replace the returned value. If an instrumented method does not return a value, this annotation must not be used. If a method returns
&nbsp; * exceptionally, the parameter is set to its default value, i.e. to {@code 0} for primitive types and to {@code null} for reference types. The
&nbsp; * parameter&#39;s type must be equal to the instrumented method&#39;s return type if it is not set to &lt;i&gt;read-only&lt;/i&gt; where it suffices to declare the
&nbsp; * parameter type to be of any super type to the instrumented method&#39;s return type. An exception can be read by annotating a parameter of type
&nbsp; * {@link Throwable} annotated with {@link Thrown} which is assigned the thrown {@link Throwable} or {@code null} if a method returns normally.
&nbsp; * Doing so, it is possible to exchange a thrown exception with any checked or unchecked exception.Finally, if a method annotated with
&nbsp; * {@link OnMethodEnter} exists and this method returns a value, this value can be accessed by a parameter annotated with {@link Enter}.
&nbsp; * This parameter must declare the same type as type being returned by the method annotated with {@link OnMethodEnter}. If the parameter is marked
&nbsp; * to be &lt;i&gt;read-only&lt;/i&gt;, it suffices that the annotated parameter is of a super type of the return type of the method annotated by
&nbsp; * {@link OnMethodEnter}. If no such method exists or this method returns {@code void}, no such parameter must be declared. Any return value
&nbsp; * of a method that is annotated by {@link OnMethodExit} is discarded.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * If any advice method throws an exception, the method is terminated prematurely. If the method annotated by {@link OnMethodEnter} throws an exception,
&nbsp; * the method annotated by {@link OnMethodExit} method is not invoked. If the instrumented method throws an exception, the method that is annotated by
&nbsp; * {@link OnMethodExit} is only invoked if the {@link OnMethodExit#onThrowable()} property is set to {@code true} what is the default. If this property
&nbsp; * is set to {@code false}, the {@link Thrown} annotation must not be used on any parameter.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Byte Buddy does not assert the visibility of any types that are referenced within an inlined advice method. It is the responsibility of
&nbsp; * the user of this class to assure that all types referenced within the advice methods are visible to the instrumented class. Failing to
&nbsp; * do so results in a {@link IllegalAccessError} at the instrumented class&#39;s runtime.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * Advice can be used either as a {@link AsmVisitorWrapper} where any declared methods of the currently instrumented type are enhanced without
&nbsp; * replacing an existing implementation. Alternatively, advice can function as an {@link Implementation} where, by default, the original super
&nbsp; * or default method of the instrumented method is invoked. If this is not possible or undesired, the delegate implementation can be changed
&nbsp; * by specifying a wrapped implementation explicitly by {@link Advice#wrap(Implementation)}.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * When using an advice class as a visitor wrapper, native or abstract methods which are silently skipped when advice matches such a method.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Important&lt;/b&gt;: Since Java 6, class files contain &lt;i&gt;stack map frames&lt;/i&gt; embedded into a method&#39;s byte code. When advice methods are compiled
&nbsp; * with a class file version less then Java 6 but are used for a class file that was compiled to Java 6 or newer, these stack map frames must be
&nbsp; * computed by ASM by using the {@link ClassWriter#COMPUTE_FRAMES} option. If the advice methods do not contain any branching instructions, this is
&nbsp; * not required. No action is required if the advice methods are at least compiled with Java 6 but are used on classes older than Java 6. This
&nbsp; * limitation only applies to advice methods that are inlined. Also, it is the responsibility of this class&#39;s user to assure that the advice method
&nbsp; * does not contain byte code constructs that are not supported by the class containing the instrumented method. In particular, pre Java-5
&nbsp; * try-finally blocks cannot be inlined into classes with newer byte code levels as the &lt;i&gt;jsr&lt;/i&gt; instruction was deprecated. Also, classes prior
&nbsp; * to Java 7 do not support the &lt;i&gt;invokedynamic&lt;/i&gt; command which must not be contained by an advice method if the instrumented method targets an
&nbsp; * older class file format version.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: For the purpose of inlining, Java 5 and Java 6 byte code can be seen as the best candidate for advice methods. These versions do
&nbsp; * no longer allow subroutines, neither do they already allow invokedynamic instructions or method handles. This way, Java 5 and Java 6 byte
&nbsp; * code is compatible to both older and newer versions. One exception for backwards-incompatible byte code is the possibility to load type references
&nbsp; * from the constant pool onto the operand stack. These instructions can however easily be transformed for classes compiled to Java 4 and older
&nbsp; * by registering a {@link TypeConstantAdjustment} &lt;b&gt;before&lt;/b&gt; the advice visitor.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: It is not possible to trigger break points in inlined advice methods as the debugging information of the inlined advice is not
&nbsp; * preserved. It is not possible in Java to reference more than one source file per class what makes translating such debugging information
&nbsp; * impossible. It is however possible to set break points in advice methods when invoking the original advice target. This allows debugging
&nbsp; * of advice code within unit tests that invoke the advice method without instrumentation. As a consequence of not transferring debugging information,
&nbsp; * the names of the parameters of an advice method do not matter when inlining, neither does any meta information on the advice method&#39;s body
&nbsp; * such as annotations or parameter modifiers.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: The behavior of this component is undefined if it is supplied with invalid byte code what might result in runtime exceptions.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * &lt;b&gt;Note&lt;/b&gt;: When using advice from a Java agent with an {@link net.bytebuddy.agent.builder.AgentBuilder}, it often makes sense to not include
&nbsp; * any library-specific code in the agent&#39;s jar file. For being able to locate the advice code in the context of the library dependencies, Byte
&nbsp; * Buddy offers an {@link net.bytebuddy.agent.builder.AgentBuilder.Transformer.ForAdvice} implementation that allows registering the agent&#39;s
&nbsp; * class file locators for assembly of the advice class&#39;s description at runtime and with respect to the specific user dependencies.
&nbsp; * &lt;/p&gt;
&nbsp; *
&nbsp; * @see OnMethodEnter
&nbsp; * @see OnMethodExit
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public class Advice implements AsmVisitorWrapper.ForDeclaredMethods.MethodVisitorWrapper, Implementation {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that no class reader is available to an advice method.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    private static final ClassReader UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodEnter#skipOn()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape SKIP_ON;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodEnter#skipOnIndex()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape SKIP_ON_INDEX;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodEnter#prependLineNumber()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape PREPEND_LINE_NUMBER;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodEnter#inline()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape INLINE_ENTER;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodEnter#suppress()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape SUPPRESS_ENTER;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodExit#repeatOn()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape REPEAT_ON;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodExit#repeatOnIndex()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape REPEAT_ON_INDEX;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodExit#onThrowable()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape ON_THROWABLE;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodExit#backupArguments()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape BACKUP_ARGUMENTS;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodExit#inline()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape INLINE_EXIT;
&nbsp;
&nbsp;    /**
&nbsp;     * A reference to the {@link OnMethodExit#suppress()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape SUPPRESS_EXIT;
&nbsp;
&nbsp;    /*
&nbsp;     * Extracts the annotation values for the enter and exit advice annotations.
&nbsp;     */
&nbsp;    static {
<b class="fc">&nbsp;        MethodList&lt;MethodDescription.InDefinedShape&gt; enter = TypeDescription.ForLoadedType.of(OnMethodEnter.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;        SKIP_ON = enter.filter(named(&quot;skipOn&quot;)).getOnly();</b>
<b class="fc">&nbsp;        SKIP_ON_INDEX = enter.filter(named(&quot;skipOnIndex&quot;)).getOnly();</b>
<b class="fc">&nbsp;        PREPEND_LINE_NUMBER = enter.filter(named(&quot;prependLineNumber&quot;)).getOnly();</b>
<b class="fc">&nbsp;        INLINE_ENTER = enter.filter(named(&quot;inline&quot;)).getOnly();</b>
<b class="fc">&nbsp;        SUPPRESS_ENTER = enter.filter(named(&quot;suppress&quot;)).getOnly();</b>
<b class="fc">&nbsp;        MethodList&lt;MethodDescription.InDefinedShape&gt; exit = TypeDescription.ForLoadedType.of(OnMethodExit.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;        REPEAT_ON = exit.filter(named(&quot;repeatOn&quot;)).getOnly();</b>
<b class="fc">&nbsp;        REPEAT_ON_INDEX = exit.filter(named(&quot;repeatOnIndex&quot;)).getOnly();</b>
<b class="fc">&nbsp;        ON_THROWABLE = exit.filter(named(&quot;onThrowable&quot;)).getOnly();</b>
<b class="fc">&nbsp;        BACKUP_ARGUMENTS = exit.filter(named(&quot;backupArguments&quot;)).getOnly();</b>
<b class="fc">&nbsp;        INLINE_EXIT = exit.filter(named(&quot;inline&quot;)).getOnly();</b>
<b class="fc">&nbsp;        SUPPRESS_EXIT = exit.filter(named(&quot;suppress&quot;)).getOnly();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The dispatcher for instrumenting the instrumented method upon entering.
&nbsp;     */
&nbsp;    private final Dispatcher.Resolved.ForMethodEnter methodEnter;
&nbsp;
&nbsp;    /**
&nbsp;     * The dispatcher for instrumenting the instrumented method upon exiting.
&nbsp;     */
&nbsp;    private final Dispatcher.Resolved.ForMethodExit methodExit;
&nbsp;
&nbsp;    /**
&nbsp;     * The assigner to use.
&nbsp;     */
&nbsp;    private final Assigner assigner;
&nbsp;
&nbsp;    /**
&nbsp;     * The exception handler to apply.
&nbsp;     */
&nbsp;    private final ExceptionHandler exceptionHandler;
&nbsp;
&nbsp;    /**
&nbsp;     * The delegate implementation to apply if this advice is used as an instrumentation.
&nbsp;     */
&nbsp;    private final Implementation delegate;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new advice.
&nbsp;     *
&nbsp;     * @param methodEnter The dispatcher for instrumenting the instrumented method upon entering.
&nbsp;     * @param methodExit  The dispatcher for instrumenting the instrumented method upon exiting.
&nbsp;     */
&nbsp;    protected Advice(Dispatcher.Resolved.ForMethodEnter methodEnter, Dispatcher.Resolved.ForMethodExit methodExit) {
<b class="fc">&nbsp;        this(methodEnter, methodExit, Assigner.DEFAULT, ExceptionHandler.Default.SUPPRESSING, SuperMethodCall.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new advice.
&nbsp;     *
&nbsp;     * @param methodEnter      The dispatcher for instrumenting the instrumented method upon entering.
&nbsp;     * @param methodExit       The dispatcher for instrumenting the instrumented method upon exiting.
&nbsp;     * @param assigner         The assigner to use.
&nbsp;     * @param exceptionHandler The exception handler to apply.
&nbsp;     * @param delegate         The delegate implementation to apply if this advice is used as an instrumentation.
&nbsp;     */
&nbsp;    private Advice(Dispatcher.Resolved.ForMethodEnter methodEnter,
&nbsp;                   Dispatcher.Resolved.ForMethodExit methodExit,
&nbsp;                   Assigner assigner,
&nbsp;                   ExceptionHandler exceptionHandler,
<b class="fc">&nbsp;                   Implementation delegate) {</b>
<b class="fc">&nbsp;        this.methodEnter = methodEnter;</b>
<b class="fc">&nbsp;        this.methodExit = methodExit;</b>
<b class="fc">&nbsp;        this.assigner = assigner;</b>
<b class="fc">&nbsp;        this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;        this.delegate = delegate;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods. The advices binary representation is
&nbsp;     * accessed by querying the class loader of the supplied class for a class file.
&nbsp;     *
&nbsp;     * @param advice The type declaring the advice.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(Class&lt;?&gt; advice) {
<b class="fc">&nbsp;        return to(advice, ClassFileLocator.ForClassLoader.of(advice.getClassLoader()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;     *
&nbsp;     * @param advice           The type declaring the advice.
&nbsp;     * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(Class&lt;?&gt; advice, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return to(TypeDescription.ForLoadedType.of(advice), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods. Using this method, a non-operational
&nbsp;     * class file locator is specified for the advice target. This implies that only advice targets with the &lt;i&gt;inline&lt;/i&gt; target set
&nbsp;     * to {@code false} are resolvable by the returned instance.
&nbsp;     *
&nbsp;     * @param advice The type declaring the advice.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(TypeDescription advice) {
<b class="fc">&nbsp;        return to(advice, ClassFileLocator.NoOp.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;     *
&nbsp;     * @param advice           A description of the type declaring the advice.
&nbsp;     * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(TypeDescription advice, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return to(advice, PostProcessor.NoOp.INSTANCE, classFileLocator, Collections.&lt;OffsetMapping.Factory&lt;?&gt;&gt;emptyList(), Delegator.ForRegularInvocation.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new advice.
&nbsp;     *
&nbsp;     * @param advice               A description of the type declaring the advice.
&nbsp;     * @param postProcessorFactory The post processor factory to use.
&nbsp;     * @param classFileLocator     The class file locator for locating the advisory class&#39;s class file.
&nbsp;     * @param userFactories        A list of custom factories for user generated offset mappings.
&nbsp;     * @param delegatorFactory     The delegator factory to use.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    protected static Advice to(TypeDescription advice,
&nbsp;                               PostProcessor.Factory postProcessorFactory,
&nbsp;                               ClassFileLocator classFileLocator,
&nbsp;                               List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                               Delegator.Factory delegatorFactory) {
<b class="fc">&nbsp;        Dispatcher.Unresolved methodEnter = Dispatcher.Inactive.INSTANCE, methodExit = Dispatcher.Inactive.INSTANCE;</b>
<b class="fc">&nbsp;        for (MethodDescription.InDefinedShape methodDescription : advice.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;            methodEnter = locate(OnMethodEnter.class, INLINE_ENTER, methodEnter, methodDescription, delegatorFactory);</b>
<b class="fc">&nbsp;            methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription, delegatorFactory);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (!methodEnter.isAlive() &amp;&amp; !methodExit.isAlive()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;No advice defined by &quot; + advice);</b>
&nbsp;        }
&nbsp;        try {
<b class="fc">&nbsp;            ClassReader classReader = methodEnter.isBinary() || methodExit.isBinary()</b>
<b class="fc">&nbsp;                    ? OpenedClassReader.of(classFileLocator.locate(advice.getName()).resolve())</b>
<b class="fc">&nbsp;                    : UNDEFINED;</b>
<b class="fc">&nbsp;            return new Advice(methodEnter.asMethodEnter(userFactories, classReader, methodExit, postProcessorFactory),</b>
<b class="fc">&nbsp;                    methodExit.asMethodExit(userFactories, classReader, methodEnter, postProcessorFactory));</b>
<b class="fc">&nbsp;        } catch (IOException exception) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Error reading class file of &quot; + advice, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods. The advices binary representation is
&nbsp;     * accessed by querying the class loader of the supplied class for a class file.
&nbsp;     *
&nbsp;     * @param enterAdvice The type declaring the enter advice.
&nbsp;     * @param exitAdvice  The type declaring the exit advice.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice) {
<b class="fc">&nbsp;        ClassLoader enterLoader = enterAdvice.getClassLoader(), exitLoader = exitAdvice.getClassLoader();</b>
<b class="fc">&nbsp;        return to(enterAdvice, exitAdvice, enterLoader == exitLoader</b>
<b class="fc">&nbsp;                ? ClassFileLocator.ForClassLoader.of(enterLoader)</b>
<b class="fc">&nbsp;                : new ClassFileLocator.Compound(ClassFileLocator.ForClassLoader.of(enterLoader), ClassFileLocator.ForClassLoader.of(exitLoader)));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;     *
&nbsp;     * @param enterAdvice      The type declaring the enter advice.
&nbsp;     * @param exitAdvice       The type declaring the exit advice.
&nbsp;     * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return to(TypeDescription.ForLoadedType.of(enterAdvice), TypeDescription.ForLoadedType.of(exitAdvice), classFileLocator);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods. Using this method, a non-operational
&nbsp;     * class file locator is specified for the advice target. This implies that only advice targets with the &lt;i&gt;inline&lt;/i&gt; target set
&nbsp;     * to {@code false} are resolvable by the returned instance.
&nbsp;     *
&nbsp;     * @param enterAdvice The type declaring the enter advice.
&nbsp;     * @param exitAdvice  The type declaring the exit advice.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice) {
<b class="nc">&nbsp;        return to(enterAdvice, exitAdvice, ClassFileLocator.NoOp.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;     *
&nbsp;     * @param enterAdvice      The type declaring the enter advice.
&nbsp;     * @param exitAdvice       The type declaring the exit advice.
&nbsp;     * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    public static Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        return to(enterAdvice, exitAdvice, PostProcessor.NoOp.INSTANCE, classFileLocator, Collections.&lt;OffsetMapping.Factory&lt;?&gt;&gt;emptyList(), Delegator.ForRegularInvocation.Factory.INSTANCE);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new advice.
&nbsp;     *
&nbsp;     * @param enterAdvice          The type declaring the enter advice.
&nbsp;     * @param exitAdvice           The type declaring the exit advice.
&nbsp;     * @param postProcessorFactory The post processor factory to use.
&nbsp;     * @param classFileLocator     The class file locator for locating the advisory class&#39;s class file.
&nbsp;     * @param userFactories        A list of custom factories for user generated offset mappings.
&nbsp;     * @param delegatorFactory     The delegator factory to use.
&nbsp;     * @return A method visitor wrapper representing the supplied advice.
&nbsp;     */
&nbsp;    protected static Advice to(TypeDescription enterAdvice,
&nbsp;                               TypeDescription exitAdvice,
&nbsp;                               PostProcessor.Factory postProcessorFactory,
&nbsp;                               ClassFileLocator classFileLocator,
&nbsp;                               List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                               Delegator.Factory delegatorFactory) {
<b class="fc">&nbsp;        Dispatcher.Unresolved methodEnter = Dispatcher.Inactive.INSTANCE, methodExit = Dispatcher.Inactive.INSTANCE;</b>
<b class="fc">&nbsp;        for (MethodDescription.InDefinedShape methodDescription : enterAdvice.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;            methodEnter = locate(OnMethodEnter.class, INLINE_ENTER, methodEnter, methodDescription, delegatorFactory);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (!methodEnter.isAlive()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;No enter advice defined by &quot; + enterAdvice);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (MethodDescription.InDefinedShape methodDescription : exitAdvice.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;            methodExit = locate(OnMethodExit.class, INLINE_EXIT, methodExit, methodDescription, delegatorFactory);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        if (!methodExit.isAlive()) {</b>
<b class="fc">&nbsp;            throw new IllegalArgumentException(&quot;No exit advice defined by &quot; + exitAdvice);</b>
&nbsp;        }
&nbsp;        try {
<b class="fc">&nbsp;            return new Advice(methodEnter.asMethodEnter(userFactories, methodEnter.isBinary()</b>
<b class="fc">&nbsp;                    ? OpenedClassReader.of(classFileLocator.locate(enterAdvice.getName()).resolve())</b>
<b class="fc">&nbsp;                    : UNDEFINED, methodExit, postProcessorFactory), methodExit.asMethodExit(userFactories, methodExit.isBinary()</b>
<b class="fc">&nbsp;                    ? OpenedClassReader.of(classFileLocator.locate(exitAdvice.getName()).resolve())</b>
<b class="fc">&nbsp;                    : UNDEFINED, methodEnter, postProcessorFactory));</b>
<b class="nc">&nbsp;        } catch (IOException exception) {</b>
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Error reading class file of &quot; + enterAdvice + &quot; or &quot; + exitAdvice, exception);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Locates a dispatcher for the method if available.
&nbsp;     *
&nbsp;     * @param type              The annotation type that indicates a given form of advice that is currently resolved.
&nbsp;     * @param property          An annotation property that indicates if the advice method should be inlined.
&nbsp;     * @param dispatcher        Any previous dispatcher that was discovered or the previous dispatcher if found.
&nbsp;     * @param methodDescription The method description that is considered as an advice method.
&nbsp;     * @param delegatorFactory  The delegator factory to use.
&nbsp;     * @return A resolved dispatcher or the previous dispatcher if none was found.
&nbsp;     */
&nbsp;    private static Dispatcher.Unresolved locate(Class&lt;? extends Annotation&gt; type,
&nbsp;                                                MethodDescription.InDefinedShape property,
&nbsp;                                                Dispatcher.Unresolved dispatcher,
&nbsp;                                                MethodDescription.InDefinedShape methodDescription,
&nbsp;                                                Delegator.Factory delegatorFactory) {
<b class="fc">&nbsp;        AnnotationDescription annotation = methodDescription.getDeclaredAnnotations().ofType(type);</b>
<b class="fc">&nbsp;        if (annotation == null) {</b>
<b class="fc">&nbsp;            return dispatcher;</b>
<b class="fc">&nbsp;        } else if (dispatcher.isAlive()) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Duplicate advice for &quot; + dispatcher + &quot; and &quot; + methodDescription);</b>
<b class="fc">&nbsp;        } else if (!methodDescription.isStatic()) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Advice for &quot; + methodDescription + &quot; is not static&quot;);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return annotation.getValue(property).resolve(Boolean.class)</b>
<b class="fc">&nbsp;                    ? new Dispatcher.Inlining(methodDescription)</b>
<b class="fc">&nbsp;                    : new Dispatcher.Delegating(methodDescription, delegatorFactory);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows for the configuration of custom annotations that are then bound to a dynamically computed, constant value.
&nbsp;     *
&nbsp;     * @return A builder for an {@link Advice} instrumentation with custom values.
&nbsp;     * @see OffsetMapping.Factory
&nbsp;     */
&nbsp;    public static WithCustomMapping withCustomMapping() {
<b class="fc">&nbsp;        return new WithCustomMapping();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns an ASM visitor wrapper that matches the given matcher and applies this advice to the matched methods.
&nbsp;     *
&nbsp;     * @param matcher The matcher identifying methods to apply the advice to.
&nbsp;     * @return A suitable ASM visitor wrapper with the &lt;i&gt;compute frames&lt;/i&gt; option enabled.
&nbsp;     */
&nbsp;    public AsmVisitorWrapper.ForDeclaredMethods on(ElementMatcher&lt;? super MethodDescription&gt; matcher) {
<b class="fc">&nbsp;        return new AsmVisitorWrapper.ForDeclaredMethods().invokable(matcher, this);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public MethodVisitor wrap(TypeDescription instrumentedType,
&nbsp;                              MethodDescription instrumentedMethod,
&nbsp;                              MethodVisitor methodVisitor,
&nbsp;                              Implementation.Context implementationContext,
&nbsp;                              TypePool typePool,
&nbsp;                              int writerFlags,
&nbsp;                              int readerFlags) {
<b class="fc">&nbsp;        return instrumentedMethod.isAbstract() || instrumentedMethod.isNative()</b>
<b class="fc">&nbsp;                ? methodVisitor</b>
<b class="fc">&nbsp;                : doWrap(instrumentedType, instrumentedMethod, methodVisitor, implementationContext, writerFlags, readerFlags);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps the method visitor to implement this advice.
&nbsp;     *
&nbsp;     * @param instrumentedType      The instrumented type.
&nbsp;     * @param instrumentedMethod    The instrumented method.
&nbsp;     * @param methodVisitor         The method visitor to write to.
&nbsp;     * @param implementationContext The implementation context to use.
&nbsp;     * @param writerFlags           The ASM writer flags to use.
&nbsp;     * @param readerFlags           The ASM reader flags to use.
&nbsp;     * @return A method visitor that applies this advice.
&nbsp;     */
&nbsp;    protected MethodVisitor doWrap(TypeDescription instrumentedType,
&nbsp;                                   MethodDescription instrumentedMethod,
&nbsp;                                   MethodVisitor methodVisitor,
&nbsp;                                   Implementation.Context implementationContext,
&nbsp;                                   int writerFlags,
&nbsp;                                   int readerFlags) {
<b class="fc">&nbsp;        if (methodEnter.isPrependLineNumber()) {</b>
<b class="fc">&nbsp;            methodVisitor = new LineNumberPrependingMethodVisitor(methodVisitor);</b>
&nbsp;        }
<b class="fc">&nbsp;        if (!methodExit.isAlive()) {</b>
<b class="fc">&nbsp;            return new AdviceVisitor.WithoutExitAdvice(methodVisitor,</b>
&nbsp;                    implementationContext,
&nbsp;                    assigner,
<b class="fc">&nbsp;                    exceptionHandler.resolve(instrumentedMethod, instrumentedType),</b>
&nbsp;                    instrumentedType,
&nbsp;                    instrumentedMethod,
&nbsp;                    methodEnter,
&nbsp;                    writerFlags,
&nbsp;                    readerFlags);
<b class="fc">&nbsp;        } else if (methodExit.getThrowable().represents(NoExceptionHandler.class)) {</b>
<b class="fc">&nbsp;            return new AdviceVisitor.WithExitAdvice.WithoutExceptionHandling(methodVisitor,</b>
&nbsp;                    implementationContext,
&nbsp;                    assigner,
<b class="fc">&nbsp;                    exceptionHandler.resolve(instrumentedMethod, instrumentedType),</b>
&nbsp;                    instrumentedType,
&nbsp;                    instrumentedMethod,
&nbsp;                    methodEnter,
&nbsp;                    methodExit,
&nbsp;                    writerFlags,
&nbsp;                    readerFlags);
<b class="fc">&nbsp;        } else if (instrumentedMethod.isConstructor()) {</b>
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot catch exception during constructor call for &quot; + instrumentedMethod);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return new AdviceVisitor.WithExitAdvice.WithExceptionHandling(methodVisitor,</b>
&nbsp;                    implementationContext,
&nbsp;                    assigner,
<b class="fc">&nbsp;                    exceptionHandler.resolve(instrumentedMethod, instrumentedType),</b>
&nbsp;                    instrumentedType,
&nbsp;                    instrumentedMethod,
&nbsp;                    methodEnter,
&nbsp;                    methodExit,
&nbsp;                    writerFlags,
&nbsp;                    readerFlags,
<b class="fc">&nbsp;                    methodExit.getThrowable());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public InstrumentedType prepare(InstrumentedType instrumentedType) {
<b class="fc">&nbsp;        return delegate.prepare(instrumentedType);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public ByteCodeAppender appender(Target implementationTarget) {
<b class="fc">&nbsp;        return new Appender(this, implementationTarget, delegate.appender(implementationTarget));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this advice to use the specified assigner. Any previous or default assigner is replaced.
&nbsp;     *
&nbsp;     * @param assigner The assigner to use,
&nbsp;     * @return A version of this advice that uses the specified assigner.
&nbsp;     */
&nbsp;    public Advice withAssigner(Assigner assigner) {
<b class="fc">&nbsp;        return new Advice(methodEnter, methodExit, assigner, exceptionHandler, delegate);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this advice to call {@link Throwable#printStackTrace()} upon a suppressed exception.
&nbsp;     *
&nbsp;     * @return A version of this advice that prints any suppressed exception.
&nbsp;     */
&nbsp;    public Advice withExceptionPrinting() {
<b class="fc">&nbsp;        return withExceptionHandler(ExceptionHandler.Default.PRINTING);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this advice to execute the given stack manipulation upon a suppressed exception. The stack manipulation is executed with a
&nbsp;     * {@link Throwable} instance on the operand stack. The stack must be empty upon completing the exception handler.
&nbsp;     *
&nbsp;     * @param exceptionHandler The exception handler to apply.
&nbsp;     * @return A version of this advice that applies the supplied exception handler.
&nbsp;     */
&nbsp;    public Advice withExceptionHandler(StackManipulation exceptionHandler) {
<b class="nc">&nbsp;        return withExceptionHandler(new ExceptionHandler.Simple(exceptionHandler));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Configures this advice to execute the given exception handler upon a suppressed exception. The stack manipulation is executed with a
&nbsp;     * {@link Throwable} instance on the operand stack. The stack must be empty upon completing the exception handler.
&nbsp;     *
&nbsp;     * @param exceptionHandler The exception handler to apply.
&nbsp;     * @return A version of this advice that applies the supplied exception handler.
&nbsp;     */
&nbsp;    public Advice withExceptionHandler(ExceptionHandler exceptionHandler) {
<b class="fc">&nbsp;        return new Advice(methodEnter, methodExit, assigner, exceptionHandler, delegate);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps the supplied implementation to have this advice applied around it.
&nbsp;     *
&nbsp;     * @param implementation The implementation to wrap.
&nbsp;     * @return An implementation that applies the supplied implementation and wraps it with this advice.
&nbsp;     */
&nbsp;    public Implementation wrap(Implementation implementation) {
<b class="fc">&nbsp;        return new Advice(methodEnter, methodExit, assigner, exceptionHandler, implementation);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents an offset mapping for an advice method to an alternative offset.
&nbsp;     */
&nbsp;    public interface OffsetMapping {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves an offset mapping to a given target offset.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The instrumented method for which the mapping is to be resolved.
&nbsp;         * @param assigner           The assigner to use.
&nbsp;         * @param argumentHandler    The argument handler to use for resolving offsets of the local variable array of the instrumented method.
&nbsp;         * @param sort               The sort of the advice method being resolved.
&nbsp;         * @return A suitable target mapping.
&nbsp;         */
&nbsp;        Target resolve(TypeDescription instrumentedType,
&nbsp;                       MethodDescription instrumentedMethod,
&nbsp;                       Assigner assigner,
&nbsp;                       ArgumentHandler argumentHandler,
&nbsp;                       Sort sort);
&nbsp;
&nbsp;        /**
&nbsp;         * A target offset of an offset mapping.
&nbsp;         */
&nbsp;        interface Target {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a read instruction.
&nbsp;             *
&nbsp;             * @return A stack manipulation that represents a reading of an advice parameter.
&nbsp;             */
&nbsp;            StackManipulation resolveRead();
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a write instruction.
&nbsp;             *
&nbsp;             * @return A stack manipulation that represents a writing to an advice parameter.
&nbsp;             */
&nbsp;            StackManipulation resolveWrite();
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an increment instruction.
&nbsp;             *
&nbsp;             * @param value The incrementation value.
&nbsp;             * @return A stack manipulation that represents a writing to an advice parameter.
&nbsp;             */
&nbsp;            StackManipulation resolveIncrement(int value);
&nbsp;
&nbsp;            /**
&nbsp;             * An adapter class for a target that only can be read.
&nbsp;             */
<b class="nc">&nbsp;            abstract class AbstractReadOnlyAdapter implements Target {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveWrite() {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot write to read-only value&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot write to read-only value&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target for an offset mapping that represents a non-operational value. All writes are discarded and a value&#39;s
&nbsp;             * default value is returned upon every read.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class ForDefaultValue implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type.
&nbsp;                 */
&nbsp;                protected final TypeDefinition typeDefinition;
&nbsp;
&nbsp;                /**
&nbsp;                 * A stack manipulation to apply after a read instruction.
&nbsp;                 */
&nbsp;                protected final StackManipulation readAssignment;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target for a default value.
&nbsp;                 *
&nbsp;                 * @param typeDefinition The represented type.
&nbsp;                 * @param readAssignment A stack manipulation to apply after a read instruction.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForDefaultValue(TypeDefinition typeDefinition, StackManipulation readAssignment) {</b>
<b class="fc">&nbsp;                    this.typeDefinition = typeDefinition;</b>
<b class="fc">&nbsp;                    this.readAssignment = readAssignment;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveRead() {
<b class="fc">&nbsp;                    return new StackManipulation.Compound(DefaultValue.of(typeDefinition), readAssignment);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A read-only target for a default value.
&nbsp;                 */
&nbsp;                public static class ReadOnly extends ForDefaultValue {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new writable target for a default value.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     */
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                        this(typeDefinition, StackManipulation.Trivial.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new -writable target for a default value.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     * @param readAssignment A stack manipulation to apply after a read instruction.
&nbsp;                     */
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition, StackManipulation readAssignment) {
<b class="fc">&nbsp;                        super(typeDefinition, readAssignment);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only default value&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only default value&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A read-write target for a default value.
&nbsp;                 */
&nbsp;                public static class ReadWrite extends ForDefaultValue {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new read-only target for a default value.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     */
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                        this(typeDefinition, StackManipulation.Trivial.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new read-only target for a default value.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     * @param readAssignment A stack manipulation to apply after a read instruction.
&nbsp;                     */
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition, StackManipulation readAssignment) {
<b class="fc">&nbsp;                        super(typeDefinition, readAssignment);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        return Removal.of(typeDefinition);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="fc">&nbsp;                        return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target for an offset mapping that represents a local variable.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class ForVariable implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type.
&nbsp;                 */
&nbsp;                protected final TypeDefinition typeDefinition;
&nbsp;
&nbsp;                /**
&nbsp;                 * The value&#39;s offset.
&nbsp;                 */
&nbsp;                protected final int offset;
&nbsp;
&nbsp;                /**
&nbsp;                 * An assignment to execute upon reading a value.
&nbsp;                 */
&nbsp;                protected final StackManipulation readAssignment;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target for a local variable mapping.
&nbsp;                 *
&nbsp;                 * @param typeDefinition The represented type.
&nbsp;                 * @param offset         The value&#39;s offset.
&nbsp;                 * @param readAssignment An assignment to execute upon reading a value.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForVariable(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment) {</b>
<b class="fc">&nbsp;                    this.typeDefinition = typeDefinition;</b>
<b class="fc">&nbsp;                    this.offset = offset;</b>
<b class="fc">&nbsp;                    this.readAssignment = readAssignment;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveRead() {
<b class="fc">&nbsp;                    return new StackManipulation.Compound(MethodVariableAccess.of(typeDefinition).loadFrom(offset), readAssignment);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A target for a read-only mapping of a local variable.
&nbsp;                 */
&nbsp;                public static class ReadOnly extends ForVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a read-only mapping for a local variable.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     * @param offset         The value&#39;s offset.
&nbsp;                     */
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition, int offset) {
<b class="nc">&nbsp;                        this(typeDefinition, offset, StackManipulation.Trivial.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a read-only mapping for a local variable.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     * @param offset         The value&#39;s offset.
&nbsp;                     * @param readAssignment An assignment to execute upon reading a value.
&nbsp;                     */
&nbsp;                    public ReadOnly(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment) {
<b class="fc">&nbsp;                        super(typeDefinition, offset, readAssignment);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only parameter &quot; + typeDefinition + &quot; at &quot; + offset);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only variable &quot; + typeDefinition + &quot; at &quot; + offset);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A target for a writable mapping of a local variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ReadWrite extends ForVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A stack manipulation to apply upon a write to the variable.
&nbsp;                     */
&nbsp;                    private final StackManipulation writeAssignment;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new target mapping for a writable local variable.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The represented type.
&nbsp;                     * @param offset         The value&#39;s offset.
&nbsp;                     */
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition, int offset) {
<b class="nc">&nbsp;                        this(typeDefinition, offset, StackManipulation.Trivial.INSTANCE, StackManipulation.Trivial.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new target mapping for a writable local variable.
&nbsp;                     *
&nbsp;                     * @param typeDefinition  The represented type.
&nbsp;                     * @param offset          The value&#39;s offset.
&nbsp;                     * @param readAssignment  An assignment to execute upon reading a value.
&nbsp;                     * @param writeAssignment A stack manipulation to apply upon a write to the variable.
&nbsp;                     */
&nbsp;                    public ReadWrite(TypeDefinition typeDefinition, int offset, StackManipulation readAssignment, StackManipulation writeAssignment) {
<b class="fc">&nbsp;                        super(typeDefinition, offset, readAssignment);</b>
<b class="fc">&nbsp;                        this.writeAssignment = writeAssignment;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        return new StackManipulation.Compound(writeAssignment, MethodVariableAccess.of(typeDefinition).storeAt(offset));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="fc">&nbsp;                        return typeDefinition.represents(int.class)</b>
<b class="fc">&nbsp;                                ? MethodVariableAccess.of(typeDefinition).increment(offset, value)</b>
<b class="nc">&nbsp;                                : new StackManipulation.Compound(resolveRead(), IntegerConstant.forValue(1), Addition.INTEGER, resolveWrite());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target mapping for an array of all local variables.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class ForArray implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The compound target type.
&nbsp;                 */
&nbsp;                protected final TypeDescription.Generic target;
&nbsp;
&nbsp;                /**
&nbsp;                 * The stack manipulations to apply upon reading a variable array.
&nbsp;                 */
&nbsp;                protected final List&lt;? extends StackManipulation&gt; valueReads;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target mapping for an array of all local variables.
&nbsp;                 *
&nbsp;                 * @param target     The compound target type.
&nbsp;                 * @param valueReads The stack manipulations to apply upon reading a variable array.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForArray(TypeDescription.Generic target, List&lt;? extends StackManipulation&gt; valueReads) {</b>
<b class="fc">&nbsp;                    this.target = target;</b>
<b class="fc">&nbsp;                    this.valueReads = valueReads;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveRead() {
<b class="fc">&nbsp;                    return ArrayFactory.forType(target).withValues(valueReads);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot increment read-only array value&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A target mapping for a read-only target mapping for an array of local variables.
&nbsp;                 */
&nbsp;                public static class ReadOnly extends ForArray {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a read-only target mapping for an array of all local variables.
&nbsp;                     *
&nbsp;                     * @param target     The compound target type.
&nbsp;                     * @param valueReads The stack manipulations to apply upon reading a variable array.
&nbsp;                     */
&nbsp;                    public ReadOnly(TypeDescription.Generic target, List&lt;? extends StackManipulation&gt; valueReads) {
<b class="fc">&nbsp;                        super(target, valueReads);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only array value&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A target mapping for a writable target mapping for an array of local variables.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ReadWrite extends ForArray {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack manipulations to apply upon writing to a variable array.
&nbsp;                     */
&nbsp;                    private final List&lt;? extends StackManipulation&gt; valueWrites;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a writable target mapping for an array of all local variables.
&nbsp;                     *
&nbsp;                     * @param target      The compound target type.
&nbsp;                     * @param valueReads  The stack manipulations to apply upon reading a variable array.
&nbsp;                     * @param valueWrites The stack manipulations to apply upon writing to a variable array.
&nbsp;                     */
&nbsp;                    public ReadWrite(TypeDescription.Generic target,
&nbsp;                                     List&lt;? extends StackManipulation&gt; valueReads,
&nbsp;                                     List&lt;? extends StackManipulation&gt; valueWrites) {
<b class="fc">&nbsp;                        super(target, valueReads);</b>
<b class="fc">&nbsp;                        this.valueWrites = valueWrites;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        return new StackManipulation.Compound(ArrayAccess.of(target).forEach(valueWrites), Removal.SINGLE);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target for an offset mapping that loads a field value.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class ForField implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field value to load.
&nbsp;                 */
&nbsp;                protected final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The stack manipulation to apply upon a read.
&nbsp;                 */
&nbsp;                protected final StackManipulation readAssignment;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target for a field value mapping.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The field value to load.
&nbsp;                 * @param readAssignment   The stack manipulation to apply upon a read.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForField(FieldDescription fieldDescription, StackManipulation readAssignment) {</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                    this.readAssignment = readAssignment;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveRead() {
<b class="fc">&nbsp;                    return new StackManipulation.Compound(fieldDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? StackManipulation.Trivial.INSTANCE</b>
<b class="fc">&nbsp;                            : MethodVariableAccess.loadThis(), FieldAccess.forField(fieldDescription).read(), readAssignment);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A read-only mapping for a field value.
&nbsp;                 */
&nbsp;                public static class ReadOnly extends ForField {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new read-only mapping for a field.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field value to load.
&nbsp;                     */
&nbsp;                    public ReadOnly(FieldDescription fieldDescription) {
<b class="nc">&nbsp;                        this(fieldDescription, StackManipulation.Trivial.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new read-only mapping for a field.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field value to load.
&nbsp;                     * @param readAssignment   The stack manipulation to apply upon a read.
&nbsp;                     */
&nbsp;                    public ReadOnly(FieldDescription fieldDescription, StackManipulation readAssignment) {
<b class="fc">&nbsp;                        super(fieldDescription, readAssignment);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only field value&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to read-only field value&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A write-only mapping for a field value, typically to be used for constructors prior to invoking the super-constructor.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WriteOnly implements Target {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field value to load.
&nbsp;                     */
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * An assignment to apply prior to a field write.
&nbsp;                     */
&nbsp;                    private final StackManipulation writeAssignment;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a write-only mapping for a field value.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field value to load.
&nbsp;                     * @param writeAssignment  An assignment to apply prior to a field write.
&nbsp;                     */
<b class="fc">&nbsp;                    protected WriteOnly(FieldDescription fieldDescription, StackManipulation writeAssignment) {</b>
<b class="fc">&nbsp;                        this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                        this.writeAssignment = writeAssignment;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveRead() {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot read write-only field value&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        StackManipulation preparation;
<b class="fc">&nbsp;                        if (fieldDescription.isStatic()) {</b>
<b class="nc">&nbsp;                            preparation = StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            preparation = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                    Duplication.SINGLE.flipOver(fieldDescription.getType()),</b>
&nbsp;                                    Removal.SINGLE
&nbsp;                            );
&nbsp;                        }
<b class="fc">&nbsp;                        return new StackManipulation.Compound(writeAssignment, preparation, FieldAccess.forField(fieldDescription).write());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot increment write-only field value&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping for a writable field.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ReadWrite extends ForField {
&nbsp;
&nbsp;                    /**
&nbsp;                     * An assignment to apply prior to a field write.
&nbsp;                     */
&nbsp;                    private final StackManipulation writeAssignment;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new target for a writable field.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field value to load.
&nbsp;                     */
&nbsp;                    public ReadWrite(FieldDescription fieldDescription) {
<b class="fc">&nbsp;                        this(fieldDescription, StackManipulation.Trivial.INSTANCE, StackManipulation.Trivial.INSTANCE);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new target for a writable field.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field value to load.
&nbsp;                     * @param readAssignment   The stack manipulation to apply upon a read.
&nbsp;                     * @param writeAssignment  An assignment to apply prior to a field write.
&nbsp;                     */
&nbsp;                    public ReadWrite(FieldDescription fieldDescription, StackManipulation readAssignment, StackManipulation writeAssignment) {
<b class="fc">&nbsp;                        super(fieldDescription, readAssignment);</b>
<b class="fc">&nbsp;                        this.writeAssignment = writeAssignment;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
&nbsp;                        StackManipulation preparation;
<b class="fc">&nbsp;                        if (fieldDescription.isStatic()) {</b>
<b class="fc">&nbsp;                            preparation = StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            preparation = new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                    MethodVariableAccess.loadThis(),</b>
<b class="fc">&nbsp;                                    Duplication.SINGLE.flipOver(fieldDescription.getType()),</b>
&nbsp;                                    Removal.SINGLE
&nbsp;                            );
&nbsp;                        }
<b class="fc">&nbsp;                        return new StackManipulation.Compound(writeAssignment, preparation, FieldAccess.forField(fieldDescription).write());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="fc">&nbsp;                        return new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                resolveRead(),</b>
<b class="fc">&nbsp;                                IntegerConstant.forValue(value),</b>
&nbsp;                                Addition.INTEGER,
<b class="fc">&nbsp;                                resolveWrite()</b>
&nbsp;                        );
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A target for an offset mapping that represents a read-only stack manipulation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForStackManipulation implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented stack manipulation.
&nbsp;                 */
&nbsp;                private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target for an offset mapping for a stack manipulation.
&nbsp;                 *
&nbsp;                 * @param stackManipulation The represented stack manipulation.
&nbsp;                 */
<b class="fc">&nbsp;                public ForStackManipulation(StackManipulation stackManipulation) {</b>
<b class="fc">&nbsp;                    this.stackManipulation = stackManipulation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a target for a {@link Method} or {@link Constructor} constant.
&nbsp;                 *
&nbsp;                 * @param methodDescription The method or constructor to represent.
&nbsp;                 * @return A mapping for a method or constructor constant.
&nbsp;                 */
&nbsp;                public static Target of(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                    return new ForStackManipulation(MethodConstant.of(methodDescription));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a target for an offset mapping for a type constant.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type constant to represent.
&nbsp;                 * @return A mapping for a type constant.
&nbsp;                 */
&nbsp;                public static Target of(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    return new ForStackManipulation(ClassConstant.of(typeDescription));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a target for an offset mapping for a constant value or {@code null}.
&nbsp;                 *
&nbsp;                 * @param value The constant value to represent or {@code null}.
&nbsp;                 * @return An appropriate target for an offset mapping.
&nbsp;                 */
&nbsp;                public static Target of(@MaybeNull Object value) {
<b class="fc">&nbsp;                    return new ForStackManipulation(value == null</b>
<b class="nc">&nbsp;                            ? NullConstant.INSTANCE</b>
<b class="fc">&nbsp;                            : ConstantValue.Simple.wrap(value).toStackManipulation());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveRead() {
<b class="fc">&nbsp;                    return stackManipulation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot write to constant value: &quot; + stackManipulation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot write to constant value: &quot; + stackManipulation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A constant value that can be written to.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Writable implements Target {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The reading stack manipulation.
&nbsp;                     */
&nbsp;                    private final StackManipulation read;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The writing stack manipulation.
&nbsp;                     */
&nbsp;                    private final StackManipulation write;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a writable target.
&nbsp;                     *
&nbsp;                     * @param read  The reading stack manipulation.
&nbsp;                     * @param write The writing stack manipulation.
&nbsp;                     */
<b class="fc">&nbsp;                    public Writable(StackManipulation read, StackManipulation write) {</b>
<b class="fc">&nbsp;                        this.read = read;</b>
<b class="fc">&nbsp;                        this.write = write;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveRead() {
<b class="nc">&nbsp;                        return read;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveWrite() {
<b class="fc">&nbsp;                        return write;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation resolveIncrement(int value) {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot increment mutable constant value: &quot; + write);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a factory for creating a {@link OffsetMapping} for a given parameter for a given annotation.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The annotation type that triggers this factory.
&nbsp;         */
&nbsp;        interface Factory&lt;T extends Annotation&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the annotation type of this factory.
&nbsp;             *
&nbsp;             * @return The factory&#39;s annotation type.
&nbsp;             */
&nbsp;            Class&lt;T&gt; getAnnotationType();
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for the supplied parameter if possible.
&nbsp;             *
&nbsp;             * @param target     The parameter description for which to resolve an offset mapping.
&nbsp;             * @param annotation The annotation that triggered this factory.
&nbsp;             * @param adviceType {@code true} if the binding is applied using advice method delegation.
&nbsp;             * @return A resolved offset mapping or {@code null} if no mapping can be resolved for this parameter.
&nbsp;             */
&nbsp;            OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType);
&nbsp;
&nbsp;            /**
&nbsp;             * Describes the type of advice being applied.
&nbsp;             */
<b class="fc">&nbsp;            enum AdviceType {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates advice where the invocation is delegated.
&nbsp;                 */
<b class="fc">&nbsp;                DELEGATION(true),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates advice where the invocation&#39;s code is copied into the target method.
&nbsp;                 */
<b class="fc">&nbsp;                INLINING(false);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if delegation is used.
&nbsp;                 */
&nbsp;                private final boolean delegation;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new advice type.
&nbsp;                 *
&nbsp;                 * @param delegation {@code true} if delegation is used.
&nbsp;                 */
<b class="fc">&nbsp;                AdviceType(boolean delegation) {</b>
<b class="fc">&nbsp;                    this.delegation = delegation;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if delegation is used.
&nbsp;                 *
&nbsp;                 * @return {@code true} if delegation is used.
&nbsp;                 */
&nbsp;                public boolean isDelegation() {
<b class="fc">&nbsp;                    return delegation;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A simple factory that binds a constant offset mapping.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type that represents this offset mapping.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Simple&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type being bound.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The fixed offset mapping.
&nbsp;                 */
&nbsp;                private final OffsetMapping offsetMapping;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a simple factory for a simple binding for an offset mapping.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type being bound.
&nbsp;                 * @param offsetMapping  The fixed offset mapping.
&nbsp;                 */
<b class="fc">&nbsp;                public Simple(Class&lt;T&gt; annotationType, OffsetMapping offsetMapping) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                    this.offsetMapping = offsetMapping;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
<b class="fc">&nbsp;                    return offsetMapping;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an annotation whose use is not permitted.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Illegal&lt;T extends Annotation&gt; implements Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory that does not permit the usage of the represented annotation.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type.
&nbsp;                 */
<b class="fc">&nbsp;                public Illegal(Class&lt;T&gt; annotationType) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Usage of &quot; + annotationType + &quot; is not allowed on &quot; + target);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes the sort of the executed advice.
&nbsp;         */
<b class="fc">&nbsp;        enum Sort {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that an offset is mapped for an enter advice.
&nbsp;             */
<b class="fc">&nbsp;            ENTER {</b>
&nbsp;                @Override
&nbsp;                public boolean isPremature(MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return methodDescription.isConstructor();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that an offset is mapped for an exit advice.
&nbsp;             */
<b class="fc">&nbsp;            EXIT {</b>
&nbsp;                @Override
&nbsp;                public boolean isPremature(MethodDescription methodDescription) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if an advice is executed in a premature state, i.e. the instrumented method is a constructor where the super constructor is not
&nbsp;             * yet invoked. In this case, the {@code this} reference is not yet initialized and therefore not available.
&nbsp;             *
&nbsp;             * @param methodDescription The instrumented method.
&nbsp;             * @return {@code true} if the advice is executed premature for the instrumented method.
&nbsp;             */
&nbsp;            public abstract boolean isPremature(MethodDescription methodDescription);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for a given parameter of the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class ForArgument implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The type expected by the advice method.
&nbsp;             */
&nbsp;            protected final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if the parameter is to be treated as read-only.
&nbsp;             */
&nbsp;            protected final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply when assigning values.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for a parameter of the instrumented method.
&nbsp;             *
&nbsp;             * @param target   The type expected by the advice method.
&nbsp;             * @param readOnly Determines if the parameter is to be treated as read-only.
&nbsp;             * @param typing   The typing to apply.
&nbsp;             */
<b class="fc">&nbsp;            protected ForArgument(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                ParameterDescription parameterDescription = resolve(instrumentedMethod);</b>
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(parameterDescription.getType(), target, typing);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + target);</b>
<b class="fc">&nbsp;                } else if (readOnly) {</b>
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadOnly(parameterDescription.getType(), argumentHandler.argument(parameterDescription.getOffset()), readAssignment);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation writeAssignment = assigner.assign(target, parameterDescription.getType(), typing);</b>
<b class="fc">&nbsp;                    if (!writeAssignment.isValid()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + target);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadWrite(parameterDescription.getType(), argumentHandler.argument(parameterDescription.getOffset()), readAssignment,</b>
&nbsp;                            writeAssignment);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the bound parameter.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return The bound parameter.
&nbsp;             */
&nbsp;            protected abstract ParameterDescription resolve(MethodDescription instrumentedMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * An offset mapping for a parameter of the instrumented method with a specific index.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Unresolved extends ForArgument {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the parameter.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if the parameter binding is optional.
&nbsp;                 */
&nbsp;                private final boolean optional;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new offset binding for a parameter with a given index.
&nbsp;                 *
&nbsp;                 * @param target     The target type.
&nbsp;                 * @param annotation The annotation that triggers this binding.
&nbsp;                 */
&nbsp;                protected Unresolved(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;Argument&gt; annotation) {
<b class="fc">&nbsp;                    this(target, annotation.getValue(Factory.ARGUMENT_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                            annotation.getValue(Factory.ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                            annotation.getValue(Factory.ARGUMENT_VALUE).resolve(Integer.class),</b>
<b class="fc">&nbsp;                            annotation.getValue(Factory.ARGUMENT_OPTIONAL).resolve(Boolean.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new offset binding for a parameter with a given index.
&nbsp;                 *
&nbsp;                 * @param parameterDescription The parameter triggering this binding.
&nbsp;                 */
&nbsp;                protected Unresolved(ParameterDescription parameterDescription) {
<b class="fc">&nbsp;                    this(parameterDescription.getType(), true, Assigner.Typing.STATIC, parameterDescription.getIndex());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-optional offset binding for a parameter with a given index.
&nbsp;                 *
&nbsp;                 * @param target   The type expected by the advice method.
&nbsp;                 * @param readOnly Determines if the parameter is to be treated as read-only.
&nbsp;                 * @param typing   The typing to apply.
&nbsp;                 * @param index    The index of the parameter.
&nbsp;                 */
&nbsp;                public Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, int index) {
<b class="fc">&nbsp;                    this(target, readOnly, typing, index, false);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new offset binding for a parameter with a given index.
&nbsp;                 *
&nbsp;                 * @param target   The type expected by the advice method.
&nbsp;                 * @param readOnly Determines if the parameter is to be treated as read-only.
&nbsp;                 * @param typing   The typing to apply.
&nbsp;                 * @param index    The index of the parameter.
&nbsp;                 * @param optional {@code true} if the parameter binding is optional.
&nbsp;                 */
&nbsp;                public Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, int index, boolean optional) {
<b class="fc">&nbsp;                    super(target, readOnly, typing);</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.optional = optional;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected ParameterDescription resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    ParameterList&lt;?&gt; parameters = instrumentedMethod.getParameters();</b>
<b class="fc">&nbsp;                    if (parameters.size() &lt;= index) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; does not define an index &quot; + index);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return parameters.get(index);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Target resolve(TypeDescription instrumentedType,
&nbsp;                                      MethodDescription instrumentedMethod,
&nbsp;                                      Assigner assigner,
&nbsp;                                      ArgumentHandler argumentHandler,
&nbsp;                                      Sort sort) {
<b class="fc">&nbsp;                    if (optional &amp;&amp; instrumentedMethod.getParameters().size() &lt;= index) {</b>
<b class="fc">&nbsp;                        return readOnly</b>
<b class="fc">&nbsp;                                ? new Target.ForDefaultValue.ReadOnly(target)</b>
<b class="nc">&nbsp;                                : new Target.ForDefaultValue.ReadWrite(target);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return super.resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, sort);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a mapping of a parameter of the instrumented method.
&nbsp;                 */
<b class="fc">&nbsp;                protected enum Factory implements OffsetMapping.Factory&lt;Argument&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link Argument#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link Argument#readOnly()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_READ_ONLY;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link Argument#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_TYPING;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link Argument#optional()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape ARGUMENT_OPTIONAL;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(Argument.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        ARGUMENT_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        ARGUMENT_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        ARGUMENT_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        ARGUMENT_OPTIONAL = methods.filter(named(&quot;optional&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;Argument&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return Argument.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;Argument&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="fc">&nbsp;                        if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(ARGUMENT_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot define writable field access for &quot; + target + &quot; when using delegation&quot;);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return new ForArgument.Unresolved(target.getType(), annotation);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An offset mapping for a specific parameter of the instrumented method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Resolved extends ForArgument {
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter being bound.
&nbsp;                 */
&nbsp;                private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an offset mapping that binds a parameter of the instrumented method.
&nbsp;                 *
&nbsp;                 * @param target               The type expected by the advice method.
&nbsp;                 * @param readOnly             Determines if the parameter is to be treated as read-only.
&nbsp;                 * @param typing               The typing to apply.
&nbsp;                 * @param parameterDescription The parameter being bound.
&nbsp;                 */
&nbsp;                public Resolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, ParameterDescription parameterDescription) {
<b class="fc">&nbsp;                    super(target, readOnly, typing);</b>
<b class="fc">&nbsp;                    this.parameterDescription = parameterDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected ParameterDescription resolve(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    if (!parameterDescription.getDeclaringMethod().equals(instrumentedMethod)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(parameterDescription + &quot; is not a parameter of &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return parameterDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a parameter argument of the instrumented method.
&nbsp;                 *
&nbsp;                 * @param &lt;T&gt; The type of the bound annotation.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Factory&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation type.
&nbsp;                     */
&nbsp;                    private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The bound parameter.
&nbsp;                     */
&nbsp;                    private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the factory should create a read-only binding.
&nbsp;                     */
&nbsp;                    private final boolean readOnly;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The typing to use.
&nbsp;                     */
&nbsp;                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new factory for binding a parameter of the instrumented method with read-only semantics and static typing.
&nbsp;                     *
&nbsp;                     * @param annotationType       The annotation type.
&nbsp;                     * @param parameterDescription The bound parameter.
&nbsp;                     */
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, ParameterDescription parameterDescription) {
<b class="fc">&nbsp;                        this(annotationType, parameterDescription, true, Assigner.Typing.STATIC);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new factory for binding a parameter of the instrumented method.
&nbsp;                     *
&nbsp;                     * @param annotationType       The annotation type.
&nbsp;                     * @param parameterDescription The bound parameter.
&nbsp;                     * @param readOnly             {@code true} if the factory should create a read-only binding.
&nbsp;                     * @param typing               The typing to use.
&nbsp;                     */
<b class="fc">&nbsp;                    public Factory(Class&lt;T&gt; annotationType, ParameterDescription parameterDescription, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                        this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                        this.parameterDescription = parameterDescription;</b>
<b class="fc">&nbsp;                        this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                        this.typing = typing;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return annotationType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;T&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="fc">&nbsp;                        return new Resolved(target.getType(), readOnly, typing, parameterDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that provides access to the {@code this} reference of the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForThisReference implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The type that the advice method expects for the {@code this} reference.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if the parameter is to be treated as read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the parameter should be bound to {@code null} if the instrumented method is static.
&nbsp;             */
&nbsp;            private final boolean optional;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for a {@code this} reference.
&nbsp;             *
&nbsp;             * @param target     The type that the advice method expects for the {@code this} reference.
&nbsp;             * @param annotation The mapped annotation.
&nbsp;             */
&nbsp;            protected ForThisReference(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;This&gt; annotation) {
<b class="fc">&nbsp;                this(target,</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.THIS_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.THIS_OPTIONAL).resolve(Boolean.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for a {@code this} reference.
&nbsp;             *
&nbsp;             * @param target   The type that the advice method expects for the {@code this} reference.
&nbsp;             * @param readOnly Determines if the parameter is to be treated as read-only.
&nbsp;             * @param typing   The typing to apply.
&nbsp;             * @param optional {@code true} if the parameter should be bound to {@code null} if the instrumented method is static.
&nbsp;             */
<b class="fc">&nbsp;            public ForThisReference(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, boolean optional) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
<b class="fc">&nbsp;                this.optional = optional;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                if (instrumentedMethod.isStatic() || sort.isPremature(instrumentedMethod)) {</b>
<b class="fc">&nbsp;                    if (optional) {</b>
<b class="fc">&nbsp;                        return readOnly</b>
<b class="fc">&nbsp;                                ? new Target.ForDefaultValue.ReadOnly(instrumentedType)</b>
<b class="nc">&nbsp;                                : new Target.ForDefaultValue.ReadWrite(instrumentedType);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot map this reference for static method or constructor start: &quot; + instrumentedMethod);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(instrumentedType.asGenericType(), target, typing);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedType + &quot; to &quot; + target);</b>
<b class="fc">&nbsp;                } else if (readOnly) {</b>
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadOnly(instrumentedType.asGenericType(), argumentHandler.argument(ArgumentHandler.THIS_REFERENCE), readAssignment);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation writeAssignment = assigner.assign(target, instrumentedType.asGenericType(), typing);</b>
<b class="fc">&nbsp;                    if (!writeAssignment.isValid()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadWrite(instrumentedType.asGenericType(), argumentHandler.argument(ArgumentHandler.THIS_REFERENCE), readAssignment,</b>
&nbsp;                            writeAssignment);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ForThisReference} offset mapping.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;This&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link This#readOnly()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape THIS_READ_ONLY;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link This#typing()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape THIS_TYPING;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link This#optional()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape THIS_OPTIONAL;
&nbsp;
&nbsp;                /*
&nbsp;                 * Resolves annotation properties.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(This.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                    THIS_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    THIS_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    THIS_OPTIONAL = methods.filter(named(&quot;optional&quot;)).getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;This&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return This.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;This&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(THIS_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write to this reference for &quot; + target + &quot; in read-only context&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForThisReference(target.getType(), annotation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that maps an array containing all arguments of the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForAllArguments implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The component target type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the array is read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the method&#39;s target instance should be considered an element of the produced array.
&nbsp;             */
&nbsp;            private final boolean includeSelf;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if a {@code null} value should be assigned if the
&nbsp;             * instrumented method does not declare any parameters.
&nbsp;             */
&nbsp;            private final boolean nullIfEmpty;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for an array containing all arguments.
&nbsp;             *
&nbsp;             * @param target     The component target type.
&nbsp;             * @param annotation The mapped annotation.
&nbsp;             */
&nbsp;            protected ForAllArguments(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;AllArguments&gt; annotation) {
<b class="fc">&nbsp;                this(target, annotation.getValue(Factory.ALL_ARGUMENTS_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.ALL_ARGUMENTS_INCLUDE_SELF).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.ALL_ARGUMENTS_NULL_IF_EMPTY).resolve(Boolean.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for an array containing all arguments.
&nbsp;             *
&nbsp;             * @param target      The component target type.
&nbsp;             * @param readOnly    {@code true} if the array is read-only.
&nbsp;             * @param typing      The typing to apply.
&nbsp;             * @param includeSelf {@code true} if the method&#39;s target instance should be considered
&nbsp;             *                    an element of the produced array.
&nbsp;             * @param nullIfEmpty {@code true} if a {@code null} value should be assigned if the
&nbsp;             *                    instrumented method does not declare any parameters.
&nbsp;             */
<b class="fc">&nbsp;            public ForAllArguments(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, boolean includeSelf, boolean nullIfEmpty) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
<b class="fc">&nbsp;                this.includeSelf = includeSelf;</b>
<b class="fc">&nbsp;                this.nullIfEmpty = nullIfEmpty;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                if (nullIfEmpty &amp;&amp; instrumentedMethod.getParameters().isEmpty() &amp;&amp; (!includeSelf || instrumentedMethod.isStatic())) {</b>
<b class="fc">&nbsp;                    return readOnly</b>
<b class="fc">&nbsp;                            ? new Target.ForStackManipulation(NullConstant.INSTANCE)</b>
<b class="fc">&nbsp;                            : new Target.ForStackManipulation.Writable(NullConstant.INSTANCE, Removal.SINGLE);</b>
&nbsp;                }
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; reads = new ArrayList&lt;StackManipulation&gt;((includeSelf &amp;&amp; !instrumentedMethod.isStatic()</b>
<b class="fc">&nbsp;                        ? 1</b>
<b class="fc">&nbsp;                        : 0) + instrumentedMethod.getParameters().size());</b>
<b class="fc">&nbsp;                if (includeSelf &amp;&amp; !instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                    if (sort.isPremature(instrumentedMethod) &amp;&amp; instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot include self in all arguments array from &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(instrumentedMethod.getDeclaringType().asGenericType(), target, typing);</b>
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedMethod.getDeclaringType() + &quot; to &quot; + target);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    reads.add(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.REFERENCE.loadFrom(argumentHandler.argument(ArgumentHandler.THIS_REFERENCE)),</b>
&nbsp;                            assignment));
&nbsp;                }
<b class="fc">&nbsp;                for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(parameterDescription.getType(), target, typing);</b>
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + parameterDescription + &quot; to &quot; + target);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    reads.add(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            MethodVariableAccess.of(parameterDescription.getType()).loadFrom(argumentHandler.argument(parameterDescription.getOffset())),</b>
&nbsp;                            assignment));
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (readOnly) {</b>
<b class="fc">&nbsp;                    return new Target.ForArray.ReadOnly(target, reads);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    List&lt;StackManipulation&gt; writes = new ArrayList&lt;StackManipulation&gt;(2 * ((includeSelf &amp;&amp; !instrumentedMethod.isStatic()</b>
<b class="nc">&nbsp;                            ? 1</b>
<b class="fc">&nbsp;                            : 0) + instrumentedMethod.getParameters().size()));</b>
<b class="fc">&nbsp;                    if (includeSelf &amp;&amp; !instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                        StackManipulation assignment = assigner.assign(target, instrumentedMethod.getDeclaringType().asGenericType(), typing);</b>
<b class="nc">&nbsp;                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + instrumentedMethod.getDeclaringType());</b>
&nbsp;                        }
<b class="nc">&nbsp;                        writes.add(new StackManipulation.Compound(</b>
&nbsp;                                assignment,
<b class="nc">&nbsp;                                MethodVariableAccess.REFERENCE.storeAt(argumentHandler.argument(ArgumentHandler.THIS_REFERENCE))));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="fc">&nbsp;                        StackManipulation assignment = assigner.assign(target, parameterDescription.getType(), typing);</b>
<b class="fc">&nbsp;                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + parameterDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        writes.add(new StackManipulation.Compound(</b>
&nbsp;                                assignment,
<b class="fc">&nbsp;                                MethodVariableAccess.of(parameterDescription.getType()).storeAt(argumentHandler.argument(parameterDescription.getOffset()))));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new Target.ForArray.ReadWrite(target, reads, writes);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an offset mapping that maps all arguments values of the instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;AllArguments&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link AllArguments#readOnly()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_READ_ONLY;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link AllArguments#typing()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_TYPING;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link AllArguments#includeSelf()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_INCLUDE_SELF;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link AllArguments#nullIfEmpty()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape ALL_ARGUMENTS_NULL_IF_EMPTY;
&nbsp;
&nbsp;                /*
&nbsp;                 * Resolves annotation properties.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(AllArguments.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                    ALL_ARGUMENTS_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    ALL_ARGUMENTS_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    ALL_ARGUMENTS_INCLUDE_SELF = methods.filter(named(&quot;includeSelf&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    ALL_ARGUMENTS_NULL_IF_EMPTY = methods.filter(named(&quot;nullIfEmpty&quot;)).getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;AllArguments&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return AllArguments.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;AllArguments&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (!target.getType().represents(Object.class) &amp;&amp; !target.getType().isArray()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot use AllArguments annotation on a non-array type&quot;);</b>
<b class="fc">&nbsp;                    } else if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(ALL_ARGUMENTS_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot define writable field access for &quot; + target);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForAllArguments(target.getType().represents(Object.class)</b>
<b class="fc">&nbsp;                                ? TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;                                : target.getType().getComponentType(), annotation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Maps the declaring type of the instrumented method.
&nbsp;         */
<b class="fc">&nbsp;        enum ForInstrumentedType implements OffsetMapping {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                return Target.ForStackManipulation.of(instrumentedType);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Maps a constant representing the instrumented method.
&nbsp;         */
<b class="fc">&nbsp;        enum ForInstrumentedMethod implements OffsetMapping {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A constant that must be a {@link Method} instance.
&nbsp;             */
<b class="fc">&nbsp;            METHOD {</b>
&nbsp;                @Override
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return instrumentedMethod.isMethod();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                    return Target.ForStackManipulation.of(methodDescription);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A constant that must be a {@link Constructor} instance.
&nbsp;             */
<b class="fc">&nbsp;            CONSTRUCTOR {</b>
&nbsp;                @Override
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return instrumentedMethod.isConstructor();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                    return Target.ForStackManipulation.of(methodDescription);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A constant that must be a {@code java.lang.reflect.Executable} instance.
&nbsp;             */
<b class="fc">&nbsp;            EXECUTABLE {</b>
&nbsp;                @Override
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
<b class="nc">&nbsp;                    return Target.ForStackManipulation.of(methodDescription);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;
&nbsp;            /**
&nbsp;             * A constant that must be a {@code java.lang.invoke.MethodHandle} instance.
&nbsp;             */
<b class="fc">&nbsp;            METHOD_HANDLE {</b>
&nbsp;                @Override
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                    return new Target.ForStackManipulation(JavaConstant.MethodHandle.of(methodDescription).toStackManipulation());</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A constant that must be a {@code java.lang.invoke.MethodType} instance.
&nbsp;             */
<b class="fc">&nbsp;            METHOD_TYPE {</b>
&nbsp;                @Override
&nbsp;                protected boolean isRepresentable(MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Target resolve(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                    return new Target.ForStackManipulation(JavaConstant.MethodType.of(methodDescription).toStackManipulation());</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                if (!isRepresentable(instrumentedMethod)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot represent &quot; + instrumentedMethod + &quot; as the specified constant&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return resolve(instrumentedMethod.asDefined());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the supplied method is representable for the assigned offset mapping.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method to represent.
&nbsp;             * @return {@code true} if this method is representable.
&nbsp;             */
&nbsp;            protected abstract boolean isRepresentable(MethodDescription instrumentedMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the target for a given method description.
&nbsp;             *
&nbsp;             * @param methodDescription The method description for which to resolve a constant.
&nbsp;             * @return A suitable target.
&nbsp;             */
&nbsp;            protected abstract Target resolve(MethodDescription.InDefinedShape methodDescription);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for a field.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        abstract class ForField implements OffsetMapping {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The {@link FieldValue#value()} method.
&nbsp;             */
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_VALUE;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@link FieldValue#declaringType()}} method.
&nbsp;             */
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_DECLARING_TYPE;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@link FieldValue#readOnly()}} method.
&nbsp;             */
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_READ_ONLY;
&nbsp;
&nbsp;            /**
&nbsp;             * The {@link FieldValue#typing()}} method.
&nbsp;             */
&nbsp;            private static final MethodDescription.InDefinedShape FIELD_TYPING;
&nbsp;
&nbsp;            /*
&nbsp;             * Looks up all annotation properties to avoid loading of the declaring field type.
&nbsp;             */
&nbsp;            static {
<b class="fc">&nbsp;                MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(FieldValue.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                FIELD_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                FIELD_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
<b class="fc">&nbsp;                FIELD_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                FIELD_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * The expected type that the field can be assigned to.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if this mapping is read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an offset mapping for a field.
&nbsp;             *
&nbsp;             * @param target   The target type.
&nbsp;             * @param readOnly {@code true} if this mapping is read-only.
&nbsp;             * @param typing   The typing to apply.
&nbsp;             */
<b class="fc">&nbsp;            protected ForField(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (sort.isPremature(instrumentedMethod) &amp;&amp; !fieldDescription.isStatic()) {</b>
<b class="fc">&nbsp;                    if (readOnly) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot read &quot; + fieldDescription + &quot; before super constructor call&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        StackManipulation writeAssignment = assigner.assign(target, fieldDescription.getType(), typing);</b>
<b class="fc">&nbsp;                        if (!writeAssignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + fieldDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Target.ForField.WriteOnly(fieldDescription.asDefined(), writeAssignment);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation readAssignment = assigner.assign(fieldDescription.getType(), target, typing);</b>
<b class="fc">&nbsp;                    if (!readAssignment.isValid()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + fieldDescription + &quot; to &quot; + target);</b>
<b class="fc">&nbsp;                    } else if (readOnly) {</b>
<b class="fc">&nbsp;                        return new Target.ForField.ReadOnly(fieldDescription, readAssignment);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        StackManipulation writeAssignment = assigner.assign(target, fieldDescription.getType(), typing);</b>
<b class="fc">&nbsp;                        if (!writeAssignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + fieldDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new Target.ForField.ReadWrite(fieldDescription.asDefined(), readAssignment, writeAssignment);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the field being bound.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return The field being bound.
&nbsp;             */
&nbsp;            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * An offset mapping for a field that is resolved from the instrumented type by its name.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public abstract static class Unresolved extends ForField {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates that a name should be extracted from an accessor method.
&nbsp;                 */
&nbsp;                protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an offset mapping for a field that is not yet resolved.
&nbsp;                 *
&nbsp;                 * @param target   The target type.
&nbsp;                 * @param readOnly {@code true} if this mapping is read-only.
&nbsp;                 * @param typing   The typing to apply.
&nbsp;                 * @param name     The name of the field.
&nbsp;                 */
&nbsp;                protected Unresolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name) {
<b class="fc">&nbsp;                    super(target, readOnly, typing);</b>
<b class="fc">&nbsp;                    this.name = name;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    FieldLocator locator = fieldLocator(instrumentedType);</b>
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY)</b>
<b class="fc">&nbsp;                            ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod)</b>
<b class="fc">&nbsp;                            : locator.locate(name);</b>
<b class="fc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot locate field named &quot; + name + &quot; for &quot; + instrumentedType);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return resolution.getField();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a field locator for this instance.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @return An appropriate field locator.
&nbsp;                 */
&nbsp;                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
&nbsp;
&nbsp;                /**
&nbsp;                 * An offset mapping for a field with an implicit declaring type.
&nbsp;                 */
&nbsp;                public static class WithImplicitType extends Unresolved {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an offset mapping for a field with an implicit declaring type.
&nbsp;                     *
&nbsp;                     * @param target     The target type.
&nbsp;                     * @param annotation The annotation to represent.
&nbsp;                     */
&nbsp;                    protected WithImplicitType(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;FieldValue&gt; annotation) {
<b class="fc">&nbsp;                        this(target,</b>
<b class="fc">&nbsp;                                annotation.getValue(FIELD_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(FIELD_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(FIELD_VALUE).resolve(String.class));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an offset mapping for a field with an implicit declaring type.
&nbsp;                     *
&nbsp;                     * @param target   The target type.
&nbsp;                     * @param name     The name of the field.
&nbsp;                     * @param readOnly {@code true} if the field is read-only.
&nbsp;                     * @param typing   The typing to apply.
&nbsp;                     */
&nbsp;                    public WithImplicitType(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, String name) {
<b class="fc">&nbsp;                        super(target, readOnly, typing, name);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                        return new FieldLocator.ForClassHierarchy(instrumentedType);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An offset mapping for a field with an explicit declaring type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithExplicitType extends Unresolved {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type declaring the field.
&nbsp;                     */
&nbsp;                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an offset mapping for a field with an explicit declaring type.
&nbsp;                     *
&nbsp;                     * @param target        The target type.
&nbsp;                     * @param annotation    The annotation to represent.
&nbsp;                     * @param declaringType The field&#39;s declaring type.
&nbsp;                     */
&nbsp;                    protected WithExplicitType(TypeDescription.Generic target,
&nbsp;                                               AnnotationDescription.Loadable&lt;FieldValue&gt; annotation,
&nbsp;                                               TypeDescription declaringType) {
<b class="fc">&nbsp;                        this(target,</b>
<b class="fc">&nbsp;                                annotation.getValue(FIELD_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(FIELD_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(FIELD_VALUE).resolve(String.class),</b>
&nbsp;                                declaringType);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an offset mapping for a field with an explicit declaring type.
&nbsp;                     *
&nbsp;                     * @param target        The target type.
&nbsp;                     * @param name          The name of the field.
&nbsp;                     * @param readOnly      {@code true} if the field is read-only.
&nbsp;                     * @param typing        The typing to apply.
&nbsp;                     * @param declaringType The field&#39;s declaring type.
&nbsp;                     */
&nbsp;                    public WithExplicitType(TypeDescription.Generic target,
&nbsp;                                            boolean readOnly,
&nbsp;                                            Assigner.Typing typing,
&nbsp;                                            String name,
&nbsp;                                            TypeDescription declaringType) {
<b class="fc">&nbsp;                        super(target, readOnly, typing, name);</b>
<b class="fc">&nbsp;                        this.declaringType = declaringType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                        if (!declaringType.represents(TargetType.class) &amp;&amp; !instrumentedType.isAssignableTo(declaringType)) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(declaringType + &quot; is no super type of &quot; + instrumentedType);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a {@link Unresolved} offset mapping.
&nbsp;                 */
<b class="fc">&nbsp;                protected enum Factory implements OffsetMapping.Factory&lt;FieldValue&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;FieldValue&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return FieldValue.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;FieldValue&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="fc">&nbsp;                        if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(ForField.FIELD_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write to field for &quot; + target + &quot; in read-only context&quot;);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            TypeDescription declaringType = annotation.getValue(FIELD_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                            return declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                                    ? new WithImplicitType(target.getType(), annotation)</b>
<b class="fc">&nbsp;                                    : new WithExplicitType(target.getType(), annotation, declaringType);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A binding for an offset mapping that represents a specific field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Resolved extends ForField {
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessed field.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a resolved offset mapping for a field.
&nbsp;                 *
&nbsp;                 * @param target           The target type.
&nbsp;                 * @param readOnly         {@code true} if this mapping is read-only.
&nbsp;                 * @param typing           The typing to apply.
&nbsp;                 * @param fieldDescription The accessed field.
&nbsp;                 */
&nbsp;                public Resolved(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                    super(target, readOnly, typing);</b>
<b class="fc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    if (!fieldDescription.isStatic() &amp;&amp; !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(fieldDescription + &quot; is no member of &quot; + instrumentedType);</b>
<b class="fc">&nbsp;                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory that binds a field.
&nbsp;                 *
&nbsp;                 * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Factory&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation type.
&nbsp;                     */
&nbsp;                    private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field to be bound.
&nbsp;                     */
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if this factory should create a read-only binding.
&nbsp;                     */
&nbsp;                    private final boolean readOnly;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The typing to use.
&nbsp;                     */
&nbsp;                    private final Assigner.Typing typing;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new factory for binding a specific field with read-only semantics and static typing.
&nbsp;                     *
&nbsp;                     * @param annotationType   The annotation type.
&nbsp;                     * @param fieldDescription The field to bind.
&nbsp;                     */
&nbsp;                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription) {
<b class="fc">&nbsp;                        this(annotationType, fieldDescription, true, Assigner.Typing.STATIC);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new factory for binding a specific field.
&nbsp;                     *
&nbsp;                     * @param annotationType   The annotation type.
&nbsp;                     * @param fieldDescription The field to bind.
&nbsp;                     * @param readOnly         {@code true} if this factory should create a read-only binding.
&nbsp;                     * @param typing           The typing to use.
&nbsp;                     */
<b class="fc">&nbsp;                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                        this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                        this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;                        this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                        this.typing = typing;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return annotationType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;T&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="fc">&nbsp;                        return new Resolved(target.getType(), readOnly, typing, fieldDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for a field handle.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class ForFieldHandle implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The access type of the represented handle.
&nbsp;             */
&nbsp;            private final Access access;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an offset mapping for a field handle.
&nbsp;             *
&nbsp;             * @param access The access type of the represented handle.
&nbsp;             */
<b class="fc">&nbsp;            protected ForFieldHandle(Access access) {</b>
<b class="fc">&nbsp;                this.access = access;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                FieldDescription fieldDescription = resolve(instrumentedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!fieldDescription.isStatic() &amp;&amp; instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access non-static field &quot; + fieldDescription + &quot; from static method &quot; + instrumentedMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (sort.isPremature(instrumentedMethod) &amp;&amp; !fieldDescription.isStatic()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; before super constructor call&quot;);</b>
<b class="fc">&nbsp;                } else if (fieldDescription.isStatic()) {</b>
<b class="nc">&nbsp;                    return new Target.ForStackManipulation(access.resolve(fieldDescription.asDefined()).toStackManipulation());</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new Target.ForStackManipulation(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                            access.resolve(fieldDescription.asDefined()).toStackManipulation(),</b>
<b class="fc">&nbsp;                            MethodVariableAccess.REFERENCE.loadFrom(argumentHandler.argument(ArgumentHandler.THIS_REFERENCE)),</b>
<b class="fc">&nbsp;                            MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token(&quot;bindTo&quot;,</b>
&nbsp;                                    Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                    JavaType.METHOD_HANDLE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                    new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class)))))));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the field being bound.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @return The field being bound.
&nbsp;             */
&nbsp;            protected abstract FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * A description of the field handle&#39;s access type.
&nbsp;             */
<b class="fc">&nbsp;            public enum Access {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines the resolution of a getter for the method handle.
&nbsp;                 */
<b class="fc">&nbsp;                GETTER {</b>
&nbsp;                    @Override
&nbsp;                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
<b class="fc">&nbsp;                        return JavaConstant.MethodHandle.ofGetter(fieldDescription);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Determines the resolution of a setter for the method handle.
&nbsp;                 */
<b class="fc">&nbsp;                SETTER {</b>
&nbsp;                    @Override
&nbsp;                    protected JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription) {
<b class="fc">&nbsp;                        return JavaConstant.MethodHandle.ofSetter(fieldDescription);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the appropriate method handle.
&nbsp;                 *
&nbsp;                 * @param fieldDescription The field description to resolve the handle for.
&nbsp;                 * @return The appropriate method handle.
&nbsp;                 */
&nbsp;                protected abstract JavaConstant.MethodHandle resolve(FieldDescription.InDefinedShape fieldDescription);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An offset mapping for a field handle that is resolved from the instrumented type by its name.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public abstract static class Unresolved extends ForFieldHandle {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates that a name should be extracted from an accessor method.
&nbsp;                 */
&nbsp;                protected static final String BEAN_PROPERTY = &quot;&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the field.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an offset mapping for a field that is not yet resolved.
&nbsp;                 *
&nbsp;                 * @param access The access type of the represented handle.
&nbsp;                 * @param name   The name of the field.
&nbsp;                 */
&nbsp;                public Unresolved(Access access, String name) {
<b class="fc">&nbsp;                    super(access);</b>
<b class="fc">&nbsp;                    this.name = name;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                    FieldLocator locator = fieldLocator(instrumentedType);</b>
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = name.equals(BEAN_PROPERTY)</b>
<b class="fc">&nbsp;                            ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod)</b>
<b class="fc">&nbsp;                            : locator.locate(name);</b>
<b class="fc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot locate field named &quot; + name + &quot; for &quot; + instrumentedType);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return resolution.getField();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a field locator for this instance.
&nbsp;                 *
&nbsp;                 * @param instrumentedType The instrumented type.
&nbsp;                 * @return An appropriate field locator.
&nbsp;                 */
&nbsp;                protected abstract FieldLocator fieldLocator(TypeDescription instrumentedType);
&nbsp;
&nbsp;                /**
&nbsp;                 * An offset mapping for a field handle with an implicit declaring type.
&nbsp;                 */
&nbsp;                public static class WithImplicitType extends Unresolved {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an offset mapping for a field handle with an implicit declaring type.
&nbsp;                     *
&nbsp;                     * @param access The access type of the represented handle.
&nbsp;                     * @param name   The name of the field.
&nbsp;                     */
&nbsp;                    public WithImplicitType(Access access, String name) {
<b class="fc">&nbsp;                        super(access, name);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                        return new FieldLocator.ForClassHierarchy(instrumentedType);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An offset mapping for a field handle with an explicit declaring type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithExplicitType extends Unresolved {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type declaring the field.
&nbsp;                     */
&nbsp;                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an offset mapping for a field handle with an explicit declaring type.
&nbsp;                     *
&nbsp;                     * @param access        The access type of the represented handle.
&nbsp;                     * @param name          The name of the field.
&nbsp;                     * @param declaringType The type declaring the field.
&nbsp;                     */
&nbsp;                    public WithExplicitType(Access access, String name, TypeDescription declaringType) {
<b class="fc">&nbsp;                        super(access, name);</b>
<b class="fc">&nbsp;                        this.declaringType = declaringType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected FieldLocator fieldLocator(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                        if (!declaringType.represents(TargetType.class) &amp;&amp; !instrumentedType.isAssignableTo(declaringType)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(declaringType + &quot; is no super type of &quot; + instrumentedType);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return new FieldLocator.ForExactType(TargetType.resolve(declaringType, instrumentedType));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a {@link ForFieldHandle.Unresolved} offset mapping representing a getter.
&nbsp;                 */
<b class="fc">&nbsp;                protected enum ReaderFactory implements OffsetMapping.Factory&lt;FieldGetterHandle&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@link FieldGetterHandle#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@link FieldGetterHandle#declaringType()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_GETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(FieldGetterHandle.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        FIELD_GETTER_HANDLE_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        FIELD_GETTER_HANDLE_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;FieldGetterHandle&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return FieldGetterHandle.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;FieldGetterHandle&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="fc">&nbsp;                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        TypeDescription declaringType = annotation.getValue(FIELD_GETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                        return declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                                ? new ForFieldHandle.Unresolved.WithImplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class))</b>
<b class="fc">&nbsp;                                : new ForFieldHandle.Unresolved.WithExplicitType(Access.GETTER, annotation.getValue(FIELD_GETTER_HANDLE_VALUE).resolve(String.class), declaringType);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a {@link ForFieldHandle.Unresolved} offset mapping representing a setter.
&nbsp;                 */
<b class="fc">&nbsp;                protected enum WriterFactory implements OffsetMapping.Factory&lt;FieldSetterHandle&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@link FieldSetterHandle#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The {@link FieldSetterHandle#declaringType()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape FIELD_SETTER_HANDLE_DECLARING_TYPE;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(FieldSetterHandle.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        FIELD_SETTER_HANDLE_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        FIELD_SETTER_HANDLE_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;FieldSetterHandle&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return FieldSetterHandle.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;FieldSetterHandle&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="fc">&nbsp;                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        TypeDescription declaringType = annotation.getValue(FIELD_SETTER_HANDLE_DECLARING_TYPE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                        return declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                                ? new ForFieldHandle.Unresolved.WithImplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class))</b>
<b class="nc">&nbsp;                                : new ForFieldHandle.Unresolved.WithExplicitType(Access.SETTER, annotation.getValue(FIELD_SETTER_HANDLE_VALUE).resolve(String.class), declaringType);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A binding for an offset mapping that represents a specific field.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Resolved extends ForFieldHandle {
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessed field.
&nbsp;                 */
&nbsp;                private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a resolved offset mapping for a field handle.
&nbsp;                 *
&nbsp;                 * @param access           The access type of the represented handle.
&nbsp;                 * @param fieldDescription The accessed field.
&nbsp;                 */
&nbsp;                public Resolved(Access access, FieldDescription fieldDescription) {
<b class="nc">&nbsp;                    super(access);</b>
<b class="nc">&nbsp;                    this.fieldDescription = fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                protected FieldDescription resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="nc">&nbsp;                    if (!fieldDescription.isStatic() &amp;&amp; !fieldDescription.getDeclaringType().asErasure().isAssignableFrom(instrumentedType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(fieldDescription + &quot; is no member of &quot; + instrumentedType);</b>
<b class="nc">&nbsp;                    } else if (!fieldDescription.isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access &quot; + fieldDescription + &quot; from &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return fieldDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory that binds a field handle.
&nbsp;                 *
&nbsp;                 * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Factory&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation type.
&nbsp;                     */
&nbsp;                    private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The field to be bound.
&nbsp;                     */
&nbsp;                    private final FieldDescription fieldDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The access type of the represented handle.
&nbsp;                     */
&nbsp;                    private final Access access;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new factory for binding a specific field handle.
&nbsp;                     *
&nbsp;                     * @param annotationType   The annotation type.
&nbsp;                     * @param fieldDescription The field to bind.
&nbsp;                     * @param access           The access type of the represented handle.
&nbsp;                     */
<b class="nc">&nbsp;                    public Factory(Class&lt;T&gt; annotationType, FieldDescription fieldDescription, Access access) {</b>
<b class="nc">&nbsp;                        this.annotationType = annotationType;</b>
<b class="nc">&nbsp;                        this.fieldDescription = fieldDescription;</b>
<b class="nc">&nbsp;                        this.access = access;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;T&gt; getAnnotationType() {
<b class="nc">&nbsp;                        return annotationType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                              AnnotationDescription.Loadable&lt;T&gt; annotation,
&nbsp;                                              AdviceType adviceType) {
<b class="nc">&nbsp;                        if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign method handle to &quot; + target);</b>
&nbsp;                        }
<b class="nc">&nbsp;                        return new Resolved(access, fieldDescription);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for the {@link Advice.Origin} annotation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForOrigin implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The delimiter character.
&nbsp;             */
&nbsp;            private static final char DELIMITER = &#39;#&#39;;
&nbsp;
&nbsp;            /**
&nbsp;             * The escape character.
&nbsp;             */
&nbsp;            private static final char ESCAPE = &#39;\\&#39;;
&nbsp;
&nbsp;            /**
&nbsp;             * The renderers to apply.
&nbsp;             */
&nbsp;            private final List&lt;Renderer&gt; renderers;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for an origin value.
&nbsp;             *
&nbsp;             * @param renderers The renderers to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForOrigin(List&lt;Renderer&gt; renderers) {</b>
<b class="fc">&nbsp;                this.renderers = renderers;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Parses a pattern of an origin annotation.
&nbsp;             *
&nbsp;             * @param pattern The supplied pattern.
&nbsp;             * @return An appropriate offset mapping.
&nbsp;             */
&nbsp;            public static OffsetMapping parse(String pattern) {
<b class="fc">&nbsp;                if (pattern.equals(Origin.DEFAULT)) {</b>
<b class="fc">&nbsp;                    return new ForOrigin(Collections.&lt;Renderer&gt;singletonList(Renderer.ForStringRepresentation.INSTANCE));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    List&lt;Renderer&gt; renderers = new ArrayList&lt;Renderer&gt;(pattern.length());</b>
<b class="fc">&nbsp;                    int from = 0;</b>
<b class="fc">&nbsp;                    for (int to = pattern.indexOf(DELIMITER); to != -1; to = pattern.indexOf(DELIMITER, from)) {</b>
<b class="fc">&nbsp;                        if (to != 0 &amp;&amp; pattern.charAt(to - 1) == ESCAPE &amp;&amp; (to == 1 || pattern.charAt(to - 2) != ESCAPE)) {</b>
<b class="fc">&nbsp;                            renderers.add(new Renderer.ForConstantValue(pattern.substring(from, Math.max(0, to - 1)) + DELIMITER));</b>
<b class="fc">&nbsp;                            from = to + 1;</b>
<b class="fc">&nbsp;                            continue;</b>
<b class="fc">&nbsp;                        } else if (pattern.length() == to + 1) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Missing sort descriptor for &quot; + pattern + &quot; at index &quot; + to);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        renderers.add(new Renderer.ForConstantValue(pattern.substring(from, to).replace(&quot;&quot; + ESCAPE + ESCAPE, &quot;&quot; + ESCAPE)));</b>
<b class="fc">&nbsp;                        switch (pattern.charAt(to + 1)) {</b>
&nbsp;                            case Renderer.ForMethodName.SYMBOL:
<b class="fc">&nbsp;                                renderers.add(Renderer.ForMethodName.INSTANCE);</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Renderer.ForTypeName.SYMBOL:
<b class="fc">&nbsp;                                renderers.add(Renderer.ForTypeName.INSTANCE);</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Renderer.ForDescriptor.SYMBOL:
<b class="fc">&nbsp;                                renderers.add(Renderer.ForDescriptor.INSTANCE);</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Renderer.ForReturnTypeName.SYMBOL:
<b class="fc">&nbsp;                                renderers.add(Renderer.ForReturnTypeName.INSTANCE);</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Renderer.ForJavaSignature.SYMBOL:
<b class="fc">&nbsp;                                renderers.add(Renderer.ForJavaSignature.INSTANCE);</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Renderer.ForPropertyName.SYMBOL:
<b class="fc">&nbsp;                                renderers.add(Renderer.ForPropertyName.INSTANCE);</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            default:
<b class="fc">&nbsp;                                throw new IllegalStateException(&quot;Illegal sort descriptor &quot; + pattern.charAt(to + 1) + &quot; for &quot; + pattern);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        from = to + 2;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    renderers.add(new Renderer.ForConstantValue(pattern.substring(from)));</b>
<b class="fc">&nbsp;                    return new ForOrigin(renderers);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;                for (Renderer renderer : renderers) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(renderer.apply(instrumentedType, instrumentedMethod));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return Target.ForStackManipulation.of(stringBuilder.toString());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A renderer for an origin pattern element.
&nbsp;             */
&nbsp;            public interface Renderer {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a string representation for this renderer.
&nbsp;                 *
&nbsp;                 * @param instrumentedType   The instrumented type.
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @return The string representation.
&nbsp;                 */
&nbsp;                String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a method&#39;s internal name.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForMethodName implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method name symbol.
&nbsp;                     */
&nbsp;                    public static final char SYMBOL = &#39;m&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return instrumentedMethod.getInternalName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a method declaring type&#39;s binary name.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForTypeName implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type name symbol.
&nbsp;                     */
&nbsp;                    public static final char SYMBOL = &#39;t&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return instrumentedType.getName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a method descriptor.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForDescriptor implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The descriptor symbol.
&nbsp;                     */
&nbsp;                    public static final char SYMBOL = &#39;d&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return instrumentedMethod.getDescriptor();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a method&#39;s Java signature in binary form.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForJavaSignature implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The signature symbol.
&nbsp;                     */
&nbsp;                    public static final char SYMBOL = &#39;s&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        StringBuilder stringBuilder = new StringBuilder(&quot;(&quot;);</b>
<b class="fc">&nbsp;                        boolean comma = false;</b>
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="nc">&nbsp;                            if (comma) {</b>
<b class="nc">&nbsp;                                stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                comma = true;</b>
&nbsp;                            }
<b class="nc">&nbsp;                            stringBuilder.append(typeDescription.getName());</b>
<b class="nc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return stringBuilder.append(&#39;)&#39;).toString();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a method&#39;s return type in binary form.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForReturnTypeName implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The return type symbol.
&nbsp;                     */
&nbsp;                    public static final char SYMBOL = &#39;r&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return instrumentedMethod.getReturnType().asErasure().getName();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a method&#39;s {@link Object#toString()} representation.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForStringRepresentation implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return instrumentedMethod.toString();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a constant value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForConstantValue implements Renderer {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The constant value.
&nbsp;                     */
&nbsp;                    private final String value;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new renderer for a constant value.
&nbsp;                     *
&nbsp;                     * @param value The constant value.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForConstantValue(String value) {</b>
<b class="fc">&nbsp;                        this.value = value;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return value;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A renderer for a property name.
&nbsp;                 */
<b class="fc">&nbsp;                enum ForPropertyName implements Renderer {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The signature symbol.
&nbsp;                     */
&nbsp;                    public static final char SYMBOL = &#39;p&#39;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                        return FieldAccessor.FieldNameExtractor.ForBeanProperty.INSTANCE.resolve(instrumentedMethod);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a method origin.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;Origin&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Origin#value()} method.
&nbsp;                 */
<b class="fc">&nbsp;                private static final MethodDescription.InDefinedShape ORIGIN_VALUE = TypeDescription.ForLoadedType.of(Origin.class)</b>
<b class="fc">&nbsp;                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                        .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;                        .getOnly();</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Origin&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Origin.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Origin&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (target.getType().asErasure().represents(Class.class)) {</b>
<b class="fc">&nbsp;                        return ForInstrumentedType.INSTANCE;</b>
<b class="fc">&nbsp;                    } else if (target.getType().asErasure().represents(Method.class)) {</b>
<b class="fc">&nbsp;                        return ForInstrumentedMethod.METHOD;</b>
<b class="fc">&nbsp;                    } else if (target.getType().asErasure().represents(Constructor.class)) {</b>
<b class="fc">&nbsp;                        return ForInstrumentedMethod.CONSTRUCTOR;</b>
<b class="fc">&nbsp;                    } else if (JavaType.EXECUTABLE.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="nc">&nbsp;                        return ForInstrumentedMethod.EXECUTABLE;</b>
<b class="fc">&nbsp;                    } else if (JavaType.METHOD_HANDLE.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="fc">&nbsp;                        return ForInstrumentedMethod.METHOD_HANDLE;</b>
<b class="fc">&nbsp;                    } else if (JavaType.METHOD_TYPE.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="fc">&nbsp;                        return ForInstrumentedMethod.METHOD_TYPE;</b>
<b class="fc">&nbsp;                    } else if (JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().equals(target.getType().asErasure())) {</b>
<b class="fc">&nbsp;                        return new OffsetMapping.ForStackManipulation(MethodInvocation.lookup(),</b>
<b class="fc">&nbsp;                                JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                target.getType(),</b>
&nbsp;                                Assigner.Typing.STATIC);
<b class="fc">&nbsp;                    } else if (target.getType().asErasure().isAssignableFrom(String.class)) {</b>
<b class="fc">&nbsp;                        return ForOrigin.parse(annotation.getValue(ORIGIN_VALUE).resolve(String.class));</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Non-supported type &quot; + target.getType() + &quot; for @Origin annotation&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for assigning a method handle that invokes the instrumented method.
&nbsp;         */
<b class="fc">&nbsp;        enum ForSelfCallHandle implements OffsetMapping {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A bound assignment that invokes the instrumented method as is.
&nbsp;             */
<b class="fc">&nbsp;            BOUND {</b>
&nbsp;                @Override
&nbsp;                protected StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation) {
<b class="fc">&nbsp;                    List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(1</b>
<b class="fc">&nbsp;                            + (methodDescription.isStatic() ? 0 : 2)</b>
<b class="fc">&nbsp;                            + methodDescription.getParameters().size() * 3);</b>
<b class="fc">&nbsp;                    stackManipulations.add(stackManipulation);</b>
<b class="fc">&nbsp;                    if (!methodDescription.isStatic()) {</b>
<b class="fc">&nbsp;                        stackManipulations.add(MethodVariableAccess.loadThis());</b>
<b class="fc">&nbsp;                        stackManipulations.add(MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLE.getTypeStub(), new MethodDescription.Token(&quot;bindTo&quot;,</b>
&nbsp;                                Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                                JavaType.METHOD_HANDLE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                new TypeList.Generic.Explicit(TypeDefinition.Sort.describe(Object.class))))));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (!methodDescription.getParameters().isEmpty()) {</b>
<b class="fc">&nbsp;                        List&lt;StackManipulation&gt; values = new ArrayList&lt;StackManipulation&gt;(methodDescription.getParameters().size());</b>
<b class="fc">&nbsp;                        for (ParameterDescription parameterDescription : methodDescription.getParameters()) {</b>
<b class="fc">&nbsp;                            values.add(parameterDescription.getType().isPrimitive() ?</b>
<b class="fc">&nbsp;                                    new StackManipulation.Compound(MethodVariableAccess.load(parameterDescription), Assigner.DEFAULT.assign(parameterDescription.getType(),</b>
<b class="fc">&nbsp;                                            parameterDescription.getType().asErasure().asBoxed().asGenericType(),</b>
<b class="fc">&nbsp;                                            Assigner.Typing.STATIC)) : MethodVariableAccess.load(parameterDescription));</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        stackManipulations.add(IntegerConstant.forValue(0));</b>
<b class="fc">&nbsp;                        stackManipulations.add(ArrayFactory.forType(TypeDescription.ForLoadedType.of(Object.class).asGenericType()).withValues(values));</b>
<b class="fc">&nbsp;                        stackManipulations.add(</b>
<b class="fc">&nbsp;                                MethodInvocation.invoke(new MethodDescription.Latent(JavaType.METHOD_HANDLES.getTypeStub(), new MethodDescription.Token(&quot;insertArguments&quot;,</b>
&nbsp;                                        Opcodes.ACC_PUBLIC | Opcodes.ACC_STATIC,
<b class="fc">&nbsp;                                        JavaType.METHOD_HANDLE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                                        new TypeList.Generic.Explicit(JavaType.METHOD_HANDLE.getTypeStub(), TypeDefinition.Sort.describe(int.class),</b>
<b class="fc">&nbsp;                                                TypeDefinition.Sort.describe(Object[].class))))));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(stackManipulations);</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * An unbound self call handle which requires manual assignment of parameters.
&nbsp;             */
<b class="fc">&nbsp;            UNBOUND {</b>
&nbsp;                @Override
&nbsp;                protected StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation) {
<b class="fc">&nbsp;                    return stackManipulation;</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                if (!instrumentedMethod.isMethod()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException();</b>
&nbsp;                }
<b class="fc">&nbsp;                StackManipulation stackManipulation = (instrumentedMethod.isStatic()</b>
<b class="fc">&nbsp;                        ? JavaConstant.MethodHandle.of(instrumentedMethod.asDefined())</b>
<b class="fc">&nbsp;                        : JavaConstant.MethodHandle.ofSpecial(instrumentedMethod.asDefined(), instrumentedType)).toStackManipulation();</b>
<b class="fc">&nbsp;                return new Target.ForStackManipulation(decorate(instrumentedMethod, stackManipulation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a stack manipulation.
&nbsp;             *
&nbsp;             * @param methodDescription The method description being represented.
&nbsp;             * @param stackManipulation The stack manipulation for the current method handle.
&nbsp;             * @return The decorated stack manipulation.
&nbsp;             */
&nbsp;            protected abstract StackManipulation decorate(MethodDescription methodDescription, StackManipulation stackManipulation);
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a self call method handle.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;SelfCallHandle&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The {@code bound} property of the {@link SelfCallHandle} annotation.
&nbsp;                 */
<b class="fc">&nbsp;                private static final MethodDescription.InDefinedShape SELF_CALL_HANDLE_BOUND = TypeDescription.ForLoadedType.of(SelfCallHandle.class)</b>
<b class="fc">&nbsp;                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                        .filter(named(&quot;bound&quot;))</b>
<b class="fc">&nbsp;                        .getOnly();</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;SelfCallHandle&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return SelfCallHandle.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;SelfCallHandle&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (!target.getType().asErasure().isAssignableFrom(JavaType.METHOD_HANDLE.getTypeStub())) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign a MethodHandle to &quot; + target);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return annotation.getValue(SELF_CALL_HANDLE_BOUND).resolve(Boolean.class)</b>
<b class="fc">&nbsp;                            ? ForSelfCallHandle.BOUND</b>
<b class="fc">&nbsp;                            : ForSelfCallHandle.UNBOUND;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for a parameter where assignments are fully ignored and that always return the parameter type&#39;s default value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForUnusedValue implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The unused type.
&nbsp;             */
&nbsp;            private final TypeDefinition target;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for an unused type.
&nbsp;             *
&nbsp;             * @param target The unused type.
&nbsp;             */
<b class="fc">&nbsp;            public ForUnusedValue(TypeDefinition target) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                return new Target.ForDefaultValue.ReadWrite(target);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an offset mapping for an unused value.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;Unused&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for representing an unused value.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Unused&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Unused.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Unused&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    return new ForUnusedValue(target.getType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for a parameter where assignments are fully ignored and that is assigned a boxed version of the instrumented
&nbsp;         * method&#39;s return value or {@code null} if the return type is not primitive or {@code void}.
&nbsp;         */
<b class="fc">&nbsp;        enum ForStubValue implements OffsetMapping, Factory&lt;StubValue&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                return new Target.ForDefaultValue.ReadOnly(instrumentedMethod.getReturnType(), assigner.assign(instrumentedMethod.getReturnType(),</b>
<b class="fc">&nbsp;                        TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class),</b>
&nbsp;                        Assigner.Typing.DYNAMIC));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Class&lt;StubValue&gt; getAnnotationType() {
<b class="fc">&nbsp;                return StubValue.class;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                      AnnotationDescription.Loadable&lt;StubValue&gt; annotation,
&nbsp;                                      AdviceType adviceType) {
<b class="fc">&nbsp;                if (!target.getType().represents(Object.class)) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot use StubValue on non-Object parameter type &quot; + target);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that provides access to the value that is returned by the enter advice.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForEnterValue implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented target type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * The enter type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic enterType;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the annotated value is read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for the enter type.
&nbsp;             *
&nbsp;             * @param target     The represented target type.
&nbsp;             * @param enterType  The enter type.
&nbsp;             * @param annotation The represented annotation.
&nbsp;             */
&nbsp;            protected ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, AnnotationDescription.Loadable&lt;Enter&gt; annotation) {
<b class="fc">&nbsp;                this(target,</b>
&nbsp;                        enterType,
<b class="fc">&nbsp;                        annotation.getValue(Factory.ENTER_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.ENTER_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for the enter type.
&nbsp;             *
&nbsp;             * @param target    The represented target type.
&nbsp;             * @param enterType The enter type.
&nbsp;             * @param readOnly  {@code true} if the annotated value is read-only.
&nbsp;             * @param typing    The typing to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForEnterValue(TypeDescription.Generic target, TypeDescription.Generic enterType, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.enterType = enterType;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(enterType, target, typing);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + enterType + &quot; to &quot; + target);</b>
<b class="fc">&nbsp;                } else if (readOnly) {</b>
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadOnly(target, argumentHandler.enter(), readAssignment);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation writeAssignment = assigner.assign(target, enterType, typing);</b>
<b class="fc">&nbsp;                    if (!writeAssignment.isValid()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + enterType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadWrite(target, argumentHandler.enter(), readAssignment, writeAssignment);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ForEnterValue} offset mapping.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class Factory implements OffsetMapping.Factory&lt;Enter&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Argument#readOnly()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape ENTER_READ_ONLY;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Argument#typing()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape ENTER_TYPING;
&nbsp;
&nbsp;                static {
<b class="fc">&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(Enter.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                    ENTER_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    ENTER_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The supplied type of the enter advice.
&nbsp;                 */
&nbsp;                private final TypeDefinition enterType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for creating a {@link ForEnterValue} offset mapping.
&nbsp;                 *
&nbsp;                 * @param enterType The supplied type of the enter method.
&nbsp;                 */
<b class="fc">&nbsp;                protected Factory(TypeDefinition enterType) {</b>
<b class="fc">&nbsp;                    this.enterType = enterType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for creating a {@link ForEnterValue} offset mapping.
&nbsp;                 *
&nbsp;                 * @param typeDefinition The supplied type of the enter advice.
&nbsp;                 * @return An appropriate offset mapping factory.
&nbsp;                 */
&nbsp;                protected static OffsetMapping.Factory&lt;Enter&gt; of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                    return typeDefinition.represents(void.class)</b>
<b class="fc">&nbsp;                            ? new Illegal&lt;Enter&gt;(Enter.class)</b>
<b class="fc">&nbsp;                            : new Factory(typeDefinition);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Enter&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Enter.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Enter&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(ENTER_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot use writable &quot; + target + &quot; on read-only parameter&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForEnterValue(target.getType(), enterType.asGenericType(), annotation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that provides access to the value that is returned by the exit advice.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForExitValue implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented target type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * The exit type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic exitType;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the annotated value is read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for the exit type.
&nbsp;             *
&nbsp;             * @param target     The represented target type.
&nbsp;             * @param exitType   The exit type.
&nbsp;             * @param annotation The represented annotation.
&nbsp;             */
&nbsp;            protected ForExitValue(TypeDescription.Generic target, TypeDescription.Generic exitType, AnnotationDescription.Loadable&lt;Exit&gt; annotation) {
<b class="fc">&nbsp;                this(target,</b>
&nbsp;                        exitType,
<b class="fc">&nbsp;                        annotation.getValue(Factory.EXIT_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.EXIT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for the enter type.
&nbsp;             *
&nbsp;             * @param target   The represented target type.
&nbsp;             * @param exitType The exit type.
&nbsp;             * @param readOnly {@code true} if the annotated value is read-only.
&nbsp;             * @param typing   The typing to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForExitValue(TypeDescription.Generic target, TypeDescription.Generic exitType, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.exitType = exitType;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(exitType, target, typing);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + exitType + &quot; to &quot; + target);</b>
<b class="fc">&nbsp;                } else if (readOnly) {</b>
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadOnly(target, argumentHandler.exit(), readAssignment);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation writeAssignment = assigner.assign(target, exitType, typing);</b>
<b class="fc">&nbsp;                    if (!writeAssignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + exitType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadWrite(target, argumentHandler.exit(), readAssignment, writeAssignment);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ForExitValue} offset mapping.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            protected static class Factory implements OffsetMapping.Factory&lt;Exit&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Exit#readOnly()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape EXIT_READ_ONLY;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Exit#typing()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape EXIT_TYPING;
&nbsp;
&nbsp;                /*
&nbsp;                 * Resolves annotation properties.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(Exit.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                    EXIT_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    EXIT_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The supplied type of the exit advice.
&nbsp;                 */
&nbsp;                private final TypeDefinition exitType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for creating a {@link ForExitValue} offset mapping.
&nbsp;                 *
&nbsp;                 * @param exitType The supplied type of the exit advice.
&nbsp;                 */
<b class="fc">&nbsp;                protected Factory(TypeDefinition exitType) {</b>
<b class="fc">&nbsp;                    this.exitType = exitType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for creating a {@link ForExitValue} offset mapping.
&nbsp;                 *
&nbsp;                 * @param typeDefinition The supplied type of the enter method.
&nbsp;                 * @return An appropriate offset mapping factory.
&nbsp;                 */
&nbsp;                protected static OffsetMapping.Factory&lt;Exit&gt; of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                    return typeDefinition.represents(void.class)</b>
<b class="fc">&nbsp;                            ? new Illegal&lt;Exit&gt;(Exit.class)</b>
<b class="fc">&nbsp;                            : new Factory(typeDefinition);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Exit&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Exit.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Exit&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(EXIT_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot use writable &quot; + target + &quot; on read-only parameter&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForExitValue(target.getType(), exitType.asGenericType(), annotation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that provides access to a named local variable that is declared by the advice methods via {@link Local}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForLocalValue implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The variable&#39;s target type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * The local variable&#39;s type.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic localType;
&nbsp;
&nbsp;            /**
&nbsp;             * The local variable&#39;s name.
&nbsp;             */
&nbsp;            private final String name;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an offset mapping for a local variable that is declared by the advice methods via {@link Local}.
&nbsp;             *
&nbsp;             * @param target    The variable&#39;s target type.
&nbsp;             * @param localType The local variable&#39;s type.
&nbsp;             * @param name      The local variable&#39;s name.
&nbsp;             */
<b class="fc">&nbsp;            public ForLocalValue(TypeDescription.Generic target, TypeDescription.Generic localType, String name) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.localType = localType;</b>
<b class="fc">&nbsp;                this.name = name;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(localType, target, Assigner.Typing.STATIC);</b>
<b class="fc">&nbsp;                StackManipulation writeAssignment = assigner.assign(target, localType, Assigner.Typing.STATIC);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid() || !writeAssignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + localType + &quot; to &quot; + target);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadWrite(target, argumentHandler.named(name), readAssignment, writeAssignment);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for an offset mapping for a local variable that is declared by the advice methods via {@link Local}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements OffsetMapping.Factory&lt;Local&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Local#value()} method.
&nbsp;                 */
<b class="fc">&nbsp;                protected static final MethodDescription.InDefinedShape LOCAL_VALUE = TypeDescription.ForLoadedType.of(Local.class)</b>
<b class="fc">&nbsp;                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                        .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;                        .getOnly();</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The mapping of type names to their type that are available.
&nbsp;                 */
&nbsp;                private final Map&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for a {@link Local} variable mapping.
&nbsp;                 *
&nbsp;                 * @param namedTypes The mapping of type names to their type that are available.
&nbsp;                 */
<b class="fc">&nbsp;                protected Factory(Map&lt;String, TypeDefinition&gt; namedTypes) {</b>
<b class="fc">&nbsp;                    this.namedTypes = namedTypes;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Local&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Local.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Local&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    String name = annotation.getValue(LOCAL_VALUE).resolve(String.class);</b>
<b class="fc">&nbsp;                    TypeDefinition namedType = namedTypes.get(name);</b>
<b class="fc">&nbsp;                    if (namedType == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Named local variable is unknown: &quot; + name);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new ForLocalValue(target.getType(), namedType.asGenericType(), name);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that provides access to the value that is returned by the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForReturnValue implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The type that the advice method expects for the return value.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if the parameter is to be treated as read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for a return value.
&nbsp;             *
&nbsp;             * @param target     The type that the advice method expects for the return value.
&nbsp;             * @param annotation The annotation being bound.
&nbsp;             */
&nbsp;            protected ForReturnValue(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;Return&gt; annotation) {
<b class="fc">&nbsp;                this(target,</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.RETURN_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.RETURN_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for a return value.
&nbsp;             *
&nbsp;             * @param target   The type that the advice method expects for the return value.
&nbsp;             * @param readOnly Determines if the parameter is to be treated as read-only.
&nbsp;             * @param typing   The typing to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForReturnValue(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(instrumentedMethod.getReturnType(), target, typing);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + instrumentedMethod.getReturnType() + &quot; to &quot; + target);</b>
<b class="fc">&nbsp;                } else if (readOnly) {</b>
<b class="fc">&nbsp;                    return instrumentedMethod.getReturnType().represents(void.class)</b>
<b class="fc">&nbsp;                            ? new Target.ForDefaultValue.ReadOnly(target)</b>
<b class="fc">&nbsp;                            : new Target.ForVariable.ReadOnly(instrumentedMethod.getReturnType(), argumentHandler.returned(), readAssignment);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation writeAssignment = assigner.assign(target, instrumentedMethod.getReturnType(), typing);</b>
<b class="fc">&nbsp;                    if (!writeAssignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to &quot; + instrumentedMethod.getReturnType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return instrumentedMethod.getReturnType().represents(void.class)</b>
<b class="fc">&nbsp;                            ? new Target.ForDefaultValue.ReadWrite(target)</b>
<b class="fc">&nbsp;                            : new Target.ForVariable.ReadWrite(instrumentedMethod.getReturnType(), argumentHandler.returned(), readAssignment, writeAssignment);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ForReturnValue} offset mapping.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;Return&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Return#readOnly()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape RETURN_READ_ONLY;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Return#typing()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape RETURN_TYPING;
&nbsp;
&nbsp;                /*
&nbsp;                 * Resolves the annotation properties.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(Return.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                    RETURN_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    RETURN_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Return&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Return.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Return&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(RETURN_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot write return value for &quot; + target + &quot; in read-only context&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForReturnValue(target.getType(), annotation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for accessing a {@link Throwable} of the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForThrowable implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The type of parameter that is being accessed.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the parameter is read-only.
&nbsp;             */
&nbsp;            private final boolean readOnly;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for access of the exception that is thrown by the instrumented method..
&nbsp;             *
&nbsp;             * @param target     The type of parameter that is being accessed.
&nbsp;             * @param annotation The annotation to bind.
&nbsp;             */
&nbsp;            protected ForThrowable(TypeDescription.Generic target, AnnotationDescription.Loadable&lt;Thrown&gt; annotation) {
<b class="fc">&nbsp;                this(target,</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.THROWN_READ_ONLY).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                        annotation.getValue(Factory.THROWN_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for access of the exception that is thrown by the instrumented method..
&nbsp;             *
&nbsp;             * @param target   The type of parameter that is being accessed.
&nbsp;             * @param readOnly {@code true} if the parameter is read-only.
&nbsp;             * @param typing   The typing to apply.
&nbsp;             */
<b class="fc">&nbsp;            public ForThrowable(TypeDescription.Generic target, boolean readOnly, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.readOnly = readOnly;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation readAssignment = assigner.assign(TypeDescription.ForLoadedType.of(Throwable.class).asGenericType(), target, typing);</b>
<b class="fc">&nbsp;                if (!readAssignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign Throwable to &quot; + target);</b>
<b class="fc">&nbsp;                } else if (readOnly) {</b>
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadOnly(TypeDescription.ForLoadedType.of(Throwable.class), argumentHandler.thrown(), readAssignment);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    StackManipulation writeAssignment = assigner.assign(target, TypeDescription.ForLoadedType.of(Throwable.class).asGenericType(), typing);</b>
<b class="fc">&nbsp;                    if (!writeAssignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + target + &quot; to Throwable&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Target.ForVariable.ReadWrite(TypeDescription.ForLoadedType.of(Throwable.class), argumentHandler.thrown(), readAssignment, writeAssignment);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for accessing an exception that was thrown by the instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements OffsetMapping.Factory&lt;Thrown&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Thrown#readOnly()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape THROWN_READ_ONLY;
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of the {@link Thrown#typing()} method.
&nbsp;                 */
&nbsp;                private static final MethodDescription.InDefinedShape THROWN_TYPING;
&nbsp;
&nbsp;                /*
&nbsp;                 * Resolves annotation properties.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(Thrown.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                    THROWN_READ_ONLY = methods.filter(named(&quot;readOnly&quot;)).getOnly();</b>
<b class="fc">&nbsp;                    THROWN_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves an appropriate offset mapping factory for the {@link Thrown} parameter annotation.
&nbsp;                 *
&nbsp;                 * @param adviceMethod The exit advice method, annotated with {@link OnMethodExit}.
&nbsp;                 * @return An appropriate offset mapping factory.
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                protected static OffsetMapping.Factory&lt;?&gt; of(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                    return adviceMethod.getDeclaredAnnotations()</b>
<b class="fc">&nbsp;                            .ofType(OnMethodExit.class)</b>
<b class="fc">&nbsp;                            .getValue(ON_THROWABLE)</b>
<b class="fc">&nbsp;                            .resolve(TypeDescription.class)</b>
<b class="fc">&nbsp;                            .represents(NoExceptionHandler.class) ? new OffsetMapping.Factory.Illegal&lt;Thrown&gt;(Thrown.class) : Factory.INSTANCE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;Thrown&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return Thrown.class;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;Thrown&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    if (adviceType.isDelegation() &amp;&amp; !annotation.getValue(THROWN_READ_ONLY).resolve(Boolean.class)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot use writable &quot; + target + &quot; on read-only parameter&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForThrowable(target.getType(), annotation);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping for binding a stack manipulation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForStackManipulation implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation that loads the bound value.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the loaded value.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The target type of the annotated parameter.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic targetType;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply.
&nbsp;             */
&nbsp;            private final Assigner.Typing typing;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an offset mapping that binds a stack manipulation.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation that loads the bound value.
&nbsp;             * @param typeDescription   The type of the loaded value.
&nbsp;             * @param targetType        The target type of the annotated parameter.
&nbsp;             * @param typing            The typing to apply.
&nbsp;             */
&nbsp;            public ForStackManipulation(StackManipulation stackManipulation,
&nbsp;                                        TypeDescription.Generic typeDescription,
&nbsp;                                        TypeDescription.Generic targetType,
<b class="fc">&nbsp;                                        Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.targetType = targetType;</b>
<b class="fc">&nbsp;                this.typing = typing;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation assignment = assigner.assign(typeDescription, targetType, typing);</b>
<b class="fc">&nbsp;                if (!assignment.isValid()) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + typeDescription + &quot; to &quot; + targetType);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Target.ForStackManipulation(new StackManipulation.Compound(stackManipulation, assignment));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory that binds a stack manipulation.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Factory&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The stack manipulation that loads the bound value.
&nbsp;                 */
&nbsp;                private final StackManipulation stackManipulation;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the loaded value.
&nbsp;                 */
&nbsp;                private final TypeDescription.Generic typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for binding a type description.
&nbsp;                 *
&nbsp;                 * @param annotationType  The annotation type.
&nbsp;                 * @param typeDescription The type to bind.
&nbsp;                 */
&nbsp;                public Factory(Class&lt;T&gt; annotationType, TypeDescription typeDescription) {
<b class="fc">&nbsp;                    this(annotationType, ClassConstant.of(typeDescription), TypeDescription.ForLoadedType.of(Class.class).asGenericType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for binding an enumeration.
&nbsp;                 *
&nbsp;                 * @param annotationType         The annotation type.
&nbsp;                 * @param enumerationDescription The enumeration to bind.
&nbsp;                 */
&nbsp;                public Factory(Class&lt;T&gt; annotationType, EnumerationDescription enumerationDescription) {
<b class="fc">&nbsp;                    this(annotationType, FieldAccess.forEnumeration(enumerationDescription), enumerationDescription.getEnumerationType().asGenericType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for binding a Java constant.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type.
&nbsp;                 * @param constant       The bound constant value.
&nbsp;                 */
&nbsp;                public Factory(Class&lt;T&gt; annotationType, ConstantValue constant) {
<b class="fc">&nbsp;                    this(annotationType, constant.toStackManipulation(), constant.getTypeDescription().asGenericType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for binding a stack manipulation.
&nbsp;                 *
&nbsp;                 * @param annotationType    The annotation type.
&nbsp;                 * @param stackManipulation The stack manipulation that loads the bound value.
&nbsp;                 * @param typeDescription   The type of the loaded value.
&nbsp;                 */
<b class="fc">&nbsp;                public Factory(Class&lt;T&gt; annotationType, StackManipulation stackManipulation, TypeDescription.Generic typeDescription) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                    this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a binding for a fixed {@link String}, a primitive value or a method handle or type.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type.
&nbsp;                 * @param value          The constant value to bind or {@code null} to bind the parameter type&#39;s default value.
&nbsp;                 * @param &lt;S&gt;            The annotation type.
&nbsp;                 * @return A factory for creating an offset mapping that binds the supplied value.
&nbsp;                 */
&nbsp;                public static &lt;S extends Annotation&gt; OffsetMapping.Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, @MaybeNull Object value) {
<b class="fc">&nbsp;                    return value == null</b>
<b class="fc">&nbsp;                            ? new OfDefaultValue&lt;S&gt;(annotationType)</b>
<b class="fc">&nbsp;                            : new Factory&lt;S&gt;(annotationType, ConstantValue.Simple.wrap(value));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target,
&nbsp;                                          AnnotationDescription.Loadable&lt;T&gt; annotation,
&nbsp;                                          AdviceType adviceType) {
<b class="fc">&nbsp;                    return new ForStackManipulation(stackManipulation, typeDescription, target.getType(), Assigner.Typing.STATIC);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for binding the annotated parameter&#39;s default value.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfDefaultValue&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an offset mapping tat binds the parameter&#39;s default value.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type.
&nbsp;                 */
<b class="fc">&nbsp;                public OfDefaultValue(Class&lt;T&gt; annotationType) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
<b class="fc">&nbsp;                    return new ForStackManipulation(DefaultValue.of(target.getType()), target.getType(), target.getType(), Assigner.Typing.STATIC);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for binding an annotation&#39;s property.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfAnnotationProperty&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation property.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape property;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for binding an annotation property.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type.
&nbsp;                 * @param property       The annotation property.
&nbsp;                 */
<b class="fc">&nbsp;                protected OfAnnotationProperty(Class&lt;T&gt; annotationType, MethodDescription.InDefinedShape property) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                    this.property = property;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an offset mapping that binds an annotation property.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type to bind.
&nbsp;                 * @param property       The property to bind.
&nbsp;                 * @param &lt;S&gt;            The annotation type.
&nbsp;                 * @return A factory for binding a property of the annotation type.
&nbsp;                 */
&nbsp;                public static &lt;S extends Annotation&gt; OffsetMapping.Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, String property) {
<b class="fc">&nbsp;                    if (!annotationType.isAnnotation()) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + annotationType);</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return new OfAnnotationProperty&lt;S&gt;(annotationType, new MethodDescription.ForLoadedMethod(annotationType.getMethod(property)));</b>
<b class="nc">&nbsp;                    } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Cannot find a property &quot; + property + &quot; on &quot; + annotationType, exception);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
<b class="fc">&nbsp;                    ConstantValue value = ConstantValue.Simple.wrapOrNull(annotation.getValue(property).resolve());</b>
<b class="fc">&nbsp;                    if (value == null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Property does not represent a constant value: &quot; + property);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new ForStackManipulation(value.toStackManipulation(),</b>
<b class="fc">&nbsp;                            value.getTypeDescription().asGenericType(),</b>
<b class="fc">&nbsp;                            target.getType(),</b>
&nbsp;                            Assigner.Typing.STATIC);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Uses dynamic method invocation for binding an annotated parameter to a value.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class OfDynamicInvocation&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The bootstrap method or constructor.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The arguments to the bootstrap method.
&nbsp;                 */
&nbsp;                private final List&lt;? extends JavaConstant&gt; arguments;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new factory for a dynamic invocation.
&nbsp;                 *
&nbsp;                 * @param annotationType  The annotation type.
&nbsp;                 * @param bootstrapMethod The bootstrap method or constructor.
&nbsp;                 * @param arguments       The arguments to the bootstrap method.
&nbsp;                 */
<b class="fc">&nbsp;                public OfDynamicInvocation(Class&lt;T&gt; annotationType, MethodDescription.InDefinedShape bootstrapMethod, List&lt;? extends JavaConstant&gt; arguments) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                    this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                    this.arguments = arguments;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
<b class="fc">&nbsp;                    if (!target.getType().isInterface()) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; is not an interface&quot;);</b>
<b class="fc">&nbsp;                    } else if (!target.getType().getInterfaces().isEmpty()) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; must not extend other interfaces&quot;);</b>
<b class="fc">&nbsp;                    } else if (!target.getType().isPublic()) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; is mot public&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    MethodList&lt;?&gt; methodCandidates = target.getType().getDeclaredMethods().filter(isAbstract());</b>
<b class="fc">&nbsp;                    if (methodCandidates.size() != 1) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(target.getType() + &quot; must declare exactly one abstract method&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new ForStackManipulation(MethodInvocation.invoke(bootstrapMethod).dynamic(methodCandidates.getOnly().getInternalName(),</b>
<b class="fc">&nbsp;                            target.getType().asErasure(),</b>
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
<b class="fc">&nbsp;                            arguments), target.getType(), target.getType(), Assigner.Typing.STATIC);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An offset mapping that loads a serialized value.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForSerializedValue implements OffsetMapping {
&nbsp;
&nbsp;            /**
&nbsp;             * The type of the serialized value as it is used.
&nbsp;             */
&nbsp;            private final TypeDescription.Generic target;
&nbsp;
&nbsp;            /**
&nbsp;             * The class type of the serialized value.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation deserializing the represented value.
&nbsp;             */
&nbsp;            private final StackManipulation deserialization;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new offset mapping for a serialized value.
&nbsp;             *
&nbsp;             * @param target          The type of the serialized value as it is used.
&nbsp;             * @param typeDescription The class type of the serialized value.
&nbsp;             * @param deserialization The stack manipulation deserializing the represented value.
&nbsp;             */
<b class="fc">&nbsp;            public ForSerializedValue(TypeDescription.Generic target, TypeDescription typeDescription, StackManipulation deserialization) {</b>
<b class="fc">&nbsp;                this.target = target;</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.deserialization = deserialization;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Target resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  Sort sort) {
<b class="fc">&nbsp;                StackManipulation assignment = assigner.assign(typeDescription.asGenericType(), target, Assigner.Typing.DYNAMIC);</b>
<b class="fc">&nbsp;                if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot assign &quot; + typeDescription + &quot; to &quot; + target);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Target.ForStackManipulation(new StackManipulation.Compound(deserialization, assignment));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for loading a deserialized value.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type this factory binds.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            public static class Factory&lt;T extends Annotation&gt; implements OffsetMapping.Factory&lt;T&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation type.
&nbsp;                 */
&nbsp;                private final Class&lt;T&gt; annotationType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type description as which to treat the deserialized value.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The stack manipulation that loads the represented value.
&nbsp;                 */
&nbsp;                private final StackManipulation deserialization;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for loading a deserialized value.
&nbsp;                 *
&nbsp;                 * @param annotationType  The annotation type.
&nbsp;                 * @param typeDescription The type description as which to treat the deserialized value.
&nbsp;                 * @param deserialization The stack manipulation that loads the represented value.
&nbsp;                 */
<b class="fc">&nbsp;                protected Factory(Class&lt;T&gt; annotationType, TypeDescription typeDescription, StackManipulation deserialization) {</b>
<b class="fc">&nbsp;                    this.annotationType = annotationType;</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                    this.deserialization = deserialization;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for an offset mapping that loads the provided value.
&nbsp;                 *
&nbsp;                 * @param annotationType The annotation type to be bound.
&nbsp;                 * @param target         The instance representing the value to be deserialized.
&nbsp;                 * @param targetType     The target type as which to use the target value.
&nbsp;                 * @param &lt;S&gt;            The annotation type the created factory binds.
&nbsp;                 * @param &lt;U&gt;            The type of the -represented constant.
&nbsp;                 * @return An appropriate offset mapping factory.
&nbsp;                 */
&nbsp;                public static &lt;S extends Annotation, U extends Serializable&gt; OffsetMapping.Factory&lt;S&gt; of(Class&lt;S&gt; annotationType, U target, Class&lt;? super U&gt; targetType) {
<b class="fc">&nbsp;                    if (!targetType.isInstance(target)) {</b>
<b class="nc">&nbsp;                        throw new IllegalArgumentException(target + &quot; is no instance of &quot; + targetType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Factory&lt;S&gt;(annotationType, TypeDescription.ForLoadedType.of(targetType), SerializedConstant.of(target));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;T&gt; getAnnotationType() {
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public OffsetMapping make(ParameterDescription.InDefinedShape target, AnnotationDescription.Loadable&lt;T&gt; annotation, AdviceType adviceType) {
<b class="fc">&nbsp;                    return new ForSerializedValue(target.getType(), typeDescription, deserialization);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An argument handler is responsible for resolving offsets of the local variable array in the context of the applied instrumentation.
&nbsp;     */
&nbsp;    public interface ArgumentHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * The offset of the {@code this} reference.
&nbsp;         */
&nbsp;        int THIS_REFERENCE = 0;
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves an offset relative to an offset of the instrumented method.
&nbsp;         *
&nbsp;         * @param offset The offset to resolve.
&nbsp;         * @return The resolved offset.
&nbsp;         */
&nbsp;        int argument(int offset);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the offset of the exit value of the exit advice.
&nbsp;         *
&nbsp;         * @return The offset of the exit value.
&nbsp;         */
&nbsp;        int exit();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the offset of the enter value of the enter advice.
&nbsp;         *
&nbsp;         * @return The offset of the enter value.
&nbsp;         */
&nbsp;        int enter();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the offset of the local variable with the given name.
&nbsp;         *
&nbsp;         * @param name The name of the local variable being accessed.
&nbsp;         * @return The named variable&#39;s offset.
&nbsp;         */
&nbsp;        int named(String name);
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the offset of the returned value of the instrumented method.
&nbsp;         *
&nbsp;         * @return The offset of the returned value of the instrumented method.
&nbsp;         */
&nbsp;        int returned();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the offset of the thrown exception of the instrumented method.
&nbsp;         *
&nbsp;         * @return The offset of the thrown exception of the instrumented method.
&nbsp;         */
&nbsp;        int thrown();
&nbsp;
&nbsp;        /**
&nbsp;         * An argument handler that is used for resolving the instrumented method.
&nbsp;         */
&nbsp;        interface ForInstrumentedMethod extends ArgumentHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Prepares this argument handler for future offset access.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor to which to write any potential byte code.
&nbsp;             * @return The minimum stack size that is required to apply this manipulation.
&nbsp;             */
&nbsp;            int prepare(MethodVisitor methodVisitor);
&nbsp;
&nbsp;            /**
&nbsp;             * Binds an advice method as enter advice for this handler.
&nbsp;             *
&nbsp;             * @param adviceMethod The resolved enter advice handler.
&nbsp;             * @return The resolved argument handler for enter advice.
&nbsp;             */
&nbsp;            ForAdvice bindEnter(MethodDescription adviceMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Binds an advice method as exit advice for this handler.
&nbsp;             *
&nbsp;             * @param adviceMethod  The resolved exit advice handler.
&nbsp;             * @param skipThrowable {@code true} if no throwable is stored.
&nbsp;             * @return The resolved argument handler for enter advice.
&nbsp;             */
&nbsp;            ForAdvice bindExit(MethodDescription adviceMethod, boolean skipThrowable);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the original arguments are copied before invoking the instrumented method.
&nbsp;             *
&nbsp;             * @return {@code true} if the original arguments are copied before invoking the instrumented method.
&nbsp;             */
&nbsp;            boolean isCopyingArguments();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a list of the named types in their declared order.
&nbsp;             *
&nbsp;             * @return A list of the named types in their declared order.
&nbsp;             */
&nbsp;            List&lt;TypeDescription&gt; getNamedTypes();
&nbsp;
&nbsp;            /**
&nbsp;             * A default implementation of an argument handler for an instrumented method.
&nbsp;             */
&nbsp;            abstract class Default implements ForInstrumentedMethod {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented method.
&nbsp;                 */
&nbsp;                protected final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The exit type or {@code void} if no exit type is defined.
&nbsp;                 */
&nbsp;                protected final TypeDefinition exitType;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of all available local variables by their name to their type.
&nbsp;                 */
&nbsp;                protected final SortedMap&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * The enter type or {@code void} if no enter type is defined.
&nbsp;                 */
&nbsp;                protected final TypeDefinition enterType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new default argument handler for an instrumented method.
&nbsp;                 *
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;                 * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;                 * @param enterType          The enter type or {@code void} if no enter type is defined.
&nbsp;                 */
&nbsp;                protected Default(MethodDescription instrumentedMethod,
&nbsp;                                  TypeDefinition exitType,
&nbsp;                                  SortedMap&lt;String, TypeDefinition&gt; namedTypes,
<b class="fc">&nbsp;                                  TypeDefinition enterType) {</b>
<b class="fc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                    this.namedTypes = namedTypes;</b>
<b class="fc">&nbsp;                    this.exitType = exitType;</b>
<b class="fc">&nbsp;                    this.enterType = enterType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int exit() {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int named(String name) {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(namedTypes.headMap(name).values());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int enter() {
<b class="nc">&nbsp;                    return instrumentedMethod.getStackSize()</b>
<b class="nc">&nbsp;                            + exitType.getStackSize().getSize()</b>
<b class="nc">&nbsp;                            + StackSize.of(namedTypes.values());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int returned() {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                            + enterType.getStackSize().getSize();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int thrown() {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                            + enterType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                            + instrumentedMethod.getReturnType().getStackSize().getSize();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ForAdvice bindEnter(MethodDescription adviceMethod) {
<b class="fc">&nbsp;                    return new ForAdvice.Default.ForMethodEnter(instrumentedMethod, adviceMethod, exitType, namedTypes);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ForAdvice bindExit(MethodDescription adviceMethod, boolean skipThrowable) {
<b class="fc">&nbsp;                    return new ForAdvice.Default.ForMethodExit(instrumentedMethod,</b>
&nbsp;                            adviceMethod,
&nbsp;                            exitType,
&nbsp;                            namedTypes,
&nbsp;                            enterType,
<b class="fc">&nbsp;                            skipThrowable ? StackSize.ZERO : StackSize.SINGLE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public List&lt;TypeDescription&gt; getNamedTypes() {
<b class="fc">&nbsp;                    List&lt;TypeDescription&gt; namedTypes = new ArrayList&lt;TypeDescription&gt;(this.namedTypes.size());</b>
<b class="fc">&nbsp;                    for (TypeDefinition typeDefinition : this.namedTypes.values()) {</b>
<b class="fc">&nbsp;                        namedTypes.add(typeDefinition.asErasure());</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return namedTypes;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple argument handler for an instrumented method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Simple extends Default {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple argument handler for an instrumented method.
&nbsp;                     *
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;                     * @param enterType          The enter type or {@code void} if no enter type is defined.
&nbsp;                     */
&nbsp;                    protected Simple(MethodDescription instrumentedMethod,
&nbsp;                                     TypeDefinition exitType,
&nbsp;                                     SortedMap&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                     TypeDefinition enterType) {
<b class="fc">&nbsp;                        super(instrumentedMethod, exitType, namedTypes, enterType);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int argument(int offset) {
<b class="fc">&nbsp;                        return offset &lt; instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                ? offset</b>
<b class="fc">&nbsp;                                : offset + exitType.getStackSize().getSize() + StackSize.of(namedTypes.values()) + enterType.getStackSize().getSize();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isCopyingArguments() {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int prepare(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        return 0;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument handler for an instrumented method that copies all arguments before executing the instrumented method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Copying extends Default {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new copying argument handler for an instrumented method.
&nbsp;                     *
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;                     * @param enterType          The enter type or {@code void} if no enter type is defined.
&nbsp;                     */
&nbsp;                    protected Copying(MethodDescription instrumentedMethod,
&nbsp;                                      TypeDefinition exitType,
&nbsp;                                      SortedMap&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                      TypeDefinition enterType) {
<b class="fc">&nbsp;                        super(instrumentedMethod, exitType, namedTypes, enterType);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int argument(int offset) {
<b class="fc">&nbsp;                        return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                + enterType.getStackSize().getSize()</b>
&nbsp;                                + offset;
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isCopyingArguments() {
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int prepare(MethodVisitor methodVisitor) {
&nbsp;                        StackSize stackSize;
<b class="fc">&nbsp;                        if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ASTORE, instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                    + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                    + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                    + enterType.getStackSize().getSize());</b>
<b class="fc">&nbsp;                            stackSize = StackSize.SINGLE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            stackSize = StackSize.ZERO;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="fc">&nbsp;                            Type type = Type.getType(parameterDescription.getType().asErasure().getDescriptor());</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ILOAD), parameterDescription.getOffset());</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(type.getOpcode(Opcodes.ISTORE), instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                    + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                    + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                    + enterType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                    + parameterDescription.getOffset());</b>
<b class="fc">&nbsp;                            stackSize = stackSize.maximum(parameterDescription.getType().getStackSize());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return stackSize.getSize();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument handler that is used for resolving an advice method.
&nbsp;         */
&nbsp;        interface ForAdvice extends ArgumentHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves an offset of the advice method.
&nbsp;             *
&nbsp;             * @param offset The offset to resolve.
&nbsp;             * @return The resolved offset.
&nbsp;             */
&nbsp;            int mapped(int offset);
&nbsp;
&nbsp;            /**
&nbsp;             * A default implementation for an argument handler for an advice method.
&nbsp;             */
&nbsp;            abstract class Default implements ForAdvice {
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented method.
&nbsp;                 */
&nbsp;                protected final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The advice method.
&nbsp;                 */
&nbsp;                protected final MethodDescription adviceMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The enter type or {@code void} if no enter type is defined.
&nbsp;                 */
&nbsp;                protected final TypeDefinition exitType;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of all available local variables by their name to their type.
&nbsp;                 */
&nbsp;                protected final SortedMap&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new argument handler for an enter advice.
&nbsp;                 *
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param adviceMethod       The advice method.
&nbsp;                 * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;                 * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;                 */
&nbsp;                protected Default(MethodDescription instrumentedMethod,
&nbsp;                                  MethodDescription adviceMethod,
&nbsp;                                  TypeDefinition exitType,
<b class="fc">&nbsp;                                  SortedMap&lt;String, TypeDefinition&gt; namedTypes) {</b>
<b class="fc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                    this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                    this.exitType = exitType;</b>
<b class="fc">&nbsp;                    this.namedTypes = namedTypes;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int argument(int offset) {
<b class="fc">&nbsp;                    return offset;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int exit() {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int named(String name) {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(namedTypes.headMap(name).values());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int enter() {
<b class="fc">&nbsp;                    return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(namedTypes.values());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument handler for an enter advice method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForMethodEnter extends Default {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new argument handler for an enter advice method.
&nbsp;                     *
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param adviceMethod       The advice method.
&nbsp;                     * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;                     */
&nbsp;                    protected ForMethodEnter(MethodDescription instrumentedMethod,
&nbsp;                                             MethodDescription adviceMethod,
&nbsp;                                             TypeDefinition exitType,
&nbsp;                                             SortedMap&lt;String, TypeDefinition&gt; namedTypes) {
<b class="fc">&nbsp;                        super(instrumentedMethod, adviceMethod, exitType, namedTypes);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int returned() {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve the return value offset during enter advice&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int thrown() {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve the thrown value offset during enter advice&quot;);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int mapped(int offset) {
<b class="fc">&nbsp;                        return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                - adviceMethod.getStackSize() + offset;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument handler for an exit advice method.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class ForMethodExit extends Default {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The enter type or {@code void} if no enter type is defined.
&nbsp;                     */
&nbsp;                    private final TypeDefinition enterType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack size of a possibly stored throwable.
&nbsp;                     */
&nbsp;                    private final StackSize throwableSize;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new argument handler for an exit advice method.
&nbsp;                     *
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param adviceMethod       The advice method.
&nbsp;                     * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;                     * @param enterType          The enter type or {@code void} if no enter type is defined.
&nbsp;                     * @param throwableSize      The stack size of a possibly stored throwable.
&nbsp;                     */
&nbsp;                    protected ForMethodExit(MethodDescription instrumentedMethod,
&nbsp;                                            MethodDescription adviceMethod,
&nbsp;                                            TypeDefinition exitType,
&nbsp;                                            SortedMap&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                            TypeDefinition enterType,
&nbsp;                                            StackSize throwableSize) {
<b class="fc">&nbsp;                        super(instrumentedMethod, adviceMethod, exitType, namedTypes);</b>
<b class="fc">&nbsp;                        this.enterType = enterType;</b>
<b class="fc">&nbsp;                        this.throwableSize = throwableSize;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int returned() {
<b class="fc">&nbsp;                        return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                + enterType.getStackSize().getSize();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int thrown() {
<b class="fc">&nbsp;                        return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                + enterType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + instrumentedMethod.getReturnType().getStackSize().getSize();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int mapped(int offset) {
<b class="fc">&nbsp;                        return instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                                + exitType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + StackSize.of(namedTypes.values())</b>
<b class="fc">&nbsp;                                + enterType.getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + instrumentedMethod.getReturnType().getStackSize().getSize()</b>
<b class="fc">&nbsp;                                + throwableSize.getSize()</b>
<b class="fc">&nbsp;                                - adviceMethod.getStackSize()</b>
&nbsp;                                + offset;
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating an argument handler.
&nbsp;         */
<b class="fc">&nbsp;        enum Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a simple argument handler.
&nbsp;             */
<b class="fc">&nbsp;            SIMPLE {</b>
&nbsp;                @Override
&nbsp;                protected ForInstrumentedMethod resolve(MethodDescription instrumentedMethod,
&nbsp;                                                        TypeDefinition enterType,
&nbsp;                                                        TypeDefinition exitType,
&nbsp;                                                        SortedMap&lt;String, TypeDefinition&gt; namedTypes) {
<b class="fc">&nbsp;                    return new ForInstrumentedMethod.Default.Simple(instrumentedMethod,</b>
&nbsp;                            exitType,
&nbsp;                            namedTypes,
&nbsp;                            enterType);
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating an argument handler that copies all arguments before executing the instrumented method.
&nbsp;             */
<b class="fc">&nbsp;            COPYING {</b>
&nbsp;                @Override
&nbsp;                protected ForInstrumentedMethod resolve(MethodDescription instrumentedMethod,
&nbsp;                                                        TypeDefinition enterType,
&nbsp;                                                        TypeDefinition exitType,
&nbsp;                                                        SortedMap&lt;String, TypeDefinition&gt; namedTypes) {
<b class="fc">&nbsp;                    return new ForInstrumentedMethod.Default.Copying(instrumentedMethod,</b>
&nbsp;                            exitType,
&nbsp;                            namedTypes,
&nbsp;                            enterType);
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an argument handler.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param enterType          The enter type or {@code void} if no such type is defined.
&nbsp;             * @param exitType           The exit type or {@code void} if no exit type is defined.
&nbsp;             * @param namedTypes         A mapping of all available local variables by their name to their type.
&nbsp;             * @return An argument handler for the instrumented method.
&nbsp;             */
&nbsp;            protected abstract ForInstrumentedMethod resolve(MethodDescription instrumentedMethod,
&nbsp;                                                             TypeDefinition enterType,
&nbsp;                                                             TypeDefinition exitType,
&nbsp;                                                             SortedMap&lt;String, TypeDefinition&gt; namedTypes);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A post processor for advice methods that is invoked after advice is executed. A post processor
&nbsp;     * is invoked after the instrumented method and only after a regular completion of the method. When
&nbsp;     * invoked, the advice method&#39;s return value is stored in the local variable array. Upon completion,
&nbsp;     * the local variable array must still be intact and the stack must be empty. A frame is added
&nbsp;     * subsequently to the post processor&#39;s execution, making it feasible to add a jump instruction to the
&nbsp;     * end of the method after which no further byte code instructions must be issued. This also applies
&nbsp;     * to compound post processors. If a post processor emits a frame as its last instruction, it should
&nbsp;     * yield a &lt;i&gt;NOP&lt;/i&gt; instruction to avoid that subsequent code starts with a frame.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: A post processor is triggered after the suppression handler. Exceptions triggered
&nbsp;     * by post processing code will therefore cause those exceptions to be propagated unless the post
&nbsp;     * processor configures explicit exception handling.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    public interface PostProcessor {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves this post processor for a given instrumented method.
&nbsp;         *
&nbsp;         * @param instrumentedType     The instrumented type.
&nbsp;         * @param instrumentedMethod   The instrumented method.
&nbsp;         * @param assigner             The assigner to use.
&nbsp;         * @param argumentHandler      The argument handler to use.
&nbsp;         * @param stackMapFrameHandler The argument handler for the instrumented method.
&nbsp;         * @param exceptionHandler     The exception handler that is resolved for the instrumented method.
&nbsp;         * @return The stack manipulation to apply.
&nbsp;         */
&nbsp;        StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler argumentHandler,
&nbsp;                                  StackMapFrameHandler.ForPostProcessor stackMapFrameHandler,
&nbsp;                                  StackManipulation exceptionHandler);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a {@link PostProcessor}.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a post processor for a given advice method.
&nbsp;             *
&nbsp;             * @param advice The advice method to create the post processor for.
&nbsp;             * @param exit   {@code true} if the advice is exit advice.
&nbsp;             * @return The created post processor.
&nbsp;             */
&nbsp;            PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit);
&nbsp;
&nbsp;            /**
&nbsp;             * A compound factory for a post processor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Compound implements Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented post processor factories.
&nbsp;                 */
&nbsp;                private final List&lt;Factory&gt; factories;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a compound post processor factory.
&nbsp;                 *
&nbsp;                 * @param factory The represented post processor factories.
&nbsp;                 */
&nbsp;                public Compound(Factory... factory) {
<b class="fc">&nbsp;                    this(Arrays.asList(factory));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a compound post processor factory.
&nbsp;                 *
&nbsp;                 * @param factories The represented post processor factories.
&nbsp;                 */
<b class="fc">&nbsp;                public Compound(List&lt;? extends Factory&gt; factories) {</b>
<b class="fc">&nbsp;                    this.factories = new ArrayList&lt;Factory&gt;();</b>
<b class="fc">&nbsp;                    for (Factory factory : factories) {</b>
<b class="fc">&nbsp;                        if (factory instanceof Compound) {</b>
<b class="nc">&nbsp;                            this.factories.addAll(((Compound) factory).factories);</b>
<b class="fc">&nbsp;                        } else if (!(factory instanceof NoOp)) {</b>
<b class="fc">&nbsp;                            this.factories.add(factory);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit) {
<b class="fc">&nbsp;                    List&lt;PostProcessor&gt; postProcessors = new ArrayList&lt;PostProcessor&gt;(factories.size());</b>
<b class="fc">&nbsp;                    for (Factory factory : factories) {</b>
<b class="fc">&nbsp;                        postProcessors.add(factory.make(advice, exit));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new PostProcessor.Compound(postProcessors);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational advice post processor.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements PostProcessor, Factory {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                             MethodDescription instrumentedMethod,
&nbsp;                                             Assigner assigner,
&nbsp;                                             ArgumentHandler argumentHandler,
&nbsp;                                             StackMapFrameHandler.ForPostProcessor stackMapFrameHandler,
&nbsp;                                             StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A compound post processor.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Compound implements PostProcessor {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented post processors.
&nbsp;             */
&nbsp;            private final List&lt;PostProcessor&gt; postProcessors;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new compound post processor.
&nbsp;             *
&nbsp;             * @param postProcessors The represented post processors.
&nbsp;             */
<b class="fc">&nbsp;            protected Compound(List&lt;PostProcessor&gt; postProcessors) {</b>
<b class="fc">&nbsp;                this.postProcessors = postProcessors;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                             MethodDescription instrumentedMethod,
&nbsp;                                             Assigner assigner,
&nbsp;                                             ArgumentHandler argumentHandler,
&nbsp;                                             StackMapFrameHandler.ForPostProcessor stackMapFrameHandler,
&nbsp;                                             StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(postProcessors.size());</b>
<b class="fc">&nbsp;                for (PostProcessor postProcessor : postProcessors) {</b>
<b class="fc">&nbsp;                    stackManipulations.add(postProcessor.resolve(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
&nbsp;                            assigner,
&nbsp;                            argumentHandler,
&nbsp;                            stackMapFrameHandler,
&nbsp;                            exceptionHandler));
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new StackManipulation.Compound(stackManipulations);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Materializes an advice invocation within a delegation.
&nbsp;     */
&nbsp;    protected interface Delegator {
&nbsp;
&nbsp;        /**
&nbsp;         * Materializes an invocation.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return An appropriate stack manipulation which needs to consume all arguments for the advice
&nbsp;         * method and needs to provide a compatible return type.
&nbsp;         */
&nbsp;        StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a {@link Delegator}.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a delegator.
&nbsp;             *
&nbsp;             * @param adviceMethod The advice method.
&nbsp;             * @param exit         {@code true} if the advice is applied as exit advice.
&nbsp;             * @return An appropriate delegator.
&nbsp;             */
&nbsp;            Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes an advice method using a regular method call.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForRegularInvocation implements Delegator {
&nbsp;
&nbsp;            /**
&nbsp;             * The advice method.
&nbsp;             */
&nbsp;            private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a delegator for a regular invocation.
&nbsp;             *
&nbsp;             * @param adviceMethod The advice method.
&nbsp;             */
<b class="fc">&nbsp;            protected ForRegularInvocation(MethodDescription.InDefinedShape adviceMethod) {</b>
<b class="fc">&nbsp;                this.adviceMethod = adviceMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                return MethodInvocation.invoke(adviceMethod);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for a regular method invocation delegator.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Factory implements Delegator.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
<b class="fc">&nbsp;                    return new ForRegularInvocation(adviceMethod);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invokes an advice method using a dynamic method call.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForDynamicInvocation implements Delegator {
&nbsp;
&nbsp;            /**
&nbsp;             * The bootstrap method.
&nbsp;             */
&nbsp;            private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * The advice method.
&nbsp;             */
&nbsp;            private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * A resolver to provide the arguments to the bootstrap method.
&nbsp;             */
&nbsp;            private final BootstrapArgumentResolver resolver;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a delegator for a dynamic method invocation.
&nbsp;             *
&nbsp;             * @param bootstrapMethod The bootstrap method.
&nbsp;             * @param adviceMethod    The advice method.
&nbsp;             * @param resolver        A resolver to provide the arguments to the bootstrap method.
&nbsp;             */
&nbsp;            protected ForDynamicInvocation(MethodDescription.InDefinedShape bootstrapMethod,
&nbsp;                                           MethodDescription.InDefinedShape adviceMethod,
<b class="fc">&nbsp;                                           BootstrapArgumentResolver resolver) {</b>
<b class="fc">&nbsp;                this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                this.resolver = resolver;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new dynamic invocation delegator.
&nbsp;             *
&nbsp;             * @param bootstrapMethod The bootstrap method or constructor.
&nbsp;             * @param resolverFactory A resolver factory to provide the arguments to the bootstrap method.
&nbsp;             * @return An appropriate delegator.
&nbsp;             */
&nbsp;            protected static Delegator.Factory of(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="fc">&nbsp;                if (!bootstrapMethod.isInvokeBootstrap()) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Not a suitable bootstrap target: &quot; + bootstrapMethod);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Factory(bootstrapMethod, resolverFactory);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation apply(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                List&lt;JavaConstant&gt; constants = resolver.resolve(instrumentedType, instrumentedMethod);</b>
<b class="fc">&nbsp;                if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(constants))) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot invoke &quot; + bootstrapMethod + &quot; with arguments: &quot; + constants);</b>
&nbsp;                }
<b class="fc">&nbsp;                return MethodInvocation.invoke(bootstrapMethod).dynamic(adviceMethod.getInternalName(),</b>
<b class="fc">&nbsp;                        adviceMethod.getReturnType().asErasure(),</b>
<b class="fc">&nbsp;                        adviceMethod.getParameters().asTypeList().asErasures(),</b>
&nbsp;                        constants);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a dynamic invocation dispatcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class Factory implements Delegator.Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * The bootstrap method.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape bootstrapMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolver factory to provide the arguments to the bootstrap method.
&nbsp;                 */
&nbsp;                private final BootstrapArgumentResolver.Factory resolverFactory;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a factory for a dynamic invocation dispatcher.
&nbsp;                 *
&nbsp;                 * @param bootstrapMethod The bootstrap method.
&nbsp;                 * @param resolverFactory A resolver factory to provide the arguments to the bootstrap method.
&nbsp;                 */
<b class="fc">&nbsp;                protected Factory(MethodDescription.InDefinedShape bootstrapMethod, BootstrapArgumentResolver.Factory resolverFactory) {</b>
<b class="fc">&nbsp;                    this.bootstrapMethod = bootstrapMethod;</b>
<b class="fc">&nbsp;                    this.resolverFactory = resolverFactory;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Delegator make(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
<b class="fc">&nbsp;                    return new ForDynamicInvocation(bootstrapMethod, adviceMethod, resolverFactory.resolve(adviceMethod, exit));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A resolver for the arguments that are provided to a bootstrap method if dynamic dispatch is used.
&nbsp;     */
&nbsp;    public interface BootstrapArgumentResolver {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the constants that are provided as arguments to the bootstrap methods.
&nbsp;         *
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @return A list of constants to supply as arguments to the bootstrap method.
&nbsp;         */
&nbsp;        List&lt;JavaConstant&gt; resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod);
&nbsp;
&nbsp;        /**
&nbsp;         * A factory for creating a {@link BootstrapArgumentResolver}.
&nbsp;         */
&nbsp;        interface Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a bootstrap argument resolver for a given advice.
&nbsp;             *
&nbsp;             * @param adviceMethod The advice method.
&nbsp;             * @param exit         {@code true} if the method is bound as exit advice.
&nbsp;             * @return An appropriate bootstrap argument resolver.
&nbsp;             */
&nbsp;            BootstrapArgumentResolver resolve(MethodDescription.InDefinedShape adviceMethod, boolean exit);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An argument resolver that supplies a default selection of arguments. The explicitly resolved constant values are:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;A {@link String} of the target&#39;s binary class name.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code int} with value {@code 0} for an enter advice and {code 1} for an exist advice.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link Class} representing the class implementing the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} with the name of the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} representing the instrumented method unless the target is the type&#39;s static initializer.&lt;/li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class ForDefaultValues implements BootstrapArgumentResolver {
&nbsp;
&nbsp;            /**
&nbsp;             * The advice method.
&nbsp;             */
&nbsp;            private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the advice is applied as exit advice.
&nbsp;             */
&nbsp;            private final boolean exit;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a bootstrap argument resolver with default values.
&nbsp;             *
&nbsp;             * @param adviceMethod The advice method.
&nbsp;             * @param exit         {@code true} if the advice is applied as exit advice.
&nbsp;             */
<b class="fc">&nbsp;            protected ForDefaultValues(MethodDescription.InDefinedShape adviceMethod, boolean exit) {</b>
<b class="fc">&nbsp;                this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                this.exit = exit;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public List&lt;JavaConstant&gt; resolve(TypeDescription instrumentedType, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                if (instrumentedMethod.isTypeInitializer()) {</b>
<b class="nc">&nbsp;                    return Arrays.asList(net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(adviceMethod.getDeclaringType().getName()),</b>
<b class="nc">&nbsp;                            net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(exit ? 1 : 0),</b>
<b class="nc">&nbsp;                            net.bytebuddy.utility.JavaConstant.Simple.of(instrumentedType),</b>
<b class="nc">&nbsp;                            net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return Arrays.asList(net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(adviceMethod.getDeclaringType().getName()),</b>
<b class="fc">&nbsp;                            net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(exit ? 1 : 0),</b>
<b class="fc">&nbsp;                            net.bytebuddy.utility.JavaConstant.Simple.of(instrumentedType),</b>
<b class="fc">&nbsp;                            net.bytebuddy.utility.JavaConstant.Simple.ofLoaded(instrumentedMethod.getInternalName()),</b>
<b class="fc">&nbsp;                            net.bytebuddy.utility.JavaConstant.MethodHandle.of(instrumentedMethod.asDefined()));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for creating a {@link ForDefaultValues}.
&nbsp;             */
<b class="fc">&nbsp;            public enum Factory implements BootstrapArgumentResolver.Factory {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public BootstrapArgumentResolver resolve(MethodDescription.InDefinedShape adviceMethod, boolean exit) {
<b class="fc">&nbsp;                    return new ForDefaultValues(adviceMethod, exit);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A handler for computing the instrumented method&#39;s size.
&nbsp;     */
&nbsp;    protected interface MethodSizeHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a size is not computed but handled directly by ASM.
&nbsp;         */
&nbsp;        int UNDEFINED_SIZE = Short.MAX_VALUE;
&nbsp;
&nbsp;        /**
&nbsp;         * Records a minimum stack size required by the represented advice method.
&nbsp;         *
&nbsp;         * @param stackSize The minimum size required by the represented advice method.
&nbsp;         */
&nbsp;        void requireStackSize(int stackSize);
&nbsp;
&nbsp;        /**
&nbsp;         * Requires a minimum length of the local variable array.
&nbsp;         *
&nbsp;         * @param localVariableLength The minimal required length of the local variable array.
&nbsp;         */
&nbsp;        void requireLocalVariableLength(int localVariableLength);
&nbsp;
&nbsp;        /**
&nbsp;         * A method size handler for the instrumented method.
&nbsp;         */
&nbsp;        interface ForInstrumentedMethod extends MethodSizeHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Binds a method size handler for the enter advice.
&nbsp;             *
&nbsp;             * @param adviceMethod The method representing the enter advice.
&nbsp;             * @return A method size handler for the enter advice.
&nbsp;             */
&nbsp;            ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Binds the method size handler for the exit advice.
&nbsp;             *
&nbsp;             * @param adviceMethod The method representing the exit advice.
&nbsp;             * @return A method size handler for the exit advice.
&nbsp;             */
&nbsp;            ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Computes a compound stack size for the advice and the translated instrumented method.
&nbsp;             *
&nbsp;             * @param stackSize The required stack size of the instrumented method before translation.
&nbsp;             * @return The stack size required by the instrumented method and its advice methods.
&nbsp;             */
&nbsp;            int compoundStackSize(int stackSize);
&nbsp;
&nbsp;            /**
&nbsp;             * Computes a compound local variable array length for the advice and the translated instrumented method.
&nbsp;             *
&nbsp;             * @param localVariableLength The required local variable array length of the instrumented method before translation.
&nbsp;             * @return The local variable length required by the instrumented method and its advice methods.
&nbsp;             */
&nbsp;            int compoundLocalVariableLength(int localVariableLength);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method size handler for an advice method.
&nbsp;         */
&nbsp;        interface ForAdvice extends MethodSizeHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Requires additional padding for the operand stack that is required for this advice&#39;s execution.
&nbsp;             *
&nbsp;             * @param stackSizePadding The required padding.
&nbsp;             */
&nbsp;            void requireStackSizePadding(int stackSizePadding);
&nbsp;
&nbsp;            /**
&nbsp;             * Requires additional padding for the local variable array that is required for this advice&#39;s execution.
&nbsp;             *
&nbsp;             * @param localVariableLengthPadding The required padding.
&nbsp;             */
&nbsp;            void requireLocalVariableLengthPadding(int localVariableLengthPadding);
&nbsp;
&nbsp;            /**
&nbsp;             * Records the maximum values for stack size and local variable array which are required by the advice method
&nbsp;             * for its individual execution without translation.
&nbsp;             *
&nbsp;             * @param stackSize           The minimum required stack size.
&nbsp;             * @param localVariableLength The minimum required length of the local variable array.
&nbsp;             */
&nbsp;            void recordMaxima(int stackSize, int localVariableLength);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational method size handler.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements ForInstrumentedMethod, ForAdvice {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int compoundStackSize(int stackSize) {
<b class="fc">&nbsp;                return UNDEFINED_SIZE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int compoundLocalVariableLength(int localVariableLength) {
<b class="fc">&nbsp;                return UNDEFINED_SIZE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void requireStackSize(int stackSize) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void requireLocalVariableLength(int localVariableLength) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void requireStackSizePadding(int stackSizePadding) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void requireLocalVariableLengthPadding(int localVariableLengthPadding) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void recordMaxima(int stackSize, int localVariableLength) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation for a method size handler.
&nbsp;         */
&nbsp;        abstract class Default implements MethodSizeHandler.ForInstrumentedMethod {
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            protected final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; initialTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; preMethodTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; postMethodTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * The maximum stack size required by a visited advice method.
&nbsp;             */
&nbsp;            protected int stackSize;
&nbsp;
&nbsp;            /**
&nbsp;             * The maximum length of the local variable array required by a visited advice method.
&nbsp;             */
&nbsp;            protected int localVariableLength;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default meta data handler that recomputes the space requirements of an instrumented method.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;             * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;             * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             */
&nbsp;            protected Default(MethodDescription instrumentedMethod,
&nbsp;                              List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                              List&lt;? extends TypeDescription&gt; preMethodTypes,
<b class="fc">&nbsp;                              List&lt;? extends TypeDescription&gt; postMethodTypes) {</b>
<b class="fc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                this.initialTypes = initialTypes;</b>
<b class="fc">&nbsp;                this.preMethodTypes = preMethodTypes;</b>
<b class="fc">&nbsp;                this.postMethodTypes = postMethodTypes;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a method size handler applicable for the given instrumented method.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;             * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;             * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             * @param copyArguments      {@code true} if the original arguments are copied before invoking the instrumented method.
&nbsp;             * @param writerFlags        The flags supplied to the ASM class writer.
&nbsp;             * @return An appropriate method size handler.
&nbsp;             */
&nbsp;            protected static MethodSizeHandler.ForInstrumentedMethod of(MethodDescription instrumentedMethod,
&nbsp;                                                                        List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                                                        List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                                                        List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                                                        boolean copyArguments,
&nbsp;                                                                        int writerFlags) {
<b class="fc">&nbsp;                if ((writerFlags &amp; (ClassWriter.COMPUTE_MAXS | ClassWriter.COMPUTE_FRAMES)) != 0) {</b>
<b class="fc">&nbsp;                    return NoOp.INSTANCE;</b>
<b class="fc">&nbsp;                } else if (copyArguments) {</b>
<b class="fc">&nbsp;                    return new WithCopiedArguments(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new WithRetainedArguments(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodSizeHandler.ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                return new ForAdvice(adviceMethod, instrumentedMethod.getStackSize() + StackSize.of(initialTypes));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void requireStackSize(int stackSize) {
<b class="fc">&nbsp;                Default.this.stackSize = Math.max(this.stackSize, stackSize);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void requireLocalVariableLength(int localVariableLength) {
<b class="fc">&nbsp;                this.localVariableLength = Math.max(this.localVariableLength, localVariableLength);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int compoundStackSize(int stackSize) {
<b class="fc">&nbsp;                return Math.max(this.stackSize, stackSize);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int compoundLocalVariableLength(int localVariableLength) {
<b class="nc">&nbsp;                return Math.max(this.localVariableLength, localVariableLength</b>
<b class="nc">&nbsp;                        + StackSize.of(postMethodTypes)</b>
<b class="nc">&nbsp;                        + StackSize.of(initialTypes)</b>
<b class="nc">&nbsp;                        + StackSize.of(preMethodTypes));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method size handler that expects that the original arguments are retained.
&nbsp;             */
&nbsp;            protected static class WithRetainedArguments extends Default {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new default method size handler that expects that the original arguments are retained.
&nbsp;                 *
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;                 * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;                 * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;                 */
&nbsp;                protected WithRetainedArguments(MethodDescription instrumentedMethod,
&nbsp;                                                List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                                List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                                List&lt;? extends TypeDescription&gt; postMethodTypes) {
<b class="fc">&nbsp;                    super(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodSizeHandler.ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                    return new ForAdvice(adviceMethod, instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(postMethodTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(initialTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(preMethodTypes));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int compoundLocalVariableLength(int localVariableLength) {
<b class="fc">&nbsp;                    return Math.max(this.localVariableLength, localVariableLength</b>
<b class="fc">&nbsp;                            + StackSize.of(postMethodTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(initialTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(preMethodTypes));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method size handler that expects that the original arguments were copied.
&nbsp;             */
&nbsp;            protected static class WithCopiedArguments extends Default {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new default method size handler that expects the original arguments to be copied.
&nbsp;                 *
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;                 * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;                 * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;                 */
&nbsp;                protected WithCopiedArguments(MethodDescription instrumentedMethod,
&nbsp;                                              List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                              List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                              List&lt;? extends TypeDescription&gt; postMethodTypes) {
<b class="fc">&nbsp;                    super(instrumentedMethod, initialTypes, preMethodTypes, postMethodTypes);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodSizeHandler.ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                    return new ForAdvice(adviceMethod, 2 * instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(initialTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(preMethodTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(postMethodTypes));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int compoundLocalVariableLength(int localVariableLength) {
<b class="fc">&nbsp;                    return Math.max(this.localVariableLength, localVariableLength</b>
<b class="fc">&nbsp;                            + instrumentedMethod.getStackSize()</b>
<b class="fc">&nbsp;                            + StackSize.of(postMethodTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(initialTypes)</b>
<b class="fc">&nbsp;                            + StackSize.of(preMethodTypes));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A method size handler for an advice method.
&nbsp;             */
&nbsp;            protected class ForAdvice implements MethodSizeHandler.ForAdvice {
&nbsp;
&nbsp;                /**
&nbsp;                 * The advice method.
&nbsp;                 */
&nbsp;                private final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The base of the local variable length that is implied by the method instrumentation prior to applying this advice method.
&nbsp;                 */
&nbsp;                private final int baseLocalVariableLength;
&nbsp;
&nbsp;                /**
&nbsp;                 * The additional padding to apply to the operand stack.
&nbsp;                 */
&nbsp;                private int stackSizePadding;
&nbsp;
&nbsp;                /**
&nbsp;                 * The additional padding to apply to the local variable array.
&nbsp;                 */
&nbsp;                private int localVariableLengthPadding;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a default method size handler for an advice method.
&nbsp;                 *
&nbsp;                 * @param adviceMethod            The advice method.
&nbsp;                 * @param baseLocalVariableLength The base of the local variable length that is implied by the method instrumentation
&nbsp;                 *                                prior to applying this advice method.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForAdvice(MethodDescription.InDefinedShape adviceMethod, int baseLocalVariableLength) {</b>
<b class="fc">&nbsp;                    this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                    this.baseLocalVariableLength = baseLocalVariableLength;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void requireStackSize(int stackSize) {
<b class="fc">&nbsp;                    Default.this.requireStackSize(stackSize);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void requireLocalVariableLength(int localVariableLength) {
<b class="fc">&nbsp;                    Default.this.requireLocalVariableLength(localVariableLength);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void requireStackSizePadding(int stackSizePadding) {
<b class="fc">&nbsp;                    this.stackSizePadding = Math.max(this.stackSizePadding, stackSizePadding);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void requireLocalVariableLengthPadding(int localVariableLengthPadding) {
<b class="fc">&nbsp;                    this.localVariableLengthPadding = Math.max(this.localVariableLengthPadding, localVariableLengthPadding);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void recordMaxima(int stackSize, int localVariableLength) {
<b class="fc">&nbsp;                    Default.this.requireStackSize(stackSize + stackSizePadding);</b>
<b class="fc">&nbsp;                    Default.this.requireLocalVariableLength(localVariableLength</b>
<b class="fc">&nbsp;                            - adviceMethod.getStackSize()</b>
&nbsp;                            + baseLocalVariableLength
&nbsp;                            + localVariableLengthPadding);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A handler for computing and translating stack map frames.
&nbsp;     */
&nbsp;    public interface StackMapFrameHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * Translates a frame.
&nbsp;         *
&nbsp;         * @param methodVisitor       The method visitor to write the frame to.
&nbsp;         * @param type                The frame&#39;s type.
&nbsp;         * @param localVariableLength The local variable length.
&nbsp;         * @param localVariable       An array containing the types of the current local variables.
&nbsp;         * @param stackSize           The size of the operand stack.
&nbsp;         * @param stack               An array containing the types of the current operand stack.
&nbsp;         */
&nbsp;        void translateFrame(MethodVisitor methodVisitor,
&nbsp;                            int type,
&nbsp;                            int localVariableLength,
&nbsp;                            @MaybeNull Object[] localVariable,
&nbsp;                            int stackSize,
&nbsp;                            @MaybeNull Object[] stack);
&nbsp;
&nbsp;        /**
&nbsp;         * Injects a frame indicating the beginning of a return value handler for the currently handled method.
&nbsp;         *
&nbsp;         * @param methodVisitor The method visitor onto which to apply the stack map frame.
&nbsp;         */
&nbsp;        void injectReturnFrame(MethodVisitor methodVisitor);
&nbsp;
&nbsp;        /**
&nbsp;         * Injects a frame indicating the beginning of an exception handler for the currently handled method.
&nbsp;         *
&nbsp;         * @param methodVisitor The method visitor onto which to apply the stack map frame.
&nbsp;         */
&nbsp;        void injectExceptionFrame(MethodVisitor methodVisitor);
&nbsp;
&nbsp;        /**
&nbsp;         * Injects a frame indicating the completion of the currently handled method, i.e. all yielded types were added.
&nbsp;         *
&nbsp;         * @param methodVisitor The method visitor onto which to apply the stack map frame.
&nbsp;         */
&nbsp;        void injectCompletionFrame(MethodVisitor methodVisitor);
&nbsp;
&nbsp;        /**
&nbsp;         * A stack map frame handler that can be used within a post processor. Emitting frames via this
&nbsp;         * handler is the only legal way for a post processor to produce frames.
&nbsp;         */
&nbsp;        interface ForPostProcessor {
&nbsp;
&nbsp;            /**
&nbsp;             * Injects a frame that represents the current state.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor onto which to apply the stack map frame.
&nbsp;             * @param stack         A list of types that are currently on the stack.
&nbsp;             */
&nbsp;            void injectIntermediateFrame(MethodVisitor methodVisitor, List&lt;? extends TypeDescription&gt; stack);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A stack map frame handler for an instrumented method.
&nbsp;         */
&nbsp;        interface ForInstrumentedMethod extends StackMapFrameHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Binds this meta data handler for the enter advice.
&nbsp;             *
&nbsp;             * @param adviceMethod The enter advice method.
&nbsp;             * @return An appropriate meta data handler for the enter method.
&nbsp;             */
&nbsp;            ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Binds this meta data handler for the exit advice.
&nbsp;             *
&nbsp;             * @param adviceMethod The exit advice method.
&nbsp;             * @return An appropriate meta data handler for the enter method.
&nbsp;             */
&nbsp;            ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a hint to supply to a {@link ClassReader} when parsing an advice method.
&nbsp;             *
&nbsp;             * @return The reader hint to supply to an ASM class reader.
&nbsp;             */
&nbsp;            int getReaderHint();
&nbsp;
&nbsp;            /**
&nbsp;             * Injects a frame after initialization if any initialization is performed.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor to write any frames to.
&nbsp;             */
&nbsp;            void injectInitializationFrame(MethodVisitor methodVisitor);
&nbsp;
&nbsp;            /**
&nbsp;             * Injects a frame before executing the instrumented method.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor to write any frames to.
&nbsp;             */
&nbsp;            void injectStartFrame(MethodVisitor methodVisitor);
&nbsp;
&nbsp;            /**
&nbsp;             * Injects a frame indicating the completion of the currently handled method, i.e. all yielded types were added.
&nbsp;             *
&nbsp;             * @param methodVisitor The method visitor onto which to apply the stack map frame.
&nbsp;             */
&nbsp;            void injectPostCompletionFrame(MethodVisitor methodVisitor);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A stack map frame handler for an advice method.
&nbsp;         */
&nbsp;        interface ForAdvice extends StackMapFrameHandler, ForPostProcessor {
&nbsp;            /* marker interface */
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A non-operational stack map frame handler.
&nbsp;         */
<b class="fc">&nbsp;        enum NoOp implements ForInstrumentedMethod, ForAdvice {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackMapFrameHandler.ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackMapFrameHandler.ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getReaderHint() {
<b class="fc">&nbsp;                return ClassReader.SKIP_FRAMES;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                       int type,
&nbsp;                                       int localVariableLength,
&nbsp;                                       @MaybeNull Object[] localVariable,
&nbsp;                                       int stackSize,
&nbsp;                                       @MaybeNull Object[] stack) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectReturnFrame(MethodVisitor methodVisitor) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectExceptionFrame(MethodVisitor methodVisitor) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectInitializationFrame(MethodVisitor methodVisitor) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void injectIntermediateFrame(MethodVisitor methodVisitor, List&lt;? extends TypeDescription&gt; stack) {
&nbsp;                /* do nothing */
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of a stack map frame handler for an instrumented method.
&nbsp;         */
&nbsp;        abstract class Default implements ForInstrumentedMethod {
&nbsp;
&nbsp;            /**
&nbsp;             * An empty array indicating an empty frame.
&nbsp;             */
<b class="fc">&nbsp;            protected static final Object[] EMPTY = new Object[0];</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented type.
&nbsp;             */
&nbsp;            protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;            /**
&nbsp;             * The instrumented method.
&nbsp;             */
&nbsp;            protected final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; initialTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual arguments that are available after the enter advice method is executed.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; latentTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; preMethodTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             */
&nbsp;            protected final List&lt;? extends TypeDescription&gt; postMethodTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * {@code true} if the meta data handler is expected to expand its frames.
&nbsp;             */
&nbsp;            protected final boolean expandFrames;
&nbsp;
&nbsp;            /**
&nbsp;             * The current frame&#39;s size divergence from the original local variable array.
&nbsp;             */
&nbsp;            protected int currentFrameDivergence;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default stack map frame handler.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;             * @param latentTypes        A list of virtual arguments that are available after the enter advice method is executed.
&nbsp;             * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;             * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             * @param expandFrames       {@code true} if the meta data handler is expected to expand its frames.
&nbsp;             */
&nbsp;            protected Default(TypeDescription instrumentedType,
&nbsp;                              MethodDescription instrumentedMethod,
&nbsp;                              List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                              List&lt;? extends TypeDescription&gt; latentTypes,
&nbsp;                              List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                              List&lt;? extends TypeDescription&gt; postMethodTypes,
<b class="fc">&nbsp;                              boolean expandFrames) {</b>
<b class="fc">&nbsp;                this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                this.initialTypes = initialTypes;</b>
<b class="fc">&nbsp;                this.latentTypes = latentTypes;</b>
<b class="fc">&nbsp;                this.preMethodTypes = preMethodTypes;</b>
<b class="fc">&nbsp;                this.postMethodTypes = postMethodTypes;</b>
<b class="fc">&nbsp;                this.expandFrames = expandFrames;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an appropriate stack map frame handler for an instrumented method.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;             * @param latentTypes        A list of virtual arguments that are available after the enter advice method is executed.
&nbsp;             * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;             * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             * @param exitAdvice         {@code true} if the current advice implies exit advice.
&nbsp;             * @param copyArguments      {@code true} if the original arguments are copied before invoking the instrumented method.
&nbsp;             * @param classFileVersion   The instrumented type&#39;s class file version.
&nbsp;             * @param writerFlags        The flags supplied to the ASM writer.
&nbsp;             * @param readerFlags        The reader flags supplied to the ASM reader.
&nbsp;             * @return An appropriate stack map frame handler for an instrumented method.
&nbsp;             */
&nbsp;            protected static ForInstrumentedMethod of(TypeDescription instrumentedType,
&nbsp;                                                      MethodDescription instrumentedMethod,
&nbsp;                                                      List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                                      List&lt;? extends TypeDescription&gt; latentTypes,
&nbsp;                                                      List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                                      List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                                      boolean exitAdvice,
&nbsp;                                                      boolean copyArguments,
&nbsp;                                                      ClassFileVersion classFileVersion,
&nbsp;                                                      int writerFlags,
&nbsp;                                                      int readerFlags) {
<b class="fc">&nbsp;                if ((writerFlags &amp; ClassWriter.COMPUTE_FRAMES) != 0 || classFileVersion.isLessThan(ClassFileVersion.JAVA_V6)) {</b>
<b class="fc">&nbsp;                    return NoOp.INSTANCE;</b>
<b class="fc">&nbsp;                } else if (!exitAdvice &amp;&amp; initialTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                    return new Trivial(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
&nbsp;                            latentTypes,
&nbsp;                            (readerFlags &amp; ClassReader.EXPAND_FRAMES) != 0);
<b class="fc">&nbsp;                } else if (copyArguments) {</b>
<b class="fc">&nbsp;                    return new WithPreservedArguments.WithArgumentCopy(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
&nbsp;                            initialTypes,
&nbsp;                            latentTypes,
&nbsp;                            preMethodTypes,
&nbsp;                            postMethodTypes,
&nbsp;                            (readerFlags &amp; ClassReader.EXPAND_FRAMES) != 0);
&nbsp;                } else {
<b class="fc">&nbsp;                    return new WithPreservedArguments.WithoutArgumentCopy(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
&nbsp;                            initialTypes,
&nbsp;                            latentTypes,
&nbsp;                            preMethodTypes,
&nbsp;                            postMethodTypes,
&nbsp;                            (readerFlags &amp; ClassReader.EXPAND_FRAMES) != 0,
<b class="fc">&nbsp;                            !instrumentedMethod.isConstructor());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackMapFrameHandler.ForAdvice bindEnter(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                return new ForAdvice(adviceMethod, initialTypes, latentTypes, preMethodTypes, TranslationMode.ENTER, instrumentedMethod.isConstructor()</b>
<b class="fc">&nbsp;                        ? Initialization.UNITIALIZED</b>
<b class="fc">&nbsp;                        : Initialization.INITIALIZED);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getReaderHint() {
<b class="fc">&nbsp;                return expandFrames</b>
<b class="fc">&nbsp;                        ? ClassReader.EXPAND_FRAMES</b>
<b class="fc">&nbsp;                        : AsmVisitorWrapper.NO_FLAGS;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Translates a frame.
&nbsp;             *
&nbsp;             * @param methodVisitor       The method visitor to write the frame to.
&nbsp;             * @param translationMode     The translation mode to apply.
&nbsp;             * @param methodDescription   The method description for which the frame is written.
&nbsp;             * @param additionalTypes     The additional types to consider part of the instrumented method&#39;s parameters.
&nbsp;             * @param type                The frame&#39;s type.
&nbsp;             * @param localVariableLength The local variable length.
&nbsp;             * @param localVariable       An array containing the types of the current local variables.
&nbsp;             * @param stackSize           The size of the operand stack.
&nbsp;             * @param stack               An array containing the types of the current operand stack.
&nbsp;             */
&nbsp;            protected void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                          TranslationMode translationMode,
&nbsp;                                          MethodDescription methodDescription,
&nbsp;                                          List&lt;? extends TypeDescription&gt; additionalTypes,
&nbsp;                                          int type,
&nbsp;                                          int localVariableLength,
&nbsp;                                          @MaybeNull Object[] localVariable,
&nbsp;                                          int stackSize,
&nbsp;                                          @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                switch (type) {</b>
&nbsp;                    case Opcodes.F_SAME:
&nbsp;                    case Opcodes.F_SAME1:
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.F_APPEND:
<b class="fc">&nbsp;                        currentFrameDivergence += localVariableLength;</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.F_CHOP:
<b class="fc">&nbsp;                        currentFrameDivergence -= localVariableLength;</b>
<b class="fc">&nbsp;                        if (currentFrameDivergence &lt; 0) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(methodDescription + &quot; dropped &quot; + Math.abs(currentFrameDivergence) + &quot; implicit frames&quot;);</b>
&nbsp;                        }
&nbsp;                        break;
&nbsp;                    case Opcodes.F_FULL:
&nbsp;                    case Opcodes.F_NEW:
<b class="fc">&nbsp;                        if (methodDescription.getParameters().size() + (methodDescription.isStatic() ? 0 : 1) &gt; localVariableLength) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Inconsistent frame length for &quot; + methodDescription + &quot;: &quot; + localVariableLength);</b>
&nbsp;                        }
&nbsp;                        int offset;
<b class="fc">&nbsp;                        if (methodDescription.isStatic()) {</b>
<b class="fc">&nbsp;                            offset = 0;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            if (!translationMode.isPossibleThisFrameValue(instrumentedType, instrumentedMethod, localVariable[0])) {</b>
<b class="fc">&nbsp;                                throw new IllegalStateException(methodDescription + &quot; is inconsistent for &#39;this&#39; reference: &quot; + localVariable[0]);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            offset = 1;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (int index = 0; index &lt; methodDescription.getParameters().size(); index++) {</b>
<b class="fc">&nbsp;                            if (!Initialization.INITIALIZED.toFrame(methodDescription.getParameters().get(index).getType().asErasure()).equals(localVariable[index + offset])) {</b>
<b class="fc">&nbsp;                                throw new IllegalStateException(methodDescription + &quot; is inconsistent at &quot; + index + &quot;: &quot; + localVariable[index + offset]);</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        Object[] translated = new Object[localVariableLength</b>
<b class="fc">&nbsp;                                - (methodDescription.isStatic() ? 0 : 1)</b>
<b class="fc">&nbsp;                                - methodDescription.getParameters().size()</b>
<b class="fc">&nbsp;                                + (instrumentedMethod.isStatic() ? 0 : 1)</b>
<b class="fc">&nbsp;                                + instrumentedMethod.getParameters().size()</b>
<b class="fc">&nbsp;                                + additionalTypes.size()];</b>
<b class="fc">&nbsp;                        int index = translationMode.copy(instrumentedType, instrumentedMethod, methodDescription, localVariable, translated);</b>
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : additionalTypes) {</b>
<b class="fc">&nbsp;                            translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        System.arraycopy(localVariable,</b>
<b class="fc">&nbsp;                                methodDescription.getParameters().size() + (methodDescription.isStatic() ? 0 : 1),</b>
&nbsp;                                translated,
&nbsp;                                index,
&nbsp;                                translated.length - index);
<b class="fc">&nbsp;                        localVariableLength = translated.length;</b>
<b class="fc">&nbsp;                        localVariable = translated;</b>
<b class="fc">&nbsp;                        currentFrameDivergence = translated.length - index;</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Unexpected frame type: &quot; + type);</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Injects a full stack map frame after the instrumented method has completed.
&nbsp;             *
&nbsp;             * @param methodVisitor  The method visitor onto which to write the stack map frame.
&nbsp;             * @param initialization The initialization to apply when resolving a reference to the instance on which a non-static method is invoked.
&nbsp;             * @param typesInArray   The types that were added to the local variable array additionally to the values of the instrumented method.
&nbsp;             * @param typesOnStack   The types currently on the operand stack.
&nbsp;             */
&nbsp;            protected void injectFullFrame(MethodVisitor methodVisitor,
&nbsp;                                           Initialization initialization,
&nbsp;                                           List&lt;? extends TypeDescription&gt; typesInArray,
&nbsp;                                           List&lt;? extends TypeDescription&gt; typesOnStack) {
<b class="fc">&nbsp;                Object[] localVariable = new Object[instrumentedMethod.getParameters().size()</b>
<b class="fc">&nbsp;                        + (instrumentedMethod.isStatic() ? 0 : 1)</b>
<b class="fc">&nbsp;                        + typesInArray.size()];</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                    localVariable[index++] = initialization.toFrame(instrumentedType);</b>
&nbsp;                }
<b class="fc">&nbsp;                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (TypeDescription typeDescription : typesInArray) {</b>
<b class="fc">&nbsp;                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                index = 0;</b>
<b class="fc">&nbsp;                Object[] stackType = new Object[typesOnStack.size()];</b>
<b class="fc">&nbsp;                for (TypeDescription typeDescription : typesOnStack) {</b>
<b class="fc">&nbsp;                    stackType[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                methodVisitor.visitFrame(expandFrames ? Opcodes.F_NEW : Opcodes.F_FULL, localVariable.length, localVariable, stackType.length, stackType);</b>
<b class="fc">&nbsp;                currentFrameDivergence = 0;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A translation mode that determines how the fixed frames of the instrumented method are written.
&nbsp;             */
<b class="fc">&nbsp;            protected enum TranslationMode {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A translation mode that simply copies the original frames which are available when translating frames of the instrumented method.
&nbsp;                 */
<b class="fc">&nbsp;                COPY {</b>
&nbsp;                    @Override
&nbsp;                    protected int copy(TypeDescription instrumentedType,
&nbsp;                                       MethodDescription instrumentedMethod,
&nbsp;                                       MethodDescription methodDescription,
&nbsp;                                       Object[] localVariable,
&nbsp;                                       Object[] translated) {
<b class="fc">&nbsp;                        int length = instrumentedMethod.getParameters().size() + (instrumentedMethod.isStatic() ? 0 : 1);</b>
<b class="fc">&nbsp;                        System.arraycopy(localVariable, 0, translated, 0, length);</b>
<b class="fc">&nbsp;                        return length;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
<b class="fc">&nbsp;                        return instrumentedMethod.isConstructor() &amp;&amp; Opcodes.UNINITIALIZED_THIS.equals(frame) || Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A translation mode for the enter advice that considers that the {@code this} reference might not be initialized for a constructor.
&nbsp;                 */
<b class="fc">&nbsp;                ENTER {</b>
&nbsp;                    @Override
&nbsp;                    protected int copy(TypeDescription instrumentedType,
&nbsp;                                       MethodDescription instrumentedMethod,
&nbsp;                                       MethodDescription methodDescription,
&nbsp;                                       Object[] localVariable,
&nbsp;                                       Object[] translated) {
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                            translated[index++] = instrumentedMethod.isConstructor()</b>
<b class="fc">&nbsp;                                    ? Opcodes.UNINITIALIZED_THIS</b>
<b class="fc">&nbsp;                                    : Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                            translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
<b class="nc">&nbsp;                        return instrumentedMethod.isConstructor()</b>
<b class="nc">&nbsp;                                ? Opcodes.UNINITIALIZED_THIS.equals(frame)</b>
<b class="nc">&nbsp;                                : Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A translation mode for an exit advice where the {@code this} reference is always initialized.
&nbsp;                 */
<b class="fc">&nbsp;                EXIT {</b>
&nbsp;                    @Override
&nbsp;                    protected int copy(TypeDescription instrumentedType,
&nbsp;                                       MethodDescription instrumentedMethod,
&nbsp;                                       MethodDescription methodDescription,
&nbsp;                                       Object[] localVariable,
&nbsp;                                       Object[] translated) {
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                            translated[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                            translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame) {
<b class="nc">&nbsp;                        return Initialization.INITIALIZED.toFrame(instrumentedType).equals(frame);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * Copies the fixed parameters of the instrumented method onto the operand stack.
&nbsp;                 *
&nbsp;                 * @param instrumentedType   The instrumented type.
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param methodDescription  The method for which a frame is created.
&nbsp;                 * @param localVariable      The original local variable array.
&nbsp;                 * @param translated         The array containing the translated frames.
&nbsp;                 * @return The amount of frames added to the translated frame array.
&nbsp;                 */
&nbsp;                protected abstract int copy(TypeDescription instrumentedType,
&nbsp;                                            MethodDescription instrumentedMethod,
&nbsp;                                            MethodDescription methodDescription,
&nbsp;                                            Object[] localVariable,
&nbsp;                                            Object[] translated);
&nbsp;
&nbsp;                /**
&nbsp;                 * Checks if a variable value in a stack map frame is a legal value for describing a {@code this} reference.
&nbsp;                 *
&nbsp;                 * @param instrumentedType   The instrumented type.
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param frame              The frame value representing the {@code this} reference.
&nbsp;                 * @return {@code true} if the value is a legal representation of the {@code this} reference.
&nbsp;                 */
&nbsp;                protected abstract boolean isPossibleThisFrameValue(TypeDescription instrumentedType, MethodDescription instrumentedMethod, Object frame);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents the initialization state of a stack value that can either be initialized or uninitialized.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Initialization {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an uninitialized frame value within a constructor before invoking the super constructor.
&nbsp;                 */
<b class="fc">&nbsp;                UNITIALIZED {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    protected Object toFrame(TypeDescription typeDescription) {
<b class="fc">&nbsp;                        if (typeDescription.isPrimitive()) {</b>
<b class="nc">&nbsp;                            throw new IllegalArgumentException(&quot;Cannot assume primitive uninitialized value: &quot; + typeDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return Opcodes.UNINITIALIZED_THIS;</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an initialized frame value.
&nbsp;                 */
<b class="fc">&nbsp;                INITIALIZED {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    protected Object toFrame(TypeDescription typeDescription) {
<b class="fc">&nbsp;                        if (typeDescription.represents(boolean.class)</b>
<b class="fc">&nbsp;                                || typeDescription.represents(byte.class)</b>
<b class="fc">&nbsp;                                || typeDescription.represents(short.class)</b>
<b class="fc">&nbsp;                                || typeDescription.represents(char.class)</b>
<b class="fc">&nbsp;                                || typeDescription.represents(int.class)) {</b>
<b class="fc">&nbsp;                            return Opcodes.INTEGER;</b>
<b class="fc">&nbsp;                        } else if (typeDescription.represents(long.class)) {</b>
<b class="fc">&nbsp;                            return Opcodes.LONG;</b>
<b class="fc">&nbsp;                        } else if (typeDescription.represents(float.class)) {</b>
<b class="fc">&nbsp;                            return Opcodes.FLOAT;</b>
<b class="fc">&nbsp;                        } else if (typeDescription.represents(double.class)) {</b>
<b class="fc">&nbsp;                            return Opcodes.DOUBLE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return typeDescription.getInternalName();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * Initializes a frame value to its frame type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type being resolved.
&nbsp;                 * @return The frame value.
&nbsp;                 */
&nbsp;                protected abstract Object toFrame(TypeDescription typeDescription);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A trivial stack map frame handler that applies a trivial translation for the instrumented method&#39;s stack map frames.
&nbsp;             */
&nbsp;            protected static class Trivial extends Default {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new stack map frame handler that applies a trivial translation for the instrumented method&#39;s stack map frames.
&nbsp;                 *
&nbsp;                 * @param instrumentedType   The instrumented type.
&nbsp;                 * @param instrumentedMethod The instrumented method.
&nbsp;                 * @param latentTypes        A list of virtual arguments that are available after the enter advice method is executed.
&nbsp;                 * @param expandFrames       {@code true} if the meta data handler is expected to expand its frames.
&nbsp;                 */
&nbsp;                protected Trivial(TypeDescription instrumentedType, MethodDescription instrumentedMethod, List&lt;? extends TypeDescription&gt; latentTypes, boolean expandFrames) {
<b class="fc">&nbsp;                    super(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
&nbsp;                            latentTypes,
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
&nbsp;                            expandFrames);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                           int type,
&nbsp;                                           int localVariableLength,
&nbsp;                                           @MaybeNull Object[] localVariable,
&nbsp;                                           int stackSize,
&nbsp;                                           @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                    methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackMapFrameHandler.ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect exit advice &quot; + adviceMethod + &quot; for &quot; + instrumentedMethod);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectReturnFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect return frame for &quot; + instrumentedMethod);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectExceptionFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect exception frame for &quot; + instrumentedMethod);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectCompletionFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect completion frame for &quot; + instrumentedMethod);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect post completion frame for &quot; + instrumentedMethod);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectInitializationFrame(MethodVisitor methodVisitor) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A stack map frame handler that requires the original arguments of the instrumented method to be preserved in their original form.
&nbsp;             */
&nbsp;            protected abstract static class WithPreservedArguments extends Default {
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if a completion frame for the method bust be a full frame to reflect an initialization change.
&nbsp;                 */
&nbsp;                protected boolean allowCompactCompletionFrame;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new stack map frame handler that requires the stack map frames of the original arguments to be preserved.
&nbsp;                 *
&nbsp;                 * @param instrumentedType            The instrumented type.
&nbsp;                 * @param instrumentedMethod          The instrumented method.
&nbsp;                 * @param initialTypes                A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;                 * @param latentTypes                 A list of virtual arguments that are available after the enter advice method is executed.
&nbsp;                 * @param preMethodTypes              A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;                 * @param postMethodTypes             A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;                 * @param expandFrames                {@code true} if the meta data handler is expected to expand its frames.
&nbsp;                 * @param allowCompactCompletionFrame {@code true} if a completion frame for the method bust be a full frame to reflect an initialization change.
&nbsp;                 */
&nbsp;                protected WithPreservedArguments(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                                 List&lt;? extends TypeDescription&gt; latentTypes,
&nbsp;                                                 List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                                 List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                                 boolean expandFrames,
&nbsp;                                                 boolean allowCompactCompletionFrame) {
<b class="fc">&nbsp;                    super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames);</b>
<b class="fc">&nbsp;                    this.allowCompactCompletionFrame = allowCompactCompletionFrame;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;RC_REF_COMPARISON_BAD_PRACTICE&quot;, justification = &quot;ASM models frames by reference identity.&quot;)
&nbsp;                protected void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                              TranslationMode translationMode,
&nbsp;                                              MethodDescription methodDescription,
&nbsp;                                              List&lt;? extends TypeDescription&gt; additionalTypes,
&nbsp;                                              int type,
&nbsp;                                              int localVariableLength,
&nbsp;                                              @MaybeNull Object[] localVariable,
&nbsp;                                              int stackSize,
&nbsp;                                              @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                    if (type == Opcodes.F_FULL &amp;&amp; localVariableLength &gt; 0 &amp;&amp; localVariable[0] != Opcodes.UNINITIALIZED_THIS) {</b>
<b class="fc">&nbsp;                        allowCompactCompletionFrame = true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    super.translateFrame(methodVisitor, translationMode, methodDescription, additionalTypes, type, localVariableLength, localVariable, stackSize, stack);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackMapFrameHandler.ForAdvice bindExit(MethodDescription.InDefinedShape adviceMethod) {
<b class="fc">&nbsp;                    return new ForAdvice(adviceMethod,</b>
<b class="fc">&nbsp;                            CompoundList.of(initialTypes, preMethodTypes, postMethodTypes),</b>
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription&gt;emptyList(),</b>
&nbsp;                            TranslationMode.EXIT,
&nbsp;                            Initialization.INITIALIZED);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectReturnFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!expandFrames &amp;&amp; currentFrameDivergence == 0) {</b>
<b class="fc">&nbsp;                        if (instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="nc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME1,</b>
&nbsp;                                    EMPTY.length,
&nbsp;                                    EMPTY,
&nbsp;                                    1,
<b class="fc">&nbsp;                                    new Object[]{Initialization.INITIALIZED.toFrame(instrumentedMethod.getReturnType().asErasure())});</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes),</b>
<b class="fc">&nbsp;                                instrumentedMethod.getReturnType().represents(void.class)</b>
<b class="fc">&nbsp;                                        ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                                        : Collections.singletonList(instrumentedMethod.getReturnType().asErasure()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectExceptionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!expandFrames &amp;&amp; currentFrameDivergence == 0) {</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[]{Type.getInternalName(Throwable.class)});</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes),</b>
<b class="fc">&nbsp;                                Collections.singletonList(TypeDescription.ForLoadedType.of(Throwable.class)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectCompletionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (allowCompactCompletionFrame &amp;&amp; !expandFrames &amp;&amp; currentFrameDivergence == 0 &amp;&amp; postMethodTypes.size() &lt; 4) {</b>
<b class="fc">&nbsp;                        if (postMethodTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            Object[] local = new Object[postMethodTypes.size()];</b>
<b class="fc">&nbsp;                            int index = 0;</b>
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : postMethodTypes) {</b>
<b class="fc">&nbsp;                                local[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes, postMethodTypes),</b>
<b class="fc">&nbsp;                                Collections.&lt;TypeDescription&gt;emptyList());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectPostCompletionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!expandFrames &amp;&amp; currentFrameDivergence == 0) {</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, Initialization.INITIALIZED, CompoundList.of(initialTypes, preMethodTypes, postMethodTypes),</b>
<b class="fc">&nbsp;                                Collections.&lt;TypeDescription&gt;emptyList());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectInitializationFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!initialTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                        if (!expandFrames &amp;&amp; initialTypes.size() &lt; 4) {</b>
<b class="fc">&nbsp;                            Object[] localVariable = new Object[initialTypes.size()];</b>
<b class="fc">&nbsp;                            int index = 0;</b>
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : initialTypes) {</b>
<b class="fc">&nbsp;                                localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_APPEND, localVariable.length, localVariable, EMPTY.length, EMPTY);</b>
<b class="fc">&nbsp;                        } else {</b>
<b class="fc">&nbsp;                            Object[] localVariable = new Object[(instrumentedMethod.isStatic() ? 0 : 1)</b>
<b class="fc">&nbsp;                                    + instrumentedMethod.getParameters().size()</b>
<b class="fc">&nbsp;                                    + initialTypes.size()];</b>
<b class="fc">&nbsp;                            int index = 0;</b>
<b class="fc">&nbsp;                            if (instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                                localVariable[index++] = Opcodes.UNINITIALIZED_THIS;</b>
<b class="fc">&nbsp;                            } else if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                                localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                                localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : initialTypes) {</b>
<b class="fc">&nbsp;                                localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(expandFrames ? Opcodes.F_NEW : Opcodes.F_FULL, localVariable.length, localVariable, EMPTY.length, EMPTY);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A stack map frame handler that expects that the original argument frames remain preserved throughout the original invocation.
&nbsp;                 */
&nbsp;                protected static class WithoutArgumentCopy extends WithPreservedArguments {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new stack map frame handler that expects the original frames to be preserved.
&nbsp;                     *
&nbsp;                     * @param instrumentedType            The instrumented type.
&nbsp;                     * @param instrumentedMethod          The instrumented method.
&nbsp;                     * @param initialTypes                A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;                     * @param latentTypes                 A list of virtual arguments that are available after the enter advice method is executed.
&nbsp;                     * @param preMethodTypes              A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;                     * @param postMethodTypes             A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;                     * @param expandFrames                {@code true} if the meta data handler is expected to expand its frames.
&nbsp;                     * @param allowCompactCompletionFrame {@code true} if a completion frame for the method bust be a full frame to reflect an initialization change.
&nbsp;                     */
&nbsp;                    protected WithoutArgumentCopy(TypeDescription instrumentedType,
&nbsp;                                                  MethodDescription instrumentedMethod,
&nbsp;                                                  List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                                  List&lt;? extends TypeDescription&gt; latentTypes,
&nbsp;                                                  List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                                  List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                                  boolean expandFrames,
&nbsp;                                                  boolean allowCompactCompletionFrame) {
<b class="fc">&nbsp;                        super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames, allowCompactCompletionFrame);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void injectStartFrame(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                               int type,
&nbsp;                                               int localVariableLength,
&nbsp;                                               @MaybeNull Object[] localVariable,
&nbsp;                                               int stackSize,
&nbsp;                                               @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                        translateFrame(methodVisitor,</b>
&nbsp;                                TranslationMode.COPY,
&nbsp;                                instrumentedMethod,
<b class="fc">&nbsp;                                CompoundList.of(initialTypes, preMethodTypes),</b>
&nbsp;                                type,
&nbsp;                                localVariableLength,
&nbsp;                                localVariable,
&nbsp;                                stackSize,
&nbsp;                                stack);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A stack map frame handler that expects that an argument copy of the original method arguments was made.
&nbsp;                 */
&nbsp;                protected static class WithArgumentCopy extends WithPreservedArguments {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new stack map frame handler that expects an argument copy.
&nbsp;                     *
&nbsp;                     * @param instrumentedType   The instrumented type.
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param initialTypes       A list of virtual method arguments that are explicitly added before any code execution.
&nbsp;                     * @param latentTypes        The types that are given post execution of a possible enter advice.
&nbsp;                     * @param preMethodTypes     A list of virtual method arguments that are available before the instrumented method is executed.
&nbsp;                     * @param postMethodTypes    A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;                     * @param expandFrames       {@code true} if the meta data handler is expected to expand its frames.
&nbsp;                     */
&nbsp;                    protected WithArgumentCopy(TypeDescription instrumentedType,
&nbsp;                                               MethodDescription instrumentedMethod,
&nbsp;                                               List&lt;? extends TypeDescription&gt; initialTypes,
&nbsp;                                               List&lt;? extends TypeDescription&gt; latentTypes,
&nbsp;                                               List&lt;? extends TypeDescription&gt; preMethodTypes,
&nbsp;                                               List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                               boolean expandFrames) {
<b class="fc">&nbsp;                        super(instrumentedType, instrumentedMethod, initialTypes, latentTypes, preMethodTypes, postMethodTypes, expandFrames, true);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void injectStartFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        if (!instrumentedMethod.isStatic() || !instrumentedMethod.getParameters().isEmpty()) {</b>
<b class="fc">&nbsp;                            if (!expandFrames &amp;&amp; (instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size() &lt; 4) {</b>
<b class="fc">&nbsp;                                Object[] localVariable = new Object[(instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size()];</b>
<b class="fc">&nbsp;                                int index = 0;</b>
<b class="fc">&nbsp;                                if (instrumentedMethod.isConstructor()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;</b>
<b class="fc">&nbsp;                                } else if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                methodVisitor.visitFrame(Opcodes.F_APPEND, localVariable.length, localVariable, EMPTY.length, EMPTY);</b>
<b class="fc">&nbsp;                            } else {</b>
<b class="fc">&nbsp;                                Object[] localVariable = new Object[(instrumentedMethod.isStatic() ? 0 : 2)</b>
<b class="fc">&nbsp;                                        + instrumentedMethod.getParameters().size() * 2</b>
<b class="fc">&nbsp;                                        + initialTypes.size()</b>
<b class="fc">&nbsp;                                        + preMethodTypes.size()];</b>
<b class="fc">&nbsp;                                int index = 0;</b>
<b class="fc">&nbsp;                                if (instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;</b>
<b class="fc">&nbsp;                                } else if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : initialTypes) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : preMethodTypes) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                if (instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                                    localVariable[index++] = Opcodes.UNINITIALIZED_THIS;</b>
<b class="fc">&nbsp;                                } else if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                                    localVariable[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                methodVisitor.visitFrame(expandFrames ? Opcodes.F_NEW : Opcodes.F_FULL, localVariable.length, localVariable, EMPTY.length, EMPTY);</b>
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        currentFrameDivergence = (instrumentedMethod.isStatic() ? 0 : 1) + instrumentedMethod.getParameters().size();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;RC_REF_COMPARISON_BAD_PRACTICE&quot;, justification = &quot;ASM models frames by reference identity.&quot;)
&nbsp;                    public void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                               int type,
&nbsp;                                               int localVariableLength,
&nbsp;                                               @MaybeNull Object[] localVariable,
&nbsp;                                               int stackSize,
&nbsp;                                               @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                        switch (type) {</b>
&nbsp;                            case Opcodes.F_SAME:
&nbsp;                            case Opcodes.F_SAME1:
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.F_APPEND:
<b class="fc">&nbsp;                                currentFrameDivergence += localVariableLength;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.F_CHOP:
<b class="fc">&nbsp;                                currentFrameDivergence -= localVariableLength;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.F_FULL:
&nbsp;                            case Opcodes.F_NEW:
<b class="fc">&nbsp;                                Object[] translated = new Object[localVariableLength</b>
<b class="fc">&nbsp;                                        + (instrumentedMethod.isStatic() ? 0 : 1)</b>
<b class="fc">&nbsp;                                        + instrumentedMethod.getParameters().size()</b>
<b class="fc">&nbsp;                                        + initialTypes.size()</b>
<b class="fc">&nbsp;                                        + preMethodTypes.size()];</b>
<b class="fc">&nbsp;                                int index = 0;</b>
<b class="fc">&nbsp;                                if (instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                                    Initialization initialization = Initialization.INITIALIZED;</b>
<b class="nc">&nbsp;                                    for (int variableIndex = 0; variableIndex &lt; localVariableLength; variableIndex++) {</b>
<b class="nc">&nbsp;                                        if (localVariable[variableIndex] == Opcodes.UNINITIALIZED_THIS) {</b>
<b class="nc">&nbsp;                                            initialization = Initialization.UNITIALIZED;</b>
<b class="nc">&nbsp;                                            break;</b>
&nbsp;                                        }
&nbsp;                                    }
<b class="nc">&nbsp;                                    translated[index++] = initialization.toFrame(instrumentedType);</b>
<b class="nc">&nbsp;                                } else if (!instrumentedMethod.isStatic()) {</b>
<b class="fc">&nbsp;                                    translated[index++] = Initialization.INITIALIZED.toFrame(instrumentedType);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : instrumentedMethod.getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                                    translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : initialTypes) {</b>
<b class="fc">&nbsp;                                    translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                for (TypeDescription typeDescription : preMethodTypes) {</b>
<b class="fc">&nbsp;                                    translated[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                if (localVariableLength &gt; 0) {</b>
<b class="fc">&nbsp;                                    System.arraycopy(localVariable, 0, translated, index, localVariableLength);</b>
&nbsp;                                }
<b class="fc">&nbsp;                                localVariableLength = translated.length;</b>
<b class="fc">&nbsp;                                localVariable = translated;</b>
<b class="fc">&nbsp;                                currentFrameDivergence = localVariableLength;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            default:
<b class="nc">&nbsp;                                throw new IllegalArgumentException(&quot;Unexpected frame type: &quot; + type);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        methodVisitor.visitFrame(type, localVariableLength, localVariable, stackSize, stack);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A stack map frame handler for an advice method.
&nbsp;             */
&nbsp;            protected class ForAdvice implements StackMapFrameHandler.ForAdvice {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method description for which frames are translated.
&nbsp;                 */
&nbsp;                protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The types provided before execution of the advice code.
&nbsp;                 */
&nbsp;                protected final List&lt;? extends TypeDescription&gt; startTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * The types that are given post execution of the advice.
&nbsp;                 */
&nbsp;                private final List&lt;? extends TypeDescription&gt; intermediateTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * The types provided after execution of the advice code.
&nbsp;                 */
&nbsp;                protected final List&lt;? extends TypeDescription&gt; endTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * The translation mode to apply for this advice method. Should be either {@link TranslationMode#ENTER} or {@link TranslationMode#EXIT}.
&nbsp;                 */
&nbsp;                protected final TranslationMode translationMode;
&nbsp;
&nbsp;                /**
&nbsp;                 * The initialization to apply when resolving a reference to the instance on which a non-static method is invoked.
&nbsp;                 */
&nbsp;                private final Initialization initialization;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if an intermediate frame was yielded.
&nbsp;                 */
&nbsp;                private boolean intermedate;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new meta data handler for an advice method.
&nbsp;                 *
&nbsp;                 * @param adviceMethod      The method description for which frames are translated.
&nbsp;                 * @param startTypes        The types provided before execution of the advice code.
&nbsp;                 * @param intermediateTypes The types that are given post execution of the advice.
&nbsp;                 * @param endTypes          The types provided after execution of the advice code.
&nbsp;                 * @param translationMode   The translation mode to apply for this advice method. Should be
&nbsp;                 *                          either {@link TranslationMode#ENTER} or {@link TranslationMode#EXIT}.
&nbsp;                 * @param initialization    The initialization to apply when resolving a reference to the instance on which a non-static method is invoked.
&nbsp;                 */
&nbsp;                protected ForAdvice(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                    List&lt;? extends TypeDescription&gt; startTypes,
&nbsp;                                    List&lt;? extends TypeDescription&gt; intermediateTypes,
&nbsp;                                    List&lt;? extends TypeDescription&gt; endTypes,
&nbsp;                                    TranslationMode translationMode,
<b class="fc">&nbsp;                                    Initialization initialization) {</b>
<b class="fc">&nbsp;                    this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                    this.startTypes = startTypes;</b>
<b class="fc">&nbsp;                    this.intermediateTypes = intermediateTypes;</b>
<b class="fc">&nbsp;                    this.endTypes = endTypes;</b>
<b class="fc">&nbsp;                    this.translationMode = translationMode;</b>
<b class="fc">&nbsp;                    this.initialization = initialization;</b>
<b class="fc">&nbsp;                    intermedate = false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void translateFrame(MethodVisitor methodVisitor,
&nbsp;                                           int type,
&nbsp;                                           int localVariableLength,
&nbsp;                                           @MaybeNull Object[] localVariable,
&nbsp;                                           int stackSize,
&nbsp;                                           @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                    Default.this.translateFrame(methodVisitor,</b>
&nbsp;                            translationMode,
&nbsp;                            adviceMethod,
&nbsp;                            startTypes,
&nbsp;                            type,
&nbsp;                            localVariableLength,
&nbsp;                            localVariable,
&nbsp;                            stackSize,
&nbsp;                            stack);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectReturnFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!expandFrames &amp;&amp; currentFrameDivergence == 0) {</b>
<b class="fc">&nbsp;                        if (adviceMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME1,</b>
&nbsp;                                    EMPTY.length,
&nbsp;                                    EMPTY,
&nbsp;                                    1,
<b class="fc">&nbsp;                                    new Object[]{Initialization.INITIALIZED.toFrame(adviceMethod.getReturnType().asErasure())});</b>
&nbsp;                        }
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, initialization, startTypes, adviceMethod.getReturnType().represents(void.class)</b>
<b class="nc">&nbsp;                                ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                                : Collections.singletonList(adviceMethod.getReturnType().asErasure()));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectExceptionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (!expandFrames &amp;&amp; currentFrameDivergence == 0) {</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[]{Type.getInternalName(Throwable.class)});</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, initialization, startTypes, Collections.singletonList(TypeDescription.ForLoadedType.of(Throwable.class)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectCompletionFrame(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                    if (expandFrames) {</b>
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, endTypes), Collections.&lt;TypeDescription&gt;emptyList());</b>
<b class="fc">&nbsp;                    } else if (currentFrameDivergence == 0 &amp;&amp; (intermedate || endTypes.size() &lt; 4)) {</b>
<b class="fc">&nbsp;                        if (intermedate || endTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            Object[] local = new Object[endTypes.size()];</b>
<b class="fc">&nbsp;                            int index = 0;</b>
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : endTypes) {</b>
<b class="fc">&nbsp;                                local[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    } else if (currentFrameDivergence &lt; 3 &amp;&amp; endTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentFrameDivergence, EMPTY, EMPTY.length, EMPTY);</b>
<b class="fc">&nbsp;                        currentFrameDivergence = 0;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, endTypes), Collections.&lt;TypeDescription&gt;emptyList());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void injectIntermediateFrame(MethodVisitor methodVisitor, List&lt;? extends TypeDescription&gt; stack) {
<b class="fc">&nbsp;                    if (expandFrames) {</b>
<b class="nc">&nbsp;                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, intermediateTypes), stack);</b>
<b class="fc">&nbsp;                    } else if (intermedate &amp;&amp; stack.size() &lt; 2) {</b>
<b class="fc">&nbsp;                        if (stack.isEmpty()) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[]{Initialization.INITIALIZED.toFrame(stack.get(0))});</b>
&nbsp;                        }
<b class="fc">&nbsp;                    } else if (currentFrameDivergence == 0</b>
<b class="fc">&nbsp;                            &amp;&amp; intermediateTypes.size() &lt; 4</b>
<b class="fc">&nbsp;                            &amp;&amp; (stack.isEmpty() || stack.size() &lt; 2 &amp;&amp; intermediateTypes.isEmpty())) {</b>
<b class="fc">&nbsp;                        if (intermediateTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                            if (stack.isEmpty()) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitFrame(Opcodes.F_SAME, EMPTY.length, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                methodVisitor.visitFrame(Opcodes.F_SAME1, EMPTY.length, EMPTY, 1, new Object[]{Initialization.INITIALIZED.toFrame(stack.get(0))});</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="fc">&nbsp;                            Object[] local = new Object[intermediateTypes.size()];</b>
<b class="fc">&nbsp;                            int index = 0;</b>
<b class="fc">&nbsp;                            for (TypeDescription typeDescription : intermediateTypes) {</b>
<b class="fc">&nbsp;                                local[index++] = Initialization.INITIALIZED.toFrame(typeDescription);</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            methodVisitor.visitFrame(Opcodes.F_APPEND, local.length, local, EMPTY.length, EMPTY);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    } else if (currentFrameDivergence &lt; 3 &amp;&amp; intermediateTypes.isEmpty() &amp;&amp; stack.isEmpty()) {</b>
<b class="nc">&nbsp;                        methodVisitor.visitFrame(Opcodes.F_CHOP, currentFrameDivergence, EMPTY, EMPTY.length, EMPTY);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        injectFullFrame(methodVisitor, initialization, CompoundList.of(startTypes, intermediateTypes), stack);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    currentFrameDivergence = intermediateTypes.size() - endTypes.size();</b>
<b class="fc">&nbsp;                    intermedate = true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An exception handler is responsible for providing byte code for handling an exception thrown from a suppressing advice method.
&nbsp;     */
&nbsp;    public interface ExceptionHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a stack manipulation to apply.
&nbsp;         *
&nbsp;         * @param instrumentedMethod The instrumented method.
&nbsp;         * @param instrumentedType   The instrumented type.
&nbsp;         * @return The stack manipulation to use.
&nbsp;         */
&nbsp;        StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType);
&nbsp;
&nbsp;        /**
&nbsp;         * Default implementations for commonly used exception handlers.
&nbsp;         */
<b class="fc">&nbsp;        enum Default implements ExceptionHandler {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * An exception handler the suppresses the exception.
&nbsp;             */
<b class="fc">&nbsp;            SUPPRESSING {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    return Removal.SINGLE;</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * An exception handler that invokes {@link Throwable#printStackTrace()}.
&nbsp;             */
<b class="fc">&nbsp;            PRINTING {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
&nbsp;                    try {
<b class="fc">&nbsp;                        return MethodInvocation.invoke(new MethodDescription.ForLoadedMethod(Throwable.class.getMethod(&quot;printStackTrace&quot;)));</b>
<b class="nc">&nbsp;                    } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot locate Throwable::printStackTrace&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * An exception handler that rethrows any suppressed {@link Throwable}. Normally, it is preferable to avoid suppression
&nbsp;             * altogether rather then to rethrow them. It can however be desired to make this behavior configurable where using this
&nbsp;             * handler allows to effectively disable the suppression.
&nbsp;             */
<b class="fc">&nbsp;            RETHROWING {</b>
&nbsp;                /** {@inheritDoc} */
&nbsp;                public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    return Throw.INSTANCE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A simple exception handler that returns a fixed stack manipulation.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements ExceptionHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation to execute.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new simple exception handler.
&nbsp;             *
&nbsp;             * @param stackManipulation The stack manipulation to execute.
&nbsp;             */
<b class="fc">&nbsp;            public Simple(StackManipulation stackManipulation) {</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackManipulation resolve(MethodDescription instrumentedMethod, TypeDescription instrumentedType) {
<b class="fc">&nbsp;                return stackManipulation;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A dispatcher for implementing advice.
&nbsp;     */
&nbsp;    protected interface Dispatcher {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a method does not represent advice and does not need to be visited.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        MethodVisitor IGNORE_METHOD = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Expresses that an annotation should not be visited.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        AnnotationVisitor IGNORE_ANNOTATION = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if this dispatcher is alive.
&nbsp;         *
&nbsp;         * @return {@code true} if this dispatcher is alive.
&nbsp;         */
&nbsp;        boolean isAlive();
&nbsp;
&nbsp;        /**
&nbsp;         * The type that is produced as a result of executing this advice method.
&nbsp;         *
&nbsp;         * @return A description of the type that is produced by this advice method.
&nbsp;         */
&nbsp;        TypeDefinition getAdviceType();
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher that is not yet resolved.
&nbsp;         */
&nbsp;        interface Unresolved extends Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that this dispatcher requires access to the class file declaring the advice method.
&nbsp;             *
&nbsp;             * @return {@code true} if this dispatcher requires access to the advice method&#39;s class file.
&nbsp;             */
&nbsp;            boolean isBinary();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the named types declared by this enter advice.
&nbsp;             *
&nbsp;             * @return The named types declared by this enter advice.
&nbsp;             */
&nbsp;            Map&lt;String, TypeDefinition&gt; getNamedTypes();
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves this dispatcher as a dispatcher for entering a method.
&nbsp;             *
&nbsp;             * @param userFactories        A list of custom factories for binding parameters of an advice method.
&nbsp;             * @param classReader          A class reader to query for a class file which might be {@code null} if this dispatcher is not binary.
&nbsp;             * @param methodExit           The unresolved dispatcher for the method exit advice.
&nbsp;             * @param postProcessorFactory The post processor factory to use.
&nbsp;             * @return This dispatcher as a dispatcher for entering a method.
&nbsp;             */
&nbsp;            Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                  @MaybeNull ClassReader classReader,
&nbsp;                                                  Unresolved methodExit,
&nbsp;                                                  PostProcessor.Factory postProcessorFactory);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves this dispatcher as a dispatcher for exiting a method.
&nbsp;             *
&nbsp;             * @param userFactories        A list of custom factories for binding parameters of an advice method.
&nbsp;             * @param classReader          A class reader to query for a class file which might be {@code null} if this dispatcher is not binary.
&nbsp;             * @param methodEnter          The unresolved dispatcher for the method enter advice.
&nbsp;             * @param postProcessorFactory The post processor factory to use.
&nbsp;             * @return This dispatcher as a dispatcher for exiting a method.
&nbsp;             */
&nbsp;            Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                @MaybeNull ClassReader classReader,
&nbsp;                                                Unresolved methodEnter,
&nbsp;                                                PostProcessor.Factory postProcessorFactory);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A suppression handler for optionally suppressing exceptions.
&nbsp;         */
&nbsp;        interface SuppressionHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Binds the suppression handler for instrumenting a specific method.
&nbsp;             *
&nbsp;             * @param exceptionHandler The stack manipulation to apply within a suppression handler.
&nbsp;             * @return A bound version of the suppression handler.
&nbsp;             */
&nbsp;            Bound bind(StackManipulation exceptionHandler);
&nbsp;
&nbsp;            /**
&nbsp;             * A bound version of a suppression handler that must not be reused.
&nbsp;             */
&nbsp;            interface Bound {
&nbsp;
&nbsp;                /**
&nbsp;                 * Invoked to prepare the suppression handler, i.e. to write an exception handler entry if appropriate.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor to apply the preparation to.
&nbsp;                 */
&nbsp;                void onPrepare(MethodVisitor methodVisitor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Invoked at the start of a method.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor of the instrumented method.
&nbsp;                 */
&nbsp;                void onStart(MethodVisitor methodVisitor);
&nbsp;
&nbsp;                /**
&nbsp;                 * Invoked at the end of a method.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         The method visitor of the instrumented method.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param methodSizeHandler     The advice method&#39;s method size handler.
&nbsp;                 * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                 * @param returnType            The return type of the advice method.
&nbsp;                 */
&nbsp;                void onEnd(MethodVisitor methodVisitor,
&nbsp;                           Implementation.Context implementationContext,
&nbsp;                           MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                           StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                           TypeDefinition returnType);
&nbsp;
&nbsp;                /**
&nbsp;                 * Invoked at the end of a method if the exception handler should be wrapped in a skipping block.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         The method visitor of the instrumented method.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param methodSizeHandler     The advice method&#39;s method size handler.
&nbsp;                 * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                 * @param returnType            The return type of the advice method.
&nbsp;                 */
&nbsp;                void onEndWithSkip(MethodVisitor methodVisitor,
&nbsp;                                   Implementation.Context implementationContext,
&nbsp;                                   MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                   StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                   TypeDefinition returnType);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational suppression handler that does not suppress any method.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements SuppressionHandler, Bound {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Bound bind(StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onPrepare(MethodVisitor methodVisitor) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onStart(MethodVisitor methodVisitor) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onEnd(MethodVisitor methodVisitor,
&nbsp;                                  Implementation.Context implementationContext,
&nbsp;                                  MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                  StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                  TypeDefinition returnType) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onEndWithSkip(MethodVisitor methodVisitor,
&nbsp;                                          Implementation.Context implementationContext,
&nbsp;                                          MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                          StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                          TypeDefinition returnType) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A suppression handler that suppresses a given throwable type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Suppressing implements SuppressionHandler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The suppressed throwable type.
&nbsp;                 */
&nbsp;                private final TypeDescription suppressedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new suppressing suppression handler.
&nbsp;                 *
&nbsp;                 * @param suppressedType The suppressed throwable type.
&nbsp;                 */
<b class="fc">&nbsp;                protected Suppressing(TypeDescription suppressedType) {</b>
<b class="fc">&nbsp;                    this.suppressedType = suppressedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves an appropriate suppression handler.
&nbsp;                 *
&nbsp;                 * @param suppressedType The suppressed type or {@link NoExceptionHandler} if no type should be suppressed.
&nbsp;                 * @return An appropriate suppression handler.
&nbsp;                 */
&nbsp;                protected static SuppressionHandler of(TypeDescription suppressedType) {
<b class="fc">&nbsp;                    return suppressedType.represents(NoExceptionHandler.class)</b>
<b class="fc">&nbsp;                            ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                            : new Suppressing(suppressedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SuppressionHandler.Bound bind(StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                    return new Bound(suppressedType, exceptionHandler);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An active, bound suppression handler.
&nbsp;                 */
&nbsp;                protected static class Bound implements SuppressionHandler.Bound {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The suppressed throwable type.
&nbsp;                     */
&nbsp;                    private final TypeDescription suppressedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The stack manipulation to apply within a suppression handler.
&nbsp;                     */
&nbsp;                    private final StackManipulation exceptionHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A label indicating the start of the method.
&nbsp;                     */
&nbsp;                    private final Label startOfMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A label indicating the end of the method.
&nbsp;                     */
&nbsp;                    private final Label endOfMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new active, bound suppression handler.
&nbsp;                     *
&nbsp;                     * @param suppressedType   The suppressed throwable type.
&nbsp;                     * @param exceptionHandler The stack manipulation to apply within a suppression handler.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Bound(TypeDescription suppressedType, StackManipulation exceptionHandler) {</b>
<b class="fc">&nbsp;                        this.suppressedType = suppressedType;</b>
<b class="fc">&nbsp;                        this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;                        startOfMethod = new Label();</b>
<b class="fc">&nbsp;                        endOfMethod = new Label();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onPrepare(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitTryCatchBlock(startOfMethod, endOfMethod, endOfMethod, suppressedType.getInternalName());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onStart(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitLabel(startOfMethod);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onEnd(MethodVisitor methodVisitor,
&nbsp;                                      Implementation.Context implementationContext,
&nbsp;                                      MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                      StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                      TypeDefinition returnType) {
<b class="fc">&nbsp;                        methodVisitor.visitLabel(endOfMethod);</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectExceptionFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodSizeHandler.requireStackSize(1 + exceptionHandler.apply(methodVisitor, implementationContext).getMaximalSize());</b>
<b class="fc">&nbsp;                        if (returnType.represents(boolean.class)</b>
<b class="fc">&nbsp;                                || returnType.represents(byte.class)</b>
<b class="fc">&nbsp;                                || returnType.represents(short.class)</b>
<b class="fc">&nbsp;                                || returnType.represents(char.class)</b>
<b class="fc">&nbsp;                                || returnType.represents(int.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                        } else if (returnType.represents(long.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                        } else if (returnType.represents(float.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                        } else if (returnType.represents(double.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                        } else if (!returnType.represents(void.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onEndWithSkip(MethodVisitor methodVisitor,
&nbsp;                                              Implementation.Context implementationContext,
&nbsp;                                              MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                              StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                              TypeDefinition returnType) {
<b class="fc">&nbsp;                        Label skipExceptionHandler = new Label();</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.GOTO, skipExceptionHandler);</b>
<b class="fc">&nbsp;                        onEnd(methodVisitor, implementationContext, methodSizeHandler, stackMapFrameHandler, returnType);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(skipExceptionHandler);</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A relocation handler is responsible for chaining the usual control flow of an instrumented method.
&nbsp;         */
&nbsp;        interface RelocationHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Binds this relocation handler to a relocation dispatcher.
&nbsp;             *
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param relocation         The relocation to apply.
&nbsp;             * @return A bound relocation handler.
&nbsp;             */
&nbsp;            Bound bind(MethodDescription instrumentedMethod, Relocation relocation);
&nbsp;
&nbsp;            /**
&nbsp;             * A relocator is responsible for triggering a relocation if a relocation handler triggers a relocating condition.
&nbsp;             */
&nbsp;            interface Relocation {
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this relocator.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor to use.
&nbsp;                 */
&nbsp;                void apply(MethodVisitor methodVisitor);
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation that unconditionally jumps to a given label.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForLabel implements Relocation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The label to jump to.
&nbsp;                     */
&nbsp;                    private final Label label;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new relocation for an unconditional jump to a given label.
&nbsp;                     *
&nbsp;                     * @param label The label to jump to.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLabel(Label label) {</b>
<b class="fc">&nbsp;                        this.label = label;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.GOTO, label);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A bound {@link RelocationHandler}.
&nbsp;             */
&nbsp;            interface Bound {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates that this relocation handler does not require a minimal stack size.
&nbsp;                 */
&nbsp;                int NO_REQUIRED_SIZE = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this relocation handler.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         The method visitor to use.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param offset                The offset of the relevant value.
&nbsp;                 * @return The minimal required stack size to apply this relocation handler.
&nbsp;                 */
&nbsp;                int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A disabled relocation handler that does never trigger a relocation.
&nbsp;             */
<b class="fc">&nbsp;            enum Disabled implements RelocationHandler, Bound {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
<b class="fc">&nbsp;                    return NO_REQUIRED_SIZE;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A relocation handler factory that triggers a relocation for a default or non-default value.
&nbsp;             */
<b class="fc">&nbsp;            enum ForValue {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for an {@code int} type or any compatible type.
&nbsp;                 */
<b class="fc">&nbsp;                BOOLEAN(Opcodes.ILOAD, Opcodes.BALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for an {@code int} type or any compatible type.
&nbsp;                 */
<b class="fc">&nbsp;                BYTE(Opcodes.ILOAD, Opcodes.BALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for an {@code short} type or any compatible type.
&nbsp;                 */
<b class="fc">&nbsp;                SHORT(Opcodes.ILOAD, Opcodes.SALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for an {@code char} type or any compatible type.
&nbsp;                 */
<b class="fc">&nbsp;                CHARACTER(Opcodes.ILOAD, Opcodes.CALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for an {@code int} type or any compatible type.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER(Opcodes.ILOAD, Opcodes.IALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for a {@code long} type.
&nbsp;                 */
<b class="fc">&nbsp;                LONG(Opcodes.LLOAD, Opcodes.LALOAD, Opcodes.IFNE, Opcodes.IFEQ, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.L2I);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for a {@code float} type.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT(Opcodes.FLOAD, Opcodes.FALOAD, Opcodes.IFNE, Opcodes.IFEQ, 2) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.FCMPL);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for a {@code double} type.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE(Opcodes.DLOAD, Opcodes.DALOAD, Opcodes.IFNE, Opcodes.IFEQ, 4) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DCMPL);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler for a reference type.
&nbsp;                 */
<b class="fc">&nbsp;                REFERENCE(Opcodes.ALOAD, Opcodes.AALOAD, Opcodes.IFNONNULL, Opcodes.IFNULL, 0) {</b>
&nbsp;                    @Override
&nbsp;                    protected void convertValue(MethodVisitor methodVisitor) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * An opcode for loading a value of the represented type from the local variable array.
&nbsp;                 */
&nbsp;                private final int load;
&nbsp;
&nbsp;                /**
&nbsp;                 * An opcode for loading a value of the represented type from an array.
&nbsp;                 */
&nbsp;                private final int arrayLoad;
&nbsp;
&nbsp;                /**
&nbsp;                 * The opcode to check for a non-default value.
&nbsp;                 */
&nbsp;                private final int defaultJump;
&nbsp;
&nbsp;                /**
&nbsp;                 * The opcode to check for a default value.
&nbsp;                 */
&nbsp;                private final int nonDefaultJump;
&nbsp;
&nbsp;                /**
&nbsp;                 * The minimal required stack size to apply this relocation handler.
&nbsp;                 */
&nbsp;                private final int requiredSize;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new relocation handler for a type&#39;s default or non-default value.
&nbsp;                 *
&nbsp;                 * @param load           An opcode for loading a value of the represented type from the local variable array.
&nbsp;                 * @param arrayLoad      An opcode for loading a value of the represented type from an array.
&nbsp;                 * @param defaultJump    The opcode to check for a non-default value.
&nbsp;                 * @param nonDefaultJump The opcode to check for a default value.
&nbsp;                 * @param requiredSize   The minimal required stack size to apply this relocation handler.
&nbsp;                 */
<b class="fc">&nbsp;                ForValue(int load, int arrayLoad, int defaultJump, int nonDefaultJump, int requiredSize) {</b>
<b class="fc">&nbsp;                    this.load = load;</b>
<b class="fc">&nbsp;                    this.arrayLoad = arrayLoad;</b>
<b class="fc">&nbsp;                    this.defaultJump = defaultJump;</b>
<b class="fc">&nbsp;                    this.nonDefaultJump = nonDefaultJump;</b>
<b class="fc">&nbsp;                    this.requiredSize = requiredSize;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a relocation handler for a given type.
&nbsp;                 *
&nbsp;                 * @param typeDefinition The type to be resolved for a relocation attempt.
&nbsp;                 * @param index          The index in the array returned by the advice method that contains the value to be checked.
&nbsp;                 * @param inverted       {@code true} if the relocation should be applied for any non-default value of a type.
&nbsp;                 * @return An appropriate relocation handler.
&nbsp;                 */
&nbsp;                protected static RelocationHandler of(TypeDefinition typeDefinition, int index, boolean inverted) {
&nbsp;                    ForValue skipDispatcher;
<b class="fc">&nbsp;                    if (typeDefinition.represents(boolean.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = BOOLEAN;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(byte.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = BYTE;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(short.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = SHORT;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(char.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = CHARACTER;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(int.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = INTEGER;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(long.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = LONG;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(float.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = FLOAT;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(double.class)) {</b>
<b class="fc">&nbsp;                        skipDispatcher = DOUBLE;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(void.class)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot skip on default value for void return type&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        skipDispatcher = REFERENCE;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return inverted</b>
<b class="fc">&nbsp;                            ? skipDispatcher.new OfNonDefault(index)</b>
<b class="fc">&nbsp;                            : skipDispatcher.new OfDefault(index);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies a value conversion prior to a applying a conditional jump.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor to use.
&nbsp;                 */
&nbsp;                protected abstract void convertValue(MethodVisitor methodVisitor);
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler that checks for a value being a default value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class OfDefault implements RelocationHandler {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the array returned by the advice method that contains the value to check for its value.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A relocation handler that checks if a value is a default value.
&nbsp;                     *
&nbsp;                     * @param index The index of the array returned by the advice method that contains the value to check for its value.
&nbsp;                     */
<b class="fc">&nbsp;                    public OfDefault(int index) {</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
<b class="fc">&nbsp;                        return new ForValue.Bound(instrumentedMethod, relocation, index, false);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A relocation handler that checks for a value being a non-default value.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class OfNonDefault implements RelocationHandler {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the array returned by the advice method that contains the value to check for its value.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A relocation handler that checks if a value is a non-default value.
&nbsp;                     *
&nbsp;                     * @param index The index of the array returned by the advice method that contains the value to check for its value.
&nbsp;                     */
<b class="fc">&nbsp;                    protected OfNonDefault(int index) {</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
<b class="fc">&nbsp;                        return new ForValue.Bound(instrumentedMethod, relocation, index, true);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound relocation handler for {@link ForValue}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class Bound implements RelocationHandler.Bound {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented method.
&nbsp;                     */
&nbsp;                    private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The relocation to apply.
&nbsp;                     */
&nbsp;                    private final Relocation relocation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The array index of the relocated value.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the relocation should be applied for any non-default value of a type.
&nbsp;                     */
&nbsp;                    private final boolean inverted;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new bound relocation handler.
&nbsp;                     *
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param relocation         The relocation to apply.
&nbsp;                     * @param index              The array index of the relocated value.
&nbsp;                     * @param inverted           {@code true} if the relocation should be applied for any non-default value of a type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Bound(MethodDescription instrumentedMethod, Relocation relocation, int index, boolean inverted) {</b>
<b class="fc">&nbsp;                        this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                        this.relocation = relocation;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
<b class="fc">&nbsp;                        this.inverted = inverted;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
<b class="fc">&nbsp;                        if (instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot skip code execution from constructor: &quot; + instrumentedMethod);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        Label noSkip = new Label();</b>
&nbsp;                        int size;
<b class="fc">&nbsp;                        if (index &lt; 0) {</b>
<b class="fc">&nbsp;                            size = requiredSize;</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(load, offset);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);</b>
<b class="fc">&nbsp;                            methodVisitor.visitJumpInsn(Opcodes.IFNULL, noSkip);</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);</b>
<b class="fc">&nbsp;                            size = Math.max(requiredSize, IntegerConstant.forValue(index)</b>
<b class="fc">&nbsp;                                    .apply(methodVisitor, implementationContext)</b>
<b class="fc">&nbsp;                                    .getMaximalSize() + 1);</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(arrayLoad);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        convertValue(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(inverted</b>
<b class="fc">&nbsp;                                ? nonDefaultJump</b>
<b class="fc">&nbsp;                                : defaultJump, noSkip);</b>
<b class="fc">&nbsp;                        relocation.apply(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(noSkip);</b>
<b class="fc">&nbsp;                        return size;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A relocation handler that is triggered if the checked value is an instance of a given type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            class ForType implements RelocationHandler {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type that triggers a relocation.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the array returned by the advice method that contains the value to check for its type.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new relocation handler that triggers a relocation if a value is an instance of a given type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type that triggers a relocation.
&nbsp;                 * @param index           The index of the array returned by the advice method that contains the value to check for its type.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForType(TypeDescription typeDescription, int index) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a relocation handler that is triggered if the checked instance is of a given type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type that triggers a relocation.
&nbsp;                 * @param index           The array index of the value that is returned.
&nbsp;                 * @param returnedType    The type that is returned by the advice method.
&nbsp;                 * @return An appropriate relocation handler.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                protected static RelocationHandler of(TypeDescription typeDescription, int index, TypeDefinition returnedType) {
&nbsp;                    TypeDefinition targetType;
<b class="fc">&nbsp;                    if (index &lt; 0) {</b>
<b class="fc">&nbsp;                        targetType = returnedType;</b>
<b class="fc">&nbsp;                    } else if (returnedType.isArray()) {</b>
<b class="fc">&nbsp;                        targetType = returnedType.getComponentType();</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        throw new IllegalStateException(returnedType + &quot; is not an array type but an index for a relocation is defined&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    if (typeDescription.represents(void.class)) {</b>
<b class="fc">&nbsp;                        return Disabled.INSTANCE;</b>
<b class="fc">&nbsp;                    } else if (typeDescription.represents(OnDefaultValue.class)) {</b>
<b class="fc">&nbsp;                        return ForValue.of(targetType, index, false);</b>
<b class="fc">&nbsp;                    } else if (typeDescription.represents(OnNonDefaultValue.class)) {</b>
<b class="fc">&nbsp;                        return ForValue.of(targetType, index, true);</b>
<b class="fc">&nbsp;                    } else if (typeDescription.isPrimitive() || targetType.isPrimitive()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot relocate execution by instance type for primitive type&quot;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new ForType(typeDescription, index);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RelocationHandler.Bound bind(MethodDescription instrumentedMethod, Relocation relocation) {
<b class="fc">&nbsp;                    return new Bound(instrumentedMethod, relocation);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound relocation handler for {@link ForType}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                protected class Bound implements RelocationHandler.Bound {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented method.
&nbsp;                     */
&nbsp;                    private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The relocation to use.
&nbsp;                     */
&nbsp;                    private final Relocation relocation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new bound relocation handler.
&nbsp;                     *
&nbsp;                     * @param instrumentedMethod The instrumented method.
&nbsp;                     * @param relocation         The relocation to apply.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Bound(MethodDescription instrumentedMethod, Relocation relocation) {</b>
<b class="fc">&nbsp;                        this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                        this.relocation = relocation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, int offset) {
<b class="fc">&nbsp;                        if (instrumentedMethod.isConstructor()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot skip code execution from constructor: &quot; + instrumentedMethod);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);</b>
<b class="fc">&nbsp;                        Label noSkip = new Label();</b>
&nbsp;                        int size;
<b class="fc">&nbsp;                        if (index &lt; 0) {</b>
<b class="fc">&nbsp;                            size = NO_REQUIRED_SIZE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            methodVisitor.visitJumpInsn(Opcodes.IFNULL, noSkip);</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);</b>
<b class="fc">&nbsp;                            size = IntegerConstant.forValue(index)</b>
<b class="fc">&nbsp;                                    .apply(methodVisitor, implementationContext)</b>
<b class="fc">&nbsp;                                    .getMaximalSize() + 1;</b>
<b class="fc">&nbsp;                            methodVisitor.visitInsn(Opcodes.AALOAD);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, typeDescription.getInternalName());</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, noSkip);</b>
<b class="fc">&nbsp;                        relocation.apply(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitLabel(noSkip);</b>
<b class="fc">&nbsp;                        return size;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a resolved dispatcher.
&nbsp;         */
&nbsp;        interface Resolved extends Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the named types defined by this advice.
&nbsp;             *
&nbsp;             * @return The named types defined by this advice.
&nbsp;             */
&nbsp;            Map&lt;String, TypeDefinition&gt; getNamedTypes();
&nbsp;
&nbsp;            /**
&nbsp;             * Binds this dispatcher for resolution to a specific method.
&nbsp;             *
&nbsp;             * @param instrumentedType      The instrumented type.
&nbsp;             * @param instrumentedMethod    The instrumented method.
&nbsp;             * @param methodVisitor         The method visitor for writing the instrumented method.
&nbsp;             * @param implementationContext The implementation context to use.
&nbsp;             * @param assigner              The assigner to use.
&nbsp;             * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;             * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;             * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;             * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;             * @param relocation            A relocation to use with a relocation handler.
&nbsp;             * @return A dispatcher that is bound to the instrumented method.
&nbsp;             */
&nbsp;            Bound bind(TypeDescription instrumentedType,
&nbsp;                       MethodDescription instrumentedMethod,
&nbsp;                       MethodVisitor methodVisitor,
&nbsp;                       Implementation.Context implementationContext,
&nbsp;                       Assigner assigner,
&nbsp;                       ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                       MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                       StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                       StackManipulation exceptionHandler,
&nbsp;                       RelocationHandler.Relocation relocation);
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a resolved dispatcher for entering a method.
&nbsp;             */
&nbsp;            interface ForMethodEnter extends Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns {@code true} if the first discovered line number information should be prepended to the advice code.
&nbsp;                 *
&nbsp;                 * @return {@code true} if the first discovered line number information should be prepended to the advice code.
&nbsp;                 */
&nbsp;                boolean isPrependLineNumber();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the actual advice type, even if it is not required post advice processing.
&nbsp;                 *
&nbsp;                 * @return The actual advice type, even if it is not required post advice processing.
&nbsp;                 */
&nbsp;                TypeDefinition getActualAdviceType();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a resolved dispatcher for exiting a method.
&nbsp;             */
&nbsp;            interface ForMethodExit extends Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the type of throwable for which this exit advice is supposed to be invoked.
&nbsp;                 *
&nbsp;                 * @return The {@link Throwable} type for which to invoke this exit advice or a description of {@link NoExceptionHandler}
&nbsp;                 * if this exit advice does not expect to be invoked upon any throwable.
&nbsp;                 */
&nbsp;                TypeDescription getThrowable();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a factory for creating an {@link ArgumentHandler}.
&nbsp;                 *
&nbsp;                 * @return A factory for creating an {@link ArgumentHandler}.
&nbsp;                 */
&nbsp;                ArgumentHandler.Factory getArgumentHandlerFactory();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract base implementation of a {@link Resolved} dispatcher.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            abstract class AbstractBase implements Resolved {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented advice method.
&nbsp;                 */
&nbsp;                protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The post processor to apply.
&nbsp;                 */
&nbsp;                protected final PostProcessor postProcessor;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping from offset to a mapping for this offset with retained iteration order of the method&#39;s parameters.
&nbsp;                 */
&nbsp;                protected final Map&lt;Integer, OffsetMapping&gt; offsetMappings;
&nbsp;
&nbsp;                /**
&nbsp;                 * The suppression handler to use.
&nbsp;                 */
&nbsp;                protected final SuppressionHandler suppressionHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * The relocation handler to use.
&nbsp;                 */
&nbsp;                protected final RelocationHandler relocationHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resolved version of a dispatcher.
&nbsp;                 *
&nbsp;                 * @param adviceMethod     The represented advice method.
&nbsp;                 * @param postProcessor    The post processor to use.
&nbsp;                 * @param factories        A list of factories to resolve for the parameters of the advice method.
&nbsp;                 * @param throwableType    The type to handle by a suppression handler or {@link NoExceptionHandler} to not handle any exceptions.
&nbsp;                 * @param relocatableType  The type to trigger a relocation of the method&#39;s control flow or {@code void} if no relocation should be executed.
&nbsp;                 * @param relocatableIndex The index within an array that is returned by the advice method, indicating the value to consider for relocation.
&nbsp;                 * @param adviceType       The applied advice type.
&nbsp;                 */
&nbsp;                protected AbstractBase(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                       PostProcessor postProcessor,
&nbsp;                                       List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories,
&nbsp;                                       TypeDescription throwableType,
&nbsp;                                       TypeDescription relocatableType,
&nbsp;                                       int relocatableIndex,
<b class="fc">&nbsp;                                       OffsetMapping.Factory.AdviceType adviceType) {</b>
<b class="fc">&nbsp;                    this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                    this.postProcessor = postProcessor;</b>
<b class="fc">&nbsp;                    Map&lt;TypeDescription, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings = new HashMap&lt;TypeDescription, OffsetMapping.Factory&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                    for (OffsetMapping.Factory&lt;?&gt; factory : factories) {</b>
<b class="fc">&nbsp;                        offsetMappings.put(TypeDescription.ForLoadedType.of(factory.getAnnotationType()), factory);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    this.offsetMappings = new LinkedHashMap&lt;Integer, OffsetMapping&gt;();</b>
<b class="fc">&nbsp;                    for (ParameterDescription.InDefinedShape parameterDescription : adviceMethod.getParameters()) {</b>
<b class="fc">&nbsp;                        OffsetMapping offsetMapping = null;</b>
<b class="fc">&nbsp;                        for (AnnotationDescription annotationDescription : parameterDescription.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                            OffsetMapping.Factory&lt;?&gt; factory = offsetMappings.get(annotationDescription.getAnnotationType());</b>
<b class="fc">&nbsp;                            if (factory != null) {</b>
&nbsp;                                @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;                                OffsetMapping current = factory.make(parameterDescription,</b>
<b class="fc">&nbsp;                                        (AnnotationDescription.Loadable) annotationDescription.prepare(factory.getAnnotationType()),</b>
&nbsp;                                        adviceType);
<b class="fc">&nbsp;                                if (offsetMapping == null) {</b>
<b class="fc">&nbsp;                                    offsetMapping = current;</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    throw new IllegalStateException(parameterDescription + &quot; is bound to both &quot; + current + &quot; and &quot; + offsetMapping);</b>
&nbsp;                                }
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        this.offsetMappings.put(parameterDescription.getOffset(), offsetMapping == null</b>
<b class="fc">&nbsp;                                ? new OffsetMapping.ForArgument.Unresolved(parameterDescription)</b>
<b class="fc">&nbsp;                                : offsetMapping);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    suppressionHandler = SuppressionHandler.Suppressing.of(throwableType);</b>
<b class="fc">&nbsp;                    relocationHandler = RelocationHandler.ForType.of(relocatableType, relocatableIndex, adviceMethod.getReturnType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAlive() {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A bound resolution of an advice method.
&nbsp;         */
&nbsp;        interface Bound {
&nbsp;
&nbsp;            /**
&nbsp;             * Prepares the advice method&#39;s exception handlers.
&nbsp;             */
&nbsp;            void prepare();
&nbsp;
&nbsp;            /**
&nbsp;             * Initialized the advice&#39;s methods local variables.
&nbsp;             */
&nbsp;            void initialize();
&nbsp;
&nbsp;            /**
&nbsp;             * Applies this dispatcher.
&nbsp;             */
&nbsp;            void apply();
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An implementation for inactive devise that does not write any byte code.
&nbsp;         */
<b class="fc">&nbsp;        enum Inactive implements Dispatcher.Unresolved, Resolved.ForMethodEnter, Resolved.ForMethodExit, Bound {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The singleton instance.
&nbsp;             */
<b class="fc">&nbsp;            INSTANCE;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isAlive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isBinary() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getAdviceType() {
<b class="fc">&nbsp;                return TypeDescription.ForLoadedType.of(void.class);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrependLineNumber() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDefinition getActualAdviceType() {
<b class="fc">&nbsp;                return TypeDescription.ForLoadedType.of(void.class);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="fc">&nbsp;                return Collections.emptyMap();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getThrowable() {
<b class="nc">&nbsp;                return NoExceptionHandler.DESCRIPTION;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ArgumentHandler.Factory getArgumentHandlerFactory() {
<b class="fc">&nbsp;                return ArgumentHandler.Factory.SIMPLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                         @MaybeNull ClassReader classReader,
&nbsp;                                                         Unresolved methodExit,
&nbsp;                                                         PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                       @MaybeNull ClassReader classReader,
&nbsp;                                                       Unresolved methodEnter,
&nbsp;                                                       PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void prepare() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void initialize() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void apply() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Bound bind(TypeDescription instrumentedType,
&nbsp;                              MethodDescription instrumentedMethod,
&nbsp;                              MethodVisitor methodVisitor,
&nbsp;                              Implementation.Context implementationContext,
&nbsp;                              Assigner assigner,
&nbsp;                              ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                              MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                              StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                              StackManipulation exceptionHandler,
&nbsp;                              RelocationHandler.Relocation relocation) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for an advice method that is being inlined into the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Inlining implements Unresolved {
&nbsp;
&nbsp;            /**
&nbsp;             * The advice method.
&nbsp;             */
&nbsp;            protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of all available local variables by their name to their type.
&nbsp;             */
&nbsp;            private final Map&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a dispatcher for inlined advice method.
&nbsp;             *
&nbsp;             * @param adviceMethod The advice method.
&nbsp;             */
<b class="fc">&nbsp;            protected Inlining(MethodDescription.InDefinedShape adviceMethod) {</b>
<b class="fc">&nbsp;                this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                namedTypes = new HashMap&lt;String, TypeDefinition&gt;();</b>
<b class="fc">&nbsp;                for (ParameterDescription parameterDescription : adviceMethod.getParameters()) {</b>
<b class="fc">&nbsp;                    AnnotationDescription.Loadable&lt;Local&gt; annotationDescription = parameterDescription.getDeclaredAnnotations().ofType(Local.class);</b>
<b class="fc">&nbsp;                    if (annotationDescription != null) {</b>
<b class="fc">&nbsp;                        String name = annotationDescription.getValue(OffsetMapping.ForLocalValue.Factory.LOCAL_VALUE).resolve(String.class);</b>
<b class="fc">&nbsp;                        TypeDefinition previous = namedTypes.put(name, parameterDescription.getType());</b>
<b class="fc">&nbsp;                        if (previous != null &amp;&amp; !previous.equals(parameterDescription.getType())) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Local variable for &quot; + name + &quot; is defined with inconsistent types&quot;);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isAlive() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isBinary() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getAdviceType() {
<b class="fc">&nbsp;                return adviceMethod.getReturnType().asErasure();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="fc">&nbsp;                return namedTypes;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Dispatcher.Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                                    @MaybeNull ClassReader classReader,
&nbsp;                                                                    Unresolved methodExit,
&nbsp;                                                                    PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;                if (classReader == null) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Class reader not expected null&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return Resolved.ForMethodEnter.of(adviceMethod,</b>
<b class="fc">&nbsp;                        postProcessorFactory.make(adviceMethod, false),</b>
&nbsp;                        namedTypes,
&nbsp;                        userFactories,
<b class="fc">&nbsp;                        methodExit.getAdviceType(),</b>
&nbsp;                        classReader,
<b class="fc">&nbsp;                        methodExit.isAlive());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Dispatcher.Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                                  @MaybeNull ClassReader classReader,
&nbsp;                                                                  Unresolved methodEnter,
&nbsp;                                                                  PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;                Map&lt;String, TypeDefinition&gt; namedTypes = new HashMap&lt;String, TypeDefinition&gt;(methodEnter.getNamedTypes()), uninitializedNamedTypes = new HashMap&lt;String, TypeDefinition&gt;();</b>
<b class="fc">&nbsp;                for (Map.Entry&lt;String, TypeDefinition&gt; entry : this.namedTypes.entrySet()) {</b>
<b class="fc">&nbsp;                    TypeDefinition typeDefinition = namedTypes.get(entry.getKey()), uninitializedTypeDefinition = uninitializedNamedTypes.get(entry.getKey());</b>
<b class="fc">&nbsp;                    if (typeDefinition == null &amp;&amp; uninitializedTypeDefinition == null) {</b>
<b class="fc">&nbsp;                        namedTypes.put(entry.getKey(), entry.getValue());</b>
<b class="fc">&nbsp;                        uninitializedNamedTypes.put(entry.getKey(), entry.getValue());</b>
<b class="fc">&nbsp;                    } else if (!(typeDefinition == null ? uninitializedTypeDefinition : typeDefinition).equals(entry.getValue())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Local variable for &quot; + entry.getKey() + &quot; is defined with inconsistent types&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return Resolved.ForMethodExit.of(adviceMethod, postProcessorFactory.make(adviceMethod, true), namedTypes, uninitializedNamedTypes, userFactories, classReader,</b>
<b class="fc">&nbsp;                        methodEnter.getAdviceType());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return &quot;Delegate to &quot; + adviceMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved version of a dispatcher.
&nbsp;             */
&nbsp;            protected abstract static class Resolved extends Dispatcher.Resolved.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * A class reader to query for the class file of the advice method.
&nbsp;                 */
&nbsp;                protected final ClassReader classReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resolved version of a dispatcher.
&nbsp;                 *
&nbsp;                 * @param adviceMethod     The represented advice method.
&nbsp;                 * @param postProcessor    The post processor to apply.
&nbsp;                 * @param factories        A list of factories to resolve for the parameters of the advice method.
&nbsp;                 * @param throwableType    The type to handle by a suppression handler or {@link NoExceptionHandler} to not handle any exceptions.
&nbsp;                 * @param relocatableType  The type to trigger a relocation of the method&#39;s control flow or {@code void} if no relocation should be executed.
&nbsp;                 * @param relocatableIndex The index within an array that is returned by the advice method, indicating the value to consider for relocation.
&nbsp;                 * @param classReader      A class reader to query for the class file of the advice method.
&nbsp;                 */
&nbsp;                protected Resolved(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                   PostProcessor postProcessor,
&nbsp;                                   List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories,
&nbsp;                                   TypeDescription throwableType,
&nbsp;                                   TypeDescription relocatableType,
&nbsp;                                   int relocatableIndex,
&nbsp;                                   ClassReader classReader) {
<b class="fc">&nbsp;                    super(adviceMethod, postProcessor, factories, throwableType, relocatableType, relocatableIndex, OffsetMapping.Factory.AdviceType.INLINING);</b>
<b class="fc">&nbsp;                    this.classReader = classReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves the initialization types of this advice method.
&nbsp;                 *
&nbsp;                 * @param argumentHandler The argument handler to use for resolving the initialization.
&nbsp;                 * @return A mapping of parameter offsets to the type to initialize.
&nbsp;                 */
&nbsp;                protected abstract Map&lt;Integer, TypeDefinition&gt; resolveInitializationTypes(ArgumentHandler argumentHandler);
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies a resolution for a given instrumented method.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         A method visitor for writing byte code to the instrumented method.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param assigner              The assigner to use.
&nbsp;                 * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                 * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                 * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                 * @param instrumentedType      A description of the instrumented type.
&nbsp;                 * @param instrumentedMethod    A description of the instrumented method.
&nbsp;                 * @param suppressionHandler    A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                 * @param relocationHandler     A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                 * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                 * @return A method visitor for visiting the advice method&#39;s byte code.
&nbsp;                 */
&nbsp;                protected abstract MethodVisitor apply(MethodVisitor methodVisitor,
&nbsp;                                                       Implementation.Context implementationContext,
&nbsp;                                                       Assigner assigner,
&nbsp;                                                       ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                                       MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                                       StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                                       TypeDescription instrumentedType,
&nbsp;                                                       MethodDescription instrumentedMethod,
&nbsp;                                                       SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                       RelocationHandler.Bound relocationHandler,
&nbsp;                                                       StackManipulation exceptionHandler);
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound advice method that copies the code by first extracting the exception table and later appending the
&nbsp;                 * code of the method without copying any meta data.
&nbsp;                 */
&nbsp;                protected class AdviceMethodInliner extends ClassVisitor implements Bound {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the instrumented type.
&nbsp;                     */
&nbsp;                    protected final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented method.
&nbsp;                     */
&nbsp;                    protected final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method visitor for writing the instrumented method.
&nbsp;                     */
&nbsp;                    protected final MethodVisitor methodVisitor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implementation context to use.
&nbsp;                     */
&nbsp;                    protected final Implementation.Context implementationContext;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The assigner to use.
&nbsp;                     */
&nbsp;                    protected final Assigner assigner;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handler for accessing values on the local variable array.
&nbsp;                     */
&nbsp;                    protected final ArgumentHandler.ForInstrumentedMethod argumentHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handler for computing the method size requirements.
&nbsp;                     */
&nbsp;                    protected final MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handler for translating and injecting stack map frames.
&nbsp;                     */
&nbsp;                    protected final StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                     */
&nbsp;                    protected final SuppressionHandler.Bound suppressionHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                     */
&nbsp;                    protected final RelocationHandler.Bound relocationHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The exception handler that is resolved for the instrumented method.
&nbsp;                     */
&nbsp;                    protected final StackManipulation exceptionHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A class reader for parsing the class file containing the represented advice method.
&nbsp;                     */
&nbsp;                    protected final ClassReader classReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The labels that were found during parsing the method&#39;s exception handler in the order of their discovery.
&nbsp;                     */
&nbsp;                    protected final List&lt;Label&gt; labels;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new advice method inliner.
&nbsp;                     *
&nbsp;                     * @param instrumentedType      A description of the instrumented type.
&nbsp;                     * @param instrumentedMethod    The instrumented method.
&nbsp;                     * @param methodVisitor         The method visitor for writing the instrumented method.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     * @param assigner              The assigner to use.
&nbsp;                     * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                     * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                     * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                     * @param suppressionHandler    A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                     * @param relocationHandler     A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                     * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                     * @param classReader           A class reader for parsing the class file containing the represented advice method.
&nbsp;                     */
&nbsp;                    protected AdviceMethodInliner(TypeDescription instrumentedType,
&nbsp;                                                  MethodDescription instrumentedMethod,
&nbsp;                                                  MethodVisitor methodVisitor,
&nbsp;                                                  Implementation.Context implementationContext,
&nbsp;                                                  Assigner assigner,
&nbsp;                                                  ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                                  MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                                  StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                                  SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                  RelocationHandler.Bound relocationHandler,
&nbsp;                                                  StackManipulation exceptionHandler,
<b class="fc">&nbsp;                                                  ClassReader classReader) {</b>
<b class="fc">&nbsp;                        super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                        this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                        this.methodVisitor = methodVisitor;</b>
<b class="fc">&nbsp;                        this.implementationContext = implementationContext;</b>
<b class="fc">&nbsp;                        this.assigner = assigner;</b>
<b class="fc">&nbsp;                        this.argumentHandler = argumentHandler;</b>
<b class="fc">&nbsp;                        this.methodSizeHandler = methodSizeHandler;</b>
<b class="fc">&nbsp;                        this.stackMapFrameHandler = stackMapFrameHandler;</b>
<b class="fc">&nbsp;                        this.suppressionHandler = suppressionHandler;</b>
<b class="fc">&nbsp;                        this.relocationHandler = relocationHandler;</b>
<b class="fc">&nbsp;                        this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;                        this.classReader = classReader;</b>
<b class="fc">&nbsp;                        labels = new ArrayList&lt;Label&gt;();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void prepare() {
<b class="fc">&nbsp;                        classReader.accept(new ExceptionTableExtractor(), ClassReader.SKIP_FRAMES | ClassReader.SKIP_DEBUG);</b>
<b class="fc">&nbsp;                        suppressionHandler.onPrepare(methodVisitor);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void initialize() {
<b class="fc">&nbsp;                        for (Map.Entry&lt;Integer, TypeDefinition&gt; typeDefinition : resolveInitializationTypes(argumentHandler).entrySet()) {</b>
<b class="fc">&nbsp;                            if (typeDefinition.getValue().represents(boolean.class)</b>
<b class="fc">&nbsp;                                    || typeDefinition.getValue().represents(byte.class)</b>
<b class="fc">&nbsp;                                    || typeDefinition.getValue().represents(short.class)</b>
<b class="fc">&nbsp;                                    || typeDefinition.getValue().represents(char.class)</b>
<b class="fc">&nbsp;                                    || typeDefinition.getValue().represents(int.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.ISTORE, typeDefinition.getKey());</b>
<b class="fc">&nbsp;                            } else if (typeDefinition.getValue().represents(long.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.LSTORE, typeDefinition.getKey());</b>
<b class="fc">&nbsp;                            } else if (typeDefinition.getValue().represents(float.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.FSTORE, typeDefinition.getKey());</b>
<b class="fc">&nbsp;                            } else if (typeDefinition.getValue().represents(double.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.DSTORE, typeDefinition.getKey());</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.ASTORE, typeDefinition.getKey());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            methodSizeHandler.requireStackSize(typeDefinition.getValue().getStackSize().getSize());</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply() {
<b class="fc">&nbsp;                        classReader.accept(this, ClassReader.SKIP_DEBUG | stackMapFrameHandler.getReaderHint());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @MaybeNull
&nbsp;                    public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
<b class="fc">&nbsp;                        return adviceMethod.getInternalName().equals(internalName) &amp;&amp; adviceMethod.getDescriptor().equals(descriptor)</b>
<b class="fc">&nbsp;                                ? new ExceptionTableSubstitutor(Inlining.Resolved.this.apply(methodVisitor,</b>
&nbsp;                                implementationContext,
&nbsp;                                assigner,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
<b class="fc">&nbsp;                                exceptionHandler)) : IGNORE_METHOD;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A class visitor that extracts the exception tables of the advice method.
&nbsp;                     */
&nbsp;                    protected class ExceptionTableExtractor extends ClassVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new exception table extractor.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ExceptionTableExtractor() {</b>
<b class="fc">&nbsp;                            super(OpenedClassReader.ASM_API);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public MethodVisitor visitMethod(int modifiers, String internalName, String descriptor, @MaybeNull String signature, @MaybeNull String[] exception) {
<b class="fc">&nbsp;                            return adviceMethod.getInternalName().equals(internalName) &amp;&amp; adviceMethod.getDescriptor().equals(descriptor)</b>
<b class="fc">&nbsp;                                    ? new ExceptionTableCollector(methodVisitor)</b>
<b class="fc">&nbsp;                                    : IGNORE_METHOD;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A visitor that only writes try-catch-finally blocks to the supplied method visitor. All labels of these tables are collected
&nbsp;                     * for substitution when revisiting the reminder of the method.
&nbsp;                     */
&nbsp;                    protected class ExceptionTableCollector extends MethodVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The method visitor for which the try-catch-finally blocks should be written.
&nbsp;                         */
&nbsp;                        private final MethodVisitor methodVisitor;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new exception table collector.
&nbsp;                         *
&nbsp;                         * @param methodVisitor The method visitor for which the try-catch-finally blocks should be written.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ExceptionTableCollector(MethodVisitor methodVisitor) {</b>
<b class="fc">&nbsp;                            super(OpenedClassReader.ASM_API);</b>
<b class="fc">&nbsp;                            this.methodVisitor = methodVisitor;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitTryCatchBlock(Label start, Label end, Label handler, @MaybeNull String type) {
<b class="fc">&nbsp;                            methodVisitor.visitTryCatchBlock(start, end, handler, type);</b>
<b class="fc">&nbsp;                            labels.addAll(Arrays.asList(start, end, handler));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitTryCatchAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return methodVisitor.visitTryCatchAnnotation(typeReference, typePath, descriptor, visible);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A label substitutor allows to visit an advice method a second time after the exception handlers were already written.
&nbsp;                     * Doing so, this visitor substitutes all labels that were already created during the first visit to keep the mapping
&nbsp;                     * consistent. It is not required to resolve labels for non-code instructions as meta information is not propagated to
&nbsp;                     * the target method visitor for advice code.
&nbsp;                     */
&nbsp;                    protected class ExceptionTableSubstitutor extends MethodVisitor {
&nbsp;
&nbsp;                        /**
&nbsp;                         * A map containing resolved substitutions.
&nbsp;                         */
&nbsp;                        private final Map&lt;Label, Label&gt; substitutions;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The current index of the visited labels that are used for try-catch-finally blocks.
&nbsp;                         */
&nbsp;                        private int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a label substitutor.
&nbsp;                         *
&nbsp;                         * @param methodVisitor The method visitor for which to substitute labels.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ExceptionTableSubstitutor(MethodVisitor methodVisitor) {</b>
<b class="fc">&nbsp;                            super(OpenedClassReader.ASM_API, methodVisitor);</b>
<b class="fc">&nbsp;                            substitutions = new IdentityHashMap&lt;Label, Label&gt;();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitTryCatchBlock(Label start, Label end, Label handler, String type) {
<b class="fc">&nbsp;                            substitutions.put(start, labels.get(index++));</b>
<b class="fc">&nbsp;                            substitutions.put(end, labels.get(index++));</b>
<b class="fc">&nbsp;                            Label actualHandler = labels.get(index++);</b>
<b class="fc">&nbsp;                            substitutions.put(handler, actualHandler);</b>
<b class="fc">&nbsp;                            ((CodeTranslationVisitor) mv).propagateHandler(actualHandler);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        @MaybeNull
&nbsp;                        public AnnotationVisitor visitTryCatchAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                            return IGNORE_ANNOTATION;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitLabel(Label label) {
<b class="fc">&nbsp;                            super.visitLabel(resolve(label));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitJumpInsn(int opcode, Label label) {
<b class="fc">&nbsp;                            super.visitJumpInsn(opcode, resolve(label));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitTableSwitchInsn(int minimum, int maximum, Label defaultOption, Label... label) {
<b class="nc">&nbsp;                            super.visitTableSwitchInsn(minimum, maximum, defaultOption, resolve(label));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        public void visitLookupSwitchInsn(Label defaultOption, int[] keys, Label[] label) {
<b class="nc">&nbsp;                            super.visitLookupSwitchInsn(resolve(defaultOption), keys, resolve(label));</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves an array of labels.
&nbsp;                         *
&nbsp;                         * @param label The labels to resolved.
&nbsp;                         * @return An array containing the resolved arrays.
&nbsp;                         */
&nbsp;                        private Label[] resolve(Label[] label) {
<b class="nc">&nbsp;                            Label[] resolved = new Label[label.length];</b>
<b class="nc">&nbsp;                            int index = 0;</b>
<b class="nc">&nbsp;                            for (Label aLabel : label) {</b>
<b class="nc">&nbsp;                                resolved[index++] = resolve(aLabel);</b>
&nbsp;                            }
<b class="nc">&nbsp;                            return resolved;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves a single label if mapped or returns the original label.
&nbsp;                         *
&nbsp;                         * @param label The label to resolve.
&nbsp;                         * @return The resolved label.
&nbsp;                         */
&nbsp;                        private Label resolve(Label label) {
<b class="fc">&nbsp;                            Label substitution = substitutions.get(label);</b>
<b class="fc">&nbsp;                            return substitution == null</b>
<b class="fc">&nbsp;                                    ? label</b>
<b class="fc">&nbsp;                                    : substitution;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved dispatcher for implementing method enter advice.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class ForMethodEnter extends Inlining.Resolved implements Dispatcher.Resolved.ForMethodEnter {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of all available local variables by their name to their type.
&nbsp;                     */
&nbsp;                    private final Map&lt;String, TypeDefinition&gt; namedTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the first discovered line number information should be prepended to the advice code.
&nbsp;                     */
&nbsp;                    private final boolean prependLineNumber;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved dispatcher for implementing method enter advice.
&nbsp;                     *
&nbsp;                     * @param adviceMethod  The represented advice method.
&nbsp;                     * @param postProcessor The post processor to apply.
&nbsp;                     * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                     * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                     * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param classReader   A class reader to query for the class file of the advice method.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                             PostProcessor postProcessor,
&nbsp;                                             Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                             List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                             TypeDefinition exitType,
&nbsp;                                             ClassReader classReader) {
<b class="fc">&nbsp;                        super(adviceMethod,</b>
&nbsp;                                postProcessor,
<b class="fc">&nbsp;                                CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE,</b>
&nbsp;                                        OffsetMapping.ForAllArguments.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForThisReference.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForField.Unresolved.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForOrigin.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForSelfCallHandle.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForUnusedValue.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForStubValue.INSTANCE,
&nbsp;                                        OffsetMapping.ForThrowable.Factory.INSTANCE,
<b class="fc">&nbsp;                                        OffsetMapping.ForExitValue.Factory.of(exitType),</b>
&nbsp;                                        new OffsetMapping.ForLocalValue.Factory(namedTypes),
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Thrown&gt;(Thrown.class),
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Enter&gt;(Enter.class),
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Return&gt;(Return.class)), userFactories),
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SUPPRESS_ENTER).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON_INDEX).resolve(Integer.class),</b>
&nbsp;                                classReader);
<b class="fc">&nbsp;                        this.namedTypes = namedTypes;</b>
<b class="fc">&nbsp;                        prependLineNumber = adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(PREPEND_LINE_NUMBER).resolve(Boolean.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves enter advice that only exposes the enter type if this is necessary.
&nbsp;                     *
&nbsp;                     * @param adviceMethod  The advice method.
&nbsp;                     * @param postProcessor The post processor to apply.
&nbsp;                     * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                     * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                     * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param classReader   The class reader for parsing the advice method&#39;s class file.
&nbsp;                     * @param methodExit    {@code true} if exit advice is applied.
&nbsp;                     * @return An appropriate enter handler.
&nbsp;                     */
&nbsp;                    protected static Resolved.ForMethodEnter of(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                                PostProcessor postProcessor,
&nbsp;                                                                Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                                List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                                TypeDefinition exitType,
&nbsp;                                                                ClassReader classReader,
&nbsp;                                                                boolean methodExit) {
<b class="fc">&nbsp;                        return methodExit</b>
<b class="fc">&nbsp;                                ? new WithRetainedEnterType(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader)</b>
<b class="fc">&nbsp;                                : new WithDiscardedEnterType(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Map&lt;Integer, TypeDefinition&gt; resolveInitializationTypes(ArgumentHandler argumentHandler) {
<b class="fc">&nbsp;                        SortedMap&lt;Integer, TypeDefinition&gt; resolved = new TreeMap&lt;Integer, TypeDefinition&gt;();</b>
<b class="fc">&nbsp;                        for (Map.Entry&lt;String, TypeDefinition&gt; entry : namedTypes.entrySet()) {</b>
<b class="fc">&nbsp;                            resolved.put(argumentHandler.named(entry.getKey()), entry.getValue());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return resolved;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Bound bind(TypeDescription instrumentedType,
&nbsp;                                      MethodDescription instrumentedMethod,
&nbsp;                                      MethodVisitor methodVisitor,
&nbsp;                                      Implementation.Context implementationContext,
&nbsp;                                      Assigner assigner,
&nbsp;                                      ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                      MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                      StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                      StackManipulation exceptionHandler,
&nbsp;                                      RelocationHandler.Relocation relocation) {
<b class="fc">&nbsp;                        return new AdviceMethodInliner(instrumentedType,</b>
&nbsp;                                instrumentedMethod,
&nbsp;                                methodVisitor,
&nbsp;                                implementationContext,
&nbsp;                                assigner,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
<b class="fc">&nbsp;                                suppressionHandler.bind(exceptionHandler),</b>
<b class="fc">&nbsp;                                relocationHandler.bind(instrumentedMethod, relocation),</b>
&nbsp;                                exceptionHandler,
&nbsp;                                classReader);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrependLineNumber() {
<b class="fc">&nbsp;                        return prependLineNumber;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDefinition getActualAdviceType() {
<b class="fc">&nbsp;                        return adviceMethod.getReturnType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="fc">&nbsp;                        return namedTypes;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected MethodVisitor apply(MethodVisitor methodVisitor,
&nbsp;                                                  Context implementationContext,
&nbsp;                                                  Assigner assigner,
&nbsp;                                                  ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                                  MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                                  StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                                  TypeDescription instrumentedType,
&nbsp;                                                  MethodDescription instrumentedMethod,
&nbsp;                                                  SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                  RelocationHandler.Bound relocationHandler,
&nbsp;                                                  StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                        return doApply(methodVisitor,</b>
&nbsp;                                implementationContext,
&nbsp;                                assigner,
<b class="fc">&nbsp;                                argumentHandler.bindEnter(adviceMethod),</b>
<b class="fc">&nbsp;                                methodSizeHandler.bindEnter(adviceMethod),</b>
<b class="fc">&nbsp;                                stackMapFrameHandler.bindEnter(adviceMethod),</b>
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
&nbsp;                                exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Applies a resolution for a given instrumented method.
&nbsp;                     *
&nbsp;                     * @param instrumentedType      A description of the instrumented type.
&nbsp;                     * @param instrumentedMethod    The instrumented method that is being bound.
&nbsp;                     * @param methodVisitor         The method visitor for writing to the instrumented method.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     * @param assigner              The assigner to use.
&nbsp;                     * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                     * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                     * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                     * @param suppressionHandler    The bound suppression handler to use.
&nbsp;                     * @param relocationHandler     The bound relocation handler to use.
&nbsp;                     * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                     * @return A method visitor for visiting the advice method&#39;s byte code.
&nbsp;                     */
&nbsp;                    protected MethodVisitor doApply(MethodVisitor methodVisitor,
&nbsp;                                                    Implementation.Context implementationContext,
&nbsp;                                                    Assigner assigner,
&nbsp;                                                    ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                    MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                    StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                    TypeDescription instrumentedType,
&nbsp;                                                    MethodDescription instrumentedMethod,
&nbsp;                                                    SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                    RelocationHandler.Bound relocationHandler,
&nbsp;                                                    StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                        Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings = new HashMap&lt;Integer, OffsetMapping.Target&gt;();</b>
<b class="fc">&nbsp;                        for (Map.Entry&lt;Integer, OffsetMapping&gt; entry : this.offsetMappings.entrySet()) {</b>
<b class="fc">&nbsp;                            offsetMappings.put(entry.getKey(), entry.getValue().resolve(instrumentedType,</b>
&nbsp;                                    instrumentedMethod,
&nbsp;                                    assigner,
&nbsp;                                    argumentHandler,
&nbsp;                                    OffsetMapping.Sort.ENTER));
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new CodeTranslationVisitor(methodVisitor,</b>
&nbsp;                                implementationContext,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                assigner,
&nbsp;                                adviceMethod,
&nbsp;                                offsetMappings,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
&nbsp;                                exceptionHandler,
&nbsp;                                postProcessor,
&nbsp;                                false);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of an advice that does expose an enter type.
&nbsp;                     */
&nbsp;                    protected static class WithRetainedEnterType extends Inlining.Resolved.ForMethodEnter {
&nbsp;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method enter advice that does expose the enter type.
&nbsp;                         *
&nbsp;                         * @param adviceMethod  The represented advice method.
&nbsp;                         * @param postProcessor The post processor to apply.
&nbsp;                         * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                         * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                         * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                         * @param classReader   A class reader to query for the class file of the advice method.
&nbsp;                         */
&nbsp;                        protected WithRetainedEnterType(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                        PostProcessor postProcessor,
&nbsp;                                                        Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                        List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                        TypeDefinition exitType,
&nbsp;                                                        ClassReader classReader) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDefinition getAdviceType() {
<b class="fc">&nbsp;                            return adviceMethod.getReturnType();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of an advice that does not expose an enter type.
&nbsp;                     */
&nbsp;                    protected static class WithDiscardedEnterType extends Inlining.Resolved.ForMethodEnter {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method enter advice that does not expose the enter type.
&nbsp;                         *
&nbsp;                         * @param adviceMethod  The represented advice method.
&nbsp;                         * @param postProcessor The post processor to apply.
&nbsp;                         * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                         * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                         * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                         * @param classReader   A class reader to query for the class file of the advice method.
&nbsp;                         */
&nbsp;                        protected WithDiscardedEnterType(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                         PostProcessor postProcessor,
&nbsp;                                                         Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                         List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                         TypeDefinition exitType,
&nbsp;                                                         ClassReader classReader) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, exitType, classReader);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDefinition getAdviceType() {
<b class="fc">&nbsp;                            return TypeDescription.ForLoadedType.of(void.class);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        protected MethodVisitor doApply(MethodVisitor methodVisitor,
&nbsp;                                                        Context implementationContext,
&nbsp;                                                        Assigner assigner,
&nbsp;                                                        ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                        MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                        StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                        TypeDescription instrumentedType,
&nbsp;                                                        MethodDescription instrumentedMethod,
&nbsp;                                                        SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                        RelocationHandler.Bound relocationHandler,
&nbsp;                                                        StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLengthPadding(adviceMethod.getReturnType().getStackSize().getSize());</b>
<b class="fc">&nbsp;                            return super.doApply(methodVisitor,</b>
&nbsp;                                    implementationContext,
&nbsp;                                    assigner,
&nbsp;                                    argumentHandler,
&nbsp;                                    methodSizeHandler,
&nbsp;                                    stackMapFrameHandler,
&nbsp;                                    instrumentedType,
&nbsp;                                    instrumentedMethod,
&nbsp;                                    suppressionHandler,
&nbsp;                                    relocationHandler,
&nbsp;                                    exceptionHandler);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved dispatcher for implementing method exit advice.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class ForMethodExit extends Inlining.Resolved implements Dispatcher.Resolved.ForMethodExit {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of uninitialized local variables by their name.
&nbsp;                     */
&nbsp;                    private final Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the arguments of the instrumented method should be copied before executing the instrumented method.
&nbsp;                     */
&nbsp;                    private final boolean backupArguments;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved dispatcher for implementing method exit advice.
&nbsp;                     *
&nbsp;                     * @param adviceMethod            The represented advice method.
&nbsp;                     * @param postProcessor           The post processor to apply.
&nbsp;                     * @param namedTypes              A mapping of all available local variables by their name to their type.
&nbsp;                     * @param uninitializedNamedTypes A mapping of all uninitialized local variables by their name to their type.
&nbsp;                     * @param userFactories           A list of user-defined factories for offset mappings.
&nbsp;                     * @param classReader             The class reader for parsing the advice method&#39;s class file.
&nbsp;                     * @param enterType               The type of the value supplied by the enter advice method or {@code void} if no such value exists.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                            PostProcessor postProcessor,
&nbsp;                                            Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                            Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes,
&nbsp;                                            List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                            ClassReader classReader,
&nbsp;                                            TypeDefinition enterType) {
<b class="fc">&nbsp;                        super(adviceMethod,</b>
&nbsp;                                postProcessor,
<b class="fc">&nbsp;                                CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE,</b>
&nbsp;                                        OffsetMapping.ForAllArguments.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForThisReference.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForField.Unresolved.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForOrigin.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForSelfCallHandle.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForUnusedValue.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForStubValue.INSTANCE,
<b class="fc">&nbsp;                                        OffsetMapping.ForEnterValue.Factory.of(enterType),</b>
<b class="fc">&nbsp;                                        OffsetMapping.ForExitValue.Factory.of(adviceMethod.getReturnType()),</b>
&nbsp;                                        new OffsetMapping.ForLocalValue.Factory(namedTypes),
&nbsp;                                        OffsetMapping.ForReturnValue.Factory.INSTANCE,
<b class="fc">&nbsp;                                        OffsetMapping.ForThrowable.Factory.of(adviceMethod)</b>
&nbsp;                                ), userFactories),
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(SUPPRESS_EXIT).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON_INDEX).resolve(Integer.class),</b>
&nbsp;                                classReader);
<b class="fc">&nbsp;                        this.uninitializedNamedTypes = uninitializedNamedTypes;</b>
<b class="fc">&nbsp;                        backupArguments = adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(BACKUP_ARGUMENTS).resolve(Boolean.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves exit advice that handles exceptions depending on the specification of the exit advice.
&nbsp;                     *
&nbsp;                     * @param adviceMethod            The advice method.
&nbsp;                     * @param postProcessor           The post processor to apply.
&nbsp;                     * @param namedTypes              A mapping of all available local variables by their name to their type.
&nbsp;                     * @param uninitializedNamedTypes A mapping of all uninitialized local variables by their name to their type.
&nbsp;                     * @param userFactories           A list of user-defined factories for offset mappings.
&nbsp;                     * @param classReader             The class reader for parsing the advice method&#39;s class file.
&nbsp;                     * @param enterType               The type of the value supplied by the enter advice method or {@code void} if no such value exists.
&nbsp;                     * @return An appropriate exit handler.
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected static Resolved.ForMethodExit of(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                               PostProcessor postProcessor,
&nbsp;                                                               Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                               Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes,
&nbsp;                                                               List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                               ClassReader classReader,
&nbsp;                                                               TypeDefinition enterType) {
<b class="fc">&nbsp;                        TypeDescription throwable = adviceMethod.getDeclaredAnnotations()</b>
<b class="fc">&nbsp;                                .ofType(OnMethodExit.class)</b>
<b class="fc">&nbsp;                                .getValue(ON_THROWABLE).resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                        return throwable.represents(NoExceptionHandler.class)</b>
<b class="fc">&nbsp;                                ? new WithoutExceptionHandler(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType)</b>
<b class="fc">&nbsp;                                : new WithExceptionHandler(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType, throwable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="fc">&nbsp;                        return uninitializedNamedTypes;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Map&lt;Integer, TypeDefinition&gt; resolveInitializationTypes(ArgumentHandler argumentHandler) {
<b class="fc">&nbsp;                        SortedMap&lt;Integer, TypeDefinition&gt; resolved = new TreeMap&lt;Integer, TypeDefinition&gt;();</b>
<b class="fc">&nbsp;                        for (Map.Entry&lt;String, TypeDefinition&gt; entry : uninitializedNamedTypes.entrySet()) {</b>
<b class="fc">&nbsp;                            resolved.put(argumentHandler.named(entry.getKey()), entry.getValue());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        if (!adviceMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                            resolved.put(argumentHandler.exit(), adviceMethod.getReturnType());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return resolved;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected MethodVisitor apply(MethodVisitor methodVisitor,
&nbsp;                                                  Implementation.Context implementationContext,
&nbsp;                                                  Assigner assigner,
&nbsp;                                                  ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                                  MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                                  StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                                  TypeDescription instrumentedType,
&nbsp;                                                  MethodDescription instrumentedMethod,
&nbsp;                                                  SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                  RelocationHandler.Bound relocationHandler,
&nbsp;                                                  StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                        return doApply(methodVisitor,</b>
&nbsp;                                implementationContext,
&nbsp;                                assigner,
<b class="fc">&nbsp;                                argumentHandler.bindExit(adviceMethod, getThrowable().represents(NoExceptionHandler.class)),</b>
<b class="fc">&nbsp;                                methodSizeHandler.bindExit(adviceMethod),</b>
<b class="fc">&nbsp;                                stackMapFrameHandler.bindExit(adviceMethod),</b>
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
&nbsp;                                exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Applies a resolution for a given instrumented method.
&nbsp;                     *
&nbsp;                     * @param instrumentedType      A description of the instrumented type.
&nbsp;                     * @param instrumentedMethod    The instrumented method that is being bound.
&nbsp;                     * @param methodVisitor         The method visitor for writing to the instrumented method.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     * @param assigner              The assigner to use.
&nbsp;                     * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                     * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                     * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                     * @param suppressionHandler    The bound suppression handler to use.
&nbsp;                     * @param relocationHandler     The bound relocation handler to use.
&nbsp;                     * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                     * @return A method visitor for visiting the advice method&#39;s byte code.
&nbsp;                     */
&nbsp;                    private MethodVisitor doApply(MethodVisitor methodVisitor,
&nbsp;                                                  Implementation.Context implementationContext,
&nbsp;                                                  Assigner assigner,
&nbsp;                                                  ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                  MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                  StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                  TypeDescription instrumentedType,
&nbsp;                                                  MethodDescription instrumentedMethod,
&nbsp;                                                  SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                  RelocationHandler.Bound relocationHandler,
&nbsp;                                                  StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                        Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings = new HashMap&lt;Integer, OffsetMapping.Target&gt;();</b>
<b class="fc">&nbsp;                        for (Map.Entry&lt;Integer, OffsetMapping&gt; entry : this.offsetMappings.entrySet()) {</b>
<b class="fc">&nbsp;                            offsetMappings.put(entry.getKey(), entry.getValue().resolve(instrumentedType,</b>
&nbsp;                                    instrumentedMethod,
&nbsp;                                    assigner,
&nbsp;                                    argumentHandler,
&nbsp;                                    OffsetMapping.Sort.EXIT));
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new CodeTranslationVisitor(methodVisitor,</b>
&nbsp;                                implementationContext,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                assigner,
&nbsp;                                adviceMethod,
&nbsp;                                offsetMappings,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
&nbsp;                                exceptionHandler,
&nbsp;                                postProcessor,
&nbsp;                                true);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ArgumentHandler.Factory getArgumentHandlerFactory() {
<b class="fc">&nbsp;                        return backupArguments</b>
<b class="fc">&nbsp;                                ? ArgumentHandler.Factory.COPYING</b>
<b class="fc">&nbsp;                                : ArgumentHandler.Factory.SIMPLE;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDefinition getAdviceType() {
<b class="fc">&nbsp;                        return adviceMethod.getReturnType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Bound bind(TypeDescription instrumentedType,
&nbsp;                                      MethodDescription instrumentedMethod,
&nbsp;                                      MethodVisitor methodVisitor,
&nbsp;                                      Implementation.Context implementationContext,
&nbsp;                                      Assigner assigner,
&nbsp;                                      ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                      MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                      StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                      StackManipulation exceptionHandler,
&nbsp;                                      RelocationHandler.Relocation relocation) {
<b class="fc">&nbsp;                        return new AdviceMethodInliner(instrumentedType,</b>
&nbsp;                                instrumentedMethod,
&nbsp;                                methodVisitor,
&nbsp;                                implementationContext,
&nbsp;                                assigner,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
<b class="fc">&nbsp;                                suppressionHandler.bind(exceptionHandler),</b>
<b class="fc">&nbsp;                                relocationHandler.bind(instrumentedMethod, relocation),</b>
&nbsp;                                exceptionHandler,
&nbsp;                                classReader);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of exit advice that handles exceptions.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class WithExceptionHandler extends Inlining.Resolved.ForMethodExit {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type of the handled throwable type for which this advice is invoked.
&nbsp;                         */
&nbsp;                        private final TypeDescription throwable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method exit advice that handles exceptions.
&nbsp;                         *
&nbsp;                         * @param adviceMethod            The represented advice method.
&nbsp;                         * @param postProcessor           The post processor to apply.
&nbsp;                         * @param namedTypes              A mapping of all available local variables by their name to their type.
&nbsp;                         * @param uninitializedNamedTypes A mapping of all uninitialized local variables by their name to their type.
&nbsp;                         * @param userFactories           A list of user-defined factories for offset mappings.
&nbsp;                         * @param classReader             The class reader for parsing the advice method&#39;s class file.
&nbsp;                         * @param enterType               The type of the value supplied by the enter advice method or
&nbsp;                         *                                a description of {@code void} if no such value exists.
&nbsp;                         * @param throwable               The type of the handled throwable type for which this advice is invoked.
&nbsp;                         */
&nbsp;                        protected WithExceptionHandler(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                       PostProcessor postProcessor,
&nbsp;                                                       Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                       Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes,
&nbsp;                                                       List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                       ClassReader classReader,
&nbsp;                                                       TypeDefinition enterType,
&nbsp;                                                       TypeDescription throwable) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType);</b>
<b class="fc">&nbsp;                            this.throwable = throwable;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription getThrowable() {
<b class="fc">&nbsp;                            return throwable;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of exit advice that ignores exceptions.
&nbsp;                     */
&nbsp;                    protected static class WithoutExceptionHandler extends Inlining.Resolved.ForMethodExit {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method exit advice that does not handle exceptions.
&nbsp;                         *
&nbsp;                         * @param adviceMethod            The represented advice method.
&nbsp;                         * @param postProcessor           The post processor to apply.
&nbsp;                         * @param namedTypes              A mapping of all available local variables by their name to their type.
&nbsp;                         * @param uninitializedNamedTypes A mapping of all uninitialized local variables by their name to their type.
&nbsp;                         * @param userFactories           A list of user-defined factories for offset mappings.
&nbsp;                         * @param classReader             A class reader to query for the class file of the advice method.
&nbsp;                         * @param enterType               The type of the value supplied by the enter advice method or
&nbsp;                         *                                a description of {@code void} if no such value exists.
&nbsp;                         */
&nbsp;                        protected WithoutExceptionHandler(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                          PostProcessor postProcessor,
&nbsp;                                                          Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                          Map&lt;String, TypeDefinition&gt; uninitializedNamedTypes,
&nbsp;                                                          List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                          ClassReader classReader,
&nbsp;                                                          TypeDefinition enterType) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, namedTypes, uninitializedNamedTypes, userFactories, classReader, enterType);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription getThrowable() {
<b class="fc">&nbsp;                            return NoExceptionHandler.DESCRIPTION;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor for translating an advice method&#39;s byte code for inlining into the instrumented method.
&nbsp;             */
&nbsp;            protected static class CodeTranslationVisitor extends MethodVisitor {
&nbsp;
&nbsp;                /**
&nbsp;                 * The original method visitor to which all instructions are eventually written to.
&nbsp;                 */
&nbsp;                protected final MethodVisitor methodVisitor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The implementation context to use.
&nbsp;                 */
&nbsp;                protected final Context implementationContext;
&nbsp;
&nbsp;                /**
&nbsp;                 * A handler for accessing values on the local variable array.
&nbsp;                 */
&nbsp;                protected final ArgumentHandler.ForAdvice argumentHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * A handler for computing the method size requirements.
&nbsp;                 */
&nbsp;                protected final MethodSizeHandler.ForAdvice methodSizeHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * A handler for translating and injecting stack map frames.
&nbsp;                 */
&nbsp;                protected final StackMapFrameHandler.ForAdvice stackMapFrameHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented type.
&nbsp;                 */
&nbsp;                private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The instrumented method.
&nbsp;                 */
&nbsp;                private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * The assigner to use.
&nbsp;                 */
&nbsp;                private final Assigner assigner;
&nbsp;
&nbsp;                /**
&nbsp;                 * The advice method.
&nbsp;                 */
&nbsp;                protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of offsets to resolved target offsets in the instrumented method.
&nbsp;                 */
&nbsp;                private final Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings;
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                 */
&nbsp;                private final SuppressionHandler.Bound suppressionHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                 */
&nbsp;                private final RelocationHandler.Bound relocationHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * The exception handler that is resolved for the instrumented method.
&nbsp;                 */
&nbsp;                private final StackManipulation exceptionHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * The post processor to apply.
&nbsp;                 */
&nbsp;                private final PostProcessor postProcessor;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this visitor is for exit advice.
&nbsp;                 */
&nbsp;                private final boolean exit;
&nbsp;
&nbsp;                /**
&nbsp;                 * A label indicating the end of the advice byte code.
&nbsp;                 */
&nbsp;                protected final Label endOfMethod;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new code translation visitor.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         A method visitor for writing the instrumented method&#39;s byte code.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                 * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                 * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                 * @param instrumentedType      The instrumented type.
&nbsp;                 * @param instrumentedMethod    The instrumented method.
&nbsp;                 * @param assigner              The assigner to use.
&nbsp;                 * @param adviceMethod          The advice method.
&nbsp;                 * @param offsetMappings        A mapping of offsets to resolved target offsets in the instrumented method.
&nbsp;                 * @param suppressionHandler    A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                 * @param relocationHandler     A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                 * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                 * @param postProcessor         The post processor to apply.
&nbsp;                 * @param exit                  {@code true} if this visitor is for exit advice.
&nbsp;                 */
&nbsp;                protected CodeTranslationVisitor(MethodVisitor methodVisitor,
&nbsp;                                                 Context implementationContext,
&nbsp;                                                 ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                 MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                 StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                 TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                 Map&lt;Integer, OffsetMapping.Target&gt; offsetMappings,
&nbsp;                                                 SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                 RelocationHandler.Bound relocationHandler,
&nbsp;                                                 StackManipulation exceptionHandler,
&nbsp;                                                 PostProcessor postProcessor,
&nbsp;                                                 boolean exit) {
<b class="fc">&nbsp;                    super(OpenedClassReader.ASM_API, StackAwareMethodVisitor.of(methodVisitor, instrumentedMethod));</b>
<b class="fc">&nbsp;                    this.methodVisitor = methodVisitor;</b>
<b class="fc">&nbsp;                    this.implementationContext = implementationContext;</b>
<b class="fc">&nbsp;                    this.argumentHandler = argumentHandler;</b>
<b class="fc">&nbsp;                    this.methodSizeHandler = methodSizeHandler;</b>
<b class="fc">&nbsp;                    this.stackMapFrameHandler = stackMapFrameHandler;</b>
<b class="fc">&nbsp;                    this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                    this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                    this.assigner = assigner;</b>
<b class="fc">&nbsp;                    this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                    this.offsetMappings = offsetMappings;</b>
<b class="fc">&nbsp;                    this.suppressionHandler = suppressionHandler;</b>
<b class="fc">&nbsp;                    this.relocationHandler = relocationHandler;</b>
<b class="fc">&nbsp;                    this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;                    this.postProcessor = postProcessor;</b>
<b class="fc">&nbsp;                    this.exit = exit;</b>
<b class="fc">&nbsp;                    endOfMethod = new Label();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Propagates a label for an exception handler that is typically suppressed by the overlaying
&nbsp;                 * {@link Resolved.AdviceMethodInliner.ExceptionTableSubstitutor}.
&nbsp;                 *
&nbsp;                 * @param label The label to register as a target for an exception handler.
&nbsp;                 */
&nbsp;                protected void propagateHandler(Label label) {
<b class="fc">&nbsp;                    ((StackAwareMethodVisitor) mv).register(label, Collections.singletonList(StackSize.SINGLE));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitParameter(String name, int modifiers) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitAnnotableParameterCount(int count, boolean visible) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitAnnotationDefault() {
<b class="nc">&nbsp;                    return IGNORE_ANNOTATION;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitAnnotation(String descriptor, boolean visible) {
<b class="fc">&nbsp;                    return IGNORE_ANNOTATION;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitTypeAnnotation(int typeReference, @MaybeNull TypePath typePath, String descriptor, boolean visible) {
<b class="nc">&nbsp;                    return IGNORE_ANNOTATION;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public AnnotationVisitor visitParameterAnnotation(int index, String descriptor, boolean visible) {
<b class="fc">&nbsp;                    return IGNORE_ANNOTATION;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitAttribute(Attribute attribute) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitCode() {
<b class="fc">&nbsp;                    suppressionHandler.onStart(methodVisitor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
<b class="fc">&nbsp;                    stackMapFrameHandler.translateFrame(methodVisitor, type, localVariableLength, localVariable, stackSize, stack);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitVarInsn(int opcode, int offset) {
<b class="fc">&nbsp;                    OffsetMapping.Target target = offsetMappings.get(offset);</b>
<b class="fc">&nbsp;                    if (target != null) {</b>
&nbsp;                        StackManipulation stackManipulation;
&nbsp;                        StackSize expectedGrowth;
<b class="fc">&nbsp;                        switch (opcode) {</b>
&nbsp;                            case Opcodes.ILOAD:
&nbsp;                            case Opcodes.FLOAD:
&nbsp;                            case Opcodes.ALOAD:
<b class="fc">&nbsp;                                stackManipulation = target.resolveRead();</b>
<b class="fc">&nbsp;                                expectedGrowth = StackSize.SINGLE;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.DLOAD:
&nbsp;                            case Opcodes.LLOAD:
<b class="fc">&nbsp;                                stackManipulation = target.resolveRead();</b>
<b class="fc">&nbsp;                                expectedGrowth = StackSize.DOUBLE;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            case Opcodes.ISTORE:
&nbsp;                            case Opcodes.FSTORE:
&nbsp;                            case Opcodes.ASTORE:
&nbsp;                            case Opcodes.LSTORE:
&nbsp;                            case Opcodes.DSTORE:
<b class="fc">&nbsp;                                stackManipulation = target.resolveWrite();</b>
<b class="fc">&nbsp;                                expectedGrowth = StackSize.ZERO;</b>
<b class="fc">&nbsp;                                break;</b>
&nbsp;                            default:
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;Unexpected opcode: &quot; + opcode);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        methodSizeHandler.requireStackSizePadding(stackManipulation.apply(mv, implementationContext).getMaximalSize() - expectedGrowth.getSize());</b>
<b class="fc">&nbsp;                    } else {</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(opcode, argumentHandler.mapped(offset));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitIincInsn(int offset, int value) {
<b class="fc">&nbsp;                    OffsetMapping.Target target = offsetMappings.get(offset);</b>
<b class="fc">&nbsp;                    if (target != null) {</b>
<b class="fc">&nbsp;                        methodSizeHandler.requireStackSizePadding(target.resolveIncrement(value).apply(mv, implementationContext).getMaximalSize());</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        mv.visitIincInsn(argumentHandler.mapped(offset), value);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitInsn(int opcode) {
<b class="fc">&nbsp;                    switch (opcode) {</b>
&nbsp;                        case Opcodes.RETURN:
<b class="fc">&nbsp;                            ((StackAwareMethodVisitor) mv).drainStack();</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case Opcodes.IRETURN:
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.ISTORE, Opcodes.ILOAD, StackSize.SINGLE));</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case Opcodes.ARETURN:
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.ASTORE, Opcodes.ALOAD, StackSize.SINGLE));</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case Opcodes.FRETURN:
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.FSTORE, Opcodes.FLOAD, StackSize.SINGLE));</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case Opcodes.LRETURN:
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.LSTORE, Opcodes.LLOAD, StackSize.DOUBLE));</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        case Opcodes.DRETURN:
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.DSTORE, Opcodes.DLOAD, StackSize.DOUBLE));</b>
<b class="fc">&nbsp;                            break;</b>
&nbsp;                        default:
<b class="fc">&nbsp;                            mv.visitInsn(opcode);</b>
&nbsp;                            return;
&nbsp;                    }
<b class="fc">&nbsp;                    mv.visitJumpInsn(Opcodes.GOTO, endOfMethod);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitEnd() {
<b class="fc">&nbsp;                    suppressionHandler.onEnd(methodVisitor, implementationContext, methodSizeHandler, stackMapFrameHandler, adviceMethod.getReturnType());</b>
<b class="fc">&nbsp;                    methodVisitor.visitLabel(endOfMethod);</b>
<b class="fc">&nbsp;                    if (adviceMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                            || adviceMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                            || adviceMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                            || adviceMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                            || adviceMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ISTORE, exit ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                    } else if (adviceMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.LSTORE, exit ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                    } else if (adviceMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.FSTORE, exit ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                    } else if (adviceMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.DSTORE, exit ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                    } else if (!adviceMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ASTORE, exit ? argumentHandler.exit() : argumentHandler.enter());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    methodSizeHandler.requireStackSize(postProcessor</b>
<b class="fc">&nbsp;                            .resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, stackMapFrameHandler, exceptionHandler)</b>
<b class="fc">&nbsp;                            .apply(methodVisitor, implementationContext).getMaximalSize());</b>
<b class="fc">&nbsp;                    methodSizeHandler.requireStackSize(relocationHandler.apply(methodVisitor,</b>
&nbsp;                            implementationContext,
<b class="fc">&nbsp;                            exit ? argumentHandler.exit() : argumentHandler.enter()));</b>
<b class="fc">&nbsp;                    stackMapFrameHandler.injectCompletionFrame(methodVisitor);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void visitMaxs(int stackSize, int localVariableLength) {
<b class="fc">&nbsp;                    methodSizeHandler.recordMaxima(stackSize, localVariableLength);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for an advice method that is being invoked from the instrumented method.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Delegating implements Unresolved {
&nbsp;
&nbsp;            /**
&nbsp;             * The advice method.
&nbsp;             */
&nbsp;            protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;            /**
&nbsp;             * The delegator factory to use.
&nbsp;             */
&nbsp;            protected final Delegator.Factory delegatorFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new delegating advice dispatcher.
&nbsp;             *
&nbsp;             * @param adviceMethod     The advice method.
&nbsp;             * @param delegatorFactory The delegator factory to use.
&nbsp;             */
<b class="fc">&nbsp;            protected Delegating(MethodDescription.InDefinedShape adviceMethod, Delegator.Factory delegatorFactory) {</b>
<b class="fc">&nbsp;                this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                this.delegatorFactory = delegatorFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isAlive() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isBinary() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getAdviceType() {
<b class="fc">&nbsp;                return adviceMethod.getReturnType().asErasure();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="fc">&nbsp;                return Collections.emptyMap();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Dispatcher.Resolved.ForMethodEnter asMethodEnter(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                                    @MaybeNull ClassReader classReader,
&nbsp;                                                                    Unresolved methodExit,
&nbsp;                                                                    PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;                return Resolved.ForMethodEnter.of(adviceMethod,</b>
<b class="fc">&nbsp;                        postProcessorFactory.make(adviceMethod, false),</b>
<b class="fc">&nbsp;                        delegatorFactory.make(adviceMethod, false),</b>
&nbsp;                        userFactories,
<b class="fc">&nbsp;                        methodExit.getAdviceType(),</b>
<b class="fc">&nbsp;                        methodExit.isAlive());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Dispatcher.Resolved.ForMethodExit asMethodExit(List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                                  @MaybeNull ClassReader classReader,
&nbsp;                                                                  Unresolved methodEnter,
&nbsp;                                                                  PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;                Map&lt;String, TypeDefinition&gt; namedTypes = methodEnter.getNamedTypes();</b>
<b class="fc">&nbsp;                for (ParameterDescription parameterDescription : adviceMethod.getParameters()) {</b>
<b class="fc">&nbsp;                    AnnotationDescription.Loadable&lt;Local&gt; annotationDescription = parameterDescription.getDeclaredAnnotations().ofType(Local.class);</b>
<b class="fc">&nbsp;                    if (annotationDescription != null) {</b>
<b class="nc">&nbsp;                        String name = annotationDescription.getValue(OffsetMapping.ForLocalValue.Factory.LOCAL_VALUE).resolve(String.class);</b>
<b class="nc">&nbsp;                        TypeDefinition typeDefinition = namedTypes.get(name);</b>
<b class="nc">&nbsp;                        if (typeDefinition == null) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(adviceMethod + &quot; attempts use of undeclared local variable &quot; + name);</b>
<b class="nc">&nbsp;                        } else if (!typeDefinition.equals(parameterDescription.getType())) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(adviceMethod + &quot; does not read variable &quot; + name + &quot; as &quot; + typeDefinition);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return Resolved.ForMethodExit.of(adviceMethod,</b>
<b class="fc">&nbsp;                        postProcessorFactory.make(adviceMethod, true),</b>
<b class="fc">&nbsp;                        delegatorFactory.make(adviceMethod, true),</b>
&nbsp;                        namedTypes,
&nbsp;                        userFactories,
<b class="fc">&nbsp;                        methodEnter.getAdviceType());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="nc">&nbsp;                return &quot;Delegate to &quot; + adviceMethod;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A resolved version of a dispatcher.
&nbsp;             */
&nbsp;            protected abstract static class Resolved extends Dispatcher.Resolved.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegator to use.
&nbsp;                 */
&nbsp;                protected final Delegator delegator;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new resolved version of a dispatcher.
&nbsp;                 *
&nbsp;                 * @param adviceMethod     The represented advice method.
&nbsp;                 * @param postProcessor    The post processor to apply.
&nbsp;                 * @param factories        A list of factories to resolve for the parameters of the advice method.
&nbsp;                 * @param throwableType    The type to handle by a suppression handler or {@link NoExceptionHandler} to not handle any exceptions.
&nbsp;                 * @param relocatableType  The type to trigger a relocation of the method&#39;s control flow or {@code void} if no relocation should be executed.
&nbsp;                 * @param relocatableIndex The index within an array that is returned by the advice method, indicating the value to consider for relocation.
&nbsp;                 * @param delegator        The delegator to use.
&nbsp;                 */
&nbsp;                protected Resolved(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                   PostProcessor postProcessor,
&nbsp;                                   List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; factories,
&nbsp;                                   TypeDescription throwableType,
&nbsp;                                   TypeDescription relocatableType,
&nbsp;                                   int relocatableIndex,
&nbsp;                                   Delegator delegator) {
<b class="fc">&nbsp;                    super(adviceMethod, postProcessor, factories, throwableType, relocatableType, relocatableIndex, OffsetMapping.Factory.AdviceType.DELEGATION);</b>
<b class="fc">&nbsp;                    this.delegator = delegator;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Map&lt;String, TypeDefinition&gt; getNamedTypes() {
<b class="fc">&nbsp;                    return Collections.emptyMap();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Bound bind(TypeDescription instrumentedType,
&nbsp;                                  MethodDescription instrumentedMethod,
&nbsp;                                  MethodVisitor methodVisitor,
&nbsp;                                  Implementation.Context implementationContext,
&nbsp;                                  Assigner assigner,
&nbsp;                                  ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                  MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                  StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                  StackManipulation exceptionHandler,
&nbsp;                                  RelocationHandler.Relocation relocation) {
<b class="fc">&nbsp;                    if (!adviceMethod.isVisibleTo(instrumentedType)) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(adviceMethod + &quot; is not visible to &quot; + instrumentedMethod.getDeclaringType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return resolve(instrumentedType,</b>
&nbsp;                            instrumentedMethod,
&nbsp;                            methodVisitor,
&nbsp;                            implementationContext,
&nbsp;                            assigner,
&nbsp;                            argumentHandler,
&nbsp;                            methodSizeHandler,
&nbsp;                            stackMapFrameHandler,
&nbsp;                            exceptionHandler,
&nbsp;                            relocation);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Binds this dispatcher for resolution to a specific method.
&nbsp;                 *
&nbsp;                 * @param instrumentedType      A description of the instrumented type.
&nbsp;                 * @param instrumentedMethod    The instrumented method that is being bound.
&nbsp;                 * @param methodVisitor         The method visitor for writing to the instrumented method.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param assigner              The assigner to use.
&nbsp;                 * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                 * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                 * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                 * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;                 * @param relocation            A relocation to use with a relocation handler.
&nbsp;                 * @return An appropriate bound advice dispatcher.
&nbsp;                 */
&nbsp;                protected abstract Bound resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 MethodVisitor methodVisitor,
&nbsp;                                                 Implementation.Context implementationContext,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                                 MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                                 StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                                 StackManipulation exceptionHandler,
&nbsp;                                                 RelocationHandler.Relocation relocation);
&nbsp;
&nbsp;                /**
&nbsp;                 * A bound advice method that copies the code by first extracting the exception table and later appending the
&nbsp;                 * code of the method without copying any meta data.
&nbsp;                 */
&nbsp;                protected abstract static class AdviceMethodWriter implements Bound {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The advice method.
&nbsp;                     */
&nbsp;                    protected final MethodDescription.InDefinedShape adviceMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription instrumentedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instrumented method.
&nbsp;                     */
&nbsp;                    private final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The assigner to use.
&nbsp;                     */
&nbsp;                    private final Assigner assigner;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The offset mappings available to this advice.
&nbsp;                     */
&nbsp;                    private final List&lt;OffsetMapping.Target&gt; offsetMappings;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The method visitor for writing the instrumented method.
&nbsp;                     */
&nbsp;                    protected final MethodVisitor methodVisitor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The implementation context to use.
&nbsp;                     */
&nbsp;                    protected final Implementation.Context implementationContext;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handler for accessing values on the local variable array.
&nbsp;                     */
&nbsp;                    protected final ArgumentHandler.ForAdvice argumentHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handler for computing the method size requirements.
&nbsp;                     */
&nbsp;                    protected final MethodSizeHandler.ForAdvice methodSizeHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A handler for translating and injecting stack map frames.
&nbsp;                     */
&nbsp;                    protected final StackMapFrameHandler.ForAdvice stackMapFrameHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                     */
&nbsp;                    private final SuppressionHandler.Bound suppressionHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                     */
&nbsp;                    private final RelocationHandler.Bound relocationHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The exception handler that is resolved for the instrumented method.
&nbsp;                     */
&nbsp;                    private final StackManipulation exceptionHandler;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The post processor to apply.
&nbsp;                     */
&nbsp;                    private final PostProcessor postProcessor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The delegator to use.
&nbsp;                     */
&nbsp;                    private final Delegator delegator;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new advice method writer.
&nbsp;                     *
&nbsp;                     * @param adviceMethod          The advice method.
&nbsp;                     * @param instrumentedType      The instrumented type.
&nbsp;                     * @param instrumentedMethod    The instrumented method.
&nbsp;                     * @param assigner              The assigner to use.
&nbsp;                     * @param postProcessor         The post processor to apply.
&nbsp;                     * @param offsetMappings        The offset mappings available to this advice.
&nbsp;                     * @param methodVisitor         The method visitor for writing the instrumented method.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                     * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                     * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                     * @param suppressionHandler    A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                     * @param relocationHandler     A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                     * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                     * @param delegator             The delegator to use.
&nbsp;                     */
&nbsp;                    protected AdviceMethodWriter(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                 TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 PostProcessor postProcessor,
&nbsp;                                                 List&lt;OffsetMapping.Target&gt; offsetMappings,
&nbsp;                                                 MethodVisitor methodVisitor,
&nbsp;                                                 Context implementationContext,
&nbsp;                                                 ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                 MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                 StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                 SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                 RelocationHandler.Bound relocationHandler,
&nbsp;                                                 StackManipulation exceptionHandler,
<b class="fc">&nbsp;                                                 Delegator delegator) {</b>
<b class="fc">&nbsp;                        this.adviceMethod = adviceMethod;</b>
<b class="fc">&nbsp;                        this.instrumentedType = instrumentedType;</b>
<b class="fc">&nbsp;                        this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;                        this.assigner = assigner;</b>
<b class="fc">&nbsp;                        this.postProcessor = postProcessor;</b>
<b class="fc">&nbsp;                        this.offsetMappings = offsetMappings;</b>
<b class="fc">&nbsp;                        this.methodVisitor = methodVisitor;</b>
<b class="fc">&nbsp;                        this.implementationContext = implementationContext;</b>
<b class="fc">&nbsp;                        this.argumentHandler = argumentHandler;</b>
<b class="fc">&nbsp;                        this.methodSizeHandler = methodSizeHandler;</b>
<b class="fc">&nbsp;                        this.stackMapFrameHandler = stackMapFrameHandler;</b>
<b class="fc">&nbsp;                        this.suppressionHandler = suppressionHandler;</b>
<b class="fc">&nbsp;                        this.relocationHandler = relocationHandler;</b>
<b class="fc">&nbsp;                        this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;                        this.delegator = delegator;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void prepare() {
<b class="fc">&nbsp;                        suppressionHandler.onPrepare(methodVisitor);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void apply() {
<b class="fc">&nbsp;                        suppressionHandler.onStart(methodVisitor);</b>
<b class="fc">&nbsp;                        int index = 0, currentStackSize = 0, maximumStackSize = 0;</b>
<b class="fc">&nbsp;                        for (OffsetMapping.Target offsetMapping : offsetMappings) {</b>
<b class="fc">&nbsp;                            currentStackSize += adviceMethod.getParameters().get(index++).getType().getStackSize().getSize();</b>
<b class="fc">&nbsp;                            maximumStackSize = Math.max(maximumStackSize, currentStackSize + offsetMapping.resolveRead()</b>
<b class="fc">&nbsp;                                    .apply(methodVisitor, implementationContext)</b>
<b class="fc">&nbsp;                                    .getMaximalSize());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        maximumStackSize = Math.max(maximumStackSize, delegator.apply(instrumentedType, instrumentedMethod)</b>
<b class="fc">&nbsp;                                .apply(methodVisitor, implementationContext)</b>
<b class="fc">&nbsp;                                .getMaximalSize());</b>
<b class="fc">&nbsp;                        suppressionHandler.onEndWithSkip(methodVisitor,</b>
&nbsp;                                implementationContext,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
<b class="fc">&nbsp;                                adviceMethod.getReturnType());</b>
<b class="fc">&nbsp;                        if (adviceMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                                || adviceMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                                || adviceMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                                || adviceMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                                || adviceMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ISTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                        } else if (adviceMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.LSTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                        } else if (adviceMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.FSTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                        } else if (adviceMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.DSTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());</b>
<b class="fc">&nbsp;                        } else if (!adviceMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                            methodVisitor.visitVarInsn(Opcodes.ASTORE, isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        methodSizeHandler.requireStackSize(postProcessor</b>
<b class="fc">&nbsp;                                .resolve(instrumentedType, instrumentedMethod, assigner, argumentHandler, stackMapFrameHandler, exceptionHandler)</b>
<b class="fc">&nbsp;                                .apply(methodVisitor, implementationContext).getMaximalSize());</b>
<b class="fc">&nbsp;                        methodSizeHandler.requireStackSize(relocationHandler.apply(methodVisitor,</b>
&nbsp;                                implementationContext,
<b class="fc">&nbsp;                                isExitAdvice() ? argumentHandler.exit() : argumentHandler.enter()));</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectCompletionFrame(methodVisitor);</b>
<b class="fc">&nbsp;                        methodSizeHandler.requireStackSize(Math.max(maximumStackSize, adviceMethod.getReturnType().getStackSize().getSize()));</b>
<b class="fc">&nbsp;                        methodSizeHandler.requireLocalVariableLength(instrumentedMethod.getStackSize() + adviceMethod.getReturnType().getStackSize().getSize());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if this writer represents exit advice.
&nbsp;                     *
&nbsp;                     * @return {@code true} if this writer represents exit advice.
&nbsp;                     */
&nbsp;                    protected abstract boolean isExitAdvice();
&nbsp;
&nbsp;                    /**
&nbsp;                     * An advice method writer for a method enter.
&nbsp;                     */
&nbsp;                    protected static class ForMethodEnter extends AdviceMethodWriter {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new advice method writer.
&nbsp;                         *
&nbsp;                         * @param adviceMethod          The advice method.
&nbsp;                         * @param instrumentedType      The instrumented type.
&nbsp;                         * @param instrumentedMethod    The instrumented method.
&nbsp;                         * @param assigner              The assigner to use.
&nbsp;                         * @param postProcessor         The post processor to apply.
&nbsp;                         * @param offsetMappings        The offset mappings available to this advice.
&nbsp;                         * @param methodVisitor         The method visitor for writing the instrumented method.
&nbsp;                         * @param implementationContext The implementation context to use.
&nbsp;                         * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                         * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                         * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                         * @param suppressionHandler    A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                         * @param relocationHandler     A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                         * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                         * @param delegator             The delegator to use.
&nbsp;                         */
&nbsp;                        protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                 TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 PostProcessor postProcessor,
&nbsp;                                                 List&lt;OffsetMapping.Target&gt; offsetMappings,
&nbsp;                                                 MethodVisitor methodVisitor,
&nbsp;                                                 Implementation.Context implementationContext,
&nbsp;                                                 ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                 MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                 StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                 SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                 RelocationHandler.Bound relocationHandler,
&nbsp;                                                 StackManipulation exceptionHandler,
&nbsp;                                                 Delegator delegator) {
<b class="fc">&nbsp;                            super(adviceMethod,</b>
&nbsp;                                    instrumentedType,
&nbsp;                                    instrumentedMethod,
&nbsp;                                    assigner,
&nbsp;                                    postProcessor,
&nbsp;                                    offsetMappings,
&nbsp;                                    methodVisitor,
&nbsp;                                    implementationContext,
&nbsp;                                    argumentHandler,
&nbsp;                                    methodSizeHandler,
&nbsp;                                    stackMapFrameHandler,
&nbsp;                                    suppressionHandler,
&nbsp;                                    relocationHandler,
&nbsp;                                    exceptionHandler,
&nbsp;                                    delegator);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void initialize() {
&nbsp;                            /* do nothing */
<b class="fc">&nbsp;                        }</b>
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected boolean isExitAdvice() {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An advice method writer for a method exit.
&nbsp;                     */
&nbsp;                    protected static class ForMethodExit extends AdviceMethodWriter {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new advice method writer.
&nbsp;                         *
&nbsp;                         * @param adviceMethod          The advice method.
&nbsp;                         * @param instrumentedType      The instrumented type.
&nbsp;                         * @param instrumentedMethod    The instrumented method.
&nbsp;                         * @param assigner              The assigner to use.
&nbsp;                         * @param postProcessor         The post processor to apply.
&nbsp;                         * @param offsetMappings        The offset mappings available to this advice.
&nbsp;                         * @param methodVisitor         The method visitor for writing the instrumented method.
&nbsp;                         * @param implementationContext The implementation context to use.
&nbsp;                         * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                         * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                         * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                         * @param suppressionHandler    A bound suppression handler that is used for suppressing exceptions of this advice method.
&nbsp;                         * @param relocationHandler     A bound relocation handler that is responsible for considering a non-standard control flow.
&nbsp;                         * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                         * @param delegator             The delegator to use.
&nbsp;                         */
&nbsp;                        protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod,
&nbsp;                                                Assigner assigner,
&nbsp;                                                PostProcessor postProcessor,
&nbsp;                                                List&lt;OffsetMapping.Target&gt; offsetMappings,
&nbsp;                                                MethodVisitor methodVisitor,
&nbsp;                                                Implementation.Context implementationContext,
&nbsp;                                                ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                RelocationHandler.Bound relocationHandler,
&nbsp;                                                StackManipulation exceptionHandler,
&nbsp;                                                Delegator delegator) {
<b class="fc">&nbsp;                            super(adviceMethod,</b>
&nbsp;                                    instrumentedType,
&nbsp;                                    instrumentedMethod,
&nbsp;                                    assigner,
&nbsp;                                    postProcessor,
&nbsp;                                    offsetMappings,
&nbsp;                                    methodVisitor,
&nbsp;                                    implementationContext,
&nbsp;                                    argumentHandler,
&nbsp;                                    methodSizeHandler,
&nbsp;                                    stackMapFrameHandler,
&nbsp;                                    suppressionHandler,
&nbsp;                                    relocationHandler,
&nbsp;                                    exceptionHandler,
&nbsp;                                    delegator);
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void initialize() {
<b class="fc">&nbsp;                            if (adviceMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                                    || adviceMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                                    || adviceMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                                    || adviceMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                                    || adviceMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.ISTORE, argumentHandler.exit());</b>
<b class="fc">&nbsp;                            } else if (adviceMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.LSTORE, argumentHandler.exit());</b>
<b class="fc">&nbsp;                            } else if (adviceMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.FSTORE, argumentHandler.exit());</b>
<b class="fc">&nbsp;                            } else if (adviceMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.DSTORE, argumentHandler.exit());</b>
<b class="fc">&nbsp;                            } else if (!adviceMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                                methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                                methodVisitor.visitVarInsn(Opcodes.ASTORE, argumentHandler.exit());</b>
&nbsp;                            }
<b class="fc">&nbsp;                            methodSizeHandler.requireStackSize(adviceMethod.getReturnType().getStackSize().getSize());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        @Override
&nbsp;                        protected boolean isExitAdvice() {
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved dispatcher for implementing method enter advice.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class ForMethodEnter extends Delegating.Resolved implements Dispatcher.Resolved.ForMethodEnter {
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the first discovered line number information should be prepended to the advice code.
&nbsp;                     */
&nbsp;                    private final boolean prependLineNumber;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved dispatcher for implementing method enter advice.
&nbsp;                     *
&nbsp;                     * @param adviceMethod  The represented advice method.
&nbsp;                     * @param postProcessor The post processor to apply.
&nbsp;                     * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                     * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param delegator     The delegator to use.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;) // In absence of @SafeVarargs
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodEnter(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                             PostProcessor postProcessor,
&nbsp;                                             List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                             TypeDefinition exitType,
&nbsp;                                             Delegator delegator) {
<b class="fc">&nbsp;                        super(adviceMethod,</b>
&nbsp;                                postProcessor,
<b class="fc">&nbsp;                                CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE,</b>
&nbsp;                                        OffsetMapping.ForAllArguments.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForThisReference.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForField.Unresolved.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForOrigin.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForSelfCallHandle.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForUnusedValue.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForStubValue.INSTANCE,
<b class="fc">&nbsp;                                        OffsetMapping.ForExitValue.Factory.of(exitType),</b>
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Thrown&gt;(Thrown.class),
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Enter&gt;(Enter.class),
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Local&gt;(Local.class),
&nbsp;                                        new OffsetMapping.Factory.Illegal&lt;Return&gt;(Return.class)), userFactories),
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SUPPRESS_ENTER).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(SKIP_ON_INDEX).resolve(Integer.class),</b>
&nbsp;                                delegator);
<b class="fc">&nbsp;                        prependLineNumber = adviceMethod.getDeclaredAnnotations().ofType(OnMethodEnter.class).getValue(PREPEND_LINE_NUMBER).resolve(Boolean.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves enter advice that only exposes the enter type if this is necessary.
&nbsp;                     *
&nbsp;                     * @param adviceMethod  The advice method.
&nbsp;                     * @param postProcessor The post processor to apply.
&nbsp;                     * @param delegator     The delegator to use.
&nbsp;                     * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                     * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                     * @param methodExit    {@code true} if exit advice is applied.
&nbsp;                     * @return An appropriate enter handler.
&nbsp;                     */
&nbsp;                    protected static Resolved.ForMethodEnter of(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                                PostProcessor postProcessor,
&nbsp;                                                                Delegator delegator,
&nbsp;                                                                List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                                TypeDefinition exitType,
&nbsp;                                                                boolean methodExit) {
<b class="fc">&nbsp;                        return methodExit</b>
<b class="fc">&nbsp;                                ? new WithRetainedEnterType(adviceMethod, postProcessor, userFactories, exitType, delegator)</b>
<b class="fc">&nbsp;                                : new WithDiscardedEnterType(adviceMethod, postProcessor, userFactories, exitType, delegator);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean isPrependLineNumber() {
<b class="fc">&nbsp;                        return prependLineNumber;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDefinition getActualAdviceType() {
<b class="fc">&nbsp;                        return adviceMethod.getReturnType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Bound resolve(TypeDescription instrumentedType,
&nbsp;                                            MethodDescription instrumentedMethod,
&nbsp;                                            MethodVisitor methodVisitor,
&nbsp;                                            Implementation.Context implementationContext,
&nbsp;                                            Assigner assigner,
&nbsp;                                            ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                            MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                            StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                            StackManipulation exceptionHandler,
&nbsp;                                            RelocationHandler.Relocation relocation) {
<b class="fc">&nbsp;                        return doResolve(instrumentedType,</b>
&nbsp;                                instrumentedMethod,
&nbsp;                                methodVisitor,
&nbsp;                                implementationContext,
&nbsp;                                assigner,
<b class="fc">&nbsp;                                argumentHandler.bindEnter(adviceMethod),</b>
<b class="fc">&nbsp;                                methodSizeHandler.bindEnter(adviceMethod),</b>
<b class="fc">&nbsp;                                stackMapFrameHandler.bindEnter(adviceMethod),</b>
<b class="fc">&nbsp;                                suppressionHandler.bind(exceptionHandler),</b>
<b class="fc">&nbsp;                                relocationHandler.bind(instrumentedMethod, relocation),</b>
&nbsp;                                exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Binds this dispatcher for resolution to a specific method.
&nbsp;                     *
&nbsp;                     * @param instrumentedType      A description of the instrumented type.
&nbsp;                     * @param instrumentedMethod    The instrumented method that is being bound.
&nbsp;                     * @param methodVisitor         The method visitor for writing to the instrumented method.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     * @param assigner              The assigner to use.
&nbsp;                     * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                     * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                     * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                     * @param suppressionHandler    The bound suppression handler to use.
&nbsp;                     * @param relocationHandler     The bound relocation handler to use.
&nbsp;                     * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                     * @return An appropriate bound advice dispatcher.
&nbsp;                     */
&nbsp;                    protected Bound doResolve(TypeDescription instrumentedType,
&nbsp;                                              MethodDescription instrumentedMethod,
&nbsp;                                              MethodVisitor methodVisitor,
&nbsp;                                              Implementation.Context implementationContext,
&nbsp;                                              Assigner assigner,
&nbsp;                                              ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                              MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                              StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                              SuppressionHandler.Bound suppressionHandler,
&nbsp;                                              RelocationHandler.Bound relocationHandler,
&nbsp;                                              StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                        List&lt;OffsetMapping.Target&gt; offsetMappings = new ArrayList&lt;OffsetMapping.Target&gt;(this.offsetMappings.size());</b>
<b class="fc">&nbsp;                        for (OffsetMapping offsetMapping : this.offsetMappings.values()) {</b>
<b class="fc">&nbsp;                            offsetMappings.add(offsetMapping.resolve(instrumentedType,</b>
&nbsp;                                    instrumentedMethod,
&nbsp;                                    assigner,
&nbsp;                                    argumentHandler,
&nbsp;                                    OffsetMapping.Sort.ENTER));
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new AdviceMethodWriter.ForMethodEnter(adviceMethod,</b>
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                assigner,
&nbsp;                                postProcessor,
&nbsp;                                offsetMappings,
&nbsp;                                methodVisitor,
&nbsp;                                implementationContext,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
&nbsp;                                exceptionHandler,
&nbsp;                                delegator);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of an advice that does expose an enter type.
&nbsp;                     */
&nbsp;                    protected static class WithRetainedEnterType extends Delegating.Resolved.ForMethodEnter {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method enter advice that does expose the enter type.
&nbsp;                         *
&nbsp;                         * @param adviceMethod  The represented advice method.
&nbsp;                         * @param postProcessor The post processor to apply.
&nbsp;                         * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                         * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                         * @param delegator     The delegator to use.
&nbsp;                         */
&nbsp;                        protected WithRetainedEnterType(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                        PostProcessor postProcessor,
&nbsp;                                                        List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                        TypeDefinition exitType,
&nbsp;                                                        Delegator delegator) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, userFactories, exitType, delegator);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDefinition getAdviceType() {
<b class="fc">&nbsp;                            return adviceMethod.getReturnType();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of an advice that does not expose an enter type.
&nbsp;                     */
&nbsp;                    protected static class WithDiscardedEnterType extends Delegating.Resolved.ForMethodEnter {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method enter advice that does not expose the enter type.
&nbsp;                         *
&nbsp;                         * @param adviceMethod  The represented advice method.
&nbsp;                         * @param postProcessor The post processor to apply.
&nbsp;                         * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                         * @param exitType      The exit type or {@code void} if no exit type is defined.
&nbsp;                         * @param delegator     The delegator to use.
&nbsp;                         */
&nbsp;                        protected WithDiscardedEnterType(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                         PostProcessor postProcessor,
&nbsp;                                                         List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                         TypeDefinition exitType,
&nbsp;                                                         Delegator delegator) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, userFactories, exitType, delegator);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDefinition getAdviceType() {
<b class="fc">&nbsp;                            return TypeDescription.ForLoadedType.of(void.class);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        protected Bound doResolve(TypeDescription instrumentedType,
&nbsp;                                                  MethodDescription instrumentedMethod,
&nbsp;                                                  MethodVisitor methodVisitor,
&nbsp;                                                  Context implementationContext,
&nbsp;                                                  Assigner assigner,
&nbsp;                                                  ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                                  MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                                  StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                                  SuppressionHandler.Bound suppressionHandler,
&nbsp;                                                  RelocationHandler.Bound relocationHandler,
&nbsp;                                                  StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                            methodSizeHandler.requireLocalVariableLengthPadding(adviceMethod.getReturnType().getStackSize().getSize());</b>
<b class="fc">&nbsp;                            return super.doResolve(instrumentedType,</b>
&nbsp;                                    instrumentedMethod,
&nbsp;                                    methodVisitor,
&nbsp;                                    implementationContext,
&nbsp;                                    assigner,
&nbsp;                                    argumentHandler,
&nbsp;                                    methodSizeHandler,
&nbsp;                                    stackMapFrameHandler,
&nbsp;                                    suppressionHandler,
&nbsp;                                    relocationHandler,
&nbsp;                                    exceptionHandler);
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved dispatcher for implementing method exit advice.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class ForMethodExit extends Delegating.Resolved implements Dispatcher.Resolved.ForMethodExit {
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the arguments of the instrumented method should be copied prior to execution.
&nbsp;                     */
&nbsp;                    private final boolean backupArguments;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved dispatcher for implementing method exit advice.
&nbsp;                     *
&nbsp;                     * @param adviceMethod  The represented advice method.
&nbsp;                     * @param postProcessor The post processor to apply.
&nbsp;                     * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                     * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                     * @param enterType     The type of the value supplied by the enter advice method or {@code void} if no such value exists.
&nbsp;                     * @param delegator     The delegator to use.
&nbsp;                     */
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected ForMethodExit(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                            PostProcessor postProcessor,
&nbsp;                                            Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                            List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                            TypeDefinition enterType,
&nbsp;                                            Delegator delegator) {
<b class="fc">&nbsp;                        super(adviceMethod,</b>
&nbsp;                                postProcessor,
<b class="fc">&nbsp;                                CompoundList.of(Arrays.asList(OffsetMapping.ForArgument.Unresolved.Factory.INSTANCE,</b>
&nbsp;                                        OffsetMapping.ForAllArguments.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForThisReference.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForField.Unresolved.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.ReaderFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForFieldHandle.Unresolved.WriterFactory.INSTANCE,
&nbsp;                                        OffsetMapping.ForOrigin.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForSelfCallHandle.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForUnusedValue.Factory.INSTANCE,
&nbsp;                                        OffsetMapping.ForStubValue.INSTANCE,
<b class="fc">&nbsp;                                        OffsetMapping.ForEnterValue.Factory.of(enterType),</b>
<b class="fc">&nbsp;                                        OffsetMapping.ForExitValue.Factory.of(adviceMethod.getReturnType()),</b>
&nbsp;                                        new OffsetMapping.ForLocalValue.Factory(namedTypes),
&nbsp;                                        OffsetMapping.ForReturnValue.Factory.INSTANCE,
<b class="fc">&nbsp;                                        OffsetMapping.ForThrowable.Factory.of(adviceMethod)</b>
&nbsp;                                ), userFactories),
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(SUPPRESS_EXIT).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(REPEAT_ON_INDEX).resolve(Integer.class),</b>
&nbsp;                                delegator);
<b class="fc">&nbsp;                        backupArguments = adviceMethod.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(BACKUP_ARGUMENTS).resolve(Boolean.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves exit advice that handles exceptions depending on the specification of the exit advice.
&nbsp;                     *
&nbsp;                     * @param adviceMethod  The advice method.
&nbsp;                     * @param postProcessor The post processor to apply.
&nbsp;                     * @param delegator     The delegator to use.
&nbsp;                     * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                     * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                     * @param enterType     The type of the value supplied by the enter advice method or {@code void} if no such value exists.
&nbsp;                     * @return An appropriate exit handler.
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    protected static Resolved.ForMethodExit of(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                               PostProcessor postProcessor,
&nbsp;                                                               Delegator delegator,
&nbsp;                                                               Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                               List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                               TypeDefinition enterType) {
<b class="fc">&nbsp;                        TypeDescription throwable = adviceMethod.getDeclaredAnnotations()</b>
<b class="fc">&nbsp;                                .ofType(OnMethodExit.class)</b>
<b class="fc">&nbsp;                                .getValue(ON_THROWABLE)</b>
<b class="fc">&nbsp;                                .resolve(TypeDescription.class);</b>
<b class="fc">&nbsp;                        return throwable.represents(NoExceptionHandler.class)</b>
<b class="fc">&nbsp;                                ? new WithoutExceptionHandler(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator)</b>
<b class="fc">&nbsp;                                : new WithExceptionHandler(adviceMethod, postProcessor, namedTypes, userFactories, enterType, throwable, delegator);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Bound resolve(TypeDescription instrumentedType,
&nbsp;                                            MethodDescription instrumentedMethod,
&nbsp;                                            MethodVisitor methodVisitor,
&nbsp;                                            Implementation.Context implementationContext,
&nbsp;                                            Assigner assigner,
&nbsp;                                            ArgumentHandler.ForInstrumentedMethod argumentHandler,
&nbsp;                                            MethodSizeHandler.ForInstrumentedMethod methodSizeHandler,
&nbsp;                                            StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler,
&nbsp;                                            StackManipulation exceptionHandler,
&nbsp;                                            RelocationHandler.Relocation relocation) {
<b class="fc">&nbsp;                        return doResolve(instrumentedType,</b>
&nbsp;                                instrumentedMethod,
&nbsp;                                methodVisitor,
&nbsp;                                implementationContext,
&nbsp;                                assigner,
<b class="fc">&nbsp;                                argumentHandler.bindExit(adviceMethod, getThrowable().represents(NoExceptionHandler.class)),</b>
<b class="fc">&nbsp;                                methodSizeHandler.bindExit(adviceMethod),</b>
<b class="fc">&nbsp;                                stackMapFrameHandler.bindExit(adviceMethod),</b>
<b class="fc">&nbsp;                                suppressionHandler.bind(exceptionHandler),</b>
<b class="fc">&nbsp;                                relocationHandler.bind(instrumentedMethod, relocation),</b>
&nbsp;                                exceptionHandler);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Binds this dispatcher for resolution to a specific method.
&nbsp;                     *
&nbsp;                     * @param instrumentedType      A description of the instrumented type.
&nbsp;                     * @param instrumentedMethod    The instrumented method that is being bound.
&nbsp;                     * @param methodVisitor         The method visitor for writing to the instrumented method.
&nbsp;                     * @param implementationContext The implementation context to use.
&nbsp;                     * @param assigner              The assigner to use.
&nbsp;                     * @param argumentHandler       A handler for accessing values on the local variable array.
&nbsp;                     * @param methodSizeHandler     A handler for computing the method size requirements.
&nbsp;                     * @param stackMapFrameHandler  A handler for translating and injecting stack map frames.
&nbsp;                     * @param suppressionHandler    The bound suppression handler to use.
&nbsp;                     * @param relocationHandler     The bound relocation handler to use.
&nbsp;                     * @param exceptionHandler      The exception handler that is resolved for the instrumented method.
&nbsp;                     * @return An appropriate bound advice dispatcher.
&nbsp;                     */
&nbsp;                    private Bound doResolve(TypeDescription instrumentedType,
&nbsp;                                            MethodDescription instrumentedMethod,
&nbsp;                                            MethodVisitor methodVisitor,
&nbsp;                                            Implementation.Context implementationContext,
&nbsp;                                            Assigner assigner,
&nbsp;                                            ArgumentHandler.ForAdvice argumentHandler,
&nbsp;                                            MethodSizeHandler.ForAdvice methodSizeHandler,
&nbsp;                                            StackMapFrameHandler.ForAdvice stackMapFrameHandler,
&nbsp;                                            SuppressionHandler.Bound suppressionHandler,
&nbsp;                                            RelocationHandler.Bound relocationHandler,
&nbsp;                                            StackManipulation exceptionHandler) {
<b class="fc">&nbsp;                        List&lt;OffsetMapping.Target&gt; offsetMappings = new ArrayList&lt;OffsetMapping.Target&gt;(this.offsetMappings.size());</b>
<b class="fc">&nbsp;                        for (OffsetMapping offsetMapping : this.offsetMappings.values()) {</b>
<b class="fc">&nbsp;                            offsetMappings.add(offsetMapping.resolve(instrumentedType,</b>
&nbsp;                                    instrumentedMethod,
&nbsp;                                    assigner,
&nbsp;                                    argumentHandler,
&nbsp;                                    OffsetMapping.Sort.EXIT));
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new AdviceMethodWriter.ForMethodExit(adviceMethod,</b>
&nbsp;                                instrumentedType,
&nbsp;                                instrumentedMethod,
&nbsp;                                assigner,
&nbsp;                                postProcessor,
&nbsp;                                offsetMappings,
&nbsp;                                methodVisitor,
&nbsp;                                implementationContext,
&nbsp;                                argumentHandler,
&nbsp;                                methodSizeHandler,
&nbsp;                                stackMapFrameHandler,
&nbsp;                                suppressionHandler,
&nbsp;                                relocationHandler,
&nbsp;                                exceptionHandler,
&nbsp;                                delegator);
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ArgumentHandler.Factory getArgumentHandlerFactory() {
<b class="fc">&nbsp;                        return backupArguments</b>
<b class="fc">&nbsp;                                ? ArgumentHandler.Factory.COPYING</b>
<b class="fc">&nbsp;                                : ArgumentHandler.Factory.SIMPLE;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDefinition getAdviceType() {
<b class="fc">&nbsp;                        return adviceMethod.getReturnType();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of exit advice that handles exceptions.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    protected static class WithExceptionHandler extends Delegating.Resolved.ForMethodExit {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The type of the handled throwable type for which this advice is invoked.
&nbsp;                         */
&nbsp;                        private final TypeDescription throwable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method exit advice that handles exceptions.
&nbsp;                         *
&nbsp;                         * @param adviceMethod  The represented advice method.
&nbsp;                         * @param postProcessor The post processor factory to apply.
&nbsp;                         * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                         * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                         * @param enterType     The type of the value supplied by the enter advice method or
&nbsp;                         *                      a description of {@code void} if no such value exists.
&nbsp;                         * @param throwable     The type of the handled throwable type for which this advice is invoked.
&nbsp;                         * @param delegator     The delegator to use.
&nbsp;                         */
&nbsp;                        protected WithExceptionHandler(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                       PostProcessor postProcessor,
&nbsp;                                                       Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                       List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                       TypeDefinition enterType,
&nbsp;                                                       TypeDescription throwable,
&nbsp;                                                       Delegator delegator) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator);</b>
<b class="fc">&nbsp;                            this.throwable = throwable;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription getThrowable() {
<b class="fc">&nbsp;                            return throwable;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of exit advice that ignores exceptions.
&nbsp;                     */
&nbsp;                    protected static class WithoutExceptionHandler extends Delegating.Resolved.ForMethodExit {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new resolved dispatcher for implementing method exit advice that does not handle exceptions.
&nbsp;                         *
&nbsp;                         * @param adviceMethod  The represented advice method.
&nbsp;                         * @param postProcessor The post processor factory to apply.
&nbsp;                         * @param namedTypes    A mapping of all available local variables by their name to their type.
&nbsp;                         * @param userFactories A list of user-defined factories for offset mappings.
&nbsp;                         * @param enterType     The type of the value supplied by the enter advice method or
&nbsp;                         *                      a description of {@code void} if no such value exists.
&nbsp;                         * @param delegator     The delegator to use.
&nbsp;                         */
&nbsp;                        protected WithoutExceptionHandler(MethodDescription.InDefinedShape adviceMethod,
&nbsp;                                                          PostProcessor postProcessor,
&nbsp;                                                          Map&lt;String, TypeDefinition&gt; namedTypes,
&nbsp;                                                          List&lt;? extends OffsetMapping.Factory&lt;?&gt;&gt; userFactories,
&nbsp;                                                          TypeDefinition enterType,
&nbsp;                                                          Delegator delegator) {
<b class="fc">&nbsp;                            super(adviceMethod, postProcessor, namedTypes, userFactories, enterType, delegator);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeDescription getThrowable() {
<b class="fc">&nbsp;                            return NoExceptionHandler.DESCRIPTION;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method visitor that weaves the advice methods&#39; byte codes.
&nbsp;     */
&nbsp;    protected abstract static class AdviceVisitor extends ExceptionTableSensitiveMethodVisitor implements Dispatcher.RelocationHandler.Relocation {
&nbsp;
&nbsp;        /**
&nbsp;         * The expected index for the {@code this} variable.
&nbsp;         */
&nbsp;        private static final int THIS_VARIABLE_INDEX = 0;
&nbsp;
&nbsp;        /**
&nbsp;         * The expected name for the {@code this} variable.
&nbsp;         */
&nbsp;        private static final String THIS_VARIABLE_NAME = &quot;this&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the instrumented method.
&nbsp;         */
&nbsp;        protected final MethodDescription instrumentedMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * A label that indicates the start of the preparation of a user method execution.
&nbsp;         */
&nbsp;        private final Label preparationStart;
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to be used for method enter.
&nbsp;         */
&nbsp;        private final Dispatcher.Bound methodEnter;
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher to be used for method exit.
&nbsp;         */
&nbsp;        protected final Dispatcher.Bound methodExit;
&nbsp;
&nbsp;        /**
&nbsp;         * The handler for accessing arguments of the method&#39;s local variable array.
&nbsp;         */
&nbsp;        protected final ArgumentHandler.ForInstrumentedMethod argumentHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for computing the method size requirements.
&nbsp;         */
&nbsp;        protected final MethodSizeHandler.ForInstrumentedMethod methodSizeHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for translating and injecting stack map frames.
&nbsp;         */
&nbsp;        protected final StackMapFrameHandler.ForInstrumentedMethod stackMapFrameHandler;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new advice visitor.
&nbsp;         *
&nbsp;         * @param methodVisitor         The actual method visitor that is underlying this method visitor to which all instructions are written.
&nbsp;         * @param implementationContext The implementation context to use.
&nbsp;         * @param assigner              The assigner to use.
&nbsp;         * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;         * @param instrumentedType      A description of the instrumented type.
&nbsp;         * @param instrumentedMethod    The instrumented method.
&nbsp;         * @param methodEnter           The method enter advice.
&nbsp;         * @param methodExit            The method exit advice.
&nbsp;         * @param postMethodTypes       A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;         * @param writerFlags           The ASM writer flags that were set.
&nbsp;         * @param readerFlags           The ASM reader flags that were set.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR&quot;, justification = &quot;Self reference is not used before constructor completion.&quot;)
&nbsp;        protected AdviceVisitor(MethodVisitor methodVisitor,
&nbsp;                                Context implementationContext,
&nbsp;                                Assigner assigner,
&nbsp;                                StackManipulation exceptionHandler,
&nbsp;                                TypeDescription instrumentedType,
&nbsp;                                MethodDescription instrumentedMethod,
&nbsp;                                Dispatcher.Resolved.ForMethodEnter methodEnter,
&nbsp;                                Dispatcher.Resolved.ForMethodExit methodExit,
&nbsp;                                List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                int writerFlags,
&nbsp;                                int readerFlags) {
<b class="fc">&nbsp;            super(OpenedClassReader.ASM_API, methodVisitor);</b>
<b class="fc">&nbsp;            this.instrumentedMethod = instrumentedMethod;</b>
<b class="fc">&nbsp;            preparationStart = new Label();</b>
<b class="fc">&nbsp;            SortedMap&lt;String, TypeDefinition&gt; namedTypes = new TreeMap&lt;String, TypeDefinition&gt;();</b>
<b class="fc">&nbsp;            namedTypes.putAll(methodEnter.getNamedTypes());</b>
<b class="fc">&nbsp;            namedTypes.putAll(methodExit.getNamedTypes());</b>
<b class="fc">&nbsp;            argumentHandler = methodExit.getArgumentHandlerFactory().resolve(instrumentedMethod,</b>
<b class="fc">&nbsp;                    methodEnter.getAdviceType(),</b>
<b class="fc">&nbsp;                    methodExit.getAdviceType(),</b>
&nbsp;                    namedTypes);
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; initialTypes = CompoundList.of(methodExit.getAdviceType().represents(void.class)</b>
<b class="fc">&nbsp;                    ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                    : Collections.singletonList(methodExit.getAdviceType().asErasure()), argumentHandler.getNamedTypes());</b>
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; latentTypes = methodEnter.getActualAdviceType().represents(void.class)</b>
<b class="fc">&nbsp;                    ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                    : Collections.singletonList(methodEnter.getActualAdviceType().asErasure());</b>
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; preMethodTypes = methodEnter.getAdviceType().represents(void.class)</b>
<b class="fc">&nbsp;                    ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                    : Collections.singletonList(methodEnter.getAdviceType().asErasure());</b>
<b class="fc">&nbsp;            methodSizeHandler = MethodSizeHandler.Default.of(instrumentedMethod,</b>
&nbsp;                    initialTypes,
&nbsp;                    preMethodTypes,
&nbsp;                    postMethodTypes,
<b class="fc">&nbsp;                    argumentHandler.isCopyingArguments(),</b>
&nbsp;                    writerFlags);
<b class="fc">&nbsp;            stackMapFrameHandler = StackMapFrameHandler.Default.of(instrumentedType,</b>
&nbsp;                    instrumentedMethod,
&nbsp;                    initialTypes,
&nbsp;                    latentTypes,
&nbsp;                    preMethodTypes,
&nbsp;                    postMethodTypes,
<b class="fc">&nbsp;                    methodExit.isAlive(),</b>
<b class="fc">&nbsp;                    argumentHandler.isCopyingArguments(),</b>
<b class="fc">&nbsp;                    implementationContext.getClassFileVersion(),</b>
&nbsp;                    writerFlags,
&nbsp;                    readerFlags);
<b class="fc">&nbsp;            this.methodEnter = methodEnter.bind(instrumentedType,</b>
&nbsp;                    instrumentedMethod,
&nbsp;                    methodVisitor,
&nbsp;                    implementationContext,
&nbsp;                    assigner,
&nbsp;                    argumentHandler,
&nbsp;                    methodSizeHandler,
&nbsp;                    stackMapFrameHandler,
&nbsp;                    exceptionHandler,
&nbsp;                    this);
<b class="fc">&nbsp;            this.methodExit = methodExit.bind(instrumentedType,</b>
&nbsp;                    instrumentedMethod,
&nbsp;                    methodVisitor,
&nbsp;                    implementationContext,
&nbsp;                    assigner,
&nbsp;                    argumentHandler,
&nbsp;                    methodSizeHandler,
&nbsp;                    stackMapFrameHandler,
&nbsp;                    exceptionHandler,
&nbsp;                    new ForLabel(preparationStart));
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onAfterExceptionTable() {
<b class="fc">&nbsp;            methodEnter.prepare();</b>
<b class="fc">&nbsp;            onUserPrepare();</b>
<b class="fc">&nbsp;            methodExit.prepare();</b>
<b class="fc">&nbsp;            methodEnter.initialize();</b>
<b class="fc">&nbsp;            methodExit.initialize();</b>
<b class="fc">&nbsp;            stackMapFrameHandler.injectInitializationFrame(mv);</b>
<b class="fc">&nbsp;            methodEnter.apply();</b>
<b class="fc">&nbsp;            mv.visitLabel(preparationStart);</b>
<b class="fc">&nbsp;            methodSizeHandler.requireStackSize(argumentHandler.prepare(mv));</b>
<b class="fc">&nbsp;            stackMapFrameHandler.injectStartFrame(mv);</b>
<b class="fc">&nbsp;            mv.visitInsn(Opcodes.NOP);</b>
<b class="fc">&nbsp;            onUserStart();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked when the user method&#39;s exception handler (if any) is supposed to be prepared.
&nbsp;         */
&nbsp;        protected abstract void onUserPrepare();
&nbsp;
&nbsp;        /**
&nbsp;         * Writes the advice for entering the instrumented method.
&nbsp;         */
&nbsp;        protected abstract void onUserStart();
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onVisitVarInsn(int opcode, int offset) {
<b class="fc">&nbsp;            mv.visitVarInsn(opcode, argumentHandler.argument(offset));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected void onVisitIincInsn(int offset, int increment) {
<b class="fc">&nbsp;            mv.visitIincInsn(argumentHandler.argument(offset), increment);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onVisitFrame(int type, int localVariableLength, @MaybeNull Object[] localVariable, int stackSize, @MaybeNull Object[] stack) {
<b class="fc">&nbsp;            stackMapFrameHandler.translateFrame(mv, type, localVariableLength, localVariable, stackSize, stack);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void visitMaxs(int stackSize, int localVariableLength) {
<b class="fc">&nbsp;            onUserEnd();</b>
<b class="fc">&nbsp;            mv.visitMaxs(methodSizeHandler.compoundStackSize(stackSize), methodSizeHandler.compoundLocalVariableLength(localVariableLength));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void visitLocalVariable(String name, String descriptor, String signature, Label start, Label end, int offset) {
&nbsp;            // The &#39;this&#39; variable is exempt from remapping as it is assumed immutable and remapping it confuses debuggers to not display the variable.
<b class="fc">&nbsp;            mv.visitLocalVariable(name, descriptor, signature, start, end, offset == THIS_VARIABLE_INDEX &amp;&amp; THIS_VARIABLE_NAME.equals(name)</b>
<b class="fc">&nbsp;                    ? offset</b>
<b class="fc">&nbsp;                    : argumentHandler.argument(offset));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public AnnotationVisitor visitLocalVariableAnnotation(int typeReference,
&nbsp;                                                              TypePath typePath,
&nbsp;                                                              Label[] start,
&nbsp;                                                              Label[] end,
&nbsp;                                                              int[] offset,
&nbsp;                                                              String descriptor,
&nbsp;                                                              boolean visible) {
<b class="nc">&nbsp;            int[] translated = new int[offset.length];</b>
<b class="nc">&nbsp;            for (int index = 0; index &lt; offset.length; index++) {</b>
<b class="nc">&nbsp;                translated[index] = argumentHandler.argument(offset[index]);</b>
&nbsp;            }
<b class="nc">&nbsp;            return mv.visitLocalVariableAnnotation(typeReference, typePath, start, end, translated, descriptor, visible);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Writes the advice for completing the instrumented method.
&nbsp;         */
&nbsp;        protected abstract void onUserEnd();
&nbsp;
&nbsp;        /**
&nbsp;         * An advice visitor that does not apply exit advice.
&nbsp;         */
&nbsp;        protected static class WithoutExitAdvice extends AdviceVisitor {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an advice visitor that does not apply exit advice.
&nbsp;             *
&nbsp;             * @param methodVisitor         The method visitor for the instrumented method.
&nbsp;             * @param implementationContext The implementation context to use.
&nbsp;             * @param assigner              The assigner to use.
&nbsp;             * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;             * @param instrumentedType      A description of the instrumented type.
&nbsp;             * @param instrumentedMethod    A description of the instrumented method.
&nbsp;             * @param methodEnter           The dispatcher to be used for method enter.
&nbsp;             * @param writerFlags           The ASM writer flags that were set.
&nbsp;             * @param readerFlags           The ASM reader flags that were set.
&nbsp;             */
&nbsp;            protected WithoutExitAdvice(MethodVisitor methodVisitor,
&nbsp;                                        Implementation.Context implementationContext,
&nbsp;                                        Assigner assigner,
&nbsp;                                        StackManipulation exceptionHandler,
&nbsp;                                        TypeDescription instrumentedType,
&nbsp;                                        MethodDescription instrumentedMethod,
&nbsp;                                        Dispatcher.Resolved.ForMethodEnter methodEnter,
&nbsp;                                        int writerFlags,
&nbsp;                                        int readerFlags) {
<b class="fc">&nbsp;                super(methodVisitor,</b>
&nbsp;                        implementationContext,
&nbsp;                        assigner,
&nbsp;                        exceptionHandler,
&nbsp;                        instrumentedType,
&nbsp;                        instrumentedMethod,
&nbsp;                        methodEnter,
&nbsp;                        Dispatcher.Inactive.INSTANCE,
<b class="fc">&nbsp;                        Collections.&lt;TypeDescription&gt;emptyList(),</b>
&nbsp;                        writerFlags,
&nbsp;                        readerFlags);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                if (instrumentedMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.IRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.LRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.FRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.DRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.RETURN);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ARETURN);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected void onUserPrepare() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected void onUserStart() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected void onUserEnd() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An advice visitor that applies exit advice.
&nbsp;         */
&nbsp;        protected abstract static class WithExitAdvice extends AdviceVisitor {
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates the handler for the value returned by the advice method.
&nbsp;             */
&nbsp;            protected final Label returnHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an advice visitor that applies exit advice.
&nbsp;             *
&nbsp;             * @param methodVisitor         The method visitor for the instrumented method.
&nbsp;             * @param implementationContext The implementation context to use.
&nbsp;             * @param assigner              The assigner to use.
&nbsp;             * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;             * @param instrumentedType      A description of the instrumented type.
&nbsp;             * @param instrumentedMethod    A description of the instrumented method.
&nbsp;             * @param methodEnter           The dispatcher to be used for method enter.
&nbsp;             * @param methodExit            The dispatcher to be used for method exit.
&nbsp;             * @param postMethodTypes       A list of virtual method arguments that are available after the instrumented method has completed.
&nbsp;             * @param writerFlags           The ASM writer flags that were set.
&nbsp;             * @param readerFlags           The ASM reader flags that were set.
&nbsp;             */
&nbsp;            protected WithExitAdvice(MethodVisitor methodVisitor,
&nbsp;                                     Implementation.Context implementationContext,
&nbsp;                                     Assigner assigner,
&nbsp;                                     StackManipulation exceptionHandler,
&nbsp;                                     TypeDescription instrumentedType,
&nbsp;                                     MethodDescription instrumentedMethod,
&nbsp;                                     Dispatcher.Resolved.ForMethodEnter methodEnter,
&nbsp;                                     Dispatcher.Resolved.ForMethodExit methodExit,
&nbsp;                                     List&lt;? extends TypeDescription&gt; postMethodTypes,
&nbsp;                                     int writerFlags,
&nbsp;                                     int readerFlags) {
<b class="fc">&nbsp;                super(StackAwareMethodVisitor.of(methodVisitor, instrumentedMethod),</b>
&nbsp;                        implementationContext,
&nbsp;                        assigner,
&nbsp;                        exceptionHandler,
&nbsp;                        instrumentedType,
&nbsp;                        instrumentedMethod,
&nbsp;                        methodEnter,
&nbsp;                        methodExit,
&nbsp;                        postMethodTypes,
&nbsp;                        writerFlags,
&nbsp;                        readerFlags);
<b class="fc">&nbsp;                returnHandler = new Label();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public void apply(MethodVisitor methodVisitor) {
<b class="fc">&nbsp;                if (instrumentedMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                } else if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                    methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
&nbsp;                }
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.GOTO, returnHandler);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected void onVisitInsn(int opcode) {
<b class="fc">&nbsp;                switch (opcode) {</b>
&nbsp;                    case Opcodes.RETURN:
<b class="fc">&nbsp;                        ((StackAwareMethodVisitor) mv).drainStack();</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.IRETURN:
<b class="fc">&nbsp;                        methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.ISTORE, Opcodes.ILOAD, StackSize.SINGLE));</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.FRETURN:
<b class="fc">&nbsp;                        methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.FSTORE, Opcodes.FLOAD, StackSize.SINGLE));</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.DRETURN:
<b class="fc">&nbsp;                        methodSizeHandler.requireLocalVariableLength(((StackAwareMethodVisitor) mv).drainStack(Opcodes.DSTORE, Opcodes.DLOAD, StackSize.DOUBLE));</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.LRETURN:
<b class="fc">&nbsp;                        methodSizeHandler.requireLocalVariableLength((((StackAwareMethodVisitor) mv).drainStack(Opcodes.LSTORE, Opcodes.LLOAD, StackSize.DOUBLE)));</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    case Opcodes.ARETURN:
<b class="fc">&nbsp;                        methodSizeHandler.requireLocalVariableLength((((StackAwareMethodVisitor) mv).drainStack(Opcodes.ASTORE, Opcodes.ALOAD, StackSize.SINGLE)));</b>
<b class="fc">&nbsp;                        break;</b>
&nbsp;                    default:
<b class="fc">&nbsp;                        mv.visitInsn(opcode);</b>
&nbsp;                        return;
&nbsp;                }
<b class="fc">&nbsp;                mv.visitJumpInsn(Opcodes.GOTO, returnHandler);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected void onUserEnd() {
<b class="fc">&nbsp;                mv.visitLabel(returnHandler);</b>
<b class="fc">&nbsp;                onUserReturn();</b>
<b class="fc">&nbsp;                stackMapFrameHandler.injectCompletionFrame(mv);</b>
<b class="fc">&nbsp;                methodExit.apply();</b>
<b class="fc">&nbsp;                onExitAdviceReturn();</b>
<b class="fc">&nbsp;                if (instrumentedMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                        || instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.ILOAD, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.IRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.LLOAD, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.LRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.FLOAD, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.FRETURN);</b>
<b class="fc">&nbsp;                } else if (instrumentedMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.DLOAD, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.DRETURN);</b>
<b class="fc">&nbsp;                } else if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.ALOAD, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.ARETURN);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.RETURN);</b>
&nbsp;                }
<b class="fc">&nbsp;                methodSizeHandler.requireStackSize(instrumentedMethod.getReturnType().getStackSize().getSize());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked after the user method has returned.
&nbsp;             */
&nbsp;            protected abstract void onUserReturn();
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked after the exit advice method has returned.
&nbsp;             */
&nbsp;            protected abstract void onExitAdviceReturn();
&nbsp;
&nbsp;            /**
&nbsp;             * An advice visitor that does not capture exceptions.
&nbsp;             */
&nbsp;            protected static class WithoutExceptionHandling extends WithExitAdvice {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new advice visitor that does not capture exceptions.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         The method visitor for the instrumented method.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param assigner              The assigner to use.
&nbsp;                 * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;                 * @param instrumentedType      A description of the instrumented type.
&nbsp;                 * @param instrumentedMethod    A description of the instrumented method.
&nbsp;                 * @param methodEnter           The dispatcher to be used for method enter.
&nbsp;                 * @param methodExit            The dispatcher to be used for method exit.
&nbsp;                 * @param writerFlags           The ASM writer flags that were set.
&nbsp;                 * @param readerFlags           The ASM reader flags that were set.
&nbsp;                 */
&nbsp;                protected WithoutExceptionHandling(MethodVisitor methodVisitor,
&nbsp;                                                   Implementation.Context implementationContext,
&nbsp;                                                   Assigner assigner,
&nbsp;                                                   StackManipulation exceptionHandler,
&nbsp;                                                   TypeDescription instrumentedType,
&nbsp;                                                   MethodDescription instrumentedMethod,
&nbsp;                                                   Dispatcher.Resolved.ForMethodEnter methodEnter,
&nbsp;                                                   Dispatcher.Resolved.ForMethodExit methodExit,
&nbsp;                                                   int writerFlags,
&nbsp;                                                   int readerFlags) {
<b class="fc">&nbsp;                    super(methodVisitor,</b>
&nbsp;                            implementationContext,
&nbsp;                            assigner,
&nbsp;                            exceptionHandler,
&nbsp;                            instrumentedType,
&nbsp;                            instrumentedMethod,
&nbsp;                            methodEnter,
&nbsp;                            methodExit,
<b class="fc">&nbsp;                            instrumentedMethod.getReturnType().represents(void.class)</b>
<b class="fc">&nbsp;                                    ? Collections.&lt;TypeDescription&gt;emptyList()</b>
<b class="fc">&nbsp;                                    : Collections.singletonList(instrumentedMethod.getReturnType().asErasure()),</b>
&nbsp;                            writerFlags,
&nbsp;                            readerFlags);
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onUserPrepare() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onUserStart() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onUserReturn() {
<b class="fc">&nbsp;                    if (instrumentedMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(mv);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.ISTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(mv);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.LSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(mv);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.FSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(mv);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.DSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                        stackMapFrameHandler.injectReturnFrame(mv);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.returned());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onExitAdviceReturn() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An advice visitor that captures exceptions by weaving try-catch blocks around user code.
&nbsp;             */
&nbsp;            protected static class WithExceptionHandling extends WithExitAdvice {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of the handled throwable type for which this advice is invoked.
&nbsp;                 */
&nbsp;                private final TypeDescription throwable;
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates the exception handler.
&nbsp;                 */
&nbsp;                private final Label exceptionHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates the start of the user method.
&nbsp;                 */
&nbsp;                protected final Label userStart;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new advice visitor that captures exception by weaving try-catch blocks around user code.
&nbsp;                 *
&nbsp;                 * @param methodVisitor         The method visitor for the instrumented method.
&nbsp;                 * @param instrumentedType      A description of the instrumented type.
&nbsp;                 * @param implementationContext The implementation context to use.
&nbsp;                 * @param assigner              The assigner to use.
&nbsp;                 * @param exceptionHandler      The stack manipulation to apply within a suppression handler.
&nbsp;                 * @param instrumentedMethod    A description of the instrumented method.
&nbsp;                 * @param methodEnter           The dispatcher to be used for method enter.
&nbsp;                 * @param methodExit            The dispatcher to be used for method exit.
&nbsp;                 * @param writerFlags           The ASM writer flags that were set.
&nbsp;                 * @param readerFlags           The ASM reader flags that were set.
&nbsp;                 * @param throwable             The type of the handled throwable type for which this advice is invoked.
&nbsp;                 */
&nbsp;                protected WithExceptionHandling(MethodVisitor methodVisitor,
&nbsp;                                                Implementation.Context implementationContext,
&nbsp;                                                Assigner assigner,
&nbsp;                                                StackManipulation exceptionHandler,
&nbsp;                                                TypeDescription instrumentedType,
&nbsp;                                                MethodDescription instrumentedMethod,
&nbsp;                                                Dispatcher.Resolved.ForMethodEnter methodEnter,
&nbsp;                                                Dispatcher.Resolved.ForMethodExit methodExit,
&nbsp;                                                int writerFlags,
&nbsp;                                                int readerFlags,
&nbsp;                                                TypeDescription throwable) {
<b class="fc">&nbsp;                    super(methodVisitor,</b>
&nbsp;                            implementationContext,
&nbsp;                            assigner,
&nbsp;                            exceptionHandler,
&nbsp;                            instrumentedType,
&nbsp;                            instrumentedMethod,
&nbsp;                            methodEnter,
&nbsp;                            methodExit,
<b class="fc">&nbsp;                            instrumentedMethod.getReturnType().represents(void.class)</b>
<b class="fc">&nbsp;                                    ? Collections.singletonList(TypeDescription.ForLoadedType.of(Throwable.class))</b>
<b class="fc">&nbsp;                                    : Arrays.asList(instrumentedMethod.getReturnType().asErasure(), TypeDescription.ForLoadedType.of(Throwable.class)),</b>
&nbsp;                            writerFlags,
&nbsp;                            readerFlags);
<b class="fc">&nbsp;                    this.throwable = throwable;</b>
<b class="fc">&nbsp;                    this.exceptionHandler = new Label();</b>
<b class="fc">&nbsp;                    userStart = new Label();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onUserPrepare() {
<b class="fc">&nbsp;                    mv.visitTryCatchBlock(userStart, returnHandler, exceptionHandler, throwable.getInternalName());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onUserStart() {
<b class="fc">&nbsp;                    mv.visitLabel(userStart);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onUserReturn() {
<b class="fc">&nbsp;                    stackMapFrameHandler.injectReturnFrame(mv);</b>
<b class="fc">&nbsp;                    if (instrumentedMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.ISTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.LSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.FSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.DSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.returned());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.thrown());</b>
<b class="fc">&nbsp;                    Label endOfHandler = new Label();</b>
<b class="fc">&nbsp;                    mv.visitJumpInsn(Opcodes.GOTO, endOfHandler);</b>
<b class="fc">&nbsp;                    mv.visitLabel(exceptionHandler);</b>
<b class="fc">&nbsp;                    stackMapFrameHandler.injectExceptionFrame(mv);</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.thrown());</b>
<b class="fc">&nbsp;                    if (instrumentedMethod.getReturnType().represents(boolean.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(byte.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(short.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(char.class)</b>
<b class="fc">&nbsp;                            || instrumentedMethod.getReturnType().represents(int.class)) {</b>
<b class="fc">&nbsp;                        mv.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.ISTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(long.class)) {</b>
<b class="fc">&nbsp;                        mv.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.LSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(float.class)) {</b>
<b class="fc">&nbsp;                        mv.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.FSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.getReturnType().represents(double.class)) {</b>
<b class="fc">&nbsp;                        mv.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.DSTORE, argumentHandler.returned());</b>
<b class="fc">&nbsp;                    } else if (!instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                        mv.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;                        mv.visitVarInsn(Opcodes.ASTORE, argumentHandler.returned());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    mv.visitLabel(endOfHandler);</b>
<b class="fc">&nbsp;                    methodSizeHandler.requireStackSize(StackSize.SINGLE.getSize());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected void onExitAdviceReturn() {
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.ALOAD, argumentHandler.thrown());</b>
<b class="fc">&nbsp;                    Label endOfHandler = new Label();</b>
<b class="fc">&nbsp;                    mv.visitJumpInsn(Opcodes.IFNULL, endOfHandler);</b>
<b class="fc">&nbsp;                    mv.visitVarInsn(Opcodes.ALOAD, argumentHandler.thrown());</b>
<b class="fc">&nbsp;                    mv.visitInsn(Opcodes.ATHROW);</b>
<b class="fc">&nbsp;                    mv.visitLabel(endOfHandler);</b>
<b class="fc">&nbsp;                    stackMapFrameHandler.injectPostCompletionFrame(mv);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A byte code appender for implementing {@link Advice}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class Appender implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The advice to implement.
&nbsp;         */
&nbsp;        private final Advice advice;
&nbsp;
&nbsp;        /**
&nbsp;         * The current implementation target.
&nbsp;         */
&nbsp;        private final Implementation.Target implementationTarget;
&nbsp;
&nbsp;        /**
&nbsp;         * The delegate byte code appender.
&nbsp;         */
&nbsp;        private final ByteCodeAppender delegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new appender for an advice component.
&nbsp;         *
&nbsp;         * @param advice               The advice to implement.
&nbsp;         * @param implementationTarget The current implementation target.
&nbsp;         * @param delegate             The delegate byte code appender.
&nbsp;         */
<b class="fc">&nbsp;        protected Appender(Advice advice, Target implementationTarget, ByteCodeAppender delegate) {</b>
<b class="fc">&nbsp;            this.advice = advice;</b>
<b class="fc">&nbsp;            this.implementationTarget = implementationTarget;</b>
<b class="fc">&nbsp;            this.delegate = delegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            EmulatingMethodVisitor emulatingMethodVisitor = new EmulatingMethodVisitor(methodVisitor, delegate);</b>
<b class="fc">&nbsp;            methodVisitor = advice.doWrap(implementationTarget.getInstrumentedType(),</b>
&nbsp;                    instrumentedMethod,
&nbsp;                    emulatingMethodVisitor,
&nbsp;                    implementationContext,
&nbsp;                    AsmVisitorWrapper.NO_FLAGS,
&nbsp;                    AsmVisitorWrapper.NO_FLAGS);
<b class="fc">&nbsp;            return emulatingMethodVisitor.resolve(methodVisitor, implementationContext, instrumentedMethod);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method visitor that allows for the emulation of a full method visitor invocation circle without delegating initial
&nbsp;         * and ending visitations to the underlying visitor.
&nbsp;         */
&nbsp;        protected static class EmulatingMethodVisitor extends MethodVisitor {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate byte code appender.
&nbsp;             */
&nbsp;            private final ByteCodeAppender delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * The currently recorded minimal required stack size.
&nbsp;             */
&nbsp;            private int stackSize;
&nbsp;
&nbsp;            /**
&nbsp;             * The currently recorded minimal required local variable array length.
&nbsp;             */
&nbsp;            private int localVariableLength;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new emulating method visitor.
&nbsp;             *
&nbsp;             * @param methodVisitor The underlying method visitor.
&nbsp;             * @param delegate      The delegate byte code appender.
&nbsp;             */
&nbsp;            protected EmulatingMethodVisitor(MethodVisitor methodVisitor, ByteCodeAppender delegate) {
<b class="fc">&nbsp;                super(OpenedClassReader.ASM_API, methodVisitor);</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves this this advice emulating method visitor for its delegate.
&nbsp;             *
&nbsp;             * @param methodVisitor         The method visitor to apply.
&nbsp;             * @param implementationContext The implementation context to apply.
&nbsp;             * @param instrumentedMethod    The instrumented method.
&nbsp;             * @return The resulting size of the implemented method.
&nbsp;             */
&nbsp;            protected ByteCodeAppender.Size resolve(MethodVisitor methodVisitor,
&nbsp;                                                    Implementation.Context implementationContext,
&nbsp;                                                    MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;                methodVisitor.visitCode();</b>
<b class="fc">&nbsp;                Size size = delegate.apply(methodVisitor, implementationContext, instrumentedMethod);</b>
<b class="fc">&nbsp;                methodVisitor.visitMaxs(size.getOperandStackSize(), size.getLocalVariableSize());</b>
<b class="fc">&nbsp;                methodVisitor.visitEnd();</b>
<b class="fc">&nbsp;                return new ByteCodeAppender.Size(stackSize, localVariableLength);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitCode() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitMaxs(int stackSize, int localVariableLength) {
<b class="fc">&nbsp;                this.stackSize = stackSize;</b>
<b class="fc">&nbsp;                this.localVariableLength = localVariableLength;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void visitEnd() {
&nbsp;                /* do nothing */
<b class="fc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that this method should be inlined before the matched method is invoked. Any class must declare
&nbsp;     * at most one method with this annotation. The annotated method must be static. When instrumenting constructors,
&nbsp;     * the {@code this} values can only be accessed for writing fields but not for reading fields or invoking methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * The annotated method can return a value that is made accessible to another method annotated by {@link OnMethodExit}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see Argument
&nbsp;     * @see This
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;    public @interface OnMethodEnter {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Determines if the execution of the instrumented method should be skipped. This does not include any exit advice.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When specifying a non-primitive type, this method&#39;s return value that is subject to an {@code instanceof} check where
&nbsp;         * the instrumented method is only executed, if the returned instance is {@code not} an instance of the specified class.
&nbsp;         * Alternatively, it is possible to specify either {@link OnDefaultValue} or {@link OnNonDefaultValue} where the instrumented
&nbsp;         * method is only executed if the advice method returns a default or non-default value of the advice method&#39;s return type.
&nbsp;         * It is illegal to specify a primitive type as an argument whereas setting the value to {@code void} indicates that the
&nbsp;         * instrumented method should never be skipped.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Constructors cannot be skipped.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A value defining what return values of the advice method indicate that the instrumented method
&nbsp;         * should be skipped or {@code void} if the instrumented method should never be skipped.
&nbsp;         */
&nbsp;        Class&lt;?&gt; skipOn() default void.class;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the value to be used for {@link OnMethodEnter#skipOn()} should be read from an array that is returned by
&nbsp;         * the advice method, if the assigned property is non-negative. If the returned array is shorter than the supplied index,
&nbsp;         * an {@link ArrayIndexOutOfBoundsException} will be thrown, even if suppression is used.
&nbsp;         *
&nbsp;         * @return The array index for the value to be considered for skipping a method, or a negative value for using the returned value.
&nbsp;         */
&nbsp;        int skipOnIndex() default -1;
&nbsp;
&nbsp;        /**
&nbsp;         * If set to {@code true}, the instrumented method&#39;s line number information is adjusted such that stack traces generated within
&nbsp;         * this advice method appear as if they were generated within the first line of the instrumented method. If set to {@code false},
&nbsp;         * no line number information is made available for such stack traces.
&nbsp;         *
&nbsp;         * @return {@code true} if this advice code should appear as if it was added within the first line of the instrumented method.
&nbsp;         */
&nbsp;        boolean prependLineNumber() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the annotated method should be inlined into the instrumented method or invoked from it. When a method
&nbsp;         * is inlined, its byte code is copied into the body of the target method. this makes it is possible to execute code
&nbsp;         * with the visibility privileges of the instrumented method while loosing the privileges of the declared method methods.
&nbsp;         * When a method is not inlined, it is invoked similarly to a common Java method call. Note that it is not possible to
&nbsp;         * set breakpoints within a method when it is inlined as no debugging information is copied from the advice method into
&nbsp;         * the instrumented method.
&nbsp;         *
&nbsp;         * @return {@code true} if the annotated method should be inlined into the instrumented method.
&nbsp;         */
&nbsp;        boolean inline() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that this advice should suppress any {@link Throwable} type being thrown during the advice&#39;s execution. By default,
&nbsp;         * any such exception is silently suppressed. Custom behavior can be configured by using {@link Advice#withExceptionHandler(StackManipulation)}.
&nbsp;         *
&nbsp;         * @return The type of {@link Throwable} to suppress.
&nbsp;         * @see Advice#withExceptionPrinting()
&nbsp;         */
&nbsp;        Class&lt;? extends Throwable&gt; suppress() default NoExceptionHandler.class;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that this method should be executed before exiting the instrumented method. Any class must declare
&nbsp;     * at most one method with this annotation. The annotated method must be static.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * By default, the annotated method is not invoked if the instrumented method terminates exceptionally. This behavior
&nbsp;     * can be changed by setting the {@link OnMethodExit#onThrowable()} property to an exception type for which this advice
&nbsp;     * method should be invoked. By setting the value to {@link Throwable}, the advice method is always invoked.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see Argument
&nbsp;     * @see This
&nbsp;     * @see Enter
&nbsp;     * @see Return
&nbsp;     * @see Thrown
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;    public @interface OnMethodExit {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Determines if the execution of the instrumented method should be repeated. This does not include any enter advice.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * When specifying a non-primitive type, this method&#39;s return value that is subject to an {@code instanceof} check where
&nbsp;         * the instrumented method is only executed, if the returned instance is {@code not} an instance of the specified class.
&nbsp;         * Alternatively, it is possible to specify either {@link OnDefaultValue} or {@link OnNonDefaultValue} where the instrumented
&nbsp;         * method is only repeated if the advice method returns a default or non-default value of the advice method&#39;s return type.
&nbsp;         * It is illegal to specify a primitive type as an argument whereas setting the value to {@code void} indicates that the
&nbsp;         * instrumented method should never be repeated.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: Constructors cannot be repeated.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A value defining what return values of the advice method indicate that the instrumented method
&nbsp;         * should be repeated or {@code void} if the instrumented method should never be repeated.
&nbsp;         */
&nbsp;        Class&lt;?&gt; repeatOn() default void.class;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the value to be used for {@link OnMethodExit#repeatOn()} should be read from an array that is returned by
&nbsp;         * the advice method, if the assigned property is non-negative. If the returned array is shorter than the supplied index,
&nbsp;         * an {@link ArrayIndexOutOfBoundsException} will be thrown, even if suppression is used.
&nbsp;         *
&nbsp;         * @return The array index for the value to be considered for repeating a method, or a negative value for using the returned value.
&nbsp;         */
&nbsp;        int repeatOnIndex() default -1;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates a {@link Throwable} super type for which this exit advice is invoked if it was thrown from the instrumented method.
&nbsp;         * If an exception is thrown, it is available via the {@link Thrown} parameter annotation. If a method returns exceptionally,
&nbsp;         * any parameter annotated with {@link Return} is assigned the parameter type&#39;s default value.
&nbsp;         *
&nbsp;         * @return The type of {@link Throwable} for which this exit advice handler is invoked.
&nbsp;         */
&nbsp;        Class&lt;? extends Throwable&gt; onThrowable() default NoExceptionHandler.class;
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * If {@code true}, all arguments of the instrumented method are copied before execution. Doing so, parameter reassignments applied
&nbsp;         * by the instrumented are not effective during the execution of the annotated exit advice.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Disabling this option can cause problems with the translation of stack map frames (meta data that is embedded in a Java class) if these
&nbsp;         * frames become inconsistent with the original arguments of the instrumented method. In this case, the original arguments are no longer
&nbsp;         * available to the exit advice such that Byte Buddy must abort the instrumentation with an error. If the instrumented method does not issue
&nbsp;         * a stack map frame due to a lack of branching instructions, Byte Buddy might not be able to discover such an inconsistency what can cause
&nbsp;         * a {@link VerifyError} instead of a Byte Buddy-issued exception as those inconsistencies are not discovered.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if a backup of all method arguments should be made.
&nbsp;         */
&nbsp;        boolean backupArguments() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the annotated method should be inlined into the instrumented method or invoked from it. When a method
&nbsp;         * is inlined, its byte code is copied into the body of the target method. this makes it is possible to execute code
&nbsp;         * with the visibility privileges of the instrumented method while loosing the privileges of the declared method methods.
&nbsp;         * When a method is not inlined, it is invoked similarly to a common Java method call. Note that it is not possible to
&nbsp;         * set breakpoints within a method when it is inlined as no debugging information is copied from the advice method into
&nbsp;         * the instrumented method.
&nbsp;         *
&nbsp;         * @return {@code true} if the annotated method should be inlined into the instrumented method.
&nbsp;         */
&nbsp;        boolean inline() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that this advice should suppress any {@link Throwable} type being thrown during the advice&#39;s execution. By default,
&nbsp;         * any such exception is silently suppressed. Custom behavior can be configured by using {@link Advice#withExceptionHandler(StackManipulation)}.
&nbsp;         *
&nbsp;         * @return The type of {@link Throwable} to suppress.
&nbsp;         * @see Advice#withExceptionPrinting()
&nbsp;         */
&nbsp;        Class&lt;? extends Throwable&gt; suppress() default NoExceptionHandler.class;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the {@code this} reference of the instrumented method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Parameters with this option must not be used when from a constructor in combination with
&nbsp;     * {@link OnMethodEnter} where the {@code this} reference is not available.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.This} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.This}. This annotation should be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface This {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the {@code this} value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the parameter should be assigned {@code null} if the instrumented method is static or a constructor within an enter advice.
&nbsp;         *
&nbsp;         * @return {@code true} if the value assignment is optional.
&nbsp;         */
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the parameter with index {@link Argument#value()} of
&nbsp;     * the instrumented method.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.Argument} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.Argument}. This annotation should be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Argument {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the index of the mapped parameter.
&nbsp;         *
&nbsp;         * @return The index of the mapped parameter.
&nbsp;         */
&nbsp;        int value();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the argument.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates if a parameter binding is optional. If a binding is optional and a parameter with the specified index does not exist,
&nbsp;         * the parameter&#39;s default value is bound.
&nbsp;         *
&nbsp;         * @return {@code true} if the binding is optional.
&nbsp;         */
&nbsp;        boolean optional() default false;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Assigns an array containing all arguments of the instrumented method to the annotated parameter. The annotated parameter must
&nbsp;     * be an array type. If the annotation indicates writability, the assigned array must have at least as many values as the
&nbsp;     * instrumented method or an {@link ArrayIndexOutOfBoundsException} is thrown.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.AllArguments} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.AllArguments}. This annotation should be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface AllArguments {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the arguments.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the produced array should include the instrumented method&#39;s target reference within the array, if
&nbsp;         * the instrumented method is non-static.
&nbsp;         *
&nbsp;         * @return {@code true} if the method&#39;s target instance should be considered an element of the produced array.
&nbsp;         */
&nbsp;        boolean includeSelf() default false;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if a {@code null} value should be assigned if the instrumented method does not declare any parameters.
&nbsp;         * If this option is set and a value is written to annotated parameter, the operation remains without effect.
&nbsp;         *
&nbsp;         * @return {@code true} if a {@code null} value should be assigned if the instrumented method does not declare any parameters.
&nbsp;         */
&nbsp;        boolean nullIfEmpty() default false;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the return value of the instrumented method. If the instrumented
&nbsp;     * method terminates exceptionally, the type&#39;s default value is assigned to the parameter, i.e. {@code 0} for numeric types
&nbsp;     * and {@code null} for reference types. If the return type is {@code void}, the annotated value is {@code null} if and only if
&nbsp;     * {@link Return#typing()} is set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This annotation must only be used on {@link OnMethodExit} advice methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Return {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the typing that is applied when assigning the return value.
&nbsp;         *
&nbsp;         * @return The typing to apply when assigning the annotated parameter.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the {@link Throwable} thrown by the instrumented method or to {@code null}
&nbsp;     * if the method returned regularly. Note that the Java runtime does not enforce checked exceptions. In order to capture any error, the parameter
&nbsp;     * type must therefore be of type {@link Throwable}. By assigning another value or {@code null} to this parameter, a thrown exception can be
&nbsp;     * suppressed.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: This annotation must only be used on {@link OnMethodExit} advice methods.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Thrown {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the typing that is applied when assigning the captured {@link Throwable} to the annotated parameter.
&nbsp;         *
&nbsp;         * @return The typing to apply when assigning the annotated parameter.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.DYNAMIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should load a {@code java.lang.invoke.MethodHandle} that represents an invocation of
&nbsp;     * the current method. If the current method is virtual, it is bound to the current instance such that the virtual hierarchy
&nbsp;     * is avoided. This annotation can only be used on methods, not constructors.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.SelfCallHandle}. This annotation should
&nbsp;     * be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface SelfCallHandle {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the method is bound to the arguments and instance of the current invocation.
&nbsp;         *
&nbsp;         * @return {@code true} if the handle should be bound to the current arguments.
&nbsp;         */
&nbsp;        boolean bound() default true;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a field in the scope of the instrumented type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Setting {@link FieldValue#value()} is optional. If the value is not set, the field value attempts to bind a setter&#39;s
&nbsp;     * or getter&#39;s field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
&nbsp;     * to be an illegal candidate for binding.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Parameters with this option must not be used when from a constructor in combination with
&nbsp;     * {@link OnMethodEnter} and a non-static field where the {@code this} reference is not available.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: As the mapping is virtual, Byte Buddy might be required to reserve more space on the operand stack than the
&nbsp;     * optimal value when accessing this parameter. This does not normally matter as the additional space requirement is minimal.
&nbsp;     * However, if the runtime performance of class creation is secondary, one can require ASM to recompute the optimal frames by
&nbsp;     * setting {@link ClassWriter#COMPUTE_MAXS}. This is however only relevant when writing to a non-static field.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.FieldValue} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.FieldValue}. This annotation should
&nbsp;     * be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface FieldValue {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the field.
&nbsp;         *
&nbsp;         * @return The name of the field.
&nbsp;         */
&nbsp;        String value() default OffsetMapping.ForField.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type that declares the field that should be mapped to the annotated parameter. If this property
&nbsp;         * is set to {@code void}, the field is looked up implicitly within the instrumented class&#39;s class hierarchy.
&nbsp;         * The value can also be set to {@link TargetType} in order to look up the type on the instrumented type.
&nbsp;         *
&nbsp;         * @return The type that declares the field, {@code void} if this type should be determined implicitly or
&nbsp;         * {@link TargetType} for the instrumented type.
&nbsp;         */
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the field value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a {@code java.lang.invoke.MethodHandle} representing a field getter.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Setting {@link FieldValue#value()} is optional. If the value is not set, the field value attempts to bind a setter&#39;s
&nbsp;     * or getter&#39;s field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
&nbsp;     * to be an illegal candidate for binding.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Parameters with this option must not be used when from a constructor in combination with
&nbsp;     * {@link OnMethodEnter} and a non-static field where the {@code this} reference is not available.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.FieldGetterHandle} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.FieldGetterHandle}. This annotation should
&nbsp;     * be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface FieldGetterHandle {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the field.
&nbsp;         *
&nbsp;         * @return The name of the field.
&nbsp;         */
&nbsp;        String value() default OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type that declares the field that should be mapped to the annotated parameter. If this property
&nbsp;         * is set to {@code void}, the field is looked up implicitly within the instrumented class&#39;s class hierarchy.
&nbsp;         * The value can also be set to {@link TargetType} in order to look up the type on the instrumented type.
&nbsp;         *
&nbsp;         * @return The type that declares the field, {@code void} if this type should be determined implicitly or
&nbsp;         * {@link TargetType} for the instrumented type.
&nbsp;         */
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a {@code java.lang.invoke.MethodHandle} representing a field setter.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Setting {@link FieldValue#value()} is optional. If the value is not set, the field value attempts to bind a setter&#39;s
&nbsp;     * or getter&#39;s field if the intercepted method is an accessor method. Otherwise, the binding renders the target method
&nbsp;     * to be an illegal candidate for binding.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Parameters with this option must not be used when from a constructor in combination with
&nbsp;     * {@link OnMethodEnter} and a non-static field where the {@code this} reference is not available.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.FieldSetterHandle} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.FieldSetterHandle}. This annotation should
&nbsp;     * be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface FieldSetterHandle {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the field.
&nbsp;         *
&nbsp;         * @return The name of the field.
&nbsp;         */
&nbsp;        String value() default OffsetMapping.ForFieldHandle.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type that declares the field that should be mapped to the annotated parameter. If this property
&nbsp;         * is set to {@code void}, the field is looked up implicitly within the instrumented class&#39;s class hierarchy.
&nbsp;         * The value can also be set to {@link TargetType} in order to look up the type on the instrumented type.
&nbsp;         *
&nbsp;         * @return The type that declares the field, {@code void} if this type should be determined implicitly or
&nbsp;         * {@link TargetType} for the instrumented type.
&nbsp;         */
&nbsp;        Class&lt;?&gt; declaringType() default void.class;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to a string representation of the instrumented method,
&nbsp;     * a constant representing the {@link Class} declaring the adviced method or a {@link Method}, {@link Constructor}
&nbsp;     * or {@code java.lang.reflect.Executable} representing this method. It can also load the instrumented method&#39;s
&nbsp;     * {@code java.lang.invoke.MethodType}, {@code java.lang.invoke.MethodHandle} or
&nbsp;     * {@code java.lang.invoke.MethodHandles$Lookup}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: A constant representing a {@link Method} or {@link Constructor} is not cached but is recreated for
&nbsp;     * every read.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.Origin} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.Origin}. This annotation should
&nbsp;     * be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Origin {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the origin string should be indicated by the {@link Object#toString()} representation of the instrumented method.
&nbsp;         */
&nbsp;        String DEFAULT = &quot;&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the pattern the annotated parameter should be assigned. By default, the {@link Origin#toString()} representation
&nbsp;         * of the method is assigned. Alternatively, a pattern can be assigned where:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;{@code #t} inserts the method&#39;s declaring type.&lt;/li&gt;
&nbsp;         * &lt;li&gt;{@code #m} inserts the name of the method ({@code &lt;init&gt;} for constructors and {@code &lt;clinit&gt;} for static initializers).&lt;/li&gt;
&nbsp;         * &lt;li&gt;{@code #d} for the method&#39;s descriptor.&lt;/li&gt;
&nbsp;         * &lt;li&gt;{@code #s} for the method&#39;s signature.&lt;/li&gt;
&nbsp;         * &lt;li&gt;{@code #r} for the method&#39;s return type.&lt;/li&gt;
&nbsp;         * &lt;li&gt;{@code #p} for the property&#39;s name.&lt;/li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         * Any other {@code #} character must be escaped by {@code \} which can be escaped by itself. This property is ignored if the annotated
&nbsp;         * parameter is of type {@link Class}.
&nbsp;         *
&nbsp;         * @return The pattern the annotated parameter should be assigned.
&nbsp;         */
&nbsp;        String value() default DEFAULT;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should be mapped to the value that is returned by the advice method that is annotated
&nbsp;     * by {@link OnMethodEnter}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;&lt;b&gt;Note&lt;/b&gt;&lt;/p&gt;: This annotation must only be used within an {@link OnMethodExit} advice and is only meaningful in
&nbsp;     * combination with an {@link OnMethodEnter} advice.
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Enter {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the enter value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates that the annotated parameter should be mapped to the value that is returned by the advice method that is annotated
&nbsp;     * by {@link OnMethodExit}. Before the exit advice returns for the first time, this parameter is initialized to its type&#39;s default value.
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Exit {
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Indicates if it is possible to write to this parameter. If this property is set to {@code false}, the annotated
&nbsp;         * type must be equal to the type declaring the instrumented method if the typing is not also set to {@link Assigner.Typing#DYNAMIC}.
&nbsp;         * If this property is set to {@code true}, the annotated parameter can be any super type of the instrumented method&#39;s declaring type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This property must be set to {@code true} if the advice method is not inlined.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return {@code true} if this parameter is read-only.
&nbsp;         */
&nbsp;        boolean readOnly() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * The typing that should be applied when assigning the exit value.
&nbsp;         *
&nbsp;         * @return The typing to apply upon assignment.
&nbsp;         */
&nbsp;        Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Declares the annotated parameter as a local variable that is created by Byte Buddy for the instrumented method. The local variable can
&nbsp;     * be both read and written by advice methods with {@link OnMethodEnter} and {@link OnMethodExit} annotation and are uniquely identified by
&nbsp;     * their name. However, if a local variable is referenced from an exit advice method, it must also be declared by an enter advice method.
&nbsp;     * It is possible to annotate multiple parameters of an advice method with local variables of the same name as long as all annotated parameters
&nbsp;     * share the same parameter type. All local variables are initialized with their default value which is {@code 0} value for primitive types and
&nbsp;     * {@code null} for reference types.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Local {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the local variable that the annotated parameter references.
&nbsp;         *
&nbsp;         * @return The name of the local variable that the annotated parameter references.
&nbsp;         */
&nbsp;        String value();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should always return a boxed version of the instrumented method&#39;s return value
&nbsp;     * (i.e. {@code 0} for numeric values, {@code false} for {@code boolean} types and {@code null} for reference types). The annotated
&nbsp;     * parameter must be of type {@link Object} and cannot be assigned a value.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.StubValue} or
&nbsp;     * {@link MemberSubstitution.StubValue}. This annotation should
&nbsp;     * be used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface StubValue {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Indicates that the annotated parameter should always return a default value (i.e. {@code 0} for numeric values, {@code false}
&nbsp;     * for {@code boolean} types and {@code null} for reference types).
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Don&#39;t confuse this annotation with {@link net.bytebuddy.implementation.bind.annotation.Empty} or
&nbsp;     * {@link net.bytebuddy.asm.MemberSubstitution.Unused}. This annotation should be
&nbsp;     * used only in combination with {@link Advice}.
&nbsp;     * &lt;/p&gt;
&nbsp;     *
&nbsp;     * @see Advice
&nbsp;     * @see OnMethodEnter
&nbsp;     * @see OnMethodExit
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    @java.lang.annotation.Target(ElementType.PARAMETER)
&nbsp;    public @interface Unused {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A post processor that uses the return value of an advice method to define values for fields, arguments, the instrumented
&nbsp;     * method&#39;s return value or the exception being thrown. This post processor allows for the assignment of values from advice
&nbsp;     * methods that use delegation. When inlining advice code, it is recommended to assign values directly to annotated parameters.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Assignments can either be performed by returning a single value from an advice method or by returning an array with multiple
&nbsp;     * values. If the return type of an advice method is declared as an array type, the latter is assumed what can be overridden by
&nbsp;     * annotating the advice method with {@link AsScalar}. With a scalar assignment, the return type&#39;s default value is considered
&nbsp;     * as an indication to skip any assignment what can be configured via the annotation&#39;s property. When returning {@code null}
&nbsp;     * when using an array-typed assignment, the assignment will always be skipped.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This post processor is not registered by default but requires explicit registration via
&nbsp;     * {@link Advice.WithCustomMapping#with(Advice.PostProcessor.Factory)}.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: Assignment exceptions will not be handled by a suppression handler but will be propagated.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public abstract static class AssignReturned implements PostProcessor {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that a value is not assigned from an array but as a scalar value.
&nbsp;         */
&nbsp;        public static final int NO_INDEX = -1;
&nbsp;
&nbsp;        /**
&nbsp;         * The advice method&#39;s return type.
&nbsp;         */
&nbsp;        protected final TypeDescription.Generic type;
&nbsp;
&nbsp;        /**
&nbsp;         * The exception handler factory to use.
&nbsp;         */
&nbsp;        protected final ExceptionHandler.Factory exceptionHandlerFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if this post processor is used within exit advice.
&nbsp;         */
&nbsp;        protected final boolean exit;
&nbsp;
&nbsp;        /**
&nbsp;         * {@code true} if a default value indicates that no assignment should be conducted.
&nbsp;         */
&nbsp;        protected final boolean skipOnDefaultValue;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new post processor for assigning an advice method&#39;s return value.
&nbsp;         *
&nbsp;         * @param type                    The advice method&#39;s return type.
&nbsp;         * @param exceptionHandlerFactory The exception handler factory to use.
&nbsp;         * @param exit                    {@code true} if this post processor is used within exit advice.
&nbsp;         * @param skipOnDefaultValue      {@code true} if a default value indicates that no assignment should be conducted.
&nbsp;         */
&nbsp;        protected AssignReturned(TypeDescription.Generic type,
&nbsp;                                 ExceptionHandler.Factory exceptionHandlerFactory,
&nbsp;                                 boolean exit,
<b class="fc">&nbsp;                                 boolean skipOnDefaultValue) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.exceptionHandlerFactory = exceptionHandlerFactory;</b>
<b class="fc">&nbsp;            this.exit = exit;</b>
<b class="fc">&nbsp;            this.skipOnDefaultValue = skipOnDefaultValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                         MethodDescription instrumentedMethod,
&nbsp;                                         Assigner assigner,
&nbsp;                                         ArgumentHandler argumentHandler,
&nbsp;                                         StackMapFrameHandler.ForPostProcessor stackMapFrameHandler,
&nbsp;                                         StackManipulation exceptionHandler) {
<b class="fc">&nbsp;            List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(getHandlers().size());</b>
<b class="fc">&nbsp;            for (Handler handler : getHandlers()) {</b>
<b class="fc">&nbsp;                stackManipulations.add(handler.resolve(instrumentedType,</b>
&nbsp;                        instrumentedMethod,
&nbsp;                        assigner,
&nbsp;                        argumentHandler,
<b class="fc">&nbsp;                        getType(),</b>
<b class="fc">&nbsp;                        toLoadInstruction(handler, exit ? argumentHandler.exit() : argumentHandler.enter())));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            StackManipulation stackManipulation = exceptionHandlerFactory.wrap(new StackManipulation.Compound(stackManipulations),</b>
&nbsp;                    exceptionHandler,
&nbsp;                    stackMapFrameHandler);
<b class="fc">&nbsp;            return skipOnDefaultValue</b>
<b class="fc">&nbsp;                    ? DefaultValueSkip.of(stackManipulation, stackMapFrameHandler, exit ? argumentHandler.exit() : argumentHandler.enter(), type)</b>
<b class="fc">&nbsp;                    : stackManipulation;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the assigned type that is handled by any handler.
&nbsp;         *
&nbsp;         * @return The handled type.
&nbsp;         */
&nbsp;        protected abstract TypeDescription.Generic getType();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a collection of all handlers to apply.
&nbsp;         *
&nbsp;         * @return The handlers to apply.
&nbsp;         */
&nbsp;        protected abstract Collection&lt;Handler&gt; getHandlers();
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a load instruction for the given handler.
&nbsp;         *
&nbsp;         * @param handler The handler for which to apply a load instruction.
&nbsp;         * @param offset  The offset of the value that is returned by the advice method.
&nbsp;         * @return A stack manipulation to load the handled value.
&nbsp;         */
&nbsp;        protected abstract StackManipulation toLoadInstruction(Handler handler, int offset);
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates that the advice method&#39;s return value is to be treated as a scalar value also if it is
&nbsp;         * of an array type. This implies that the advice method&#39;s return value is assigned as such and not by
&nbsp;         * array element.
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface AsScalar {
&nbsp;
&nbsp;            /**
&nbsp;             * If {@code false}, a default value will cause an assignment. This implies that a suppressed error will
&nbsp;             * cause an assignment of the default value.
&nbsp;             *
&nbsp;             * @return {@code false}, a default value will cause an assignment.
&nbsp;             */
&nbsp;            boolean skipOnDefaultValue() default true;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Assigns the advice method&#39;s return value to an argument of the instrumented method of the given index.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This annotation has no effect unless an {@link AssignReturned} post processor is explicitly registered.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface ToArguments {
&nbsp;
&nbsp;            /**
&nbsp;             * The assignments to process.
&nbsp;             *
&nbsp;             * @return The assignments to process.
&nbsp;             */
&nbsp;            ToArgument[] value();
&nbsp;
&nbsp;            /**
&nbsp;             * Defines a particular assignment for a {@link ToArguments}.
&nbsp;             */
&nbsp;            @java.lang.annotation.Target({})
&nbsp;            @RepeatedAnnotationPlugin.Enhance(ToArguments.class)
&nbsp;            @interface ToArgument {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the parameter to assign.
&nbsp;                 *
&nbsp;                 * @return The index of the parameter to assign.
&nbsp;                 */
&nbsp;                int value();
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value. If negative,
&nbsp;                 * a scalar return value is expected.
&nbsp;                 *
&nbsp;                 * @return The index in the array that is returned which represents the assigned value.
&nbsp;                 */
&nbsp;                int index() default NO_INDEX;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 *
&nbsp;                 * @return The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for a {@link ToArgument} annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Handler implements AssignReturned.Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index of the assigned argument.
&nbsp;                 */
&nbsp;                private final int value;
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value or a negative value
&nbsp;                 * if assigning a scalar value.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler.
&nbsp;                 *
&nbsp;                 * @param value  The index of the assigned argument.
&nbsp;                 * @param index  The index in the array that is returned which represents the assigned value or a
&nbsp;                 *               negative value if assigning a scalar value.
&nbsp;                 * @param typing The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
<b class="fc">&nbsp;                protected Handler(int value, int index, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.value = value;</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getIndex() {
<b class="fc">&nbsp;                    return index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler argumentHandler,
&nbsp;                                                 TypeDescription.Generic type,
&nbsp;                                                 StackManipulation value) {
<b class="fc">&nbsp;                    if (instrumentedMethod.getParameters().size() &lt; this.value) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedMethod + &quot; declares less then &quot; + this.value + &quot; parameters&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(type,</b>
<b class="fc">&nbsp;                            instrumentedMethod.getParameters().get(this.value).getType(),</b>
&nbsp;                            typing);
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + instrumentedMethod.getParameters().get(this.value).getType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(value,</b>
&nbsp;                            assignment,
<b class="fc">&nbsp;                            MethodVariableAccess.of(instrumentedMethod.getParameters().get(this.value).getType())</b>
<b class="fc">&nbsp;                                    .storeAt(argumentHandler.argument(instrumentedMethod.getParameters().get(this.value).getOffset())));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory to create a handler for a {@link ToArguments} annotation.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements AssignReturned.Handler.Factory&lt;ToArguments&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToArguments#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENTS_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToArgument#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToArgument#index()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_INDEX;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToArgument#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ARGUMENT_TYPING;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        TO_ARGUMENTS_VALUE = TypeDescription.ForLoadedType.of(ToArguments.class)</b>
<b class="fc">&nbsp;                                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;                                .getOnly();</b>
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(ToArgument.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        TO_ARGUMENT_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_ARGUMENT_INDEX = methods.filter(named(&quot;index&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_ARGUMENT_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;ToArguments&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return ToArguments.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;AssignReturned.Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                                             boolean exit,
&nbsp;                                                             AnnotationDescription.Loadable&lt;? extends ToArguments&gt; annotation) {
<b class="fc">&nbsp;                        List&lt;AssignReturned.Handler&gt; handlers = new ArrayList&lt;AssignReturned.Handler&gt;();</b>
<b class="fc">&nbsp;                        for (AnnotationDescription argument : annotation.getValue(TO_ARGUMENTS_VALUE).resolve(AnnotationDescription[].class)) {</b>
<b class="fc">&nbsp;                            int value = argument.getValue(TO_ARGUMENT_VALUE).resolve(Integer.class);</b>
<b class="fc">&nbsp;                            if (value &lt; 0) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(&quot;An argument cannot have a negative index for &quot; + advice);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            handlers.add(new Handler(value,</b>
<b class="fc">&nbsp;                                    argument.getValue(TO_ARGUMENT_INDEX).resolve(Integer.class),</b>
<b class="fc">&nbsp;                                    argument.getValue(TO_ARGUMENT_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return handlers;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Assigns the advice method&#39;s return value as an array to a number of arguments which are returned as an array where
&nbsp;         * each element assigns a single value with the same index as the instrumented method&#39;s parameter.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Note&lt;/b&gt;: If this is the only intended assignment, the return value must either be a nested array or be annotated
&nbsp;         * with {@link AsScalar} to indicate that the advice method&#39;s returned value should be treated as a singular return value.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This annotation has no effect unless an {@link AssignReturned} post processor is explicitly registered.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface ToAllArguments {
&nbsp;
&nbsp;            /**
&nbsp;             * The index in the array that is returned which represents the assigned value. If negative,
&nbsp;             * a scalar return value is expected.
&nbsp;             *
&nbsp;             * @return The index in the array that is returned which represents the assigned value.
&nbsp;             */
&nbsp;            int index() default NO_INDEX;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply when assigning the returned value to the targeted value.
&nbsp;             *
&nbsp;             * @return The typing to apply when assigning the returned value to the targeted value.
&nbsp;             */
&nbsp;            Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for a {@link ToAllArguments} annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Handler implements AssignReturned.Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value or a negative value
&nbsp;                 * if assigning a scalar value.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler.
&nbsp;                 *
&nbsp;                 * @param index  The index in the array that is returned which represents the assigned value or a
&nbsp;                 *               negative value if assigning a scalar value.
&nbsp;                 * @param typing The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
<b class="fc">&nbsp;                protected Handler(int index, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getIndex() {
<b class="fc">&nbsp;                    return index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler argumentHandler,
&nbsp;                                                 TypeDescription.Generic type,
&nbsp;                                                 StackManipulation value) {
<b class="fc">&nbsp;                    List&lt;StackManipulation&gt; stackManipulations = new ArrayList&lt;StackManipulation&gt;(instrumentedMethod.getParameters().size());</b>
<b class="fc">&nbsp;                    if (!type.isArray()) {</b>
<b class="fc">&nbsp;                        StackManipulation assignment = assigner.assign(type, TypeDefinition.Sort.describe(Object[].class), typing);</b>
<b class="fc">&nbsp;                        if (!assignment.isValid()) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + Object[].class);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        type = TypeDefinition.Sort.describe(Object[].class);</b>
<b class="fc">&nbsp;                        value = new StackManipulation.Compound(value, assignment);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (ParameterDescription parameterDescription : instrumentedMethod.getParameters()) {</b>
<b class="fc">&nbsp;                        StackManipulation assignment = assigner.assign(type.getComponentType(), parameterDescription.getType(), typing);</b>
<b class="fc">&nbsp;                        if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign &quot; + type.getComponentType() + &quot; to &quot; + parameterDescription);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        stackManipulations.add(new StackManipulation.Compound(assignment, MethodVariableAccess.of(parameterDescription.getType())</b>
<b class="fc">&nbsp;                                .storeAt(argumentHandler.argument(parameterDescription.getOffset()))));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new StackManipulation.Compound(value, ArrayAccess.of(type.getComponentType()).forEach(stackManipulations), Removal.SINGLE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory to create a handler for a {@link ToAllArguments} annotation.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements AssignReturned.Handler.Factory&lt;ToAllArguments&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToAllArguments#index()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_INDEX;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToAllArguments#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_ALL_ARGUMENTS_TYPING;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(ToAllArguments.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        TO_ALL_ARGUMENTS_INDEX = methods.filter(named(&quot;index&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_ALL_ARGUMENTS_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;ToAllArguments&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return ToAllArguments.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;AssignReturned.Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                                             boolean exit,
&nbsp;                                                             AnnotationDescription.Loadable&lt;? extends ToAllArguments&gt; annotation) {
<b class="fc">&nbsp;                        return Collections.&lt;AssignReturned.Handler&gt;singletonList(new Handler(annotation.getValue(TO_ALL_ARGUMENTS_INDEX).resolve(Integer.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(TO_ALL_ARGUMENTS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Assigns the advice method&#39;s return value to the {@code this} reference of the instrumented method.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This annotation has no effect unless an {@link AssignReturned} post processor is explicitly registered.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface ToThis {
&nbsp;
&nbsp;            /**
&nbsp;             * The index in the array that is returned which represents the assigned value. If negative,
&nbsp;             * a scalar return value is expected.
&nbsp;             *
&nbsp;             * @return The index in the array that is returned which represents the assigned value.
&nbsp;             */
&nbsp;            int index() default NO_INDEX;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply when assigning the returned value to the targeted value.
&nbsp;             *
&nbsp;             * @return The typing to apply when assigning the returned value to the targeted value.
&nbsp;             */
&nbsp;            Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for the {@link ToThis} annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Handler implements AssignReturned.Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value or a negative value
&nbsp;                 * if assigning a scalar value.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this handler is applied on exit advice.
&nbsp;                 */
&nbsp;                private final boolean exit;
&nbsp;
&nbsp;                /**
&nbsp;                 * A handler for assigning the {@code this} reference.
&nbsp;                 *
&nbsp;                 * @param index  The index in the array that is returned which represents the assigned
&nbsp;                 *               value or a negative value if assigning a scalar value.
&nbsp;                 * @param typing The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 * @param exit   {@code true} if this handler is applied on exit advice.
&nbsp;                 */
<b class="fc">&nbsp;                protected Handler(int index, Assigner.Typing typing, boolean exit) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
<b class="fc">&nbsp;                    this.exit = exit;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getIndex() {
<b class="fc">&nbsp;                    return index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler argumentHandler,
&nbsp;                                                 TypeDescription.Generic type,
&nbsp;                                                 StackManipulation value) {
<b class="fc">&nbsp;                    if (instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign this reference for static method &quot; + instrumentedMethod);</b>
<b class="fc">&nbsp;                    } else if (!exit &amp;&amp; instrumentedMethod.isConstructor()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign this reference in constructor prior to initialization for &quot; + instrumentedMethod);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(type,</b>
<b class="fc">&nbsp;                            instrumentedType.asGenericType(),</b>
&nbsp;                            typing);
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + instrumentedType);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(value,</b>
&nbsp;                            assignment,
<b class="fc">&nbsp;                            MethodVariableAccess.REFERENCE.storeAt(argumentHandler.argument(0)));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A handler factory for the {@link ToThis} annotation which assigns an advice method&#39;s return value
&nbsp;                 * to the &lt;i&gt;this&lt;/i&gt; reference of a non-static method.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements AssignReturned.Handler.Factory&lt;ToThis&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToThis#index()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_THIS_INDEX;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToThis#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_THIS_TYPING;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(ToThis.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        TO_THIS_INDEX = methods.filter(named(&quot;index&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_THIS_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;ToThis&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return ToThis.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;AssignReturned.Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                                             boolean exit,
&nbsp;                                                             AnnotationDescription.Loadable&lt;? extends ToThis&gt; annotation) {
<b class="fc">&nbsp;                        return Collections.&lt;AssignReturned.Handler&gt;singletonList(new Handler(annotation.getValue(TO_THIS_INDEX).resolve(Integer.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(TO_THIS_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class),</b>
&nbsp;                                exit));
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Assigns the advice method&#39;s return value to a given field.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This annotation has no effect unless an {@link AssignReturned} post processor is explicitly registered.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface ToFields {
&nbsp;
&nbsp;            /**
&nbsp;             * The field assignments to apply.
&nbsp;             *
&nbsp;             * @return The field assignments to apply.
&nbsp;             */
&nbsp;            ToField[] value();
&nbsp;
&nbsp;            /**
&nbsp;             * Determines what fields are assigned when using a {@link ToFields} annotation.
&nbsp;             */
&nbsp;            @java.lang.annotation.Target({})
&nbsp;            @RepeatedAnnotationPlugin.Enhance(ToFields.class)
&nbsp;            @interface ToField {
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessed field&#39;s name or an empty string if the field name should be inferred from
&nbsp;                 * the method&#39;s accessor name.
&nbsp;                 *
&nbsp;                 * @return The accessed field&#39;s name or an empty string if the field name should be inferred
&nbsp;                 * from the method&#39;s accessor name.
&nbsp;                 */
&nbsp;                String value() default OffsetMapping.ForField.Unresolved.BEAN_PROPERTY;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s declaring type or {@code void} if the type should be found within the
&nbsp;                 * instrumented type&#39;s hierarchy.
&nbsp;                 *
&nbsp;                 * @return The field&#39;s declaring type or {@code void} if the type should be found within the
&nbsp;                 * instrumented type&#39;s hierarchy.
&nbsp;                 */
&nbsp;                Class&lt;?&gt; declaringType() default void.class;
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value. If negative,
&nbsp;                 * a scalar return value is expected.
&nbsp;                 *
&nbsp;                 * @return The index in the array that is returned which represents the assigned value.
&nbsp;                 */
&nbsp;                int index() default NO_INDEX;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 *
&nbsp;                 * @return The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for a {@link ToField} annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Handler implements AssignReturned.Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value or a negative value
&nbsp;                 * if assigning a scalar value.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The accessed field&#39;s name or an empty string if the field name should be inferred from the
&nbsp;                 * method&#39;s accessor name.
&nbsp;                 */
&nbsp;                private final String name;
&nbsp;
&nbsp;                /**
&nbsp;                 * The field&#39;s declaring type or {@code void} if the type should be found within the instrumented
&nbsp;                 * type&#39;s hierarchy.
&nbsp;                 */
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler for a {@link ToReturned} annotation.
&nbsp;                 *
&nbsp;                 * @param index         The index in the array that is returned which represents the assigned value or
&nbsp;                 *                      a negative value if assigning a scalar value.
&nbsp;                 * @param name          The accessed field&#39;s name or an empty string if the field name should be
&nbsp;                 *                      inferred from the method&#39;s accessor name.
&nbsp;                 * @param declaringType The field&#39;s declaring type or {@code void} if the type should be found within
&nbsp;                 *                      the instrumented type&#39;s hierarchy.
&nbsp;                 * @param typing        The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                protected Handler(int index,
&nbsp;                                  String name,
&nbsp;                                  TypeDescription declaringType,
<b class="fc">&nbsp;                                  Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.name = name;</b>
<b class="fc">&nbsp;                    this.declaringType = declaringType;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getIndex() {
<b class="fc">&nbsp;                    return index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler argumentHandler,
&nbsp;                                                 TypeDescription.Generic type,
&nbsp;                                                 StackManipulation value) {
<b class="fc">&nbsp;                    FieldLocator locator = declaringType.represents(void.class)</b>
<b class="fc">&nbsp;                            ? new FieldLocator.ForClassHierarchy(instrumentedType)</b>
<b class="nc">&nbsp;                            : new FieldLocator.ForExactType(declaringType);</b>
<b class="fc">&nbsp;                    FieldLocator.Resolution resolution = name.equals(OffsetMapping.ForField.Unresolved.BEAN_PROPERTY)</b>
<b class="nc">&nbsp;                            ? FieldLocator.Resolution.Simple.ofBeanAccessor(locator, instrumentedMethod)</b>
<b class="fc">&nbsp;                            : locator.locate(name);</b>
&nbsp;                    StackManipulation stackManipulation;
<b class="fc">&nbsp;                    if (!resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot resolve field &quot; + name + &quot; for &quot; + instrumentedType);</b>
<b class="fc">&nbsp;                    } else if (!resolution.getField().isVisibleTo(instrumentedType)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(resolution.getField() + &quot; is not visible to &quot; + instrumentedType);</b>
<b class="fc">&nbsp;                    } else if (resolution.getField().isStatic()) {</b>
<b class="fc">&nbsp;                        stackManipulation = StackManipulation.Trivial.INSTANCE;</b>
<b class="fc">&nbsp;                    } else if (instrumentedMethod.isStatic()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot access member field &quot; + resolution.getField() + &quot; from static &quot; + instrumentedMethod);</b>
<b class="fc">&nbsp;                    } else if (!instrumentedType.isAssignableTo(resolution.getField().getDeclaringType().asErasure())) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(instrumentedType + &quot; does not define &quot; + resolution.getField());</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        stackManipulation = MethodVariableAccess.loadThis();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(type,</b>
<b class="fc">&nbsp;                            resolution.getField().getType(),</b>
&nbsp;                            typing);
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + resolution.getField());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(stackManipulation,</b>
&nbsp;                            value,
&nbsp;                            assignment,
<b class="fc">&nbsp;                            FieldAccess.forField(resolution.getField()).write());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory to create a handler for a {@link ToFields} annotation.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements AssignReturned.Handler.Factory&lt;ToFields&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToFields#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELDS_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToField#value()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_VALUE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToField#index()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_INDEX;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToField#declaringType()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_DECLARING_TYPE;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToField#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_FIELD_TYPING;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        TO_FIELDS_VALUE = TypeDescription.ForLoadedType.of(ToFields.class)</b>
<b class="fc">&nbsp;                                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;                                .getOnly();</b>
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(ToField.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        TO_FIELD_VALUE = methods.filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_FIELD_INDEX = methods.filter(named(&quot;index&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_FIELD_DECLARING_TYPE = methods.filter(named(&quot;declaringType&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_FIELD_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;ToFields&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return ToFields.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;AssignReturned.Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                                             boolean exit,
&nbsp;                                                             AnnotationDescription.Loadable&lt;? extends ToFields&gt; annotation) {
<b class="fc">&nbsp;                        List&lt;AssignReturned.Handler&gt; handlers = new ArrayList&lt;AssignReturned.Handler&gt;();</b>
<b class="fc">&nbsp;                        for (AnnotationDescription field : annotation.getValue(TO_FIELDS_VALUE).resolve(AnnotationDescription[].class)) {</b>
<b class="fc">&nbsp;                            handlers.add(new Handler(field.getValue(TO_FIELD_INDEX).resolve(Integer.class),</b>
<b class="fc">&nbsp;                                    field.getValue(TO_FIELD_VALUE).resolve(String.class),</b>
<b class="fc">&nbsp;                                    field.getValue(TO_FIELD_DECLARING_TYPE).resolve(TypeDescription.class),</b>
<b class="fc">&nbsp;                                    field.getValue(TO_FIELD_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return handlers;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Assigns the advice method&#39;s return value to the instrumented method&#39;s return value. This annotation can only be used
&nbsp;         * with exit advice marked with {@link OnMethodExit}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This annotation has no effect unless an {@link AssignReturned} post processor is explicitly registered.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface ToReturned {
&nbsp;
&nbsp;            /**
&nbsp;             * The index in the array that is returned which represents the assigned value. If negative,
&nbsp;             * a scalar return value is expected.
&nbsp;             *
&nbsp;             * @return The index in the array that is returned which represents the assigned value.
&nbsp;             */
&nbsp;            int index() default NO_INDEX;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply when assigning the returned value to the targeted value.
&nbsp;             *
&nbsp;             * @return The typing to apply when assigning the returned value to the targeted value.
&nbsp;             */
&nbsp;            Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for a {@link ToReturned} annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Handler implements AssignReturned.Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value or a negative value
&nbsp;                 * if assigning a scalar value.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler for a {@link ToReturned} annotation.
&nbsp;                 *
&nbsp;                 * @param index  The index in the array that is returned which represents the assigned value or
&nbsp;                 *               a negative value if assigning a scalar value.
&nbsp;                 * @param typing The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
<b class="fc">&nbsp;                protected Handler(int index, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getIndex() {
<b class="fc">&nbsp;                    return index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler argumentHandler,
&nbsp;                                                 TypeDescription.Generic type,
&nbsp;                                                 StackManipulation value) {
<b class="fc">&nbsp;                    if (instrumentedMethod.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                        return StackManipulation.Trivial.INSTANCE;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(type, instrumentedMethod.getReturnType(), typing);</b>
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + instrumentedMethod.getReturnType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(value,</b>
&nbsp;                            assignment,
<b class="fc">&nbsp;                            MethodVariableAccess.of(instrumentedMethod.getReturnType()).storeAt(argumentHandler.returned()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory to create a handler for a {@link ToReturned} annotation.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements AssignReturned.Handler.Factory&lt;ToReturned&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToReturned#index()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_RETURNED_INDEX;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToReturned#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_RETURNED_TYPING;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(ToReturned.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        TO_RETURNED_INDEX = methods.filter(named(&quot;index&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_RETURNED_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;ToReturned&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return ToReturned.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;AssignReturned.Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                                             boolean exit,
&nbsp;                                                             AnnotationDescription.Loadable&lt;? extends ToReturned&gt; annotation) {
<b class="fc">&nbsp;                        if (!exit) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot write returned value from enter advice &quot; + advice);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return Collections.&lt;AssignReturned.Handler&gt;singletonList(new ToReturned.Handler(annotation.getValue(TO_RETURNED_INDEX).resolve(Integer.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(TO_RETURNED_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Assigns the advice method&#39;s return value as the instrumented method&#39;s thrown exception. This annotation can only be used
&nbsp;         * with exit advice marked with {@link OnMethodExit}. Note that a {@code null} value on a scalar assignment deactivates this
&nbsp;         * handler and does not, by default, remove a thrown exception. To avoid this, an array assignment must be used or
&nbsp;         * {@link AsScalar#skipOnDefaultValue()} must be set to {@code false}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * &lt;b&gt;Important&lt;/b&gt;: This annotation has no effect unless an {@link AssignReturned} post processor is explicitly registered.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
&nbsp;        @Documented
&nbsp;        @Retention(RetentionPolicy.RUNTIME)
&nbsp;        @java.lang.annotation.Target(ElementType.METHOD)
&nbsp;        public @interface ToThrown {
&nbsp;
&nbsp;            /**
&nbsp;             * The index in the array that is returned which represents the assigned value. If negative,
&nbsp;             * a scalar return value is expected.
&nbsp;             *
&nbsp;             * @return The index in the array that is returned which represents the assigned value.
&nbsp;             */
&nbsp;            int index() default NO_INDEX;
&nbsp;
&nbsp;            /**
&nbsp;             * The typing to apply when assigning the returned value to the targeted value.
&nbsp;             *
&nbsp;             * @return The typing to apply when assigning the returned value to the targeted value.
&nbsp;             */
&nbsp;            Assigner.Typing typing() default Assigner.Typing.STATIC;
&nbsp;
&nbsp;            /**
&nbsp;             * A handler for a {@link ToThrown} annotation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Handler implements AssignReturned.Handler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The index in the array that is returned which represents the assigned value or a negative value
&nbsp;                 * if assigning a scalar value.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
&nbsp;                private final Assigner.Typing typing;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new handler to assign a {@link ToThrown} annotation.
&nbsp;                 *
&nbsp;                 * @param index  The index in the array that is returned which represents the assigned value or a
&nbsp;                 *               negative value if assigning a scalar value.
&nbsp;                 * @param typing The typing to apply when assigning the returned value to the targeted value.
&nbsp;                 */
<b class="fc">&nbsp;                protected Handler(int index, Assigner.Typing typing) {</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.typing = typing;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getIndex() {
<b class="fc">&nbsp;                    return index;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                                 MethodDescription instrumentedMethod,
&nbsp;                                                 Assigner assigner,
&nbsp;                                                 ArgumentHandler argumentHandler,
&nbsp;                                                 TypeDescription.Generic type,
&nbsp;                                                 StackManipulation value) {
<b class="fc">&nbsp;                    StackManipulation assignment = assigner.assign(type, TypeDefinition.Sort.describe(Throwable.class), typing);</b>
<b class="fc">&nbsp;                    if (!assignment.isValid()) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot assign &quot; + type + &quot; to &quot; + Throwable.class.getName());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new StackManipulation.Compound(value,</b>
&nbsp;                            assignment,
<b class="fc">&nbsp;                            MethodVariableAccess.REFERENCE.storeAt(argumentHandler.thrown()));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory to create a handler for a {@link ToThrown} annotation.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements AssignReturned.Handler.Factory&lt;ToThrown&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToThrown#index()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_THROWN_INDEX;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the {@link ToThrown#typing()} method.
&nbsp;                     */
&nbsp;                    private static final MethodDescription.InDefinedShape TO_THROWN_TYPING;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Resolves annotation properties.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        MethodList&lt;MethodDescription.InDefinedShape&gt; methods = TypeDescription.ForLoadedType.of(ToThrown.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;                        TO_THROWN_INDEX = methods.filter(named(&quot;index&quot;)).getOnly();</b>
<b class="fc">&nbsp;                        TO_THROWN_TYPING = methods.filter(named(&quot;typing&quot;)).getOnly();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;ToThrown&gt; getAnnotationType() {
<b class="fc">&nbsp;                        return ToThrown.class;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming annotation for exit advice.&quot;)
&nbsp;                    public List&lt;AssignReturned.Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                                             boolean exit,
&nbsp;                                                             AnnotationDescription.Loadable&lt;? extends ToThrown&gt; annotation) {
<b class="fc">&nbsp;                        if (!exit) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign thrown value from enter advice &quot; + advice);</b>
<b class="fc">&nbsp;                        } else if (advice.getDeclaredAnnotations().ofType(OnMethodExit.class).getValue(ON_THROWABLE).resolve(TypeDescription.class)</b>
<b class="fc">&nbsp;                                .represents(NoExceptionHandler.class)) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Cannot assign thrown value for non-catching exit advice &quot; + advice);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return Collections.&lt;AssignReturned.Handler&gt;singletonList(new ToThrown.Handler(annotation.getValue(TO_THROWN_INDEX).resolve(Integer.class),</b>
<b class="fc">&nbsp;                                annotation.getValue(TO_THROWN_TYPING).resolve(EnumerationDescription.class).load(Assigner.Typing.class)));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A post processor implementation of {@link AssignReturned} that works on the value of an array.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ForArray extends AssignReturned {
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of the handlers to apply mapped to the index in the array that is returned by the advice method.
&nbsp;             */
&nbsp;            private final Map&lt;Handler, Integer&gt; handlers;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a post processor to assign a returned array value by index.
&nbsp;             *
&nbsp;             * @param type                    The array type that is returned by the advice method.
&nbsp;             * @param exceptionHandlerFactory The exception handler factory to use.
&nbsp;             * @param exit                    {@code true} if the post processor is applied to exit advice.
&nbsp;             * @param handlers                The handlers to apply.
&nbsp;             */
&nbsp;            protected ForArray(TypeDescription.Generic type,
&nbsp;                               ExceptionHandler.Factory exceptionHandlerFactory,
&nbsp;                               boolean exit,
&nbsp;                               Collection&lt;List&lt;Handler&gt;&gt; handlers) {
<b class="fc">&nbsp;                super(type, exceptionHandlerFactory, exit, true);</b>
<b class="fc">&nbsp;                this.handlers = new LinkedHashMap&lt;Handler, Integer&gt;();</b>
<b class="fc">&nbsp;                for (List&lt;Handler&gt; collection : handlers) {</b>
<b class="fc">&nbsp;                    for (Handler handler : collection) {</b>
<b class="fc">&nbsp;                        int index = handler.getIndex();</b>
<b class="fc">&nbsp;                        if (index &lt;= NO_INDEX) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Handler on array requires positive index for &quot; + handler);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        this.handlers.put(handler, index);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            protected TypeDescription.Generic getType() {
<b class="fc">&nbsp;                return type.getComponentType();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Collection&lt;Handler&gt; getHandlers() {
<b class="fc">&nbsp;                return handlers.keySet();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            protected StackManipulation toLoadInstruction(Handler handler, int offset) {
<b class="fc">&nbsp;                return new StackManipulation.Compound(MethodVariableAccess.REFERENCE.loadFrom(offset),</b>
<b class="fc">&nbsp;                        IntegerConstant.forValue(handlers.get(handler)),</b>
<b class="fc">&nbsp;                        ArrayAccess.of(type.getComponentType()).load());</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A post processor implementation of {@link AssignReturned} that uses the returned value as such.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ForScalar extends AssignReturned {
&nbsp;
&nbsp;            /**
&nbsp;             * The list of handlers to apply.
&nbsp;             */
&nbsp;            private final List&lt;Handler&gt; handlers;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a post processor to assign a returned scalar value.
&nbsp;             *
&nbsp;             * @param type                    The type of the advice method.
&nbsp;             * @param exceptionHandlerFactory The exception handler factory to use.
&nbsp;             * @param exit                    {@code true} if the post processor is applied to exit advice.
&nbsp;             * @param skipOnDefaultValue      {@code true} if a default value indicates that no assignment should be conducted.
&nbsp;             * @param handlers                The handlers to apply.
&nbsp;             */
&nbsp;            protected ForScalar(TypeDescription.Generic type,
&nbsp;                                ExceptionHandler.Factory exceptionHandlerFactory,
&nbsp;                                boolean exit,
&nbsp;                                boolean skipOnDefaultValue,
&nbsp;                                Collection&lt;List&lt;Handler&gt;&gt; handlers) {
<b class="fc">&nbsp;                super(type, exceptionHandlerFactory, exit, skipOnDefaultValue);</b>
<b class="fc">&nbsp;                this.handlers = new ArrayList&lt;Handler&gt;();</b>
<b class="fc">&nbsp;                for (List&lt;Handler&gt; collection : handlers) {</b>
<b class="fc">&nbsp;                    for (Handler handler : collection) {</b>
<b class="fc">&nbsp;                        int index = handler.getIndex();</b>
<b class="fc">&nbsp;                        if (index &gt; NO_INDEX) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Handler on array requires negative index for &quot; + handler);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        this.handlers.add(handler);</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected TypeDescription.Generic getType() {
<b class="fc">&nbsp;                return type;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Collection&lt;Handler&gt; getHandlers() {
<b class="fc">&nbsp;                return handlers;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected StackManipulation toLoadInstruction(Handler handler, int offset) {
<b class="fc">&nbsp;                return MethodVariableAccess.of(type).loadFrom(offset);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A stack manipulation that applies a null-check on the returned value which indicates if an assignment
&nbsp;         * should be skipped, if discovered.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class DefaultValueSkip implements StackManipulation {
&nbsp;
&nbsp;            /**
&nbsp;             * The wrapped stack manipulation in case the value is not a default value.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * The stack map frame handler to use.
&nbsp;             */
&nbsp;            private final StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * The offset of the value of the returned type.
&nbsp;             */
&nbsp;            private final int offset;
&nbsp;
&nbsp;            /**
&nbsp;             * The dispatcher to use.
&nbsp;             */
&nbsp;            private final Dispatcher dispatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a null-check wrapper.
&nbsp;             *
&nbsp;             * @param stackManipulation    The wrapped stack manipulation in case the value is not a default value.
&nbsp;             * @param stackMapFrameHandler The stack map frame handler to use.
&nbsp;             * @param offset               The offset of the value of the returned type.
&nbsp;             * @param dispatcher           The dispatcher to use.
&nbsp;             */
&nbsp;            protected DefaultValueSkip(StackManipulation stackManipulation,
&nbsp;                                       StackMapFrameHandler.ForPostProcessor stackMapFrameHandler,
&nbsp;                                       int offset,
<b class="fc">&nbsp;                                       Dispatcher dispatcher) {</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                this.stackMapFrameHandler = stackMapFrameHandler;</b>
<b class="fc">&nbsp;                this.offset = offset;</b>
<b class="fc">&nbsp;                this.dispatcher = dispatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a skipping stack manipulation for the supplied type.
&nbsp;             *
&nbsp;             * @param stackManipulation    The stack manipulation to wrap.
&nbsp;             * @param stackMapFrameHandler The stack map frame handler to use.
&nbsp;             * @param offset               The offset of the value of the returned type.
&nbsp;             * @param typeDefinition       The type that is returned by the advice method.
&nbsp;             * @return A suitable stack manipulation.
&nbsp;             */
&nbsp;            protected static StackManipulation of(StackManipulation stackManipulation,
&nbsp;                                                  StackMapFrameHandler.ForPostProcessor stackMapFrameHandler,
&nbsp;                                                  int offset,
&nbsp;                                                  TypeDefinition typeDefinition) {
&nbsp;                Dispatcher dispatcher;
<b class="fc">&nbsp;                if (typeDefinition.isPrimitive()) {</b>
<b class="fc">&nbsp;                    if (typeDefinition.represents(boolean.class)</b>
<b class="fc">&nbsp;                            || typeDefinition.represents(byte.class)</b>
<b class="fc">&nbsp;                            || typeDefinition.represents(short.class)</b>
<b class="fc">&nbsp;                            || typeDefinition.represents(char.class)</b>
<b class="fc">&nbsp;                            || typeDefinition.represents(int.class)) {</b>
<b class="fc">&nbsp;                        dispatcher = Dispatcher.INTEGER;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(long.class)) {</b>
<b class="fc">&nbsp;                        dispatcher = Dispatcher.LONG;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(float.class)) {</b>
<b class="fc">&nbsp;                        dispatcher = Dispatcher.FLOAT;</b>
<b class="fc">&nbsp;                    } else if (typeDefinition.represents(double.class)) {</b>
<b class="fc">&nbsp;                        dispatcher = Dispatcher.DOUBLE;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IllegalArgumentException(&quot;Cannot apply skip for &quot; + typeDefinition);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    dispatcher = Dispatcher.REFERENCE;</b>
&nbsp;                }
<b class="fc">&nbsp;                return new DefaultValueSkip(stackManipulation, stackMapFrameHandler, offset, dispatcher);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isValid() {
<b class="nc">&nbsp;                return stackManipulation.isValid();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                Label label = new Label();</b>
<b class="fc">&nbsp;                Size size = dispatcher.apply(methodVisitor, offset, label).aggregate(stackManipulation.apply(methodVisitor, implementationContext));</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(label);</b>
<b class="fc">&nbsp;                stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.&lt;TypeDescription&gt;emptyList());</b>
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.NOP);</b>
<b class="fc">&nbsp;                return size;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher for skipping a default value.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Dispatcher {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for integer types.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER {</b>
&nbsp;                    @Override
&nbsp;                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ILOAD, offset);</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);</b>
<b class="fc">&nbsp;                        return new Size(0, 1);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for {@code long}.
&nbsp;                 */
<b class="fc">&nbsp;                LONG {</b>
&nbsp;                    @Override
&nbsp;                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.LLOAD, offset);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.LCONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.LCMP);</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);</b>
<b class="fc">&nbsp;                        return new Size(0, 4);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for {@code float}.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT {</b>
&nbsp;                    @Override
&nbsp;                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.FLOAD, offset);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.FCONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.FCMPL);</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);</b>
<b class="fc">&nbsp;                        return new Size(0, 2);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for {@code double}.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE {</b>
&nbsp;                    @Override
&nbsp;                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.DLOAD, offset);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DCONST_0);</b>
<b class="fc">&nbsp;                        methodVisitor.visitInsn(Opcodes.DCMPL);</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);</b>
<b class="fc">&nbsp;                        return new Size(0, 4);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for reference types.
&nbsp;                 */
<b class="fc">&nbsp;                REFERENCE {</b>
&nbsp;                    @Override
&nbsp;                    protected Size apply(MethodVisitor methodVisitor, int offset, Label label) {
<b class="fc">&nbsp;                        methodVisitor.visitVarInsn(Opcodes.ALOAD, offset);</b>
<b class="fc">&nbsp;                        methodVisitor.visitJumpInsn(Opcodes.IFNULL, label);</b>
<b class="fc">&nbsp;                        return new Size(0, 2);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this jump.
&nbsp;                 *
&nbsp;                 * @param methodVisitor The method visitor to use.
&nbsp;                 * @param offset        The offset of the advice return value.
&nbsp;                 * @param label         The label to jump to if a default value is discovered.
&nbsp;                 * @return The size of this instruction.
&nbsp;                 */
&nbsp;                protected abstract Size apply(MethodVisitor methodVisitor, int offset, Label label);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An exception handler to handle exceptions during assignment.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        protected static class ExceptionHandler implements StackManipulation {
&nbsp;
&nbsp;            /**
&nbsp;             * The stack manipulation that represents the assignment.
&nbsp;             */
&nbsp;            private final StackManipulation stackManipulation;
&nbsp;
&nbsp;            /**
&nbsp;             * The exception handler to apply.
&nbsp;             */
&nbsp;            private final StackManipulation exceptionHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * The exception type to handle.
&nbsp;             */
&nbsp;            private final TypeDescription exceptionType;
&nbsp;
&nbsp;            /**
&nbsp;             * The stack map frame handler to use.
&nbsp;             */
&nbsp;            private final StackMapFrameHandler.ForPostProcessor stackMapFrameHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new exception handler for an assignment.
&nbsp;             *
&nbsp;             * @param stackManipulation    The stack manipulation that represents the assignment.
&nbsp;             * @param exceptionHandler     The exception handler to apply.
&nbsp;             * @param exceptionType        The exception type to handle.
&nbsp;             * @param stackMapFrameHandler The stack map frame handler to use.
&nbsp;             */
&nbsp;            protected ExceptionHandler(StackManipulation stackManipulation,
&nbsp;                                       StackManipulation exceptionHandler,
&nbsp;                                       TypeDescription exceptionType,
<b class="fc">&nbsp;                                       StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {</b>
<b class="fc">&nbsp;                this.stackManipulation = stackManipulation;</b>
<b class="fc">&nbsp;                this.exceptionHandler = exceptionHandler;</b>
<b class="fc">&nbsp;                this.exceptionType = exceptionType;</b>
<b class="fc">&nbsp;                this.stackMapFrameHandler = stackMapFrameHandler;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isValid() {
<b class="nc">&nbsp;                return stackManipulation.isValid() &amp;&amp; exceptionHandler.isValid();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Size apply(MethodVisitor methodVisitor, Context implementationContext) {
<b class="fc">&nbsp;                Label start = new Label(), handler = new Label(), end = new Label();</b>
<b class="fc">&nbsp;                methodVisitor.visitTryCatchBlock(start, handler, handler, exceptionType.getInternalName());</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(start);</b>
<b class="fc">&nbsp;                Size size = stackManipulation.apply(methodVisitor, implementationContext);</b>
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.GOTO, end);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(handler);</b>
<b class="fc">&nbsp;                stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.singletonList(exceptionType));</b>
<b class="fc">&nbsp;                size = exceptionHandler.apply(methodVisitor, implementationContext).aggregate(size);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;                stackMapFrameHandler.injectIntermediateFrame(methodVisitor, Collections.&lt;TypeDescription&gt;emptyList());</b>
<b class="fc">&nbsp;                return size;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for wrapping an assignment with an exception handler, if appropriate.
&nbsp;             */
&nbsp;            public interface Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * Wraps the supplied stack manipulation.
&nbsp;                 *
&nbsp;                 * @param stackManipulation    The stack manipulation that represents the assignment.
&nbsp;                 * @param exceptionHandler     The exception handler to apply.
&nbsp;                 * @param stackMapFrameHandler The stack map frame handler to use.
&nbsp;                 * @return The resolved stack manipulation.
&nbsp;                 */
&nbsp;                StackManipulation wrap(StackManipulation stackManipulation,
&nbsp;                                       StackManipulation exceptionHandler,
&nbsp;                                       StackMapFrameHandler.ForPostProcessor stackMapFrameHandler);
&nbsp;
&nbsp;                /**
&nbsp;                 * A non-operational factory that does not produce an exception handler.
&nbsp;                 */
<b class="fc">&nbsp;                enum NoOp implements Factory {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation wrap(StackManipulation stackManipulation,
&nbsp;                                                  StackManipulation exceptionHandler,
&nbsp;                                                  StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
<b class="fc">&nbsp;                        return stackManipulation;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory that creates an exception handler for a given exception type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Enabled implements Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The exception type being handled.
&nbsp;                     */
&nbsp;                    private final TypeDescription exceptionType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a factory for an exception handler of the supplied exception type.
&nbsp;                     *
&nbsp;                     * @param exceptionType The exception type being handled.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Enabled(TypeDescription exceptionType) {</b>
<b class="fc">&nbsp;                        this.exceptionType = exceptionType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public StackManipulation wrap(StackManipulation stackManipulation,
&nbsp;                                                  StackManipulation exceptionHandler,
&nbsp;                                                  StackMapFrameHandler.ForPostProcessor stackMapFrameHandler) {
<b class="fc">&nbsp;                        return new ExceptionHandler(stackManipulation, exceptionHandler, exceptionType, stackMapFrameHandler);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A handler for an {@link AssignReturned} post processor to assign a value that was returned by
&nbsp;         * advice to a value of the instrumented method.
&nbsp;         */
&nbsp;        public interface Handler {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the array offset which this handler intends to assign or a negative value if this handler
&nbsp;             * intends to assign a scalar value.
&nbsp;             *
&nbsp;             * @return The array offset which this handler intends to assign or a negative value if this handler
&nbsp;             * intends to assign a scalar value.
&nbsp;             */
&nbsp;            int getIndex();
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves this handler.
&nbsp;             *
&nbsp;             * @param instrumentedType   The instrumented type.
&nbsp;             * @param instrumentedMethod The instrumented method.
&nbsp;             * @param assigner           The assigner to use.
&nbsp;             * @param argumentHandler    The argument handler for the handled advice method.
&nbsp;             * @param type               The type that this handler receives for assignment.
&nbsp;             * @param value              An instruction to load the handled value onto the operand stack.
&nbsp;             * @return The stack manipulation resolved by this handler.
&nbsp;             */
&nbsp;            StackManipulation resolve(TypeDescription instrumentedType,
&nbsp;                                      MethodDescription instrumentedMethod,
&nbsp;                                      Assigner assigner,
&nbsp;                                      ArgumentHandler argumentHandler,
&nbsp;                                      TypeDescription.Generic type,
&nbsp;                                      StackManipulation value);
&nbsp;
&nbsp;            /**
&nbsp;             * A factory for resolving a handler for a given advice method.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The annotation type that activates this handler factory.
&nbsp;             */
&nbsp;            interface Factory&lt;T extends Annotation&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the annotation type that activates this handler factory.
&nbsp;                 *
&nbsp;                 * @return The annotation type that activates this handler factory.
&nbsp;                 */
&nbsp;                Class&lt;T&gt; getAnnotationType();
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves a list of handlers for this factory.
&nbsp;                 *
&nbsp;                 * @param advice     The advice method for which to resolve handlers.
&nbsp;                 * @param exit       {@code true} if this factory is applied for exit advice.
&nbsp;                 * @param annotation The annotation that activated this handler factory.
&nbsp;                 * @return A list of handlers to apply.
&nbsp;                 */
&nbsp;                List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                   boolean exit,
&nbsp;                                   AnnotationDescription.Loadable&lt;? extends T&gt; annotation);
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple implementation of a {@link Handler.Factory} that resolves a given list of {@link Handler}s.
&nbsp;                 *
&nbsp;                 * @param &lt;S&gt; The annotation type that activates this handler factory.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Simple&lt;S extends Annotation&gt; implements Factory&lt;S&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation type that activates this handler factory.
&nbsp;                     */
&nbsp;                    private final Class&lt;S&gt; type;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The handlers this factory should return.
&nbsp;                     */
&nbsp;                    private final List&lt;Handler&gt; handlers;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple handler.
&nbsp;                     *
&nbsp;                     * @param type     The annotation type that activates this handler factory.
&nbsp;                     * @param handlers The handlers this factory should return.
&nbsp;                     */
<b class="nc">&nbsp;                    public Simple(Class&lt;S&gt; type, List&lt;Handler&gt; handlers) {</b>
<b class="nc">&nbsp;                        this.type = type;</b>
<b class="nc">&nbsp;                        this.handlers = handlers;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Class&lt;S&gt; getAnnotationType() {
<b class="nc">&nbsp;                        return type;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public List&lt;Handler&gt; make(MethodDescription.InDefinedShape advice,
&nbsp;                                              boolean exit,
&nbsp;                                              AnnotationDescription.Loadable&lt;? extends S&gt; annotation) {
<b class="nc">&nbsp;                        return handlers;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A factory to create a {@link AssignReturned} post processor. This processor is only added if the advice
&nbsp;         * method does not return {@code void}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        public static class Factory implements PostProcessor.Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * A description of the {@link AsScalar#skipOnDefaultValue()} method.
&nbsp;             */
<b class="fc">&nbsp;            private static final MethodDescription.InDefinedShape SKIP_ON_DEFAULT_VALUE = TypeDescription.ForLoadedType.of(AsScalar.class)</b>
<b class="fc">&nbsp;                    .getDeclaredMethods()</b>
<b class="fc">&nbsp;                    .filter(named(&quot;skipOnDefaultValue&quot;))</b>
<b class="fc">&nbsp;                    .getOnly();</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The handler factories to apply.
&nbsp;             */
&nbsp;            private final List&lt;? extends Handler.Factory&lt;?&gt;&gt; factories;
&nbsp;
&nbsp;            /**
&nbsp;             * The exception handler factory to use.
&nbsp;             */
&nbsp;            private final ExceptionHandler.Factory exceptionHandlerFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new factory which a preresolved list of handler factories.
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public Factory() {
<b class="fc">&nbsp;                this(Arrays.asList(ToArguments.Handler.Factory.INSTANCE,</b>
&nbsp;                        ToAllArguments.Handler.Factory.INSTANCE,
&nbsp;                        ToThis.Handler.Factory.INSTANCE,
&nbsp;                        ToFields.Handler.Factory.INSTANCE,
&nbsp;                        ToReturned.Handler.Factory.INSTANCE,
&nbsp;                        ToThrown.Handler.Factory.INSTANCE), ExceptionHandler.Factory.NoOp.INSTANCE);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new factory.
&nbsp;             *
&nbsp;             * @param factories               The handler factories to apply.
&nbsp;             * @param exceptionHandlerFactory The exception handler factory to use.
&nbsp;             */
<b class="fc">&nbsp;            protected Factory(List&lt;? extends Handler.Factory&lt;?&gt;&gt; factories, ExceptionHandler.Factory exceptionHandlerFactory) {</b>
<b class="fc">&nbsp;                this.factories = factories;</b>
<b class="fc">&nbsp;                this.exceptionHandlerFactory = exceptionHandlerFactory;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Includes a list of handlers upon discovering an annotation of a given type.
&nbsp;             *
&nbsp;             * @param type    The annotation type that activates the handler factory.
&nbsp;             * @param handler The handlers to use upon discovery.
&nbsp;             * @return A new {@link AssignReturned.Factory} that includes the provided handlers.
&nbsp;             */
&nbsp;            public Factory with(Class&lt;? extends Annotation&gt; type, Handler... handler) {
<b class="nc">&nbsp;                return with(type, Arrays.asList(handler));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Includes a list of handlers upon discovering an annotation of a given type.
&nbsp;             *
&nbsp;             * @param type     The annotation type that activates the handler factory.
&nbsp;             * @param handlers The handlers to use upon discovery.
&nbsp;             * @return A new {@link AssignReturned.Factory} that includes the provided handlers.
&nbsp;             */
&nbsp;            @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
&nbsp;            public Factory with(Class&lt;? extends Annotation&gt; type, List&lt;Handler&gt; handlers) {
<b class="nc">&nbsp;                return with(new Handler.Factory.Simple(type, handlers));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Includes the provided handler factory.
&nbsp;             *
&nbsp;             * @param factory The handler factory to include.
&nbsp;             * @return new {@link AssignReturned.Factory} that includes the provided handler factory.
&nbsp;             */
&nbsp;            public Factory with(Handler.Factory&lt;?&gt; factory) {
<b class="nc">&nbsp;                return new Factory(CompoundList.of(factories, factory), exceptionHandlerFactory);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Configures this post processor to handle exceptions during assignment with the advice&#39;s {@link Advice.ExceptionHandler}.
&nbsp;             *
&nbsp;             * @param exceptionType The {@link Throwable} type to handle.
&nbsp;             * @return A new assigning post processor that handles the specified exception types.
&nbsp;             */
&nbsp;            public PostProcessor.Factory withSuppressed(Class&lt;? extends Throwable&gt; exceptionType) {
<b class="fc">&nbsp;                return withSuppressed(TypeDescription.ForLoadedType.of(exceptionType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Configures this post processor to handle exceptions during assignment with the advice&#39;s {@link Advice.ExceptionHandler}.
&nbsp;             *
&nbsp;             * @param exceptionType The {@link Throwable} type to handle.
&nbsp;             * @return A new assigning post processor that handles the specified exception types.
&nbsp;             */
&nbsp;            public PostProcessor.Factory withSuppressed(TypeDescription exceptionType) {
<b class="fc">&nbsp;                if (!exceptionType.isAssignableTo(Throwable.class)) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(exceptionType + &quot; is not a throwable type&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Factory(factories, new ExceptionHandler.Factory.Enabled(exceptionType));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public PostProcessor make(MethodDescription.InDefinedShape advice, boolean exit) {
<b class="fc">&nbsp;                if (advice.getReturnType().represents(void.class)) {</b>
<b class="nc">&nbsp;                    return NoOp.INSTANCE;</b>
&nbsp;                }
<b class="fc">&nbsp;                Map&lt;String, Handler.Factory&lt;?&gt;&gt; factories = new HashMap&lt;String, Handler.Factory&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                for (Handler.Factory&lt;?&gt; factory : this.factories) {</b>
<b class="fc">&nbsp;                    if (factories.put(factory.getAnnotationType().getName(), factory) != null) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Duplicate registration of handler for &quot; + factory.getAnnotationType());</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                Map&lt;Class&lt;?&gt;, List&lt;Handler&gt;&gt; handlers = new LinkedHashMap&lt;Class&lt;?&gt;, List&lt;Handler&gt;&gt;();</b>
<b class="fc">&nbsp;                boolean scalar = false, skipOnDefaultValue = true;</b>
<b class="fc">&nbsp;                for (AnnotationDescription annotation : advice.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                    if (annotation.getAnnotationType().represents(AsScalar.class)) {</b>
<b class="fc">&nbsp;                        scalar = true;</b>
<b class="fc">&nbsp;                        skipOnDefaultValue = annotation.getValue(SKIP_ON_DEFAULT_VALUE).resolve(Boolean.class);</b>
<b class="fc">&nbsp;                        continue;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Handler.Factory&lt;?&gt; factory = factories.get(annotation.getAnnotationType().getName());</b>
<b class="fc">&nbsp;                    if (factory != null) {</b>
<b class="fc">&nbsp;                        if (handlers.put(factory.getAnnotationType(), factory.make(advice,</b>
&nbsp;                                exit,
<b class="fc">&nbsp;                                (AnnotationDescription.Loadable) annotation.prepare(factory.getAnnotationType()))) != null) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Duplicate handler registration for &quot; + annotation.getAnnotationType());</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (handlers.isEmpty()) {</b>
<b class="fc">&nbsp;                    return NoOp.INSTANCE;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return !scalar &amp;&amp; advice.getReturnType().isArray()</b>
<b class="fc">&nbsp;                            ? new ForArray(advice.getReturnType(), exceptionHandlerFactory, exit, handlers.values())</b>
<b class="fc">&nbsp;                            : new ForScalar(advice.getReturnType(), exceptionHandlerFactory, exit, skipOnDefaultValue, handlers.values());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A builder step for creating an {@link Advice} that uses custom mappings of annotations to constant pool values.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class WithCustomMapping {
&nbsp;
&nbsp;        /**
&nbsp;         * The post processor factory to apply.
&nbsp;         */
&nbsp;        private final PostProcessor.Factory postProcessorFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * The delegator factory to use.
&nbsp;         */
&nbsp;        private final Delegator.Factory delegatorFactory;
&nbsp;
&nbsp;        /**
&nbsp;         * A map containing dynamically computed constant pool values that are mapped by their triggering annotation type.
&nbsp;         */
&nbsp;        private final Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new custom mapping builder step without including any custom mappings.
&nbsp;         */
&nbsp;        protected WithCustomMapping() {
<b class="fc">&nbsp;            this(PostProcessor.NoOp.INSTANCE, Collections.&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt;emptyMap(), Delegator.ForRegularInvocation.Factory.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new custom mapping builder step with the given custom mappings.
&nbsp;         *
&nbsp;         * @param postProcessorFactory The post processor factory to apply.
&nbsp;         * @param offsetMappings       A map containing dynamically computed constant pool values that are mapped by their triggering annotation type.
&nbsp;         * @param delegatorFactory     The delegator factory to use.
&nbsp;         */
&nbsp;        protected WithCustomMapping(PostProcessor.Factory postProcessorFactory,
&nbsp;                                    Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings,
<b class="fc">&nbsp;                                    Delegator.Factory delegatorFactory) {</b>
<b class="fc">&nbsp;            this.postProcessorFactory = postProcessorFactory;</b>
<b class="fc">&nbsp;            this.offsetMappings = offsetMappings;</b>
<b class="fc">&nbsp;            this.delegatorFactory = delegatorFactory;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a type constant of the supplied value. Constants can be strings, method handles, method types
&nbsp;         * and any primitive or the value {@code null}.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param value The value to bind to the annotation or {@code null} to bind the parameter type&#39;s default value.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, @MaybeNull Object value) {
<b class="fc">&nbsp;            return bind(OffsetMapping.ForStackManipulation.Factory.of(type, value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the value of the supplied field. The field must be visible by the
&nbsp;         * instrumented type and must be declared by a super type of the instrumented field.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param field The field to bind to this annotation.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Field field) {
<b class="fc">&nbsp;            return bind(type, new FieldDescription.ForLoadedField(field));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the value of the supplied field. The field must be visible by the
&nbsp;         * instrumented type and must be declared by a super type of the instrumented field. The binding is defined
&nbsp;         * as read-only and applied static typing.
&nbsp;         *
&nbsp;         * @param type             The type of the annotation being bound.
&nbsp;         * @param fieldDescription The field to bind to this annotation.
&nbsp;         * @param &lt;T&gt;              The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, FieldDescription fieldDescription) {
<b class="fc">&nbsp;            return bind(new OffsetMapping.ForField.Resolved.Factory&lt;T&gt;(type, fieldDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied parameter&#39;s argument.
&nbsp;         *
&nbsp;         * @param type   The type of the annotation being bound.
&nbsp;         * @param method The method that defines the parameter.
&nbsp;         * @param index  The index of the parameter.
&nbsp;         * @param &lt;T&gt;    The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Method method, int index) {
<b class="fc">&nbsp;            if (index &lt; 0) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;A parameter cannot be negative: &quot; + index);</b>
<b class="fc">&nbsp;            } else if (method.getParameterTypes().length &lt;= index) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(method + &quot; does not declare a parameter with index &quot; + index);</b>
&nbsp;            }
<b class="fc">&nbsp;            return bind(type, new MethodDescription.ForLoadedMethod(method).getParameters().get(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied parameter&#39;s argument.
&nbsp;         *
&nbsp;         * @param type        The type of the annotation being bound.
&nbsp;         * @param constructor The constructor that defines the parameter.
&nbsp;         * @param index       The index of the parameter.
&nbsp;         * @param &lt;T&gt;         The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Constructor&lt;?&gt; constructor, int index) {
<b class="fc">&nbsp;            if (index &lt; 0) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;A parameter cannot be negative: &quot; + index);</b>
<b class="fc">&nbsp;            } else if (constructor.getParameterTypes().length &lt;= index) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(constructor + &quot; does not declare a parameter with index &quot; + index);</b>
&nbsp;            }
<b class="nc">&nbsp;            return bind(type, new MethodDescription.ForLoadedConstructor(constructor).getParameters().get(index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied parameter&#39;s argument. The binding is declared read-only and
&nbsp;         * applies static typing.
&nbsp;         *
&nbsp;         * @param type                 The type of the annotation being bound.
&nbsp;         * @param parameterDescription The parameter for which to bind an argument.
&nbsp;         * @param &lt;T&gt;                  The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, ParameterDescription parameterDescription) {
<b class="fc">&nbsp;            return bind(new OffsetMapping.ForArgument.Resolved.Factory&lt;T&gt;(type, parameterDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied type constant.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param value The type constant to bind.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Class&lt;?&gt; value) {
<b class="fc">&nbsp;            return bind(type, TypeDescription.ForLoadedType.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied type constant.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param value The type constant to bind.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, TypeDescription value) {
<b class="fc">&nbsp;            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied enumeration constant.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param value The enumeration constant to bind.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, Enum&lt;?&gt; value) {
<b class="fc">&nbsp;            return bind(type, new EnumerationDescription.ForLoadedEnumeration(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied enumeration constant.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param value The enumeration constant to bind.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, EnumerationDescription value) {
<b class="fc">&nbsp;            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied fixed value.
&nbsp;         *
&nbsp;         * @param type  The type of the annotation being bound.
&nbsp;         * @param value The value to bind to this annotation.
&nbsp;         * @param &lt;T&gt;   The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindSerialized(Class&lt;T&gt; type, Serializable value) {
<b class="fc">&nbsp;            return bindSerialized(type, value, (Class&lt;Serializable&gt;) value.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the supplied fixed value.
&nbsp;         *
&nbsp;         * @param type       The type of the annotation being bound.
&nbsp;         * @param value      The value to bind to this annotation.
&nbsp;         * @param targetType The type of {@code value} as which the instance should be treated.
&nbsp;         * @param &lt;T&gt;        The annotation type.
&nbsp;         * @param &lt;S&gt;        The type of the serialized instance.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation, S extends Serializable&gt; WithCustomMapping bindSerialized(Class&lt;T&gt; type, S value, Class&lt;? super S&gt; targetType) {
<b class="fc">&nbsp;            return bind(OffsetMapping.ForSerializedValue.Factory.of(type, value, targetType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;         *
&nbsp;         * @param type     The type of the annotation being bound.
&nbsp;         * @param property The name of the annotation property to be bound.
&nbsp;         * @param &lt;T&gt;      The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindProperty(Class&lt;T&gt; type, String property) {
<b class="fc">&nbsp;            return bind(OffsetMapping.ForStackManipulation.OfAnnotationProperty.of(type, property));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the given Java constant.
&nbsp;         *
&nbsp;         * @param type     The type of the annotation being bound.
&nbsp;         * @param constant The Java constant that is bound.
&nbsp;         * @param &lt;T&gt;      The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, JavaConstant constant) {
<b class="nc">&nbsp;            return bind(type, (ConstantValue) constant);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the given Java constant.
&nbsp;         *
&nbsp;         * @param type     The type of the annotation being bound.
&nbsp;         * @param constant The constant value that is bound.
&nbsp;         * @param &lt;T&gt;      The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, ConstantValue constant) {
<b class="nc">&nbsp;            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, constant.toStackManipulation(), constant.getTypeDescription().asGenericType()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;         *
&nbsp;         * @param type              The type of the annotation being bound.
&nbsp;         * @param stackManipulation The stack manipulation loading the bound value.
&nbsp;         * @param targetType        The type of the loaded value.
&nbsp;         * @param &lt;T&gt;               The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, StackManipulation stackManipulation, java.lang.reflect.Type targetType) {
<b class="fc">&nbsp;            return bind(type, stackManipulation, TypeDefinition.Sort.describe(targetType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;         *
&nbsp;         * @param type              The type of the annotation being bound.
&nbsp;         * @param stackManipulation The stack manipulation loading the bound value.
&nbsp;         * @param targetType        The type of the loaded value.
&nbsp;         * @param &lt;T&gt;               The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, StackManipulation stackManipulation, TypeDescription.Generic targetType) {
<b class="fc">&nbsp;            return bind(new OffsetMapping.ForStackManipulation.Factory&lt;T&gt;(type, stackManipulation, targetType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;         *
&nbsp;         * @param type                The type of the annotation being bound.
&nbsp;         * @param constructor         The constructor being bound as the lambda expression&#39;s implementation.
&nbsp;         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;         * @param &lt;T&gt;                 The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                   Constructor&lt;?&gt; constructor,
&nbsp;                                                                   Class&lt;?&gt; functionalInterface) {
<b class="nc">&nbsp;            return bindLambda(type,</b>
&nbsp;                    new MethodDescription.ForLoadedConstructor(constructor),
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(functionalInterface));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;         *
&nbsp;         * @param type                The type of the annotation being bound.
&nbsp;         * @param constructor         The constructor being bound as the lambda expression&#39;s implementation.
&nbsp;         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;         * @param methodGraphCompiler The method graph compiler that resolves the functional method of the function interface.
&nbsp;         * @param &lt;T&gt;                 The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                   Constructor&lt;?&gt; constructor,
&nbsp;                                                                   Class&lt;?&gt; functionalInterface,
&nbsp;                                                                   MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;            return bindLambda(type,</b>
&nbsp;                    new MethodDescription.ForLoadedConstructor(constructor),
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(functionalInterface),</b>
&nbsp;                    methodGraphCompiler);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;         *
&nbsp;         * @param type                The type of the annotation being bound.
&nbsp;         * @param method              The method being bound as the lambda expression&#39;s implementation.
&nbsp;         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;         * @param &lt;T&gt;                 The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                   Method method,
&nbsp;                                                                   Class&lt;?&gt; functionalInterface) {
<b class="fc">&nbsp;            return bindLambda(type,</b>
&nbsp;                    new MethodDescription.ForLoadedMethod(method),
<b class="fc">&nbsp;                    TypeDescription.ForLoadedType.of(functionalInterface));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;         *
&nbsp;         * @param type                The type of the annotation being bound.
&nbsp;         * @param method              The method being bound as the lambda expression&#39;s implementation.
&nbsp;         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;         * @param methodGraphCompiler The method graph compiler that resolves the functional method of the function interface.
&nbsp;         * @param &lt;T&gt;                 The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                   Method method,
&nbsp;                                                                   Class&lt;?&gt; functionalInterface,
&nbsp;                                                                   MethodGraph.Compiler methodGraphCompiler) {
<b class="nc">&nbsp;            return bindLambda(type,</b>
&nbsp;                    new MethodDescription.ForLoadedMethod(method),
<b class="nc">&nbsp;                    TypeDescription.ForLoadedType.of(functionalInterface),</b>
&nbsp;                    methodGraphCompiler);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;         *
&nbsp;         * @param type                The type of the annotation being bound.
&nbsp;         * @param methodDescription   The method or constructor being bound as the lambda expression&#39;s implementation.
&nbsp;         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;         * @param &lt;T&gt;                 The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                   MethodDescription.InDefinedShape methodDescription,
&nbsp;                                                                   TypeDescription functionalInterface) {
<b class="fc">&nbsp;            return bindLambda(type, methodDescription, functionalInterface, MethodGraph.Compiler.DEFAULT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation as a lambda expression via the JVM&#39;s lambda metafactory.
&nbsp;         *
&nbsp;         * @param type                The type of the annotation being bound.
&nbsp;         * @param methodDescription   The method or constuctor being bound as the lambda expression&#39;s implementation.
&nbsp;         * @param functionalInterface The functional interface that represents the lambda expression.
&nbsp;         * @param methodGraphCompiler The method graph compiler that resolves the functional method of the function interface.
&nbsp;         * @param &lt;T&gt;                 The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindLambda(Class&lt;T&gt; type,
&nbsp;                                                                   MethodDescription.InDefinedShape methodDescription,
&nbsp;                                                                   TypeDescription functionalInterface,
&nbsp;                                                                   MethodGraph.Compiler methodGraphCompiler) {
<b class="fc">&nbsp;            if (!functionalInterface.isInterface()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(functionalInterface + &quot; is not an interface type&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodList&lt;?&gt; methods = methodGraphCompiler.compile((TypeDefinition) functionalInterface)</b>
<b class="fc">&nbsp;                    .listNodes()</b>
<b class="fc">&nbsp;                    .asMethodList()</b>
<b class="fc">&nbsp;                    .filter(isAbstract());</b>
<b class="fc">&nbsp;            if (methods.size() != 1) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(functionalInterface + &quot; does not define exactly one abstract method: &quot; + methods);</b>
&nbsp;            }
<b class="fc">&nbsp;            return bindDynamic(type, new MethodDescription.Latent(new TypeDescription.Latent(&quot;java.lang.invoke.LambdaMetafactory&quot;,</b>
&nbsp;                            Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                            TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)),</b>
&nbsp;                            &quot;metafactory&quot;,
&nbsp;                            Opcodes.ACC_STATIC | Opcodes.ACC_PUBLIC,
<b class="fc">&nbsp;                            Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
<b class="fc">&nbsp;                            JavaType.CALL_SITE.getTypeStub().asGenericType(),</b>
<b class="fc">&nbsp;                            Arrays.asList(new ParameterDescription.Token(JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                    new ParameterDescription.Token(TypeDescription.ForLoadedType.of(String.class).asGenericType()),</b>
<b class="fc">&nbsp;                                    new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                    new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                    new ParameterDescription.Token(JavaType.METHOD_HANDLE.getTypeStub().asGenericType()),</b>
<b class="fc">&nbsp;                                    new ParameterDescription.Token(JavaType.METHOD_TYPE.getTypeStub().asGenericType())),</b>
<b class="fc">&nbsp;                            Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                            Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                            AnnotationValue.UNDEFINED,
&nbsp;                            TypeDescription.Generic.UNDEFINED),
<b class="fc">&nbsp;                    JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()),</b>
<b class="fc">&nbsp;                    JavaConstant.MethodHandle.of(methodDescription),</b>
<b class="fc">&nbsp;                    JavaConstant.MethodType.ofSignature(methods.asDefined().getOnly()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;         *
&nbsp;         * @param type            The type of the annotation being bound.
&nbsp;         * @param bootstrapMethod The bootstrap method returning the call site.
&nbsp;         * @param constant        The arguments supplied to the bootstrap method.
&nbsp;         * @param &lt;T&gt;             The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Method bootstrapMethod, Object... constant) {
<b class="fc">&nbsp;            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;         *
&nbsp;         * @param type            The type of the annotation being bound.
&nbsp;         * @param bootstrapMethod The bootstrap method returning the call site.
&nbsp;         * @param constants       The arguments supplied to the bootstrap method.
&nbsp;         * @param &lt;T&gt;             The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Method bootstrapMethod, List&lt;?&gt; constants) {
<b class="fc">&nbsp;            return bindDynamic(type, new MethodDescription.ForLoadedMethod(bootstrapMethod), constants);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;         *
&nbsp;         * @param type            The type of the annotation being bound.
&nbsp;         * @param bootstrapMethod The bootstrap constructor returning the call site.
&nbsp;         * @param constant        The arguments supplied to the bootstrap method.
&nbsp;         * @param &lt;T&gt;             The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Constructor&lt;?&gt; bootstrapMethod, Object... constant) {
<b class="nc">&nbsp;            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;         *
&nbsp;         * @param type            The type of the annotation being bound.
&nbsp;         * @param bootstrapMethod The bootstrap constructor returning the call site.
&nbsp;         * @param constants       The arguments supplied to the bootstrap method.
&nbsp;         * @param &lt;T&gt;             The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, Constructor&lt;?&gt; bootstrapMethod, List&lt;?&gt; constants) {
<b class="nc">&nbsp;            return bindDynamic(type, new MethodDescription.ForLoadedConstructor(bootstrapMethod), constants);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;         *
&nbsp;         * @param type            The type of the annotation being bound.
&nbsp;         * @param bootstrapMethod The bootstrap method or constructor returning the call site.
&nbsp;         * @param constant        The arguments supplied to the bootstrap method.
&nbsp;         * @param &lt;T&gt;             The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, MethodDescription.InDefinedShape bootstrapMethod, Object... constant) {
<b class="fc">&nbsp;            return bindDynamic(type, bootstrapMethod, Arrays.asList(constant));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to a dynamically bootstrapped value.
&nbsp;         *
&nbsp;         * @param type            The type of the annotation being bound.
&nbsp;         * @param bootstrapMethod The bootstrap method or constructor returning the call site.
&nbsp;         * @param constants       The arguments supplied to the bootstrap method.
&nbsp;         * @param &lt;T&gt;             The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bindDynamic(Class&lt;T&gt; type, MethodDescription.InDefinedShape bootstrapMethod, List&lt;?&gt; constants) {
<b class="fc">&nbsp;            List&lt;JavaConstant&gt; arguments = JavaConstant.Simple.wrap(constants);</b>
<b class="fc">&nbsp;            if (!bootstrapMethod.isInvokeBootstrap(TypeList.Explicit.of(arguments))) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a valid bootstrap method &quot; + bootstrapMethod + &quot; for &quot; + arguments);</b>
&nbsp;            }
<b class="fc">&nbsp;            return bind(new OffsetMapping.ForStackManipulation.OfDynamicInvocation&lt;T&gt;(type, bootstrapMethod, arguments));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds the supplied annotation to the annotation&#39;s property of the specified name.
&nbsp;         *
&nbsp;         * @param type          The type of the annotation being bound.
&nbsp;         * @param offsetMapping The offset mapping being bound.
&nbsp;         * @param &lt;T&gt;           The annotation type.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation during binding.
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; WithCustomMapping bind(Class&lt;T&gt; type, OffsetMapping offsetMapping) {
<b class="fc">&nbsp;            return bind(new OffsetMapping.Factory.Simple&lt;T&gt;(type, offsetMapping));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Binds an annotation to a dynamically computed value. Whenever the {@link Advice} component discovers the given annotation on
&nbsp;         * a parameter of an advice method, the dynamic value is asked to provide a value that is then assigned to the parameter in question.
&nbsp;         *
&nbsp;         * @param offsetMapping The dynamic value that is computed for binding the parameter to a value.
&nbsp;         * @return A new builder for an advice that considers the supplied annotation type during binding.
&nbsp;         */
&nbsp;        public WithCustomMapping bind(OffsetMapping.Factory&lt;?&gt; offsetMapping) {
<b class="fc">&nbsp;            Map&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt; offsetMappings = new LinkedHashMap&lt;Class&lt;? extends Annotation&gt;, OffsetMapping.Factory&lt;?&gt;&gt;(this.offsetMappings);</b>
<b class="fc">&nbsp;            if (!offsetMapping.getAnnotationType().isAnnotation()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + offsetMapping.getAnnotationType());</b>
<b class="fc">&nbsp;            } else if (offsetMappings.put(offsetMapping.getAnnotationType(), offsetMapping) != null) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Annotation type already mapped: &quot; + offsetMapping.getAnnotationType());</b>
&nbsp;            }
<b class="fc">&nbsp;            return new WithCustomMapping(postProcessorFactory, offsetMappings, delegatorFactory);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied constructor as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;         * method arguments are:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} representing the constructor&#39;s internal name {@code &lt;init&gt;}.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} of the target&#39;s binary class name.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code int} with value {@code 0} for an enter advice and {code 1} for an exist advice.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link Class} representing the class implementing the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} with the name of the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} representing the instrumented method unless the target is the type&#39;s static initializer.&lt;/li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         *
&nbsp;         * @param constructor The bootstrap constructor.
&nbsp;         * @return A new builder for an advice that uses the supplied constructor for bootstrapping.
&nbsp;         */
&nbsp;        public WithCustomMapping bootstrap(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied constructor as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;         * method arguments are provided explicitly by the supplied resolver.
&nbsp;         *
&nbsp;         * @param constructor     The bootstrap constructor.
&nbsp;         * @param resolverFactory A resolver factory to provide the arguments to the bootstrap method.
&nbsp;         * @return A new builder for an advice that uses the supplied constructor for bootstrapping.
&nbsp;         */
&nbsp;        public WithCustomMapping bootstrap(Constructor&lt;?&gt; constructor, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="nc">&nbsp;            return bootstrap(new MethodDescription.ForLoadedConstructor(constructor), resolverFactory);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied method as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;         * method arguments are:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} representing the method&#39;s name.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} of the target&#39;s binary class name.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code int} with value {@code 0} for an enter advice and {code 1} for an exist advice.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link Class} representing the class implementing the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} with the name of the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} representing the instrumented method unless the target is the type&#39;s static initializer.&lt;/li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         *
&nbsp;         * @param method The bootstrap method.
&nbsp;         * @return A new builder for an advice that uses the supplied method for bootstrapping.
&nbsp;         */
&nbsp;        public WithCustomMapping bootstrap(Method method) {
<b class="fc">&nbsp;            return bootstrap(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied method as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;         * method arguments are provided explicitly by the supplied resolver.
&nbsp;         *
&nbsp;         * @param method   The bootstrap method.
&nbsp;         * @param resolver A resolver to provide the arguments to the bootstrap method.
&nbsp;         * @return A new builder for an advice that uses the supplied method for bootstrapping.
&nbsp;         */
&nbsp;        public WithCustomMapping bootstrap(Method method, BootstrapArgumentResolver.Factory resolver) {
<b class="nc">&nbsp;            return bootstrap(new MethodDescription.ForLoadedMethod(method), resolver);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied method or constructor as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;         * method arguments are:
&nbsp;         * &lt;ul&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandles.Lookup} representing the source method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} representing the method&#39;s name or constructor&#39;s internal name {@code &lt;init&gt;}.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodType} representing the type that is requested for binding.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} of the target&#39;s binary class name.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code int} with value {@code 0} for an enter advice and {code 1} for an exist advice.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link Class} representing the class implementing the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@link String} with the name of the instrumented method.&lt;/li&gt;
&nbsp;         * &lt;li&gt;A {@code java.lang.invoke.MethodHandle} representing the instrumented method unless the target is the type&#39;s static initializer.&lt;/li&gt;
&nbsp;         * &lt;/ul&gt;
&nbsp;         *
&nbsp;         * @param bootstrap The bootstrap method or constructor.
&nbsp;         * @return A new builder for an advice that uses the supplied method or constructor for bootstrapping.
&nbsp;         */
&nbsp;        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap) {
<b class="fc">&nbsp;            return bootstrap(bootstrap, BootstrapArgumentResolver.ForDefaultValues.Factory.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Defines the supplied method or constructor as a dynamic invocation bootstrap target for delegating advice methods. The bootstrap
&nbsp;         * method arguments are provided explicitly by the supplied resolver.
&nbsp;         *
&nbsp;         * @param bootstrap       The bootstrap method or constructor.
&nbsp;         * @param resolverFactory A factory for a resolver to provide arguments to the bootstrap method.
&nbsp;         * @return A new builder for an advice that uses the supplied method or constructor for bootstrapping.
&nbsp;         */
&nbsp;        public WithCustomMapping bootstrap(MethodDescription.InDefinedShape bootstrap, BootstrapArgumentResolver.Factory resolverFactory) {
<b class="fc">&nbsp;            return new WithCustomMapping(postProcessorFactory, offsetMappings, Delegator.ForDynamicInvocation.of(bootstrap, resolverFactory));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Adds the supplied post processor factory for advice method post processing.
&nbsp;         *
&nbsp;         * @param postProcessorFactory The post processor factory to add.
&nbsp;         * @return A new builder for an advice that applies the supplied post processor factory.
&nbsp;         */
&nbsp;        public WithCustomMapping with(PostProcessor.Factory postProcessorFactory) {
<b class="fc">&nbsp;            return new WithCustomMapping(new PostProcessor.Factory.Compound(this.postProcessorFactory, postProcessorFactory), offsetMappings, delegatorFactory);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods. The advices binary representation is
&nbsp;         * accessed by querying the class loader of the supplied class for a class file.
&nbsp;         *
&nbsp;         * @param advice The type declaring the advice.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(Class&lt;?&gt; advice) {
<b class="fc">&nbsp;            return to(advice, ClassFileLocator.ForClassLoader.of(advice.getClassLoader()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;         *
&nbsp;         * @param advice           The type declaring the advice.
&nbsp;         * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(Class&lt;?&gt; advice, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;            return to(TypeDescription.ForLoadedType.of(advice), classFileLocator);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;         *
&nbsp;         * @param advice           A description of the type declaring the advice.
&nbsp;         * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(TypeDescription advice, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;            return Advice.to(advice, postProcessorFactory, classFileLocator, new ArrayList&lt;OffsetMapping.Factory&lt;?&gt;&gt;(offsetMappings.values()), delegatorFactory);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods. The advices binary representation is
&nbsp;         * accessed by querying the class loader of the supplied class for a class file.
&nbsp;         *
&nbsp;         * @param enterAdvice The type declaring the enter advice.
&nbsp;         * @param exitAdvice  The type declaring the exit advice.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice) {
<b class="nc">&nbsp;            ClassLoader enterLoader = enterAdvice.getClassLoader(), exitLoader = exitAdvice.getClassLoader();</b>
<b class="nc">&nbsp;            return to(enterAdvice, exitAdvice, enterLoader == exitLoader</b>
<b class="nc">&nbsp;                    ? ClassFileLocator.ForClassLoader.of(enterLoader)</b>
<b class="nc">&nbsp;                    : new ClassFileLocator.Compound(ClassFileLocator.ForClassLoader.of(enterLoader), ClassFileLocator.ForClassLoader.of(exitLoader)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;         *
&nbsp;         * @param enterAdvice      The type declaring the enter advice.
&nbsp;         * @param exitAdvice       The type declaring the exit advice.
&nbsp;         * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(Class&lt;?&gt; enterAdvice, Class&lt;?&gt; exitAdvice, ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;            return to(TypeDescription.ForLoadedType.of(enterAdvice), TypeDescription.ForLoadedType.of(exitAdvice), classFileLocator);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods. Using this method, a non-operational
&nbsp;         * class file locator is specified for the advice target. This implies that only advice targets with the &lt;i&gt;inline&lt;/i&gt; target set
&nbsp;         * to {@code false} are resolvable by the returned instance.
&nbsp;         *
&nbsp;         * @param enterAdvice The type declaring the enter advice.
&nbsp;         * @param exitAdvice  The type declaring the exit advice.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice) {
<b class="nc">&nbsp;            return to(enterAdvice, exitAdvice, ClassFileLocator.NoOp.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Implements advice where every matched method is advised by the given type&#39;s advisory methods.
&nbsp;         *
&nbsp;         * @param enterAdvice      The type declaring the enter advice.
&nbsp;         * @param exitAdvice       The type declaring the exit advice.
&nbsp;         * @param classFileLocator The class file locator for locating the advisory class&#39;s class file.
&nbsp;         * @return A method visitor wrapper representing the supplied advice.
&nbsp;         */
&nbsp;        public Advice to(TypeDescription enterAdvice, TypeDescription exitAdvice, ClassFileLocator classFileLocator) {
<b class="nc">&nbsp;            return Advice.to(enterAdvice, exitAdvice, postProcessorFactory, classFileLocator, new ArrayList&lt;OffsetMapping.Factory&lt;?&gt;&gt;(offsetMappings.values()), delegatorFactory);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A marker class that indicates that an advice method does not suppress any {@link Throwable}.
&nbsp;     */
<b class="fc">&nbsp;    private static class NoExceptionHandler extends Throwable {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The class&#39;s serial version UID.
&nbsp;         */
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the {@link NoExceptionHandler} type.
&nbsp;         */
<b class="fc">&nbsp;        private static final TypeDescription DESCRIPTION = TypeDescription.ForLoadedType.of(NoExceptionHandler.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A private constructor as this class is not supposed to be invoked.
&nbsp;         */
<b class="fc">&nbsp;        private NoExceptionHandler() {</b>
<b class="fc">&nbsp;            throw new UnsupportedOperationException(&quot;This class only serves as a marker type and should not be instantiated&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A marker type to be used as an argument for {@link OnMethodEnter#skipOn()}. If this value is set, the instrumented method
&nbsp;     * is not invoked if the annotated advice method &lt;b&gt;returns a default value&lt;/b&gt;. A default value is {@code false} for a
&nbsp;     * {@code boolean} type, {@code 0} for a {@code byte}, {@code short}, {@code char}, {@code int}, {@code long}, {@code float}
&nbsp;     * or {@code double} type and {@code null} for a reference type. It is illegal to use this value if the advice method
&nbsp;     * returns {@code void}.
&nbsp;     */
&nbsp;    public static final class OnDefaultValue {
&nbsp;
&nbsp;        /**
&nbsp;         * A private constructor as this class is not supposed to be invoked.
&nbsp;         */
<b class="fc">&nbsp;        private OnDefaultValue() {</b>
<b class="fc">&nbsp;            throw new UnsupportedOperationException(&quot;This class only serves as a marker type and should not be instantiated&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A marker type to be used as an argument for {@link OnMethodEnter#skipOn()}. If this value is set, the instrumented method
&nbsp;     * is not invoked if the annotated advice method &lt;b&gt;returns a non-default value&lt;/b&gt;. A default value is {@code false} for a
&nbsp;     * {@code boolean} type, {@code 0} for a {@code byte}, {@code short}, {@code char}, {@code int}, {@code long}, {@code float}
&nbsp;     * or {@code double} type and {@code null} for a reference type. It is illegal to use this value if the advice method
&nbsp;     * returns {@code void}.
&nbsp;     */
&nbsp;    public static final class OnNonDefaultValue {
&nbsp;
&nbsp;        /**
&nbsp;         * A private constructor as this class is not supposed to be invoked.
&nbsp;         */
<b class="fc">&nbsp;        private OnNonDefaultValue() {</b>
<b class="fc">&nbsp;            throw new UnsupportedOperationException(&quot;This class only serves as a marker type and should not be instantiated&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
