


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ClassVisitorFactory</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.asm</a>
</div>

<h1>Coverage Summary for Class: ClassVisitorFactory (net.bytebuddy.asm)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ClassVisitorFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    98.8%
  </span>
  <span class="absValue">
    (81/82)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ClassVisitorFactory$AttributeTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (29/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$00HxWE3Z</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$01r4xd3u</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$0IoR9e6L</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$0R4QdHXE</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$18jevGpG</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$288TpwbN</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$2P0ovikA</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$2YLWtwCE</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$34QYJCYE</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$4t6wrBNN</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$4UTbg5bZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$538R72qM</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$5f8qFkIG</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$5oH2sjLQ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$6kcznMLI</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$6OOdW1Bv</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$6R0opu08</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$6RnCQdtQ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$8GXEIDbI</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$8J6lV9lR</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$8NQExspZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$96mA0Pkb</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$98a0aitT</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$A038XKQQ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$a46aqDlV</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ACUV0g1l</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$aPBmSg8v</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$apCbYPg8</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$AqC43uq4</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$awT1jZ4J</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$BE4RJCjQ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$bftuaNAa</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$bfZjDaTx</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$BjbdkEZ1</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$bntKED01</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Bo1KFL2a</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$BVivalY7</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$cGOkC9pS</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$doiHSm5w</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$DXexHTlN</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$EFZigWaX</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$eVhWNWhD</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$EW8HZJtY</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$fi8Olkt4</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$FuJ9xXYU</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$G0wkJtOb</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$g4meE81O</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$GwiyMAtZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$gzPcrhcP</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$hAMleRhV</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Hd6jJMk8</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$hmVV3zUY</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ie7wEXDi</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$IhgWH7Rz</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ihV4pWv3</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Ip5KHK1y</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$iYQm5G5q</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$J3cgPeUu</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$j4Hh6e1u</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$JF2RcFPA</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$JTDul8fx</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$K7ozeF8R</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$KawZtxHZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$KB7xibUE</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$KmPYptS9</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ksOlwmvT</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$L9YOaT0O</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$LBy3keJE</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$lf0PerMg</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$LHpQObgz</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$LNuw8O35</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$M2AHgkDc</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$mbPSvCRL</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$mep5P2Is</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Mf8HxM12</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$MJclJ3Lc</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$MuqNebxw</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$MyVf065C</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$n55ElJmW</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$n8VkL5k0</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Naq4muV4</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ncjcrS2y</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$nnri8uyG</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$NnryTTZY</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$NQfzomeQ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$nu2aucsS</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$OArbCHHy</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$oE8Btmhi</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$OUobR1yR</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$p4uSAd6B</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$PJmwIEK5</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$PSF3tgRZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$pUyp2N55</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$PYH0aS2G</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$qFDIMNE0</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$qOCQQQq4</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$qSY9Y6Jh</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$qTWyQa3R</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$QXY7qXIz</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$r1NjuVAO</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$RMXtlekz</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$RRKWd8qM</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$sjljsBUi</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Ssx2yqk7</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$SWkmPp23</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$tFdvDMtX</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$TFgI3Dk2</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$tNpm2ucI</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$todeHMpE</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$TrB5akVD</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$TsCm8h1W</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$TU4CMdC1</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$uesSYwdD</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$UhmXsjgg</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$UIt8WRCN</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ukXSf8vf</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$umwDf13Y</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$uqZhB6pv</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$US2u63iW</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Ut9paU85</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$V6h5jtS1</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$VB0RwDzZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Vefx3pDA</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$vFgU1yHt</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$vQOVBp7m</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$vSpddu52</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Vsz4jZWi</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$W0bpADIe</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$W2VQmnQ6</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$W4pSHHiv</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$WahoTGRa</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$wer1OFgF</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$wMTHW2y3</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$wnWghfzF</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$woN1342J</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ws1X7pna</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$WsEyiAVn</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$wTuhjzLK</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$wTUmpsqQ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$wU73rFvJ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$xbf7wEik</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$xFBNNtD2</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$xzMThUsS</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$YqEntbW5</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$YyCrVHuZ</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$yYEbr7G1</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$Z2WPcpz5</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$zilKkwQD</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$ZmpjIO65</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ByteBuddy$zNkVQ7ho</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ConstantArrayTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (40/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ConstantDynamicTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (63/63)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$ConstantTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (50/50)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$CreateClassVisitorFactory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.1%
  </span>
  <span class="absValue">
    (143/166)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$FrameTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (70/70)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$HandleTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (36/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$LabelArrayTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (46/46)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$LabelTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (44/44)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$NullCheckedConstruction</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ClassVisitorFactory$TypePathTranslator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (23/23)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (32/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.4%
  </span>
  <span class="absValue">
    (642/666)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.asm;
&nbsp;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.modifier.FieldManifestation;
&nbsp;import net.bytebuddy.description.modifier.Ownership;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.loading.MultipleParentClassLoader;
&nbsp;import net.bytebuddy.dynamic.scaffold.TypeValidation;
&nbsp;import net.bytebuddy.dynamic.scaffold.subclass.ConstructorStrategy;
&nbsp;import net.bytebuddy.implementation.ExceptionMethod;
&nbsp;import net.bytebuddy.implementation.FieldAccessor;
&nbsp;import net.bytebuddy.implementation.Implementation;
&nbsp;import net.bytebuddy.implementation.MethodCall;
&nbsp;import net.bytebuddy.implementation.bytecode.ByteCodeAppender;
&nbsp;import net.bytebuddy.implementation.bytecode.Duplication;
&nbsp;import net.bytebuddy.implementation.bytecode.StackManipulation;
&nbsp;import net.bytebuddy.implementation.bytecode.TypeCreation;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.implementation.bytecode.member.FieldAccess;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodInvocation;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodReturn;
&nbsp;import net.bytebuddy.implementation.bytecode.member.MethodVariableAccess;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.OpenedClassReader;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.*;
&nbsp;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A factory for wrapping a {@link ClassVisitor} in Byte Buddy&#39;s package namespace to a
&nbsp; * {@link ClassVisitor} in any other namespace. Note that this API does not allow for the
&nbsp; * passing of {@link Attribute}s. which must be filtered or propagated past this translation.
&nbsp; * If the supplied visitors do not declare a method that Byte Buddy&#39;s version of ASM is aware
&nbsp; * of, an {@link UnsupportedOperationException} is thrown.
&nbsp; *
&nbsp; * @param &lt;T&gt; The type of the mapped class visitor.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public abstract class ClassVisitorFactory&lt;T&gt; {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the delegate field containing an equivalent visitor.
&nbsp;     */
&nbsp;    private static final String DELEGATE = &quot;delegate&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The name of a map with labels that have been translated previously.
&nbsp;     */
&nbsp;    private static final String LABELS = &quot;labels&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The name of the method that wraps a translated visitor, including a {@code null} check.
&nbsp;     */
&nbsp;    private static final String WRAP = &quot;wrap&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The type of the represented class visitor wrapper.
&nbsp;     */
&nbsp;    private final Class&lt;?&gt; type;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new factory.
&nbsp;     *
&nbsp;     * @param type The type of the represented class visitor wrapper.
&nbsp;     */
<b class="fc">&nbsp;    protected ClassVisitorFactory(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;        this.type = type;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the {@link ClassVisitor} type that this factory represents.
&nbsp;     *
&nbsp;     * @return The {@link ClassVisitor} type that this factory represents.
&nbsp;     */
&nbsp;    public Class&lt;?&gt; getType() {
<b class="fc">&nbsp;        return type;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a class visitor factory for the supplied {@link ClassVisitor} type.
&nbsp;     *
&nbsp;     * @param classVisitor The type of the translated class visitor.
&nbsp;     * @param &lt;S&gt;          The type of the class visitor to map to.
&nbsp;     * @return A factory for wrapping {@link ClassVisitor}s in Byte Buddy&#39;s and the supplied package namespace.
&nbsp;     */
&nbsp;    public static &lt;S&gt; ClassVisitorFactory&lt;S&gt; of(Class&lt;S&gt; classVisitor) {
<b class="fc">&nbsp;        return of(classVisitor, new ByteBuddy().with(TypeValidation.DISABLED));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a class visitor factory for the supplied {@link ClassVisitor} type.
&nbsp;     *
&nbsp;     * @param classVisitor The type of the translated {@link ClassVisitor}.
&nbsp;     * @param byteBuddy    The Byte Buddy instance to use.
&nbsp;     * @param &lt;S&gt;          The type of the class visitor to map to.
&nbsp;     * @return A factory for wrapping {@link ClassVisitor}s in Byte Buddy&#39;s and the supplied package namespace.
&nbsp;     */
&nbsp;    public static &lt;S&gt; ClassVisitorFactory&lt;S&gt; of(Class&lt;S&gt; classVisitor, ByteBuddy byteBuddy) {
<b class="fc">&nbsp;        return doPrivileged(new CreateClassVisitorFactory&lt;S&gt;(classVisitor, byteBuddy));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;     *
&nbsp;     * @param action The action to execute from a privileged context.
&nbsp;     * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;     * @return The action&#39;s resolved value.
&nbsp;     */
&nbsp;    @AccessControllerPlugin.Enhance
&nbsp;    private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;        return action.run();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for a visitor type.
&nbsp;     *
&nbsp;     * @param byteBuddy      The Byte Buddy instance to use.
&nbsp;     * @param sourceVisitor  The visitor type to map from.
&nbsp;     * @param targetVisitor  The visitor type to map to.
&nbsp;     * @param sourceTypePath The {@link TypePath} source type.
&nbsp;     * @param targetTypePath The {@link TypePath} target type.
&nbsp;     * @param appendix       The implementation to append to the constructor.
&nbsp;     * @return The created builder.
&nbsp;     * @throws Exception If an exception occurs.
&nbsp;     */
&nbsp;    private static DynamicType.Builder&lt;?&gt; toVisitorBuilder(ByteBuddy byteBuddy,
&nbsp;                                                           Class&lt;?&gt; sourceVisitor,
&nbsp;                                                           Class&lt;?&gt; targetVisitor,
&nbsp;                                                           @MaybeNull Class&lt;?&gt; sourceTypePath,
&nbsp;                                                           @MaybeNull Class&lt;?&gt; targetTypePath,
&nbsp;                                                           Implementation appendix) throws Exception {
<b class="fc">&nbsp;        DynamicType.Builder&lt;?&gt; builder = byteBuddy.subclass(sourceVisitor, ConstructorStrategy.Default.NO_CONSTRUCTORS)</b>
<b class="fc">&nbsp;                .defineField(DELEGATE, targetVisitor, Visibility.PRIVATE, FieldManifestation.FINAL)</b>
<b class="fc">&nbsp;                .defineConstructor(Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                .withParameters(targetVisitor)</b>
<b class="fc">&nbsp;                .intercept(MethodCall.invoke(sourceVisitor.getDeclaredConstructor(int.class))</b>
<b class="fc">&nbsp;                        .with(OpenedClassReader.ASM_API)</b>
<b class="fc">&nbsp;                        .andThen(FieldAccessor.ofField(DELEGATE).setsArgumentAt(0))</b>
<b class="fc">&nbsp;                        .andThen(appendix))</b>
<b class="fc">&nbsp;                .defineMethod(WRAP, sourceVisitor, Visibility.PUBLIC, Ownership.STATIC)</b>
<b class="fc">&nbsp;                .withParameters(targetVisitor)</b>
<b class="fc">&nbsp;                .intercept(new Implementation.Simple(new NullCheckedConstruction(targetVisitor)));</b>
<b class="fc">&nbsp;        if (sourceTypePath == null || targetTypePath == null) {</b>
<b class="nc">&nbsp;            return builder;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return builder</b>
<b class="fc">&nbsp;                    .defineMethod(TypePathTranslator.NAME, targetTypePath, Visibility.PRIVATE, Ownership.STATIC)</b>
<b class="fc">&nbsp;                    .withParameters(sourceTypePath)</b>
<b class="fc">&nbsp;                    .intercept(new Implementation.Simple(new TypePathTranslator(sourceTypePath, targetTypePath)));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a builder for a method visitor type.
&nbsp;     *
&nbsp;     * @param byteBuddy             The Byte Buddy instance to use.
&nbsp;     * @param sourceVisitor         The visitor type to map from.
&nbsp;     * @param targetVisitor         The visitor type to map to.
&nbsp;     * @param sourceTypePath        The {@link TypePath} source type.
&nbsp;     * @param targetTypePath        The {@link TypePath} target type.
&nbsp;     * @param sourceLabel           The {@link Label} source type.
&nbsp;     * @param targetLabel           The {@link Label} target type.
&nbsp;     * @param sourceType            The {@link Type} source type.
&nbsp;     * @param targetType            The {@link Type} target type.
&nbsp;     * @param sourceHandle          The {@link Handle} source type.
&nbsp;     * @param targetHandle          The {@link Handle} target type.
&nbsp;     * @param sourceConstantDynamic The {@link ConstantDynamic} source type.
&nbsp;     * @param targetConstantDynamic The {@link ConstantDynamic} target type.
&nbsp;     * @return The created builder.
&nbsp;     * @throws Exception If an exception occurs.
&nbsp;     */
&nbsp;    private static DynamicType.Builder&lt;?&gt; toMethodVisitorBuilder(ByteBuddy byteBuddy,
&nbsp;                                                                 Class&lt;?&gt; sourceVisitor,
&nbsp;                                                                 Class&lt;?&gt; targetVisitor,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; sourceTypePath,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; targetTypePath,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; sourceLabel,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; targetLabel,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; sourceType,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; targetType,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; sourceHandle,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; targetHandle,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; sourceConstantDynamic,
&nbsp;                                                                 @MaybeNull Class&lt;?&gt; targetConstantDynamic) throws Exception {
<b class="fc">&nbsp;        DynamicType.Builder&lt;?&gt; builder = toVisitorBuilder(byteBuddy,</b>
&nbsp;                sourceVisitor,
&nbsp;                targetVisitor,
&nbsp;                sourceTypePath,
&nbsp;                targetTypePath,
<b class="fc">&nbsp;                FieldAccessor.ofField(LABELS).setsValue(new StackManipulation.Compound(TypeCreation.of(TypeDescription.ForLoadedType.of(HashMap.class)),</b>
&nbsp;                        Duplication.SINGLE,
<b class="fc">&nbsp;                        MethodInvocation.invoke(TypeDescription.ForLoadedType.of(HashMap.class)</b>
<b class="fc">&nbsp;                                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(ElementMatchers.&lt;MethodDescription.InDefinedShape&gt;isConstructor().and(ElementMatchers.&lt;MethodDescription.InDefinedShape&gt;takesArguments(0)))</b>
<b class="fc">&nbsp;                                .getOnly())), Map.class));</b>
<b class="fc">&nbsp;        if (sourceLabel != null &amp;&amp; targetLabel != null) {</b>
<b class="fc">&nbsp;            builder = builder</b>
<b class="fc">&nbsp;                    .defineField(LABELS, Map.class, Visibility.PRIVATE, FieldManifestation.FINAL)</b>
<b class="fc">&nbsp;                    .defineMethod(LabelTranslator.NAME, targetLabel, Visibility.PRIVATE)</b>
<b class="fc">&nbsp;                    .withParameters(sourceLabel)</b>
<b class="fc">&nbsp;                    .intercept(new Implementation.Simple(new LabelTranslator(targetLabel)))</b>
<b class="fc">&nbsp;                    .defineMethod(LabelArrayTranslator.NAME, TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.ForLoadedType.of(targetLabel)), Visibility.PRIVATE)</b>
<b class="fc">&nbsp;                    .withParameters(TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.ForLoadedType.of(sourceLabel)))</b>
<b class="fc">&nbsp;                    .intercept(new Implementation.Simple(new LabelArrayTranslator(sourceLabel, targetLabel)))</b>
<b class="fc">&nbsp;                    .defineMethod(FrameTranslator.NAME, Object[].class, Visibility.PRIVATE)</b>
<b class="fc">&nbsp;                    .withParameters(Object[].class)</b>
<b class="fc">&nbsp;                    .intercept(new Implementation.Simple(new FrameTranslator(sourceLabel, targetLabel)));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (sourceHandle != null &amp;&amp; targetHandle != null) {</b>
<b class="fc">&nbsp;            builder = builder</b>
<b class="fc">&nbsp;                    .defineMethod(HandleTranslator.NAME, targetHandle, Visibility.PRIVATE, Ownership.STATIC)</b>
<b class="fc">&nbsp;                    .withParameters(sourceHandle)</b>
<b class="fc">&nbsp;                    .intercept(new Implementation.Simple(new HandleTranslator(sourceHandle, targetHandle)));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (sourceConstantDynamic != null &amp;&amp; targetConstantDynamic != null &amp;&amp; sourceHandle != null &amp;&amp; targetHandle != null) {</b>
<b class="fc">&nbsp;            builder = builder</b>
<b class="fc">&nbsp;                    .defineMethod(ConstantDynamicTranslator.NAME, targetConstantDynamic, Visibility.PRIVATE, Ownership.STATIC)</b>
<b class="fc">&nbsp;                    .withParameters(sourceConstantDynamic)</b>
<b class="fc">&nbsp;                    .intercept(new Implementation.Simple(new ConstantDynamicTranslator(sourceConstantDynamic, targetConstantDynamic, sourceHandle, targetHandle)));</b>
&nbsp;        }
<b class="fc">&nbsp;        return builder</b>
<b class="fc">&nbsp;                .defineMethod(ConstantTranslator.NAME, Object.class, Visibility.PRIVATE, Ownership.STATIC)</b>
<b class="fc">&nbsp;                .withParameters(Object.class)</b>
<b class="fc">&nbsp;                .intercept(new Implementation.Simple(new ConstantTranslator(sourceHandle, targetHandle, sourceType, targetType, sourceConstantDynamic, targetConstantDynamic)))</b>
<b class="fc">&nbsp;                .defineMethod(ConstantArrayTranslator.NAME, Object[].class, Visibility.PRIVATE, Ownership.STATIC)</b>
<b class="fc">&nbsp;                .withParameters(Object[].class)</b>
<b class="fc">&nbsp;                .intercept(new Implementation.Simple(new ConstantArrayTranslator()));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates an argument loader for a method parameter that requires conversion.
&nbsp;     *
&nbsp;     * @param source  The source type.
&nbsp;     * @param target  The target type.
&nbsp;     * @param method  The name of the method.
&nbsp;     * @param offset  The parameter offset
&nbsp;     * @param virtual {@code true} if the invoked method is virtual.
&nbsp;     * @return An appropriate argument loader factory.
&nbsp;     */
&nbsp;    private static MethodCall.ArgumentLoader.Factory toConvertedParameter(TypeDescription source, Class&lt;?&gt; target, String method, int offset, boolean virtual) {
<b class="fc">&nbsp;        return new MethodCall.ArgumentLoader.ForStackManipulation(new StackManipulation.Compound(virtual ? MethodVariableAccess.loadThis() : StackManipulation.Trivial.INSTANCE,</b>
<b class="fc">&nbsp;                MethodVariableAccess.REFERENCE.loadFrom(offset),</b>
<b class="fc">&nbsp;                MethodInvocation.invoke(source.getDeclaredMethods().filter(named(method)).getOnly())), target);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a wrapper type for an {@link Attribute} to pass attribues along a visitor chain.
&nbsp;     *
&nbsp;     * @param builder       The builder to use for the wrapper type.
&nbsp;     * @param source        The {@link Attribute} type in the original namespace.
&nbsp;     * @param target        The {@link Attribute} type in the targeted namespace.
&nbsp;     * @param sourceWrapper The wrapper type for the {@link Attribute} type in the original namespace.
&nbsp;     * @param targetWrapper The wrapper type for the {@link Attribute} type in the targeted namespace.
&nbsp;     * @return The created dynamic type.
&nbsp;     * @throws Exception If the dynamic type cannot be built.
&nbsp;     */
&nbsp;    private static DynamicType toAttributeWrapper(DynamicType.Builder&lt;?&gt; builder, Class&lt;?&gt; source, Class&lt;?&gt; target, TypeDescription sourceWrapper, TypeDescription targetWrapper) throws Exception {
<b class="fc">&nbsp;        return builder</b>
<b class="fc">&nbsp;                .defineField(DELEGATE, target, Visibility.PUBLIC, FieldManifestation.FINAL)</b>
<b class="fc">&nbsp;                .defineConstructor(Visibility.PUBLIC)</b>
<b class="fc">&nbsp;                .withParameters(target)</b>
<b class="fc">&nbsp;                .intercept(MethodCall.invoke(source.getDeclaredConstructor(String.class))</b>
<b class="fc">&nbsp;                        .onSuper()</b>
<b class="fc">&nbsp;                        .with(new StackManipulation.Compound(</b>
<b class="fc">&nbsp;                                MethodVariableAccess.REFERENCE.loadFrom(1),</b>
<b class="fc">&nbsp;                                FieldAccess.forField(new FieldDescription.ForLoadedField(target.getField(&quot;type&quot;))).read()), String.class)</b>
<b class="fc">&nbsp;                        .andThen(FieldAccessor.ofField(DELEGATE).setsArgumentAt(0)))</b>
<b class="fc">&nbsp;                .defineMethod(AttributeTranslator.NAME, source, Visibility.PUBLIC, Ownership.STATIC)</b>
<b class="fc">&nbsp;                .withParameters(target)</b>
<b class="fc">&nbsp;                .intercept(new Implementation.Simple(new AttributeTranslator(source, target, sourceWrapper, targetWrapper)))</b>
<b class="fc">&nbsp;                .method(isProtected())</b>
<b class="fc">&nbsp;                .intercept(ExceptionMethod.throwing(UnsupportedOperationException.class))</b>
<b class="fc">&nbsp;                .method(named(&quot;isUnknown&quot;))</b>
<b class="fc">&nbsp;                .intercept(MethodCall.invoke(target.getMethod(&quot;isUnknown&quot;)).onField(DELEGATE))</b>
<b class="fc">&nbsp;                .method(named(&quot;isCodeAttribute&quot;))</b>
<b class="fc">&nbsp;                .intercept(MethodCall.invoke(target.getMethod(&quot;isCodeAttribute&quot;)).onField(DELEGATE))</b>
<b class="fc">&nbsp;                .make();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Wraps a {@link ClassVisitor} within an instance of the supplied class visitor type.
&nbsp;     *
&nbsp;     * @param classVisitor The class visitor to wrap.
&nbsp;     * @return A class visitor that wraps the supplied class visitor.
&nbsp;     */
&nbsp;    public abstract T wrap(ClassVisitor classVisitor);
&nbsp;
&nbsp;    /**
&nbsp;     * Unwraps an instance of the supplied class visitor as a {@link ClassVisitor}.
&nbsp;     *
&nbsp;     * @param classVisitor The class visitor to unwrap.
&nbsp;     * @return A class visitor that unwraps the supplied class visitor.
&nbsp;     */
&nbsp;    public abstract ClassVisitor unwrap(T classVisitor);
&nbsp;
&nbsp;    /**
&nbsp;     * An appender that performs a {@code null}-checked construction.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class NullCheckedConstruction implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The constructed type.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a byte code appender for creating a {@code null}-checked construction.
&nbsp;         *
&nbsp;         * @param type The constructed type.
&nbsp;         */
<b class="fc">&nbsp;        protected NullCheckedConstruction(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor,
&nbsp;                          Implementation.Context implementationContext,
&nbsp;                          MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            Label label = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNULL, label);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.NEW, implementationContext.getInstrumentedType().getInternalName());</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(type)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(label);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(3, 1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate a {@link Label} from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class LabelTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;label&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The label type that is targeted.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; target;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new label translator.
&nbsp;         *
&nbsp;         * @param target The label type that is targeted.
&nbsp;         */
<b class="fc">&nbsp;        protected LabelTranslator(Class&lt;?&gt; target) {</b>
<b class="fc">&nbsp;            this.target = target;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label(), end = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, CompoundList.of(</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType(),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitFieldInsn(Opcodes.GETFIELD,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    LABELS,
<b class="fc">&nbsp;                    Type.getDescriptor(Map.class));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(Map.class),</b>
&nbsp;                    &quot;get&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class)),</b>
&nbsp;                    true);
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(target));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, end);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(target));</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(target),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
&nbsp;                    &quot;()V&quot;,
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitFieldInsn(Opcodes.GETFIELD,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    LABELS,
<b class="fc">&nbsp;                    Type.getDescriptor(Map.class));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE,</b>
<b class="fc">&nbsp;                    Type.getInternalName(Map.class),</b>
&nbsp;                    &quot;put&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class), Type.getType(Object.class)),</b>
&nbsp;                    true);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.POP);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().append(methodVisitor,</b>
<b class="fc">&nbsp;                    Collections.&lt;TypeDefinition&gt;singletonList(TypeDescription.ForLoadedType.of(target)),</b>
<b class="fc">&nbsp;                    CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(3, 3);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate an array of {@link Label}s from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class LabelArrayTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;labels&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Label} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceLabel;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Label} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetLabel;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new label array translator.
&nbsp;         *
&nbsp;         * @param sourceLabel The {@link Label} type in the original namespace.
&nbsp;         * @param targetLabel The {@link Label} type in the targeted namespace.
&nbsp;         */
<b class="fc">&nbsp;        protected LabelArrayTranslator(Class&lt;?&gt; sourceLabel, Class&lt;?&gt; targetLabel) {</b>
<b class="fc">&nbsp;            this.sourceLabel = sourceLabel;</b>
<b class="fc">&nbsp;            this.targetLabel = targetLabel;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label(), loop = new Label(), end = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, CompoundList.of(</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType(),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(targetLabel));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ISTORE, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(loop);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().append(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(targetLabel)), TypeDescription.ForLoadedType.of(int.class)),</b>
<b class="fc">&nbsp;                    CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    LabelTranslator.NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(targetLabel), Type.getType(sourceLabel)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;            methodVisitor.visitIincInsn(3, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(</b>
<b class="fc">&nbsp;                    Collections.singletonList(implementationContext.getInstrumentedType()),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList(),</b>
<b class="fc">&nbsp;                    Collections.singletonList(TypeDescription.ArrayProjection.of(TypeDescription.ForLoadedType.of(targetLabel)))));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(5, 4);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate a {@link Handle} from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class HandleTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;handle&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Handle} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceHandle;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Handle} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetHandle;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new handle translator.
&nbsp;         *
&nbsp;         * @param sourceHandle The {@link Handle} type in the original namespace.
&nbsp;         * @param targetHandle The {@link Handle} type in the targeted namespace.
&nbsp;         */
<b class="fc">&nbsp;        protected HandleTranslator(Class&lt;?&gt; sourceHandle, Class&lt;?&gt; targetHandle) {</b>
<b class="fc">&nbsp;            this.sourceHandle = sourceHandle;</b>
<b class="fc">&nbsp;            this.targetHandle = targetHandle;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(targetHandle));</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceHandle),</b>
&nbsp;                    &quot;getTag&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.INT_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceHandle),</b>
&nbsp;                    &quot;getOwner&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceHandle),</b>
&nbsp;                    &quot;getName&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(sourceHandle),</b>
&nbsp;                    &quot;getDesc&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceHandle),</b>
&nbsp;                    &quot;isInterface&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.BOOLEAN_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(targetHandle),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE, Type.INT_TYPE, Type.getType(String.class), Type.getType(String.class), Type.getType(String.class), Type.BOOLEAN_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(7, 1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate a {@link ConstantDynamic} from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ConstantDynamicTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;constantDyanmic&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link ConstantDynamic} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceConstantDynamic;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link ConstantDynamic} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetConstantDynamic;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Handle} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceHandle;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Handle} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetHandle;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant dynamic translator.
&nbsp;         *
&nbsp;         * @param sourceConstantDynamic The {@link ConstantDynamic} type in the original namespace.
&nbsp;         * @param targetConstantDynamic The {@link ConstantDynamic} type in the targeted namespace.
&nbsp;         * @param sourceHandle          The {@link Handle} type in the original namespace.
&nbsp;         * @param targetHandle          The {@link Handle} type in the targeted namespace.
&nbsp;         */
<b class="fc">&nbsp;        protected ConstantDynamicTranslator(Class&lt;?&gt; sourceConstantDynamic, Class&lt;?&gt; targetConstantDynamic, Class&lt;?&gt; sourceHandle, Class&lt;?&gt; targetHandle) {</b>
<b class="fc">&nbsp;            this.sourceConstantDynamic = sourceConstantDynamic;</b>
<b class="fc">&nbsp;            this.targetConstantDynamic = targetConstantDynamic;</b>
<b class="fc">&nbsp;            this.sourceHandle = sourceHandle;</b>
<b class="fc">&nbsp;            this.targetHandle = targetHandle;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label loop = new Label(), end = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceConstantDynamic),</b>
&nbsp;                    &quot;getBootstrapMethodArgumentCount&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.INT_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(Object.class));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ASTORE, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ISTORE, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(loop);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().append(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceConstantDynamic),</b>
&nbsp;                    &quot;getBootstrapMethodArgument&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(Object.class), Type.INT_TYPE),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    &quot;ldc&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;            methodVisitor.visitIincInsn(2, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList(),</b>
<b class="fc">&nbsp;                    TypeDescription.ForLoadedType.of(Object[].class)));</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(targetConstantDynamic));</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceConstantDynamic),</b>
&nbsp;                    &quot;getName&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceConstantDynamic),</b>
&nbsp;                    &quot;getDescriptor&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceConstantDynamic),</b>
&nbsp;                    &quot;getBootstrapMethod&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(sourceHandle)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    HandleTranslator.NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(targetHandle), Type.getType(sourceHandle)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(targetConstantDynamic),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(String.class), Type.getType(String.class), Type.getType(targetHandle), Type.getType(Object[].class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitMaxs(6, 3);</b>
<b class="fc">&nbsp;            return new Size(6, 3);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate a constant value from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ConstantTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;constant&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Handle} type in the original namespace.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final Class&lt;?&gt; sourceHandle;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Handle} type in the targeted namespace.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final Class&lt;?&gt; targetHandle;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Type} type in the original namespace.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final Class&lt;?&gt; sourceType;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Type} type in the targeted namespace.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final Class&lt;?&gt; targetType;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link ConstantDynamic} type in the original namespace.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final Class&lt;?&gt; sourceConstantDynamic;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link ConstantDynamic} type in the targeted namespace.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;        private final Class&lt;?&gt; targetConstantDynamic;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant translator.
&nbsp;         *
&nbsp;         * @param sourceHandle          The {@link Handle} type in the original namespace.
&nbsp;         * @param targetHandle          The {@link Handle} type in the targeted namespace.
&nbsp;         * @param sourceType            The {@link Type} type in the original namespace.
&nbsp;         * @param targetType            The {@link Type} type in the targeted namespace.
&nbsp;         * @param sourceConstantDynamic The {@link ConstantDynamic} type in the original namespace.
&nbsp;         * @param targetConstantDynamic The {@link ConstantDynamic} type in the targeted namespace.
&nbsp;         */
&nbsp;        protected ConstantTranslator(@MaybeNull Class&lt;?&gt; sourceHandle,
&nbsp;                                     @MaybeNull Class&lt;?&gt; targetHandle,
&nbsp;                                     @MaybeNull Class&lt;?&gt; sourceType,
&nbsp;                                     @MaybeNull Class&lt;?&gt; targetType,
&nbsp;                                     @MaybeNull Class&lt;?&gt; sourceConstantDynamic,
<b class="fc">&nbsp;                                     @MaybeNull Class&lt;?&gt; targetConstantDynamic) {</b>
<b class="fc">&nbsp;            this.sourceHandle = sourceHandle;</b>
<b class="fc">&nbsp;            this.targetHandle = targetHandle;</b>
<b class="fc">&nbsp;            this.sourceType = sourceType;</b>
<b class="fc">&nbsp;            this.targetType = targetType;</b>
<b class="fc">&nbsp;            this.sourceConstantDynamic = sourceConstantDynamic;</b>
<b class="fc">&nbsp;            this.targetConstantDynamic = targetConstantDynamic;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label noType = new Label(), noHandle = new Label(), noConstantDynamic = new Label();</b>
<b class="fc">&nbsp;            if (sourceType != null &amp;&amp; targetType != null) {</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceType));</b>
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.IFEQ, noType);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceType));</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                        Type.getInternalName(sourceType),</b>
&nbsp;                        &quot;getDescriptor&quot;,
<b class="fc">&nbsp;                        Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                        Type.getInternalName(targetType),</b>
&nbsp;                        &quot;getType&quot;,
<b class="fc">&nbsp;                        Type.getMethodDescriptor(Type.getType(targetType), Type.getType(String.class)),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(noType);</b>
<b class="fc">&nbsp;                implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
&nbsp;            }
<b class="fc">&nbsp;            if (sourceHandle != null &amp;&amp; targetHandle != null) {</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceHandle));</b>
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.IFEQ, noHandle);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceHandle));</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                        implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                        HandleTranslator.NAME,
<b class="fc">&nbsp;                        Type.getMethodDescriptor(Type.getType(targetHandle), Type.getType(sourceHandle)),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(noHandle);</b>
<b class="fc">&nbsp;                implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
&nbsp;            }
<b class="fc">&nbsp;            if (sourceConstantDynamic != null &amp;&amp; targetConstantDynamic != null) {</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceConstantDynamic));</b>
<b class="fc">&nbsp;                methodVisitor.visitJumpInsn(Opcodes.IFEQ, noConstantDynamic);</b>
<b class="fc">&nbsp;                methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;                methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceConstantDynamic));</b>
<b class="fc">&nbsp;                methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                        implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                        ConstantDynamicTranslator.NAME,
<b class="fc">&nbsp;                        Type.getMethodDescriptor(Type.getType(targetConstantDynamic), Type.getType(sourceConstantDynamic)),</b>
&nbsp;                        false);
<b class="fc">&nbsp;                methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;                methodVisitor.visitLabel(noConstantDynamic);</b>
<b class="fc">&nbsp;                implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
&nbsp;            }
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(1, 1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate an array of constants from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    protected static class ConstantArrayTranslator implements ByteCodeAppender {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;constants&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label(), loop = new Label(), end = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(Object.class));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ASTORE, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ISTORE, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(loop);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().append(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    ConstantTranslator.NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(Object.class), Type.getType(Object.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;            methodVisitor.visitIincInsn(2, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList(),</b>
<b class="fc">&nbsp;                    TypeDescription.ForLoadedType.of(Object[].class)));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(4, 3);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate a stack map frame array from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class FrameTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;frames&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Label} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceLabel;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Label} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetLabel;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new frame translator.
&nbsp;         *
&nbsp;         * @param sourceLabel The {@link Label} type in the original namespace.
&nbsp;         * @param targetLabel The {@link Label} type in the targeted namespace.
&nbsp;         */
<b class="fc">&nbsp;        protected FrameTranslator(Class&lt;?&gt; sourceLabel, Class&lt;?&gt; targetLabel) {</b>
<b class="fc">&nbsp;            this.sourceLabel = sourceLabel;</b>
<b class="fc">&nbsp;            this.targetLabel = targetLabel;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label(), loop = new Label(), store = new Label(), end = new Label(), label = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, CompoundList.of(</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType(),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.ANEWARRAY, Type.getInternalName(Object.class));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ASTORE, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ICONST_0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ISTORE, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(loop);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().append(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)),</b>
<b class="fc">&nbsp;                    CompoundList.of(implementationContext.getInstrumentedType(), instrumentedMethod.getParameters().asTypeList()));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARRAYLENGTH);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IF_ICMPGE, end);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, Type.getInternalName(sourceLabel));</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFEQ, label);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(sourceLabel));</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    implementationContext.getInstrumentedType().getInternalName(),</b>
&nbsp;                    LabelTranslator.NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(targetLabel), Type.getType(sourceLabel)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.GOTO, store);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(label);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().full(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class)),</b>
<b class="fc">&nbsp;                    CompoundList.of(</b>
<b class="fc">&nbsp;                            Collections.singletonList(implementationContext.getInstrumentedType()),</b>
<b class="fc">&nbsp;                            instrumentedMethod.getParameters().asTypeList(),</b>
<b class="fc">&nbsp;                            Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class))));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ILOAD, 3);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AALOAD);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(store);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().full(methodVisitor,</b>
<b class="fc">&nbsp;                    Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class), TypeDescription.ForLoadedType.of(Object.class)),</b>
<b class="fc">&nbsp;                    CompoundList.of(</b>
<b class="fc">&nbsp;                            Collections.singletonList(implementationContext.getInstrumentedType()),</b>
<b class="fc">&nbsp;                            instrumentedMethod.getParameters().asTypeList(),</b>
<b class="fc">&nbsp;                            Arrays.asList(TypeDescription.ForLoadedType.of(Object[].class), TypeDescription.ForLoadedType.of(int.class))));</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.AASTORE);</b>
<b class="fc">&nbsp;            methodVisitor.visitIincInsn(3, 1);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.GOTO, loop);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().chop(methodVisitor, 1, CompoundList.of(</b>
<b class="fc">&nbsp;                    Collections.singletonList(implementationContext.getInstrumentedType()),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList(),</b>
<b class="fc">&nbsp;                    Collections.singletonList(TypeDescription.ForLoadedType.of(Object[].class))));</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 2);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(5, 4);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to translate a {@link TypePath} type from one namespace to another.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class TypePathTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;typePath&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link TypePath} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceTypePath;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link TypePath} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetTypePath;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type path translator.
&nbsp;         *
&nbsp;         * @param sourceTypePath The {@link TypePath} type in the original namespace.
&nbsp;         * @param targetTypePath The {@link TypePath} type in the targeted namespace.
&nbsp;         */
<b class="fc">&nbsp;        protected TypePathTranslator(Class&lt;?&gt; sourceTypePath, Class&lt;?&gt; targetTypePath) {</b>
<b class="fc">&nbsp;            this.sourceTypePath = sourceTypePath;</b>
<b class="fc">&nbsp;            this.targetTypePath = targetTypePath;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label(), end = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.GOTO, end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL,</b>
<b class="fc">&nbsp;                    Type.getInternalName(sourceTypePath),</b>
&nbsp;                    &quot;toString&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC,</b>
<b class="fc">&nbsp;                    Type.getInternalName(targetTypePath),</b>
&nbsp;                    &quot;fromString&quot;,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.getType(targetTypePath), Type.getType(String.class)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitLabel(end);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same1(methodVisitor,</b>
<b class="fc">&nbsp;                    TypeDescription.ForLoadedType.of(targetTypePath),</b>
<b class="fc">&nbsp;                    instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(1, 2);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method to wrap an {@link Attribute}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class AttributeTranslator implements ByteCodeAppender {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the method.
&nbsp;         */
&nbsp;        protected static final String NAME = &quot;attribute&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Attribute} type in the original namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; sourceAttribute;
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link Attribute} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; targetAttribute;
&nbsp;
&nbsp;        /**
&nbsp;         * The wrapper type for the {@link Attribute} type in the original namespace.
&nbsp;         */
&nbsp;        private final TypeDescription sourceWrapper;
&nbsp;
&nbsp;        /**
&nbsp;         * The wrapper type for the {@link Attribute} type in the targeted namespace.
&nbsp;         */
&nbsp;        private final TypeDescription targetWrapper;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new attribute translator.
&nbsp;         *
&nbsp;         * @param sourceAttribute The {@link Attribute} type in the original namespace.
&nbsp;         * @param targetAttribute The {@link Attribute} type in the targeted namespace.
&nbsp;         * @param sourceWrapper   The wrapper type for the {@link Attribute} type in the original namespace.
&nbsp;         * @param targetWrapper   The wrapper type for the {@link Attribute} type in the targeted namespace.
&nbsp;         */
<b class="fc">&nbsp;        protected AttributeTranslator(Class&lt;?&gt; sourceAttribute, Class&lt;?&gt; targetAttribute, TypeDescription sourceWrapper, TypeDescription targetWrapper) {</b>
<b class="fc">&nbsp;            this.sourceAttribute = sourceAttribute;</b>
<b class="fc">&nbsp;            this.targetAttribute = targetAttribute;</b>
<b class="fc">&nbsp;            this.sourceWrapper = sourceWrapper;</b>
<b class="fc">&nbsp;            this.targetWrapper = targetWrapper;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Size apply(MethodVisitor methodVisitor, Implementation.Context implementationContext, MethodDescription instrumentedMethod) {
<b class="fc">&nbsp;            Label nullCheck = new Label(), wrapperCheck = new Label();</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFNONNULL, nullCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ACONST_NULL);</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(nullCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.INSTANCEOF, targetWrapper.getInternalName());</b>
<b class="fc">&nbsp;            methodVisitor.visitJumpInsn(Opcodes.IFEQ, wrapperCheck);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, targetWrapper.getInternalName());</b>
<b class="fc">&nbsp;            methodVisitor.visitFieldInsn(Opcodes.GETFIELD, targetWrapper.getInternalName(), DELEGATE, Type.getDescriptor(sourceAttribute));</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            methodVisitor.visitLabel(wrapperCheck);</b>
<b class="fc">&nbsp;            implementationContext.getFrameGeneration().same(methodVisitor, instrumentedMethod.getParameters().asTypeList());</b>
<b class="fc">&nbsp;            methodVisitor.visitTypeInsn(Opcodes.NEW, sourceWrapper.getInternalName());</b>
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.DUP);</b>
<b class="fc">&nbsp;            methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);</b>
<b class="fc">&nbsp;            methodVisitor.visitMethodInsn(Opcodes.INVOKESPECIAL,</b>
<b class="fc">&nbsp;                    sourceWrapper.getInternalName(),</b>
&nbsp;                    MethodDescription.CONSTRUCTOR_INTERNAL_NAME,
<b class="fc">&nbsp;                    Type.getMethodDescriptor(Type.VOID_TYPE, Type.getType(targetAttribute)),</b>
&nbsp;                    false);
<b class="fc">&nbsp;            methodVisitor.visitInsn(Opcodes.ARETURN);</b>
<b class="fc">&nbsp;            return new Size(3, 1);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A factory for creating a wrapper for a {@link ClassVisitor}.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of the class visitor to map to.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class CreateClassVisitorFactory&lt;S&gt; implements PrivilegedAction&lt;ClassVisitorFactory&lt;S&gt;&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the translated {@link ClassVisitor}.
&nbsp;         */
&nbsp;        private final Class&lt;S&gt; classVisitor;
&nbsp;
&nbsp;        /**
&nbsp;         * The Byte Buddy instance to use.
&nbsp;         */
&nbsp;        private final ByteBuddy byteBuddy;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new factory for a class visitor wrapper.
&nbsp;         *
&nbsp;         * @param classVisitor The type of the translated {@link ClassVisitor}.
&nbsp;         * @param byteBuddy    The Byte Buddy instance to use.
&nbsp;         */
<b class="fc">&nbsp;        protected CreateClassVisitorFactory(Class&lt;S&gt; classVisitor, ByteBuddy byteBuddy) {</b>
<b class="fc">&nbsp;            this.classVisitor = classVisitor;</b>
<b class="fc">&nbsp;            this.byteBuddy = byteBuddy;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ClassVisitorFactory&lt;S&gt; run() {
<b class="fc">&nbsp;            if (!ClassVisitor.class.getSimpleName().equals(classVisitor.getSimpleName())) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Expected a class named &quot; + ClassVisitor.class.getSimpleName() + &quot;: &quot; + classVisitor);</b>
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                String prefix = classVisitor.getPackage().getName();</b>
<b class="fc">&nbsp;                Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; utilities = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                for (Class&lt;?&gt; type : Arrays.&lt;Class&lt;?&gt;&gt;asList(</b>
&nbsp;                        Attribute.class,
&nbsp;                        Label.class,
&nbsp;                        Type.class,
&nbsp;                        TypePath.class,
&nbsp;                        Handle.class,
&nbsp;                        ConstantDynamic.class
&nbsp;                )) {
&nbsp;                    Class&lt;?&gt; utility;
&nbsp;                    try {
<b class="fc">&nbsp;                        utility = Class.forName(prefix + &quot;.&quot; + type.getSimpleName(), false, classVisitor.getClassLoader());</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    utilities.put(type, utility);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (utilities.containsKey(Label.class)) {</b>
<b class="fc">&nbsp;                    utilities.put(Label[].class, Class.forName(&quot;[L&quot; + utilities.get(Label.class).getName() + &quot;;&quot;, false, classVisitor.getClassLoader()));</b>
&nbsp;                }
<b class="fc">&nbsp;                Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; equivalents = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                Map&lt;Class&lt;?&gt;, DynamicType.Builder&lt;?&gt;&gt; builders = new HashMap&lt;Class&lt;?&gt;, DynamicType.Builder&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                for (Class&lt;?&gt; type : Arrays.&lt;Class&lt;?&gt;&gt;asList(</b>
&nbsp;                        ClassVisitor.class,
&nbsp;                        AnnotationVisitor.class,
&nbsp;                        ModuleVisitor.class,
&nbsp;                        RecordComponentVisitor.class,
&nbsp;                        FieldVisitor.class,
&nbsp;                        MethodVisitor.class
&nbsp;                )) {
&nbsp;                    Class&lt;?&gt; equivalent;
&nbsp;                    try {
<b class="fc">&nbsp;                        equivalent = Class.forName(prefix + &quot;.&quot; + type.getSimpleName(), false, classVisitor.getClassLoader());</b>
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                        continue;</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                    DynamicType.Builder&lt;?&gt; wrapper, unwrapper;
<b class="fc">&nbsp;                    if (type == MethodVisitor.class) {</b>
<b class="fc">&nbsp;                        wrapper = toMethodVisitorBuilder(byteBuddy,</b>
&nbsp;                                type, equivalent,
<b class="fc">&nbsp;                                TypePath.class, utilities.get(TypePath.class),</b>
<b class="fc">&nbsp;                                Label.class, utilities.get(Label.class),</b>
<b class="fc">&nbsp;                                Type.class, utilities.get(Type.class),</b>
<b class="fc">&nbsp;                                Handle.class, utilities.get(Handle.class),</b>
<b class="fc">&nbsp;                                ConstantDynamic.class, utilities.get(ConstantDynamic.class));</b>
<b class="fc">&nbsp;                        unwrapper = toMethodVisitorBuilder(byteBuddy,</b>
&nbsp;                                equivalent, type,
<b class="fc">&nbsp;                                utilities.get(TypePath.class), TypePath.class,</b>
<b class="fc">&nbsp;                                utilities.get(Label.class), Label.class,</b>
<b class="fc">&nbsp;                                utilities.get(Type.class), Type.class,</b>
<b class="fc">&nbsp;                                utilities.get(Handle.class), Handle.class,</b>
<b class="fc">&nbsp;                                utilities.get(ConstantDynamic.class), ConstantDynamic.class);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        wrapper = toVisitorBuilder(byteBuddy,</b>
&nbsp;                                type, equivalent,
<b class="fc">&nbsp;                                TypePath.class, utilities.get(TypePath.class),</b>
&nbsp;                                new Implementation.Simple(MethodReturn.VOID));
<b class="fc">&nbsp;                        unwrapper = toVisitorBuilder(byteBuddy,</b>
&nbsp;                                equivalent, type,
<b class="fc">&nbsp;                                utilities.get(TypePath.class), TypePath.class,</b>
&nbsp;                                new Implementation.Simple(MethodReturn.VOID));
&nbsp;                    }
<b class="fc">&nbsp;                    equivalents.put(type, equivalent);</b>
<b class="fc">&nbsp;                    builders.put(type, wrapper);</b>
<b class="fc">&nbsp;                    builders.put(equivalent, unwrapper);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                List&lt;DynamicType&gt; dynamicTypes = new ArrayList&lt;DynamicType&gt;();</b>
<b class="fc">&nbsp;                Map&lt;Class&lt;?&gt;, TypeDescription&gt; generated = new HashMap&lt;Class&lt;?&gt;, TypeDescription&gt;();</b>
&nbsp;                DynamicType sourceAttribute, targetAttribute;
<b class="fc">&nbsp;                if (utilities.containsKey(Attribute.class)) {</b>
<b class="fc">&nbsp;                    DynamicType.Builder&lt;?&gt; source = byteBuddy.subclass(Attribute.class, ConstructorStrategy.Default.NO_CONSTRUCTORS);</b>
<b class="fc">&nbsp;                    DynamicType.Builder&lt;?&gt; target = byteBuddy.subclass(utilities.get(Attribute.class), ConstructorStrategy.Default.NO_CONSTRUCTORS);</b>
<b class="fc">&nbsp;                    sourceAttribute = toAttributeWrapper(source, Attribute.class, utilities.get(Attribute.class), source.toTypeDescription(), target.toTypeDescription());</b>
<b class="fc">&nbsp;                    dynamicTypes.add(sourceAttribute);</b>
<b class="fc">&nbsp;                    targetAttribute = toAttributeWrapper(target, utilities.get(Attribute.class), Attribute.class, target.toTypeDescription(), source.toTypeDescription());</b>
<b class="fc">&nbsp;                    dynamicTypes.add(targetAttribute);</b>
<b class="fc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    sourceAttribute = null;</b>
<b class="nc">&nbsp;                    targetAttribute = null;</b>
&nbsp;                }
<b class="fc">&nbsp;                for (Map.Entry&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; entry : equivalents.entrySet()) {</b>
<b class="fc">&nbsp;                    DynamicType.Builder&lt;?&gt; wrapper = builders.get(entry.getKey()), unwrapper = builders.get(entry.getValue());</b>
<b class="fc">&nbsp;                    for (Method method : entry.getKey().getMethods()) {</b>
<b class="fc">&nbsp;                        if (method.getDeclaringClass() == Object.class) {</b>
<b class="fc">&nbsp;                            continue;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        Class&lt;?&gt;[] parameter = method.getParameterTypes(), match = new Class&lt;?&gt;[parameter.length];</b>
<b class="fc">&nbsp;                        List&lt;MethodCall.ArgumentLoader.Factory&gt; left = new ArrayList&lt;MethodCall.ArgumentLoader.Factory&gt;(parameter.length);</b>
<b class="fc">&nbsp;                        List&lt;MethodCall.ArgumentLoader.Factory&gt; right = new ArrayList&lt;MethodCall.ArgumentLoader.Factory&gt;(match.length);</b>
<b class="fc">&nbsp;                        boolean unsupported = false, unresolved = false;</b>
<b class="fc">&nbsp;                        int offset = 1;</b>
<b class="fc">&nbsp;                        for (int index = 0; index &lt; parameter.length; index++) {</b>
<b class="fc">&nbsp;                            if (entry.getKey() == MethodVisitor.class &amp;&amp; parameter[index] == Label.class) {</b>
<b class="fc">&nbsp;                                match[index] = utilities.get(Label.class);</b>
<b class="fc">&nbsp;                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], LabelTranslator.NAME, offset, true));</b>
<b class="fc">&nbsp;                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], LabelTranslator.NAME, offset, true));</b>
<b class="fc">&nbsp;                            } else if (entry.getKey() == MethodVisitor.class &amp;&amp; parameter[index] == Label[].class) {</b>
<b class="fc">&nbsp;                                match[index] = utilities.get(Label[].class);</b>
<b class="fc">&nbsp;                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], LabelArrayTranslator.NAME, offset, true));</b>
<b class="fc">&nbsp;                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], LabelArrayTranslator.NAME, offset, true));</b>
<b class="fc">&nbsp;                            } else if (parameter[index] == TypePath.class) {</b>
<b class="fc">&nbsp;                                match[index] = utilities.get(TypePath.class);</b>
<b class="fc">&nbsp;                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], TypePathTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], TypePathTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                            } else if (entry.getKey() == MethodVisitor.class &amp;&amp; parameter[index] == Handle.class) {</b>
<b class="fc">&nbsp;                                match[index] = utilities.get(Handle.class);</b>
<b class="fc">&nbsp;                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), match[index], HandleTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), parameter[index], HandleTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                            } else if (entry.getKey() == MethodVisitor.class &amp;&amp; parameter[index] == Object.class) {</b>
<b class="fc">&nbsp;                                match[index] = Object.class;</b>
<b class="fc">&nbsp;                                left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), Object.class, ConstantTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                                right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), Object.class, ConstantTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                            } else if (entry.getKey() == MethodVisitor.class &amp;&amp; parameter[index] == Object[].class) {</b>
<b class="fc">&nbsp;                                match[index] = Object[].class;</b>
<b class="fc">&nbsp;                                if (method.getName().equals(&quot;visitFrame&quot;)) {</b>
<b class="fc">&nbsp;                                    left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), Object[].class, FrameTranslator.NAME, offset, true));</b>
<b class="fc">&nbsp;                                    right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), Object[].class, FrameTranslator.NAME, offset, true));</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    left.add(toConvertedParameter(builders.get(entry.getKey()).toTypeDescription(), Object[].class, ConstantArrayTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                                    right.add(toConvertedParameter(builders.get(entry.getValue()).toTypeDescription(), Object[].class, ConstantArrayTranslator.NAME, offset, false));</b>
&nbsp;                                }
<b class="fc">&nbsp;                            } else if (parameter[index] == Attribute.class) {</b>
<b class="fc">&nbsp;                                match[index] = utilities.get(Attribute.class);</b>
<b class="fc">&nbsp;                                if (sourceAttribute != null &amp;&amp; targetAttribute != null) {</b>
<b class="fc">&nbsp;                                    left.add(toConvertedParameter(targetAttribute.getTypeDescription(), utilities.get(Attribute.class), AttributeTranslator.NAME, offset, false));</b>
<b class="fc">&nbsp;                                    right.add(toConvertedParameter(sourceAttribute.getTypeDescription(), Attribute.class, AttributeTranslator.NAME, offset, false));</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    unsupported = true;</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="fc">&nbsp;                                match[index] = parameter[index];</b>
<b class="fc">&nbsp;                                left.add(new MethodCall.ArgumentLoader.ForMethodParameter.Factory(index));</b>
<b class="fc">&nbsp;                                right.add(new MethodCall.ArgumentLoader.ForMethodParameter.Factory(index));</b>
&nbsp;                            }
<b class="fc">&nbsp;                            if (match[index] == null) {</b>
<b class="nc">&nbsp;                                unresolved = true;</b>
<b class="nc">&nbsp;                                break;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            offset += parameter[index] == long.class || parameter[index] == double.class ? 2 : 1;</b>
&nbsp;                        }
&nbsp;                        Method target;
<b class="fc">&nbsp;                        if (unresolved) {</b>
<b class="nc">&nbsp;                            target = null;</b>
<b class="nc">&nbsp;                            unsupported = true;</b>
&nbsp;                        } else {
&nbsp;                            try {
<b class="fc">&nbsp;                                target = entry.getValue().getMethod(method.getName(), match);</b>
<b class="nc">&nbsp;                            } catch (NoSuchMethodException ignored) {</b>
<b class="nc">&nbsp;                                target = null;</b>
<b class="nc">&nbsp;                                unsupported = true;</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if (unsupported) {</b>
<b class="nc">&nbsp;                            wrapper = wrapper.method(is(method)).intercept(ExceptionMethod.throwing(UnsupportedOperationException.class));</b>
<b class="nc">&nbsp;                            if (target != null) {</b>
<b class="nc">&nbsp;                                unwrapper = unwrapper.method(is(target)).intercept(ExceptionMethod.throwing(UnsupportedOperationException.class));</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="fc">&nbsp;                            MethodCall wrapping = MethodCall.invoke(target).onField(DELEGATE).with(left);</b>
<b class="fc">&nbsp;                            MethodCall unwrapping = MethodCall.invoke(method).onField(DELEGATE).with(right);</b>
<b class="fc">&nbsp;                            Class&lt;?&gt; returned = equivalents.get(method.getReturnType());</b>
<b class="fc">&nbsp;                            if (returned != null) {</b>
<b class="fc">&nbsp;                                wrapping = MethodCall.invoke(builders.get(method.getReturnType())</b>
<b class="fc">&nbsp;                                        .toTypeDescription()</b>
<b class="fc">&nbsp;                                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                        .filter(named(WRAP))</b>
<b class="fc">&nbsp;                                        .getOnly()).withMethodCall(wrapping);</b>
<b class="fc">&nbsp;                                unwrapping = MethodCall.invoke(builders.get(returned).toTypeDescription()</b>
<b class="fc">&nbsp;                                        .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                        .filter(named(WRAP))</b>
<b class="fc">&nbsp;                                        .getOnly()).withMethodCall(unwrapping);</b>
&nbsp;                            }
<b class="fc">&nbsp;                            wrapper = wrapper.method(is(method)).intercept(wrapping);</b>
<b class="fc">&nbsp;                            unwrapper = unwrapper.method(is(target)).intercept(unwrapping);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    DynamicType left = wrapper.make(), right = unwrapper.make();</b>
<b class="fc">&nbsp;                    generated.put(entry.getKey(), left.getTypeDescription());</b>
<b class="fc">&nbsp;                    generated.put(entry.getValue(), right.getTypeDescription());</b>
<b class="fc">&nbsp;                    dynamicTypes.add(left);</b>
<b class="fc">&nbsp;                    dynamicTypes.add(right);</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                ClassLoader classLoader = new MultipleParentClassLoader.Builder(false)</b>
<b class="fc">&nbsp;                        .appendMostSpecific(ClassVisitor.class, classVisitor)</b>
<b class="fc">&nbsp;                        .build();</b>
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;                ClassVisitorFactory&lt;S&gt; factory = byteBuddy.subclass(ClassVisitorFactory.class, ConstructorStrategy.Default.IMITATE_SUPER_CLASS_OPENING)</b>
<b class="fc">&nbsp;                        .method(named(&quot;wrap&quot;)).intercept(MethodCall.construct(generated.get(classVisitor)</b>
<b class="fc">&nbsp;                                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(ElementMatchers.&lt;MethodDescription.InDefinedShape&gt;isConstructor())</b>
<b class="fc">&nbsp;                                .getOnly()).withArgument(0))</b>
<b class="fc">&nbsp;                        .method(named(&quot;unwrap&quot;)).intercept(MethodCall.construct(generated.get(ClassVisitor.class)</b>
<b class="fc">&nbsp;                                .getDeclaredMethods()</b>
<b class="fc">&nbsp;                                .filter(ElementMatchers.&lt;MethodDescription.InDefinedShape&gt;isConstructor())</b>
<b class="fc">&nbsp;                                .getOnly()).withArgument(0).withAssigner(Assigner.DEFAULT, Assigner.Typing.DYNAMIC))</b>
<b class="fc">&nbsp;                        .make()</b>
<b class="fc">&nbsp;                        .include(dynamicTypes)</b>
<b class="fc">&nbsp;                        .load(classLoader)</b>
<b class="fc">&nbsp;                        .getLoaded()</b>
<b class="fc">&nbsp;                        .getConstructor(Class.class)</b>
<b class="fc">&nbsp;                        .newInstance(classVisitor);</b>
<b class="fc">&nbsp;                if (classLoader instanceof MultipleParentClassLoader</b>
<b class="nc">&nbsp;                        &amp;&amp; classLoader != ClassVisitor.class.getClassLoader()</b>
<b class="nc">&nbsp;                        &amp;&amp; classLoader != classVisitor.getClassLoader()</b>
<b class="nc">&nbsp;                        &amp;&amp; !((MultipleParentClassLoader) classLoader).seal()) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Failed to seal multiple parent class loader: &quot; + classLoader);</b>
&nbsp;                }
<b class="fc">&nbsp;                return factory;</b>
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Failed to generate factory for &quot; + classVisitor.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
