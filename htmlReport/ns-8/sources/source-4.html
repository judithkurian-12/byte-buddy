


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AnnotationValue</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.annotation</a>
</div>

<h1>Coverage Summary for Class: AnnotationValue (net.bytebuddy.description.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationValue</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationValue$1</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForAnnotationDescription</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.4%
  </span>
  <span class="absValue">
    (14/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForAnnotationDescription$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (28/28)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.2%
  </span>
  <span class="absValue">
    (70/72)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (12/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForArrayType$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$5</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$6</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$7</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$8</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForConstant$PropertyDelegate$ForNonArrayType$9</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForDescriptionArray</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.2%
  </span>
  <span class="absValue">
    (56/65)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForDescriptionArray$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.7%
  </span>
  <span class="absValue">
    (41/49)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (12/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription$Loaded$WithIncompatibleRuntimeType</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (2/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription$WithUnknownConstant</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForEnumerationDescription$WithUnknownConstant$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForIncompatibleType</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForIncompatibleType$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForMismatchedType</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (8/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForMismatchedType$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForMissingType</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForMissingType$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForMissingValue</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    53.8%
  </span>
  <span class="absValue">
    (7/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForMissingValue$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForTypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (15/20)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$ForTypeDescription$Loaded</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded$AbstractBase$ForUnresolvedProperty</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded$MockitoMock$990071311</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded$MockitoMock$990071311$auxiliary$84PKXUed</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Loaded$MockitoMock$990071311$auxiliary$C4uZhp3N</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$MockitoMock$409454831</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$MockitoMock$409454831$auxiliary$rqRhKnQN</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$MockitoMock$409454831$auxiliary$xk8kmWsD</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$RenderingDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.8%
  </span>
  <span class="absValue">
    (31/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$RenderingDispatcher$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$RenderingDispatcher$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$RenderingDispatcher$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$RenderingDispatcher$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$RenderingDispatcher$5</td>
<td class="coverageStat">
  <span class="percent">
    11.1%
  </span>
  <span class="absValue">
    (1/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    5.3%
  </span>
  <span class="absValue">
    (1/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (46/46)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationValue$State</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    88.4%
  </span>
  <span class="absValue">
    (266/301)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.9%
  </span>
  <span class="absValue">
    (550/648)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.annotation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.annotation.AnnotationTypeMismatchException;
&nbsp;import java.lang.annotation.IncompleteAnnotationException;
&nbsp;import java.lang.reflect.Array;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.util.*;
&nbsp;
&nbsp;/**
&nbsp; * Representation of an unloaded annotation value where all values represent either:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;Primitive values (as their wrappers), {@link String}s or arrays of primitive types or strings.&lt;/li&gt;
&nbsp; * &lt;li&gt;A {@link TypeDescription} or an array of such a descriptions.&lt;/li&gt;
&nbsp; * &lt;li&gt;An {@link EnumerationDescription} or an array of such a description.&lt;/li&gt;
&nbsp; * &lt;li&gt;An {@link AnnotationDescription} or an array of such a description.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * The represented values are not necessarily resolvable, i.e. can contain non-available types, unknown enumeration
&nbsp; * constants or inconsistent annotations.
&nbsp; *
&nbsp; * @param &lt;T&gt; The represented value&#39;s unloaded type.
&nbsp; * @param &lt;S&gt; The represented value&#39;s  loaded type.
&nbsp; */
&nbsp;public interface AnnotationValue&lt;T, S&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * An undefined annotation value.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    AnnotationValue&lt;?, ?&gt; UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the state of the represented annotation value.
&nbsp;     *
&nbsp;     * @return The state represented by this instance.
&nbsp;     */
&nbsp;    State getState();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the property type of the annotation value.
&nbsp;     *
&nbsp;     * @return The property type of the annotation value.
&nbsp;     */
&nbsp;    Sort getSort();
&nbsp;
&nbsp;    /**
&nbsp;     * Filters this annotation value as a valid value of the provided property.
&nbsp;     *
&nbsp;     * @param property The property to filter against.
&nbsp;     * @return This annotation value or a new annotation value that describes why this value is not a valid value for the supplied property.
&nbsp;     */
&nbsp;    AnnotationValue&lt;T, S&gt; filter(MethodDescription.InDefinedShape property);
&nbsp;
&nbsp;    /**
&nbsp;     * Filters this annotation value as a valid value of the provided property.
&nbsp;     *
&nbsp;     * @param property       The property to filter against.
&nbsp;     * @param typeDefinition The expected type.
&nbsp;     * @return This annotation value or a new annotation value that describes why this value is not a valid value for the supplied property.
&nbsp;     */
&nbsp;    AnnotationValue&lt;T, S&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition);
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves the unloaded value of this annotation. The return value of this method is not defined if this annotation value is invalid.
&nbsp;     *
&nbsp;     * @return The unloaded value of this annotation.
&nbsp;     */
&nbsp;    T resolve();
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves the unloaded value of this annotation. The return value of this method is not defined if this annotation value is invalid.
&nbsp;     *
&nbsp;     * @param type The annotation value&#39;s unloaded type.
&nbsp;     * @param &lt;W&gt;  The annotation value&#39;s unloaded type.
&nbsp;     * @return The unloaded value of this annotation.
&nbsp;     */
&nbsp;    &lt;W&gt; W resolve(Class&lt;? extends W&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the loaded value of this annotation.
&nbsp;     *
&nbsp;     * @param classLoader The class loader for loading this value or {@code null} for using the boot loader.
&nbsp;     * @return The loaded value of this annotation.
&nbsp;     */
&nbsp;    Loaded&lt;S&gt; load(@MaybeNull ClassLoader classLoader);
&nbsp;
&nbsp;    /**
&nbsp;     * A rendering dispatcher is responsible for resolving annotation values to {@link String} representations.
&nbsp;     */
<b class="fc">&nbsp;    enum RenderingDispatcher {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for any VM previous to Java 9.
&nbsp;         */
<b class="fc">&nbsp;        LEGACY_VM(&#39;[&#39;, &#39;]&#39;, true) {</b>
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
<b class="fc">&nbsp;                return Character.toString(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
<b class="fc">&nbsp;                return Long.toString(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
<b class="fc">&nbsp;                return Float.toString(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
<b class="fc">&nbsp;                return Double.toString(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
<b class="fc">&nbsp;                return value;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
<b class="fc">&nbsp;                return value.toString();</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 9 onward.
&nbsp;         */
<b class="fc">&nbsp;        JAVA_9_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, true) {</b>
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder().append(&#39;\&#39;&#39;);</b>
<b class="fc">&nbsp;                if (value == &#39;\&#39;&#39;) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    stringBuilder.append(value);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Integer.MAX_VALUE</b>
<b class="fc">&nbsp;                        ? String.valueOf(value)</b>
<b class="fc">&nbsp;                        : value + &quot;L&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE // Float.isFinite(value)</b>
<b class="fc">&nbsp;                        ? value + &quot;f&quot;</b>
<b class="fc">&nbsp;                        : (Float.isInfinite(value) ? (value &lt; 0.0f ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE // Double.isFinite(value)</b>
<b class="fc">&nbsp;                        ? Double.toString(value)</b>
<b class="fc">&nbsp;                        : (Double.isInfinite(value) ? (value &lt; 0.0d ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
<b class="fc">&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(&#39;&quot;&#39;) == -1</b>
<b class="fc">&nbsp;                        ? value</b>
<b class="fc">&nbsp;                        : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
<b class="fc">&nbsp;                return value.getActualName() + &quot;.class&quot;;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 14 onward.
&nbsp;         */
<b class="fc">&nbsp;        JAVA_14_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, true) {</b>
&nbsp;            @Override
&nbsp;            public String toSourceString(byte value) {
<b class="fc">&nbsp;                return &quot;(byte)0x&quot; + Integer.toHexString(value &amp; 0xFF);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder().append(&#39;\&#39;&#39;);</b>
<b class="fc">&nbsp;                if (value == &#39;\&#39;&#39;) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    stringBuilder.append(value);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
<b class="fc">&nbsp;                return value + &quot;L&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE // Float.isFinite(value)</b>
<b class="fc">&nbsp;                        ? value + &quot;f&quot;</b>
<b class="fc">&nbsp;                        : (Float.isInfinite(value) ? (value &lt; 0.0f ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE // Double.isFinite(value)</b>
<b class="fc">&nbsp;                        ? Double.toString(value)</b>
<b class="fc">&nbsp;                        : (Double.isInfinite(value) ? (value &lt; 0.0d ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
<b class="fc">&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(&#39;&quot;&#39;) == -1</b>
<b class="fc">&nbsp;                        ? value</b>
<b class="fc">&nbsp;                        : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
<b class="fc">&nbsp;                return value.getActualName() + &quot;.class&quot;;</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 17 onward.
&nbsp;         */
<b class="fc">&nbsp;        JAVA_17_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, false) {</b>
&nbsp;            @Override
&nbsp;            public String toSourceString(byte value) {
<b class="fc">&nbsp;                return &quot;(byte)0x&quot; + Integer.toHexString(value &amp; 0xFF);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder().append(&#39;\&#39;&#39;);</b>
<b class="fc">&nbsp;                if (value == &#39;\&#39;&#39;) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    stringBuilder.append(value);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
<b class="fc">&nbsp;                return value + &quot;L&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE // Float.isFinite(value)</b>
<b class="fc">&nbsp;                        ? value + &quot;f&quot;</b>
<b class="fc">&nbsp;                        : (Float.isInfinite(value) ? (value &lt; 0.0f ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
<b class="fc">&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE // Double.isFinite(value)</b>
<b class="fc">&nbsp;                        ? Double.toString(value)</b>
<b class="fc">&nbsp;                        : (Double.isInfinite(value) ? (value &lt; 0.0d ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
<b class="fc">&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(&#39;&quot;&#39;) == -1</b>
<b class="fc">&nbsp;                        ? value</b>
<b class="fc">&nbsp;                        : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
<b class="fc">&nbsp;                return value.getActualName() + &quot;.class&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toTypeErrorString(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return type.getName();</b>
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 19 onward.
&nbsp;         */
<b class="fc">&nbsp;        JAVA_19_CAPABLE_VM(&#39;{&#39;, &#39;}&#39;, ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isLessThan(ClassFileVersion.JAVA_V17)) {</b>
&nbsp;            @Override
&nbsp;            public String toSourceString(byte value) {
<b class="nc">&nbsp;                return &quot;(byte)0x&quot; + Integer.toHexString(value &amp; 0xFF);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(char value) {
<b class="nc">&nbsp;                StringBuilder stringBuilder = new StringBuilder().append(&#39;\&#39;&#39;);</b>
<b class="nc">&nbsp;                if (value == &#39;\&#39;&#39;) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&quot;\\&#39;&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(value);</b>
&nbsp;                }
<b class="nc">&nbsp;                return stringBuilder.append(&#39;\&#39;&#39;).toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(long value) {
<b class="nc">&nbsp;                return value + &quot;L&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(float value) {
<b class="nc">&nbsp;                return Math.abs(value) &lt;= Float.MAX_VALUE // Float.isFinite(value)</b>
<b class="nc">&nbsp;                        ? value + &quot;f&quot;</b>
<b class="nc">&nbsp;                        : (Float.isInfinite(value) ? (value &lt; 0.0f ? &quot;-1.0f/0.0f&quot; : &quot;1.0f/0.0f&quot;) : &quot;0.0f/0.0f&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(double value) {
<b class="nc">&nbsp;                return Math.abs(value) &lt;= Double.MAX_VALUE // Double.isFinite(value)</b>
<b class="nc">&nbsp;                        ? Double.toString(value)</b>
<b class="nc">&nbsp;                        : (Double.isInfinite(value) ? (value &lt; 0.0d ? &quot;-1.0/0.0&quot; : &quot;1.0/0.0&quot;) : &quot;0.0/0.0&quot;);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(String value) {
<b class="nc">&nbsp;                return &quot;\&quot;&quot; + (value.indexOf(&#39;&quot;&#39;) == -1</b>
<b class="nc">&nbsp;                        ? value</b>
<b class="nc">&nbsp;                        : value.replace(&quot;\&quot;&quot;, &quot;\\\&quot;&quot;)) + &quot;\&quot;&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toSourceString(TypeDescription value) {
<b class="nc">&nbsp;                return value.getCanonicalName() + &quot;.class&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toTypeErrorString(Class&lt;?&gt; type) {
<b class="nc">&nbsp;                return type.getName();</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * The prefix text for describing a mistyped array property.
&nbsp;         */
&nbsp;        private static final String ARRAY_PREFIX = &quot;Array with component tag: &quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The rendering dispatcher for the current VM.
&nbsp;         */
&nbsp;        public static final RenderingDispatcher CURRENT;
&nbsp;
&nbsp;        /*
&nbsp;         * Resolves the rendering dispatcher to use.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);</b>
<b class="fc">&nbsp;            if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V19)) {</b>
<b class="nc">&nbsp;                CURRENT = RenderingDispatcher.JAVA_19_CAPABLE_VM;</b>
<b class="fc">&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V17)) {</b>
<b class="fc">&nbsp;                CURRENT = RenderingDispatcher.JAVA_17_CAPABLE_VM;</b>
<b class="nc">&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {</b>
<b class="nc">&nbsp;                CURRENT = RenderingDispatcher.JAVA_14_CAPABLE_VM;</b>
<b class="nc">&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V9)) {</b>
<b class="nc">&nbsp;                CURRENT = RenderingDispatcher.JAVA_9_CAPABLE_VM;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                CURRENT = RenderingDispatcher.LEGACY_VM;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The opening brace of an array {@link String} representation.
&nbsp;         */
&nbsp;        private final char openingBrace;
&nbsp;
&nbsp;        /**
&nbsp;         * The closing brace of an array {@link String} representation.
&nbsp;         */
&nbsp;        private final char closingBrace;
&nbsp;
&nbsp;        /**
&nbsp;         * If {@code true}, annotation types are represented as integer rather then character value.
&nbsp;         */
&nbsp;        private final boolean componentAsInteger;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new rendering dispatcher.
&nbsp;         *
&nbsp;         * @param openingBrace       The opening brace of an array {@link String} representation.
&nbsp;         * @param closingBrace       The closing brace of an array {@link String} representation.
&nbsp;         * @param componentAsInteger If {@code true}, annotation types are represented as characters rather then integer values.
&nbsp;         */
<b class="fc">&nbsp;        RenderingDispatcher(char openingBrace, char closingBrace, boolean componentAsInteger) {</b>
<b class="fc">&nbsp;            this.openingBrace = openingBrace;</b>
<b class="fc">&nbsp;            this.closingBrace = closingBrace;</b>
<b class="fc">&nbsp;            this.componentAsInteger = componentAsInteger;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code boolean} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code boolean} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(boolean value) {
<b class="fc">&nbsp;            return Boolean.toString(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code boolean} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code boolean} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(byte value) {
<b class="fc">&nbsp;            return Byte.toString(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code short} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code short} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(short value) {
<b class="fc">&nbsp;            return Short.toString(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code char} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code char} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(char value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code int} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code int} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(int value) {
<b class="fc">&nbsp;            return Integer.toString(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code long} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code long} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(long value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code float} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code float} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(float value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@code double} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@code double} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(double value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@link String} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@link String} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(String value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied {@link TypeDescription} value as a {@link String}.
&nbsp;         *
&nbsp;         * @param value The {@link TypeDescription} value to render.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public abstract String toSourceString(TypeDescription value);
&nbsp;
&nbsp;        /**
&nbsp;         * Represents the supplied list elements as a {@link String}.
&nbsp;         *
&nbsp;         * @param values The elements to render where each element is represented by its {@link Object#toString()} representation.
&nbsp;         * @return An appropriate {@link String} representation.
&nbsp;         */
&nbsp;        public String toSourceString(List&lt;?&gt; values) {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(openingBrace);</b>
<b class="fc">&nbsp;            boolean first = true;</b>
<b class="fc">&nbsp;            for (Object value : values) {</b>
<b class="fc">&nbsp;                if (first) {</b>
<b class="fc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    stringBuilder.append(&quot;, &quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                stringBuilder.append(value);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return stringBuilder.append(closingBrace).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a string for representing an inconsistently typed array of an annotation property.
&nbsp;         *
&nbsp;         * @param sort The sort of the inconsistent property.
&nbsp;         * @return A message to describe the component property.
&nbsp;         */
&nbsp;        public String toArrayErrorString(Sort sort) {
<b class="fc">&nbsp;            return ARRAY_PREFIX + (componentAsInteger || !sort.isDefined()</b>
<b class="fc">&nbsp;                    ? Integer.toString(sort.getTag())</b>
<b class="fc">&nbsp;                    : Character.toString((char) sort.getTag()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a type to be represented in an error message for a mismatched type.
&nbsp;         *
&nbsp;         * @param type The represented type.
&nbsp;         * @return The name to represent.
&nbsp;         */
&nbsp;        public String toTypeErrorString(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return type.toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A loaded variant of an {@link AnnotationValue}. While
&nbsp;     * implementations of this value are required to be processed successfully by a
&nbsp;     * {@link java.lang.ClassLoader} they might still be unresolved. Typical errors on loading an annotation
&nbsp;     * value are:
&nbsp;     * &lt;ul&gt;
&nbsp;     * &lt;li&gt;{@link java.lang.annotation.IncompleteAnnotationException}: An annotation does not define a value
&nbsp;     * even though no default value for a property is provided.&lt;/li&gt;
&nbsp;     * &lt;li&gt;{@link java.lang.EnumConstantNotPresentException}: An annotation defines an unknown value for
&nbsp;     * a known enumeration.&lt;/li&gt;
&nbsp;     * &lt;li&gt;{@link java.lang.annotation.AnnotationTypeMismatchException}: An annotation property is not
&nbsp;     * of the expected type.&lt;/li&gt;
&nbsp;     * &lt;/ul&gt;
&nbsp;     * Implementations of this interface must implement methods for {@link Object#hashCode()} and
&nbsp;     * {@link Object#toString()} that resemble those used for the annotation values of an actual
&nbsp;     * {@link java.lang.annotation.Annotation} implementation. Also, instances must implement
&nbsp;     * {@link java.lang.Object#equals(Object)} to return {@code true} for other instances of
&nbsp;     * this interface that represent the same annotation value.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The represented value&#39;s type.
&nbsp;     */
&nbsp;    interface Loaded&lt;U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the state of the represented loaded annotation value.
&nbsp;         *
&nbsp;         * @return The state represented by this instance.
&nbsp;         */
&nbsp;        State getState();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the value to the actual value of an annotation. Calling this method might throw a runtime
&nbsp;         * exception if this value is either not defined or not resolved.
&nbsp;         *
&nbsp;         * @return The actual annotation value represented by this instance.
&nbsp;         */
&nbsp;        U resolve();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the value to the actual value of an annotation. Calling this method might throw a runtime
&nbsp;         * exception if this value is either not defined or not resolved.
&nbsp;         *
&nbsp;         * @param type The value&#39;s loaded type.
&nbsp;         * @param &lt;V&gt;  The value&#39;s loaded type.
&nbsp;         * @return The actual annotation value represented by this instance.
&nbsp;         */
&nbsp;        &lt;V&gt; V resolve(Class&lt;? extends V&gt; type);
&nbsp;
&nbsp;        /**
&nbsp;         * Verifies if this loaded value represents the supplied loaded value.
&nbsp;         *
&nbsp;         * @param value A loaded annotation value.
&nbsp;         * @return {@code true} if the supplied annotation value is represented by this annotation value.
&nbsp;         */
&nbsp;        boolean represents(Object value);
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a loaded annotation value.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The represented loaded type.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase&lt;W&gt; implements Loaded&lt;W&gt; {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;X&gt; X resolve(Class&lt;? extends X&gt; type) {
<b class="fc">&nbsp;                return type.cast(resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A base implementation for an unresolved property.
&nbsp;             *
&nbsp;             * @param &lt;Z&gt; The represented loaded type.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class ForUnresolvedProperty&lt;Z&gt; extends AbstractBase&lt;Z&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public State getState() {
<b class="fc">&nbsp;                    return State.UNRESOLVED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(Object value) {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the state of an {@link AnnotationValue}.
&nbsp;     */
<b class="fc">&nbsp;    enum State {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * An undefined annotation value describes an annotation property which is missing such that
&nbsp;         * an {@link java.lang.annotation.IncompleteAnnotationException} would be thrown.
&nbsp;         */
<b class="fc">&nbsp;        UNDEFINED,</b>
&nbsp;
&nbsp;        /**
&nbsp;         * An unresolved annotation value describes an annotation property which does not represent a
&nbsp;         * valid value but an exceptional state.
&nbsp;         */
<b class="fc">&nbsp;        UNRESOLVED,</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A resolved annotation value describes an annotation property with an actual value.
&nbsp;         */
<b class="fc">&nbsp;        RESOLVED;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if the related annotation value is defined, i.e. either represents
&nbsp;         * an actual value or an exceptional state.
&nbsp;         *
&nbsp;         * @return {@code true} if the related annotation value is defined.
&nbsp;         */
&nbsp;        public boolean isDefined() {
<b class="fc">&nbsp;            return this != UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if the related annotation value is resolved, i.e. represents an actual
&nbsp;         * value.
&nbsp;         *
&nbsp;         * @return {@code true} if the related annotation value is resolved.
&nbsp;         */
&nbsp;        public boolean isResolved() {
<b class="fc">&nbsp;            return this == RESOLVED;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents the sort of an {@link AnnotationValue}.
&nbsp;     */
<b class="fc">&nbsp;    enum Sort {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code boolean}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        BOOLEAN(&#39;Z&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code byte}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        BYTE(&#39;B&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code short}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        SHORT(&#39;S&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code char}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        CHARACTER(&#39;C&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * An {@code int}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        INTEGER(&#39;I&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code long}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        LONG(&#39;J&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code float}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        FLOAT(&#39;F&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@code double}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        DOUBLE(&#39;D&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link String}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        STRING(&#39;s&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link Class}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        TYPE(&#39;c&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link Enum}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        ENUMERATION(&#39;e&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A {@link Annotation}-typed property.
&nbsp;         */
<b class="fc">&nbsp;        ANNOTATION(&#39;@&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * An array-typed property.
&nbsp;         */
<b class="fc">&nbsp;        ARRAY(&#39;[&#39;),</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A property without a well-defined value.
&nbsp;         */
<b class="fc">&nbsp;        NONE(0);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The property&#39;s tag.
&nbsp;         */
&nbsp;        private final int tag;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new sort.
&nbsp;         *
&nbsp;         * @param tag The property&#39;s tag.
&nbsp;         */
<b class="fc">&nbsp;        Sort(int tag) {</b>
<b class="fc">&nbsp;            this.tag = tag;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a sort for the provided type definition.
&nbsp;         *
&nbsp;         * @param typeDefinition The type definition to resolve.
&nbsp;         * @return The resolved sort for the provided type definition.
&nbsp;         */
&nbsp;        public static Sort of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            if (typeDefinition.represents(boolean.class)) {</b>
<b class="fc">&nbsp;                return BOOLEAN;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(byte.class)) {</b>
<b class="fc">&nbsp;                return BYTE;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(short.class)) {</b>
<b class="fc">&nbsp;                return SHORT;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(char.class)) {</b>
<b class="fc">&nbsp;                return CHARACTER;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(int.class)) {</b>
<b class="fc">&nbsp;                return INTEGER;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(long.class)) {</b>
<b class="fc">&nbsp;                return LONG;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(float.class)) {</b>
<b class="fc">&nbsp;                return FLOAT;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(double.class)) {</b>
<b class="fc">&nbsp;                return DOUBLE;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(String.class)) {</b>
<b class="fc">&nbsp;                return STRING;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.represents(Class.class)) {</b>
<b class="fc">&nbsp;                return TYPE;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.isEnum()) {</b>
<b class="fc">&nbsp;                return ENUMERATION;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.isAnnotation()) {</b>
<b class="fc">&nbsp;                return ANNOTATION;</b>
<b class="fc">&nbsp;            } else if (typeDefinition.isArray()) {</b>
<b class="fc">&nbsp;                return ARRAY;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return NONE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the property&#39;s tag.
&nbsp;         *
&nbsp;         * @return The property&#39;s tag.
&nbsp;         */
&nbsp;        protected int getTag() {
<b class="fc">&nbsp;            return tag;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns {@code true} if the property is defined.
&nbsp;         *
&nbsp;         * @return {@code true} if the property is defined.
&nbsp;         */
&nbsp;        public boolean isDefined() {
<b class="fc">&nbsp;            return this != NONE;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of an unloaded annotation value.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The represented unloaded type.
&nbsp;     * @param &lt;V&gt; The represented loaded type.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase&lt;U, V&gt; implements AnnotationValue&lt;U, V&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;W&gt; W resolve(Class&lt;? extends W&gt; type) {
<b class="fc">&nbsp;            return type.cast(resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property) {
<b class="fc">&nbsp;            return filter(property, property.getReturnType());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a primitive value, a {@link java.lang.String} or an array of the latter types.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type where primitive values are represented by their boxed type.
&nbsp;     */
&nbsp;    class ForConstant&lt;U&gt; extends AbstractBase&lt;U, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented value.
&nbsp;         */
&nbsp;        private final U value;
&nbsp;
&nbsp;        /**
&nbsp;         * The property delegate for the value&#39;s type.
&nbsp;         */
&nbsp;        private final PropertyDelegate propertyDelegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new constant annotation value.
&nbsp;         *
&nbsp;         * @param value            The represented value.
&nbsp;         * @param propertyDelegate The property delegate for the value&#39;s type.
&nbsp;         */
<b class="fc">&nbsp;        protected ForConstant(U value, PropertyDelegate propertyDelegate) {</b>
<b class="fc">&nbsp;            this.value = value;</b>
<b class="fc">&nbsp;            this.propertyDelegate = propertyDelegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code boolean} value.
&nbsp;         *
&nbsp;         * @param value The {@code boolean} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Boolean, Boolean&gt; of(boolean value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Boolean&gt;(value, PropertyDelegate.ForNonArrayType.BOOLEAN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code byte} value.
&nbsp;         *
&nbsp;         * @param value The {@code byte} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Byte, Byte&gt; of(byte value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Byte&gt;(value, PropertyDelegate.ForNonArrayType.BYTE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code short} value.
&nbsp;         *
&nbsp;         * @param value The {@code short} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Short, Short&gt; of(short value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Short&gt;(value, PropertyDelegate.ForNonArrayType.SHORT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code char} value.
&nbsp;         *
&nbsp;         * @param value The {@code char} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Character, Character&gt; of(char value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Character&gt;(value, PropertyDelegate.ForNonArrayType.CHARACTER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code int} value.
&nbsp;         *
&nbsp;         * @param value The {@code int} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Integer, Integer&gt; of(int value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Integer&gt;(value, PropertyDelegate.ForNonArrayType.INTEGER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code long} value.
&nbsp;         *
&nbsp;         * @param value The {@code long} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Long, Long&gt; of(long value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Long&gt;(value, PropertyDelegate.ForNonArrayType.LONG);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code float} value.
&nbsp;         *
&nbsp;         * @param value The {@code float} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Float, Float&gt; of(float value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Float&gt;(value, PropertyDelegate.ForNonArrayType.FLOAT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code double} value.
&nbsp;         *
&nbsp;         * @param value The {@code double} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;Double, Double&gt; of(double value) {
<b class="fc">&nbsp;            return new ForConstant&lt;Double&gt;(value, PropertyDelegate.ForNonArrayType.DOUBLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@link String} value.
&nbsp;         *
&nbsp;         * @param value The {@link String} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;String, String&gt; of(String value) {
<b class="fc">&nbsp;            return new ForConstant&lt;String&gt;(value, PropertyDelegate.ForNonArrayType.STRING);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code boolean[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code boolean[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;boolean[], boolean[]&gt; of(boolean... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;boolean[]&gt;(value, PropertyDelegate.ForArrayType.BOOLEAN);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code byte[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code byte[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;byte[], byte[]&gt; of(byte... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;byte[]&gt;(value, PropertyDelegate.ForArrayType.BYTE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code short[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code short[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;short[], short[]&gt; of(short... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;short[]&gt;(value, PropertyDelegate.ForArrayType.SHORT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code char[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code char[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;char[], char[]&gt; of(char... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;char[]&gt;(value, PropertyDelegate.ForArrayType.CHARACTER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code int[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code int[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;int[], int[]&gt; of(int... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;int[]&gt;(value, PropertyDelegate.ForArrayType.INTEGER);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code long[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code long[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;long[], long[]&gt; of(long... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;long[]&gt;(value, PropertyDelegate.ForArrayType.LONG);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code float[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code float[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;float[], float[]&gt; of(float... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;float[]&gt;(value, PropertyDelegate.ForArrayType.FLOAT);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code double[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code double[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;double[], double[]&gt; of(double... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;double[]&gt;(value, PropertyDelegate.ForArrayType.DOUBLE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for a {@code String[]} value.
&nbsp;         *
&nbsp;         * @param value The {@code String[]} value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;String[], String[]&gt; of(String... value) {
<b class="fc">&nbsp;            return new ForConstant&lt;String[]&gt;(value, PropertyDelegate.ForArrayType.STRING);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for any constant value, i.e any primitive (wrapper) type,
&nbsp;         * any primitive array type or any {@link String} value or array. If no constant annotation
&nbsp;         * type is provided, a runtime exception is thrown.
&nbsp;         *
&nbsp;         * @param value The value to represent.
&nbsp;         * @return An appropriate annotation value.
&nbsp;         */
&nbsp;        public static AnnotationValue&lt;?, ?&gt; of(Object value) {
<b class="fc">&nbsp;            if (value instanceof Boolean) {</b>
<b class="fc">&nbsp;                return of(((Boolean) value).booleanValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Byte) {</b>
<b class="fc">&nbsp;                return of(((Byte) value).byteValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Short) {</b>
<b class="fc">&nbsp;                return of(((Short) value).shortValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Character) {</b>
<b class="fc">&nbsp;                return of(((Character) value).charValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Integer) {</b>
<b class="fc">&nbsp;                return of(((Integer) value).intValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Long) {</b>
<b class="fc">&nbsp;                return of(((Long) value).longValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Float) {</b>
<b class="fc">&nbsp;                return of(((Float) value).floatValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof Double) {</b>
<b class="fc">&nbsp;                return of(((Double) value).doubleValue());</b>
<b class="fc">&nbsp;            } else if (value instanceof String) {</b>
<b class="fc">&nbsp;                return of((String) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof boolean[]) {</b>
<b class="fc">&nbsp;                return of((boolean[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof byte[]) {</b>
<b class="fc">&nbsp;                return of((byte[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof short[]) {</b>
<b class="fc">&nbsp;                return of((short[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof char[]) {</b>
<b class="fc">&nbsp;                return of((char[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof int[]) {</b>
<b class="fc">&nbsp;                return of((int[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof long[]) {</b>
<b class="fc">&nbsp;                return of((long[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof float[]) {</b>
<b class="fc">&nbsp;                return of((float[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof double[]) {</b>
<b class="fc">&nbsp;                return of((double[]) value);</b>
<b class="fc">&nbsp;            } else if (value instanceof String[]) {</b>
<b class="fc">&nbsp;                return of((String[]) value);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not a constant annotation value: &quot; + value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.RESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="fc">&nbsp;            return Sort.of(TypeDescription.ForLoadedType.of(value.getClass()).asUnboxed());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;U, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            if (typeDefinition.asErasure().asBoxed().represents(value.getClass())) {</b>
<b class="fc">&nbsp;                return this;</b>
<b class="fc">&nbsp;            } else if (value.getClass().isArray()) {</b>
<b class="fc">&nbsp;                return new ForMismatchedType&lt;U, U&gt;(property, RenderingDispatcher.CURRENT.toArrayErrorString(Sort.of(TypeDescription.ForLoadedType.of(value.getClass().getComponentType()))));</b>
<b class="fc">&nbsp;            } else if (value instanceof Enum&lt;?&gt;) {</b>
<b class="nc">&nbsp;                return new ForMismatchedType&lt;U, U&gt;(property, value.getClass().getName() + &#39;.&#39; + ((Enum&lt;?&gt;) value).name());</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return new ForMismatchedType&lt;U, U&gt;(property, RenderingDispatcher.CURRENT.toTypeErrorString(value.getClass()) + &#39;[&#39; + value + &#39;]&#39;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public U resolve() {
<b class="fc">&nbsp;            return value;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            return new Loaded&lt;U&gt;(value, propertyDelegate);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return propertyDelegate.hashCode(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; propertyDelegate.equals(value, ((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return propertyDelegate.toString(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A property delegate for a constant annotation value.
&nbsp;         */
&nbsp;        protected interface PropertyDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * Copies the provided value, if it is not immutable.
&nbsp;             *
&nbsp;             * @param value The value to copy.
&nbsp;             * @param &lt;S&gt;   The value&#39;s type.
&nbsp;             * @return A copy of the provided instance or the provided value, if it is immutable.
&nbsp;             */
&nbsp;            &lt;S&gt; S copy(S value);
&nbsp;
&nbsp;            /**
&nbsp;             * Computes the value&#39;s hash code.
&nbsp;             *
&nbsp;             * @param value The value for which to compute the hash code.
&nbsp;             * @return The hash code of the provided value.
&nbsp;             */
&nbsp;            int hashCode(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Determines if another value is equal to a constant annotation value.
&nbsp;             *
&nbsp;             * @param self  The value that is represented as a constant annotation value.
&nbsp;             * @param other Any other value for which to determine equality.
&nbsp;             * @return {@code true} if the provided value is equal to the represented value.
&nbsp;             */
&nbsp;            boolean equals(Object self, Object other);
&nbsp;
&nbsp;            /**
&nbsp;             * Renders the supplied value as a {@link String}.
&nbsp;             *
&nbsp;             * @param value The value to render.
&nbsp;             * @return An appropriate {@link String} representation of the provided value.
&nbsp;             */
&nbsp;            String toString(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * A property delegate for a non-array type.
&nbsp;             */
<b class="fc">&nbsp;            enum ForNonArrayType implements PropertyDelegate {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code boolean} value.
&nbsp;                 */
<b class="fc">&nbsp;                BOOLEAN {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Boolean) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code byte} value.
&nbsp;                 */
<b class="fc">&nbsp;                BYTE {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Byte) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code short} value.
&nbsp;                 */
<b class="fc">&nbsp;                SHORT {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Short) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code char} value.
&nbsp;                 */
<b class="fc">&nbsp;                CHARACTER {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Character) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code int} value.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Integer) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code long} value.
&nbsp;                 */
<b class="fc">&nbsp;                LONG {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Long) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code float} value.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Float) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code double} value.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((Double) value);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@link String} value.
&nbsp;                 */
<b class="fc">&nbsp;                STRING {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public String toString(Object value) {
<b class="fc">&nbsp;                        return RenderingDispatcher.CURRENT.toSourceString((String) value);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public &lt;S&gt; S copy(S value) {
<b class="fc">&nbsp;                    return value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int hashCode(Object value) {
<b class="fc">&nbsp;                    return value.hashCode();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                    return self.equals(other);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A property delegate for an array type of a constant value.
&nbsp;             */
<b class="fc">&nbsp;            enum ForArrayType implements PropertyDelegate {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code boolean[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                BOOLEAN {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((boolean[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((boolean[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof boolean[] &amp;&amp; Arrays.equals((boolean[]) self, (boolean[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.BOOLEAN.toString(Array.getBoolean(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code byte[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                BYTE {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((byte[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((byte[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof byte[] &amp;&amp; Arrays.equals((byte[]) self, (byte[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.BYTE.toString(Array.getByte(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code short[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                SHORT {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((short[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((short[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof short[] &amp;&amp; Arrays.equals((short[]) self, (short[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.SHORT.toString(Array.getShort(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code char[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                CHARACTER {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((char[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((char[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof char[] &amp;&amp; Arrays.equals((char[]) self, (char[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.CHARACTER.toString(Array.getChar(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code int[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                INTEGER {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((int[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((int[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof int[] &amp;&amp; Arrays.equals((int[]) self, (int[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.INTEGER.toString(Array.getInt(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code long[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                LONG {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((long[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((long[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof long[] &amp;&amp; Arrays.equals((long[]) self, (long[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.LONG.toString(Array.getLong(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code float[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                FLOAT {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((float[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((float[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof float[] &amp;&amp; Arrays.equals((float[]) self, (float[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.FLOAT.toString(Array.getFloat(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code double[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                DOUBLE {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((double[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((double[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof double[] &amp;&amp; Arrays.equals((double[]) self, (double[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.DOUBLE.toString(Array.getDouble(array, index));</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A property delegate for a {@code String[]} value.
&nbsp;                 */
<b class="fc">&nbsp;                STRING {</b>
&nbsp;                    @Override
&nbsp;                    protected Object doCopy(Object value) {
<b class="fc">&nbsp;                        return ((String[]) value).clone();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public int hashCode(Object value) {
<b class="fc">&nbsp;                        return Arrays.hashCode((String[]) value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public boolean equals(Object self, Object other) {
<b class="fc">&nbsp;                        return other instanceof String[] &amp;&amp; Arrays.equals((String[]) self, (String[]) other);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected String toString(Object array, int index) {
<b class="fc">&nbsp;                        return ForNonArrayType.STRING.toString(Array.get(array, index));</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                public &lt;S&gt; S copy(S value) {
<b class="fc">&nbsp;                    return (S) doCopy(value);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a copy of the provided array.
&nbsp;                 *
&nbsp;                 * @param value The array to copy.
&nbsp;                 * @return A shallow copy of the provided array.
&nbsp;                 */
&nbsp;                protected abstract Object doCopy(Object value);
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String toString(Object value) {
<b class="fc">&nbsp;                    List&lt;String&gt; elements = new ArrayList&lt;String&gt;(Array.getLength(value));</b>
<b class="fc">&nbsp;                    for (int index = 0; index &lt; Array.getLength(value); index++) {</b>
<b class="fc">&nbsp;                        elements.add(toString(value, index));</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return RenderingDispatcher.CURRENT.toSourceString(elements);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Renders the array element at the specified index.
&nbsp;                 *
&nbsp;                 * @param array The array for which an element should be rendered.
&nbsp;                 * @param index The index of the array element to render.
&nbsp;                 * @return A {@link String} representation of the array element at the supplied index.
&nbsp;                 */
&nbsp;                protected abstract String toString(Object array, int index);
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a trivial loaded value.
&nbsp;         *
&nbsp;         * @param &lt;V&gt; The annotation properties type.
&nbsp;         */
&nbsp;        protected static class Loaded&lt;V&gt; extends AnnotationValue.Loaded.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented value.
&nbsp;             */
&nbsp;            private final V value;
&nbsp;
&nbsp;            /**
&nbsp;             * The property delegate for the value&#39;s type.
&nbsp;             */
&nbsp;            private final PropertyDelegate propertyDelegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded representation of a constant value.
&nbsp;             *
&nbsp;             * @param value            The represented value.
&nbsp;             * @param propertyDelegate The property delegate for the value&#39;s type.
&nbsp;             */
<b class="fc">&nbsp;            protected Loaded(V value, PropertyDelegate propertyDelegate) {</b>
<b class="fc">&nbsp;                this.value = value;</b>
<b class="fc">&nbsp;                this.propertyDelegate = propertyDelegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return State.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public V resolve() {
<b class="fc">&nbsp;                return propertyDelegate.copy(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(Object value) {
<b class="fc">&nbsp;                return propertyDelegate.equals(this.value, value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return propertyDelegate.hashCode(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;</b>
<b class="fc">&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; propertyDelegate.equals(value, annotationValue.resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return propertyDelegate.toString(value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of an {@link java.lang.annotation.Annotation} as a value of another annotation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the annotation.
&nbsp;     */
&nbsp;    class ForAnnotationDescription&lt;U extends Annotation&gt; extends AbstractBase&lt;AnnotationDescription, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation description that this value represents.
&nbsp;         */
&nbsp;        private final AnnotationDescription annotationDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value for a given annotation description.
&nbsp;         *
&nbsp;         * @param annotationDescription The annotation description that this value represents.
&nbsp;         */
<b class="fc">&nbsp;        public ForAnnotationDescription(AnnotationDescription annotationDescription) {</b>
<b class="fc">&nbsp;            this.annotationDescription = annotationDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value instance for describing the given annotation type and values.
&nbsp;         *
&nbsp;         * @param annotationType   The annotation type.
&nbsp;         * @param annotationValues The values of the annotation.
&nbsp;         * @param &lt;V&gt;              The type of the annotation.
&nbsp;         * @return An annotation value representing the given annotation.
&nbsp;         */
&nbsp;        public static &lt;V extends Annotation&gt; AnnotationValue&lt;AnnotationDescription, V&gt; of(TypeDescription annotationType,
&nbsp;                                                                                          Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {
<b class="fc">&nbsp;            return new ForAnnotationDescription&lt;V&gt;(new AnnotationDescription.Latent(annotationType, annotationValues));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.RESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.ANNOTATION;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;AnnotationDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return typeDefinition.asErasure().equals(annotationDescription.getAnnotationType()) ? this : new ForMismatchedType&lt;AnnotationDescription, U&gt;(property, property.getReturnType().isArray()</b>
<b class="fc">&nbsp;                    ? RenderingDispatcher.CURRENT.toArrayErrorString(Sort.ANNOTATION)</b>
<b class="fc">&nbsp;                    : annotationDescription.toString());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationDescription resolve() {
<b class="fc">&nbsp;            return annotationDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;            try {
<b class="fc">&nbsp;                return new Loaded&lt;U&gt;(annotationDescription</b>
<b class="fc">&nbsp;                        .prepare((Class&lt;U&gt;) Class.forName(annotationDescription.getAnnotationType().getName(), false, classLoader))</b>
<b class="fc">&nbsp;                        .load());</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;U&gt;(annotationDescription.getAnnotationType().getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return annotationDescription.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; annotationDescription.equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return annotationDescription.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loaded version of the described annotation.
&nbsp;         *
&nbsp;         * @param &lt;V&gt; The annotation type.
&nbsp;         */
&nbsp;        public static class Loaded&lt;V extends Annotation&gt; extends AnnotationValue.Loaded.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded version of the represented annotation.
&nbsp;             */
&nbsp;            private final V annotation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a representation of a loaded annotation.
&nbsp;             *
&nbsp;             * @param annotation The represented annotation.
&nbsp;             */
<b class="fc">&nbsp;            public Loaded(V annotation) {</b>
<b class="fc">&nbsp;                this.annotation = annotation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return State.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public V resolve() {
<b class="fc">&nbsp;                return annotation;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(Object value) {
<b class="fc">&nbsp;                return annotation.equals(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return annotation.hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;</b>
<b class="fc">&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; annotation.equals(annotationValue.resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return annotation.toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of an {@link java.lang.Enum} as a value of an annotation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the enumeration.
&nbsp;     */
&nbsp;    class ForEnumerationDescription&lt;U extends Enum&lt;U&gt;&gt; extends AbstractBase&lt;EnumerationDescription, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The enumeration that is represented.
&nbsp;         */
&nbsp;        private final EnumerationDescription enumerationDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description of an annotation value for a given enumeration.
&nbsp;         *
&nbsp;         * @param enumerationDescription The enumeration that is to be represented.
&nbsp;         */
<b class="fc">&nbsp;        public ForEnumerationDescription(EnumerationDescription enumerationDescription) {</b>
<b class="fc">&nbsp;            this.enumerationDescription = enumerationDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value for the given enumeration description.
&nbsp;         *
&nbsp;         * @param value The value to represent.
&nbsp;         * @param &lt;V&gt;   The type of the represented enumeration.
&nbsp;         * @return An annotation value that describes the given enumeration.
&nbsp;         */
&nbsp;        public static &lt;V extends Enum&lt;V&gt;&gt; AnnotationValue&lt;EnumerationDescription, V&gt; of(EnumerationDescription value) {
<b class="fc">&nbsp;            return new ForEnumerationDescription&lt;V&gt;(value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public EnumerationDescription resolve() {
<b class="fc">&nbsp;            return enumerationDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.RESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.ENUMERATION;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;EnumerationDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return typeDefinition.asErasure().equals(enumerationDescription.getEnumerationType()) ? this : new ForMismatchedType&lt;EnumerationDescription, U&gt;(property, property.getReturnType().isArray()</b>
<b class="fc">&nbsp;                    ? RenderingDispatcher.CURRENT.toArrayErrorString(Sort.ENUMERATION)</b>
<b class="fc">&nbsp;                    : enumerationDescription.getEnumerationType().getName() + &#39;.&#39; + enumerationDescription.getValue());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;            try {
<b class="fc">&nbsp;                return new Loaded&lt;U&gt;(enumerationDescription.load((Class&lt;U&gt;) Class.forName(enumerationDescription.getEnumerationType().getName(), false, classLoader)));</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;U&gt;(enumerationDescription.getEnumerationType().getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return enumerationDescription.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; enumerationDescription.equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return enumerationDescription.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loaded representation of an enumeration value.
&nbsp;         *
&nbsp;         * @param &lt;V&gt; The type of the represented enumeration.
&nbsp;         */
&nbsp;        public static class Loaded&lt;V extends Enum&lt;V&gt;&gt; extends AnnotationValue.Loaded.AbstractBase&lt;V&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented enumeration.
&nbsp;             */
&nbsp;            private final V enumeration;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a loaded version of an enumeration description.
&nbsp;             *
&nbsp;             * @param enumeration The represented enumeration.
&nbsp;             */
<b class="fc">&nbsp;            public Loaded(V enumeration) {</b>
<b class="fc">&nbsp;                this.enumeration = enumeration;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return State.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public V resolve() {
<b class="fc">&nbsp;                return enumeration;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(Object value) {
<b class="fc">&nbsp;                return enumeration.equals(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return enumeration.hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;</b>
<b class="fc">&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; enumeration.equals(annotationValue.resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return enumeration.toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Represents an annotation&#39;s enumeration value for a runtime type that is not an enumeration type.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Note&lt;/b&gt;: Neither of {@link Object#hashCode()}, {@link Object#toString()} and
&nbsp;             * {@link java.lang.Object#equals(Object)} are implemented specifically what resembles the way
&nbsp;             * such exceptional states are represented in the Open JDK&#39;s annotation implementations.
&nbsp;             * &lt;/p&gt;
&nbsp;             */
&nbsp;            public static class WithIncompatibleRuntimeType extends AnnotationValue.Loaded.AbstractBase&lt;Enum&lt;?&gt;&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The runtime type which is not an enumeration type.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new representation for an incompatible runtime type.
&nbsp;                 *
&nbsp;                 * @param type The runtime type which is not an enumeration type.
&nbsp;                 */
<b class="fc">&nbsp;                public WithIncompatibleRuntimeType(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                    this.type = type;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public State getState() {
<b class="nc">&nbsp;                    return State.UNRESOLVED;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Enum&lt;?&gt; resolve() {
<b class="fc">&nbsp;                    throw new IncompatibleClassChangeError(&quot;Not an enumeration type: &quot; + type.getName());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(Object value) {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /* hashCode, equals and toString are intentionally not implemented */
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a property with an enumeration constant that is not defined by an enumeration type.
&nbsp;         *
&nbsp;         * @param &lt;U&gt; The enumerationl type.
&nbsp;         */
&nbsp;        public static class WithUnknownConstant&lt;U extends Enum&lt;U&gt;&gt; extends AbstractBase&lt;EnumerationDescription, U&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * A description of the enumeration type.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * The enumeration constant value.
&nbsp;             */
&nbsp;            private final String value;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a property description for an enumeration value that does not exist for the enumeration type.
&nbsp;             *
&nbsp;             * @param typeDescription A description of the enumeration type.
&nbsp;             * @param value           The enumeration constant value.
&nbsp;             */
<b class="fc">&nbsp;            public WithUnknownConstant(TypeDescription typeDescription, String value) {</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                this.value = value;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return State.UNRESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="nc">&nbsp;                return Sort.NONE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationValue&lt;EnumerationDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public EnumerationDescription resolve() {
<b class="nc">&nbsp;                throw new IllegalStateException(typeDescription + &quot; does not declare enumeration constant &quot; + value);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public AnnotationValue.Loaded&lt;U&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;                try {
&nbsp;                    // Type casting to Object is required for Java 6 compilability.
<b class="fc">&nbsp;                    return (AnnotationValue.Loaded&lt;U&gt;) (Object) new Loaded((Class&lt;Enum&lt;?&gt;&gt;) Class.forName(typeDescription.getName(), false, classLoader), value);</b>
<b class="nc">&nbsp;                } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                    return new ForMissingType.Loaded&lt;U&gt;(typeDescription.getName(), exception);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /* does not implement hashCode and equals method to mimic OpenJDK behavior. */
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return value + &quot; /* Warning: constant not present! */&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a property with an enumeration constant that is not defined by an enumeration type.
&nbsp;             */
&nbsp;            public static class Loaded extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty&lt;Enum&lt;?&gt;&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The loaded enumeration type.
&nbsp;                 */
&nbsp;                private final Class&lt;? extends Enum&lt;?&gt;&gt; enumType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The value for which no enumeration constant exists at runtime.
&nbsp;                 */
&nbsp;                private final String value;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new representation for an unknown enumeration constant of an annotation.
&nbsp;                 *
&nbsp;                 * @param enumType The loaded enumeration type.
&nbsp;                 * @param value    The value for which no enumeration constant exists at runtime.
&nbsp;                 */
<b class="fc">&nbsp;                public Loaded(Class&lt;? extends Enum&lt;?&gt;&gt; enumType, String value) {</b>
<b class="fc">&nbsp;                    this.enumType = enumType;</b>
<b class="fc">&nbsp;                    this.value = value;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Enum&lt;?&gt; resolve() {
<b class="fc">&nbsp;                    throw new EnumConstantNotPresentException(enumType, value);</b>
&nbsp;                }
&nbsp;
&nbsp;                /* does not implement hashCode and equals method to mimic OpenJDK behavior. */
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString() {
<b class="fc">&nbsp;                    return value + &quot; /* Warning: constant not present! */&quot;;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of a {@link java.lang.Class} as a value of an annotation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the {@link java.lang.Class} that is described.
&nbsp;     */
&nbsp;    class ForTypeDescription&lt;U extends Class&lt;U&gt;&gt; extends AbstractBase&lt;TypeDescription, U&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicates to a class loading process that class initializers are not required to be executed when loading a type.
&nbsp;         */
&nbsp;        private static final boolean NO_INITIALIZATION = false;
&nbsp;
&nbsp;        /**
&nbsp;         * A map of primitive types to their loaded representation.
&nbsp;         */
&nbsp;        private static final Map&lt;TypeDescription, Class&lt;?&gt;&gt; PRIMITIVE_TYPES;
&nbsp;
&nbsp;        /*
&nbsp;         * Initializes the maps of primitive types by their description.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            PRIMITIVE_TYPES = new HashMap&lt;TypeDescription, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Class&lt;?&gt; type : new Class&lt;?&gt;[]{boolean.class,</b>
&nbsp;                    byte.class,
&nbsp;                    short.class,
&nbsp;                    char.class,
&nbsp;                    int.class,
&nbsp;                    long.class,
&nbsp;                    float.class,
&nbsp;                    double.class,
&nbsp;                    void.class}) {
<b class="fc">&nbsp;                PRIMITIVE_TYPES.put(TypeDescription.ForLoadedType.of(type), type);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the represented type.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value that represents a type.
&nbsp;         *
&nbsp;         * @param typeDescription The represented type.
&nbsp;         */
<b class="fc">&nbsp;        public ForTypeDescription(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;            this.typeDescription = typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation value for representing the given type.
&nbsp;         *
&nbsp;         * @param typeDescription The type to represent.
&nbsp;         * @param &lt;V&gt;             The represented type.
&nbsp;         * @return An annotation value that represents the given type.
&nbsp;         */
&nbsp;        public static &lt;V extends Class&lt;V&gt;&gt; AnnotationValue&lt;TypeDescription, V&gt; of(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return new ForTypeDescription&lt;V&gt;(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.RESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.TYPE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;TypeDescription, U&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return typeDefinition.asErasure().represents(Class.class) ? this : new ForMismatchedType&lt;TypeDescription, U&gt;(property, property.getReturnType().isArray()</b>
<b class="nc">&nbsp;                    ? RenderingDispatcher.CURRENT.toArrayErrorString(Sort.TYPE)</b>
<b class="nc">&nbsp;                    : Class.class.getName() + &#39;[&#39; + typeDescription.getName() + &#39;]&#39;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription resolve() {
<b class="fc">&nbsp;            return typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;U&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;            try {
<b class="fc">&nbsp;                return new Loaded&lt;U&gt;((U) (typeDescription.isPrimitive()</b>
<b class="fc">&nbsp;                        ? PRIMITIVE_TYPES.get(typeDescription)</b>
<b class="fc">&nbsp;                        : Class.forName(typeDescription.getName(), NO_INITIALIZATION, classLoader)));</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;U&gt;(typeDescription.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return typeDescription.hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            return this == other || other instanceof AnnotationValue&lt;?, ?&gt; &amp;&amp; typeDescription.equals(((AnnotationValue&lt;?, ?&gt;) other).resolve());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return RenderingDispatcher.CURRENT.toSourceString(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loaded annotation value for a given type.
&nbsp;         *
&nbsp;         * @param &lt;U&gt; The represented type.
&nbsp;         */
&nbsp;        protected static class Loaded&lt;U extends Class&lt;U&gt;&gt; extends AnnotationValue.Loaded.AbstractBase&lt;U&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented type.
&nbsp;             */
&nbsp;            private final U type;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded annotation value for a given type.
&nbsp;             *
&nbsp;             * @param type The represented type.
&nbsp;             */
<b class="fc">&nbsp;            public Loaded(U type) {</b>
<b class="fc">&nbsp;                this.type = type;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return State.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public U resolve() {
<b class="fc">&nbsp;                return type;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(Object value) {
<b class="fc">&nbsp;                return type.equals(value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return type.hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;</b>
<b class="fc">&nbsp;                return annotationValue.getState().isResolved() &amp;&amp; type.equals(annotationValue.resolve());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return RenderingDispatcher.CURRENT.toSourceString(TypeDescription.ForLoadedType.of(type));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Describes a complex array that is the value of an annotation. Complex arrays are arrays that might trigger the loading
&nbsp;     * of user-defined types, i.e. {@link java.lang.Class}, {@link java.lang.annotation.Annotation} and {@link java.lang.Enum}
&nbsp;     * instances.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The array type of the annotation&#39;s value when it is not loaded.
&nbsp;     * @param &lt;V&gt; The array type of the annotation&#39;s value when it is loaded.
&nbsp;     */
&nbsp;    class ForDescriptionArray&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The component type for arrays containing unloaded versions of the annotation array&#39;s values.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; unloadedComponentType;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the component type when it is loaded.
&nbsp;         */
&nbsp;        private final TypeDescription componentType;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of values of the array elements.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; values;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array.
&nbsp;         *
&nbsp;         * @param unloadedComponentType The component type for arrays containing unloaded versions of the annotation array&#39;s values.
&nbsp;         * @param componentType         A description of the component type when it is loaded.
&nbsp;         * @param values                A list of values of the array elements.
&nbsp;         */
&nbsp;        public ForDescriptionArray(Class&lt;?&gt; unloadedComponentType,
&nbsp;                                   TypeDescription componentType,
<b class="fc">&nbsp;                                   List&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; values) {</b>
<b class="fc">&nbsp;            this.unloadedComponentType = unloadedComponentType;</b>
<b class="fc">&nbsp;            this.componentType = componentType;</b>
<b class="fc">&nbsp;            this.values = values;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array of enumeration descriptions.
&nbsp;         *
&nbsp;         * @param enumerationType        A description of the type of the enumeration.
&nbsp;         * @param enumerationDescription An array of enumeration descriptions.
&nbsp;         * @param &lt;W&gt;                    The type of the enumeration.
&nbsp;         * @return A description of the array of enumeration values.
&nbsp;         */
&nbsp;        public static &lt;W extends Enum&lt;W&gt;&gt; AnnotationValue&lt;EnumerationDescription[], W[]&gt; of(TypeDescription enumerationType,
&nbsp;                                                                                            EnumerationDescription[] enumerationDescription) {
<b class="fc">&nbsp;            List&lt;AnnotationValue&lt;EnumerationDescription, W&gt;&gt; values = new ArrayList&lt;AnnotationValue&lt;EnumerationDescription, W&gt;&gt;(enumerationDescription.length);</b>
<b class="fc">&nbsp;            for (EnumerationDescription value : enumerationDescription) {</b>
<b class="fc">&nbsp;                if (!value.getEnumerationType().equals(enumerationType)) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of &quot; + enumerationType);</b>
&nbsp;                }
<b class="fc">&nbsp;                values.add(ForEnumerationDescription.&lt;W&gt;of(value));</b>
&nbsp;            }
<b class="fc">&nbsp;            return new ForDescriptionArray&lt;EnumerationDescription[], W[]&gt;(EnumerationDescription.class, enumerationType, values);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array of annotation descriptions.
&nbsp;         *
&nbsp;         * @param annotationType        A description of the type of the annotation.
&nbsp;         * @param annotationDescription An array of annotation descriptions.
&nbsp;         * @param &lt;W&gt;                   The type of the annotation.
&nbsp;         * @return A description of the array of enumeration values.
&nbsp;         */
&nbsp;        public static &lt;W extends Annotation&gt; AnnotationValue&lt;AnnotationDescription[], W[]&gt; of(TypeDescription annotationType,
&nbsp;                                                                                              AnnotationDescription[] annotationDescription) {
<b class="fc">&nbsp;            List&lt;AnnotationValue&lt;AnnotationDescription, W&gt;&gt; values = new ArrayList&lt;AnnotationValue&lt;AnnotationDescription, W&gt;&gt;(annotationDescription.length);</b>
<b class="fc">&nbsp;            for (AnnotationDescription value : annotationDescription) {</b>
<b class="fc">&nbsp;                if (!value.getAnnotationType().equals(annotationType)) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(value + &quot; is not of &quot; + annotationType);</b>
&nbsp;                }
<b class="fc">&nbsp;                values.add(new ForAnnotationDescription&lt;W&gt;(value));</b>
&nbsp;            }
<b class="fc">&nbsp;            return new ForDescriptionArray&lt;AnnotationDescription[], W[]&gt;(AnnotationDescription.class, annotationType, values);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new complex array of annotation descriptions.
&nbsp;         *
&nbsp;         * @param typeDescription A description of the types contained in the array.
&nbsp;         * @return A description of the array of enumeration values.
&nbsp;         */
&nbsp;        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;, &quot;cast&quot;})
&nbsp;        public static AnnotationValue&lt;TypeDescription[], Class&lt;?&gt;[]&gt; of(TypeDescription[] typeDescription) {
<b class="fc">&nbsp;            List&lt;AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt;&gt; values = new ArrayList&lt;AnnotationValue&lt;TypeDescription, Class&lt;?&gt;&gt;&gt;(typeDescription.length);</b>
<b class="fc">&nbsp;            for (TypeDescription value : typeDescription) {</b>
<b class="fc">&nbsp;                values.add((AnnotationValue) ForTypeDescription.&lt;Class&gt;of(value));</b>
&nbsp;            }
<b class="fc">&nbsp;            return new ForDescriptionArray&lt;TypeDescription[], Class&lt;?&gt;[]&gt;(TypeDescription.class, TypeDescription.ForLoadedType.of(Class.class), values);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.RESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.ARRAY;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            if (typeDefinition.isArray() &amp;&amp; typeDefinition.getComponentType().asErasure().equals(componentType)) {</b>
<b class="fc">&nbsp;                for (AnnotationValue&lt;?, ?&gt; value : values) {</b>
<b class="fc">&nbsp;                    value = value.filter(property, typeDefinition.getComponentType());</b>
<b class="fc">&nbsp;                    if (value.getState() != State.RESOLVED) {</b>
<b class="fc">&nbsp;                        return (AnnotationValue&lt;U, V&gt;) value;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return this;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return new ForMismatchedType&lt;U, V&gt;(property, RenderingDispatcher.CURRENT.toArrayErrorString(Sort.of(componentType)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public U resolve() {
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;            U resolved = (U) Array.newInstance(unloadedComponentType, values.size());</b>
<b class="fc">&nbsp;            int index = 0;</b>
<b class="fc">&nbsp;            for (AnnotationValue&lt;?, ?&gt; value : values) {</b>
<b class="fc">&nbsp;                Array.set(resolved, index++, value.resolve());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return resolved;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;V&gt; load(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values = new ArrayList&lt;AnnotationValue.Loaded&lt;?&gt;&gt;(this.values.size());</b>
<b class="fc">&nbsp;            for (AnnotationValue&lt;?, ?&gt; value : this.values) {</b>
<b class="fc">&nbsp;                values.add(value.load(classLoader));</b>
<b class="fc">&nbsp;            }</b>
&nbsp;            try {
<b class="fc">&nbsp;                return new Loaded&lt;V&gt;((Class&lt;V&gt;) Class.forName(componentType.getName(), false, classLoader), values);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;V&gt;(componentType.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = 1;</b>
<b class="fc">&nbsp;            for (AnnotationValue&lt;?, ?&gt; value : values) {</b>
<b class="fc">&nbsp;                result = 31 * result + value.hashCode();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof AnnotationValue&lt;?, ?&gt;)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationValue&lt;?, ?&gt; annotationValue = (AnnotationValue&lt;?, ?&gt;) other;</b>
<b class="fc">&nbsp;            Object value = annotationValue.resolve();</b>
<b class="fc">&nbsp;            if (!value.getClass().isArray()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            if (values.size() != Array.getLength(value)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            Iterator&lt;? extends AnnotationValue&lt;?, ?&gt;&gt; iterator = values.iterator();</b>
<b class="fc">&nbsp;            for (int index = 0; index &lt; values.size(); index++) {</b>
<b class="fc">&nbsp;                AnnotationValue&lt;?, ?&gt; self = iterator.next();</b>
<b class="fc">&nbsp;                if (!self.resolve().equals(Array.get(value, index))) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return RenderingDispatcher.CURRENT.toSourceString(values);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a loaded complex array.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The type of the loaded array.
&nbsp;         */
&nbsp;        protected static class Loaded&lt;W&gt; extends AnnotationValue.Loaded.AbstractBase&lt;W&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The loaded component type of the array.
&nbsp;             */
&nbsp;            private final Class&lt;W&gt; componentType;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of loaded values that the represented array contains.
&nbsp;             */
&nbsp;            private final List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded value representing a complex array.
&nbsp;             *
&nbsp;             * @param componentType The loaded component type of the array.
&nbsp;             * @param values        A list of loaded values that the represented array contains.
&nbsp;             */
<b class="fc">&nbsp;            protected Loaded(Class&lt;W&gt; componentType, List&lt;AnnotationValue.Loaded&lt;?&gt;&gt; values) {</b>
<b class="fc">&nbsp;                this.componentType = componentType;</b>
<b class="fc">&nbsp;                this.values = values;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                for (AnnotationValue.Loaded&lt;?&gt; value : values) {</b>
<b class="fc">&nbsp;                    if (!value.getState().isResolved()) {</b>
<b class="nc">&nbsp;                        return State.UNRESOLVED;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return State.RESOLVED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public W resolve() {
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
<b class="fc">&nbsp;                W array = (W) Array.newInstance(componentType, values.size());</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                for (AnnotationValue.Loaded&lt;?&gt; annotationValue : values) {</b>
<b class="fc">&nbsp;                    Array.set(array, index++, annotationValue.resolve());</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return array;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(Object value) {
<b class="fc">&nbsp;                if (!(value instanceof Object[])) return false;</b>
<b class="fc">&nbsp;                if (value.getClass().getComponentType() != componentType) return false;</b>
<b class="fc">&nbsp;                Object[] array = (Object[]) value;</b>
<b class="fc">&nbsp;                if (values.size() != array.length) return false;</b>
<b class="fc">&nbsp;                Iterator&lt;AnnotationValue.Loaded&lt;?&gt;&gt; iterator = values.iterator();</b>
<b class="fc">&nbsp;                for (Object aValue : array) {</b>
<b class="fc">&nbsp;                    AnnotationValue.Loaded&lt;?&gt; self = iterator.next();</b>
<b class="fc">&nbsp;                    if (!self.represents(aValue)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                int result = 1;</b>
<b class="fc">&nbsp;                for (AnnotationValue.Loaded&lt;?&gt; value : values) {</b>
<b class="fc">&nbsp;                    result = 31 * result + value.hashCode();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof AnnotationValue.Loaded&lt;?&gt;)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                AnnotationValue.Loaded&lt;?&gt; annotationValue = (AnnotationValue.Loaded&lt;?&gt;) other;</b>
<b class="fc">&nbsp;                if (!annotationValue.getState().isResolved()) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Object value = annotationValue.resolve();</b>
<b class="fc">&nbsp;                if (!(value instanceof Object[])) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Object[] arrayValue = (Object[]) value;</b>
<b class="fc">&nbsp;                if (values.size() != arrayValue.length) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Iterator&lt;AnnotationValue.Loaded&lt;?&gt;&gt; iterator = values.iterator();</b>
<b class="fc">&nbsp;                for (Object aValue : arrayValue) {</b>
<b class="fc">&nbsp;                    AnnotationValue.Loaded&lt;?&gt; self = iterator.next();</b>
<b class="fc">&nbsp;                    if (!self.getState().isResolved() || !self.resolve().equals(aValue)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return RenderingDispatcher.CURRENT.toSourceString(values);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An annotation value for a type that could not be loaded.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the annotation&#39;s value when it is not loaded.
&nbsp;     * @param &lt;V&gt; The type of the annotation&#39;s value when it is loaded.
&nbsp;     */
&nbsp;    class ForMissingType&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The type&#39;s binary name.
&nbsp;         */
&nbsp;        private final String typeName;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation value for a type that cannot be loaded.
&nbsp;         *
&nbsp;         * @param typeName The type&#39;s binary name.
&nbsp;         */
<b class="fc">&nbsp;        public ForMissingType(String typeName) {</b>
<b class="fc">&nbsp;            this.typeName = typeName;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.UNRESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.NONE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public U resolve() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Type not found: &quot; + typeName);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue.Loaded&lt;V&gt; load(@MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            return new Loaded&lt;V&gt;(typeName, new ClassNotFoundException(typeName));</b>
&nbsp;        }
&nbsp;
&nbsp;        /* does not implement hashCode and equals method to mimic OpenJDK behavior. */
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return typeName + &quot;.class /* Warning: type not present! */&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a missing type during an annotation&#39;s resolution.
&nbsp;         *
&nbsp;         * @param &lt;U&gt; The represented type.
&nbsp;         */
&nbsp;        public static class Loaded&lt;U&gt; extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty&lt;U&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s binary name.
&nbsp;             */
&nbsp;            private final String typeName;
&nbsp;
&nbsp;            /**
&nbsp;             * The exception describing the missing type.
&nbsp;             */
&nbsp;            private final ClassNotFoundException exception;
&nbsp;
&nbsp;            /**
&nbsp;             * The type&#39;s binary name.
&nbsp;             *
&nbsp;             * @param typeName  The type&#39;s binary name.
&nbsp;             * @param exception The exception describing the missing type.
&nbsp;             */
<b class="fc">&nbsp;            public Loaded(String typeName, ClassNotFoundException exception) {</b>
<b class="fc">&nbsp;                this.typeName = typeName;</b>
<b class="fc">&nbsp;                this.exception = exception;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public U resolve() {
<b class="fc">&nbsp;                throw new TypeNotPresentException(typeName, exception);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return typeName + &quot;.class /* Warning: type not present! */&quot;;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Describes an annotation value that does not match the annotation&#39; type for a property.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the annotation&#39;s value when it is not loaded.
&nbsp;     * @param &lt;V&gt; The type of the annotation&#39;s value when it is loaded.
&nbsp;     */
&nbsp;    class ForMismatchedType&lt;U, V&gt; extends AbstractBase&lt;U, V&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The property that does not defines a non-matching value.
&nbsp;         */
&nbsp;        private final MethodDescription.InDefinedShape property;
&nbsp;
&nbsp;        /**
&nbsp;         * A value description of the property.
&nbsp;         */
&nbsp;        private final String value;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation description for a mismatched type.
&nbsp;         *
&nbsp;         * @param property The property that does not defines a non-matching value.
&nbsp;         * @param value    A value description of the property.
&nbsp;         */
<b class="fc">&nbsp;        public ForMismatchedType(MethodDescription.InDefinedShape property, String value) {</b>
<b class="fc">&nbsp;            this.property = property;</b>
<b class="fc">&nbsp;            this.value = value;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.UNRESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.NONE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="fc">&nbsp;            return new ForMismatchedType&lt;U, V&gt;(property, value);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public U resolve() {
<b class="nc">&nbsp;            throw new IllegalStateException(value + &quot; cannot be used as value for &quot; + property);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue.Loaded&lt;V&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;            try {
<b class="fc">&nbsp;                Class&lt;?&gt; type = Class.forName(property.getDeclaringType().getName(), false, classLoader);</b>
&nbsp;                try {
<b class="fc">&nbsp;                    return new Loaded&lt;V&gt;(type.getMethod(property.getName()), value);</b>
<b class="nc">&nbsp;                } catch (NoSuchMethodException exception) {</b>
<b class="nc">&nbsp;                    return new ForIncompatibleType.Loaded&lt;V&gt;(type);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;V&gt;(property.getDeclaringType().getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /* does not implement hashCode and equals method to mimic OpenJDK behavior. */
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return &quot;/* Warning type mismatch! \&quot;&quot; + value + &quot;\&quot; */&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes an annotation value for a property that is not assignable to it.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The type of the annotation&#39;s expected value.
&nbsp;         */
&nbsp;        public static class Loaded&lt;W&gt; extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty&lt;W&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation property that is not well-defined.
&nbsp;             */
&nbsp;            private final Method property;
&nbsp;
&nbsp;            /**
&nbsp;             * A value description of the incompatible property or {@code null}.
&nbsp;             */
&nbsp;            private final String value;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded version of a property with an incompatible type.
&nbsp;             *
&nbsp;             * @param property The annotation property that is not well-defined.
&nbsp;             * @param value    A value description of the incompatible property or {@code null}.
&nbsp;             */
<b class="fc">&nbsp;            public Loaded(Method property, String value) {</b>
<b class="fc">&nbsp;                this.property = property;</b>
<b class="fc">&nbsp;                this.value = value;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public W resolve() {
<b class="fc">&nbsp;                throw new AnnotationTypeMismatchException(property, value);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return &quot;/* Warning type mismatch! \&quot;&quot; + value + &quot;\&quot; */&quot;;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a missing annotation property which is not represented by a default value.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the annotation&#39;s value when it is not loaded.
&nbsp;     * @param &lt;V&gt; The type of the annotation&#39;s value when it is loaded.
&nbsp;     */
&nbsp;    class ForMissingValue&lt;U, V&gt; extends AnnotationValue.AbstractBase&lt;U, V&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation type for which a property is not defined.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the property without an annotation value.
&nbsp;         */
&nbsp;        private final String property;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new missing annotation value.
&nbsp;         *
&nbsp;         * @param typeDescription The annotation type for which a property is not defined.
&nbsp;         * @param property        The name of the property without an annotation value.
&nbsp;         */
<b class="fc">&nbsp;        public ForMissingValue(TypeDescription typeDescription, String property) {</b>
<b class="fc">&nbsp;            this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;            this.property = property;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="fc">&nbsp;            return State.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.NONE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public AnnotationValue.Loaded&lt;V&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;            try {
<b class="fc">&nbsp;                Class&lt;? extends Annotation&gt; type = (Class&lt;? extends Annotation&gt;) Class.forName(typeDescription.getName(), false, classLoader);</b>
<b class="fc">&nbsp;                return type.isAnnotation()</b>
<b class="fc">&nbsp;                        ? new Loaded&lt;V&gt;(type, property)</b>
<b class="nc">&nbsp;                        : new ForIncompatibleType.Loaded&lt;V&gt;(type);</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;V&gt;(typeDescription.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public U resolve() {
<b class="nc">&nbsp;            throw new IllegalStateException(typeDescription + &quot; does not define &quot; + property);</b>
&nbsp;        }
&nbsp;
&nbsp;        /* does not implement hashCode and equals method to mimic OpenJDK behavior. Does never appear in toString methods. */
&nbsp;
&nbsp;        /**
&nbsp;         * Describes an annotation value for a property that is not assignable to it.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The type of the annotation&#39;s expected value.
&nbsp;         */
&nbsp;        public static class Loaded&lt;W&gt; extends AnnotationValue.Loaded.AbstractBase&lt;W&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation type.
&nbsp;             */
&nbsp;            private final Class&lt;? extends Annotation&gt; type;
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the property for which the annotation value is missing.
&nbsp;             */
&nbsp;            private final String property;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new loaded representation for an unresolved property.
&nbsp;             *
&nbsp;             * @param type     The annotation type.
&nbsp;             * @param property The name of the property for which the annotation value is missing.
&nbsp;             */
<b class="fc">&nbsp;            public Loaded(Class&lt;? extends Annotation&gt; type, String property) {</b>
<b class="fc">&nbsp;                this.type = type;</b>
<b class="fc">&nbsp;                this.property = property;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public State getState() {
<b class="fc">&nbsp;                return State.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public W resolve() {
<b class="fc">&nbsp;                throw new IncompleteAnnotationException(type, property);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(Object value) {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /* does not implement hashCode and equals method to mimic OpenJDK behavior. Does never appear in toString methods. */
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents an annotation value where its declared type does not fulfil an expectation.
&nbsp;     *
&nbsp;     * @param &lt;U&gt; The type of the annotation&#39;s value when it is not loaded.
&nbsp;     * @param &lt;V&gt; The type of the annotation&#39;s value when it is loaded.
&nbsp;     */
&nbsp;    class ForIncompatibleType&lt;U, V&gt; extends AnnotationValue.AbstractBase&lt;U, V&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the type that does not fulfil an expectation.
&nbsp;         */
&nbsp;        private final TypeDescription typeDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description for an annotation value that does not fulfil expectations.
&nbsp;         *
&nbsp;         * @param typeDescription A description of the type that does not fulfil the expectations.
&nbsp;         */
<b class="nc">&nbsp;        public ForIncompatibleType(TypeDescription typeDescription) {</b>
<b class="nc">&nbsp;            this.typeDescription = typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public State getState() {
<b class="nc">&nbsp;            return State.UNRESOLVED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="nc">&nbsp;            return Sort.NONE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;U, V&gt; filter(MethodDescription.InDefinedShape property, TypeDefinition typeDefinition) {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public U resolve() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Property is defined with an incompatible runtime type: &quot; + typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue.Loaded&lt;V&gt; load(@MaybeNull ClassLoader classLoader) {
&nbsp;            try {
<b class="nc">&nbsp;                return new Loaded&lt;V&gt;(Class.forName(typeDescription.getName(), false, classLoader));</b>
<b class="nc">&nbsp;            } catch (ClassNotFoundException exception) {</b>
<b class="nc">&nbsp;                return new ForMissingType.Loaded&lt;V&gt;(typeDescription.getName(), exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /* does not implement hashCode and equals method to mimic OpenJDK behavior. */
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;/* Warning type incompatibility! \&quot;&quot; + typeDescription.getName() + &quot;\&quot; */&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of annotation value for a type that does not fulfil an expectation.
&nbsp;         *
&nbsp;         * @param &lt;W&gt; The type of the annotation&#39;s expected value.
&nbsp;         */
&nbsp;        public static class Loaded&lt;W&gt; extends AnnotationValue.Loaded.AbstractBase.ForUnresolvedProperty&lt;W&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The type that does not fulfil an expectation.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt; type;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description of an annotation.
&nbsp;             *
&nbsp;             * @param type The type that does not fulfil an expectation.
&nbsp;             */
<b class="nc">&nbsp;            public Loaded(Class&lt;?&gt; type) {</b>
<b class="nc">&nbsp;                this.type = type;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public W resolve() {
<b class="nc">&nbsp;                throw new IncompatibleClassChangeError(type.toString());</b>
&nbsp;            }
&nbsp;
&nbsp;            /* does not implement hashCode and equals method to mimic OpenJDK behavior. */
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="nc">&nbsp;                return &quot;/* Warning type incompatibility! \&quot;&quot; + type.getName() + &quot;\&quot; */&quot;;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 16:00</div>
</div>
</body>
</html>
