


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > CachedReturnPlugin</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.build</a>
</div>

<h1>Coverage Summary for Class: CachedReturnPlugin (net.bytebuddy.build)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CachedReturnPlugin</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.6%
  </span>
  <span class="absValue">
    (43/45)
  </span>
</td>
</tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$boolean</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$byte</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$char</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$double</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$float</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$int</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$long</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$Object</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Advice$short</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (2/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$CacheField</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$CacheFieldOffsetMapping</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">CachedReturnPlugin$Enhance</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    42.9%
  </span>
  <span class="absValue">
    (15/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.7%
  </span>
  <span class="absValue">
    (64/102)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.build;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.asm.Advice;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.modifier.FieldPersistence;
&nbsp;import net.bytebuddy.description.modifier.Ownership;
&nbsp;import net.bytebuddy.description.modifier.SyntheticState;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.implementation.bytecode.assign.Assigner;
&nbsp;import net.bytebuddy.pool.TypePool;
<b class="fc">&nbsp;import net.bytebuddy.utility.RandomString;</b>
<b class="fc">&nbsp;</b>
&nbsp;import java.lang.annotation.*;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.Map;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A plugin that caches the return value of a method in a synthetic field. The caching mechanism is not thread-safe but can be used in a
&nbsp; * concurrent setup if the cached value is frozen, i.e. only defines {@code final} fields. In this context, it is possible that
&nbsp; * the method is executed multiple times by different threads but at the same time, this approach avoids a {@code volatile} field
<b class="nc">&nbsp; * declaration. For methods with a primitive return type, the type&#39;s default value is used to indicate that a method was not yet invoked.</b>
&nbsp; * For methods that return a reference type, {@code null} is used as an indicator. If a method returns such a value, this mechanism will
&nbsp; * not work. This plugin does not need to be closed.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
&nbsp;public class CachedReturnPlugin extends Plugin.ForElementMatcher implements Plugin.Factory {
&nbsp;
&nbsp;    /**
&nbsp;     * An infix between a field and the random suffix if no field name is chosen.
&nbsp;     */
&nbsp;    private static final String NAME_INFIX = &quot;_&quot;;
&nbsp;
<b class="nc">&nbsp;    /**</b>
<b class="nc">&nbsp;     * The infix symbol for advice classes.</b>
&nbsp;     */
<b class="nc">&nbsp;    private static final String ADVICE_INFIX = &quot;$Advice$&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Enhance#value()} method.
&nbsp;     */
<b class="fc">&nbsp;    private static final MethodDescription.InDefinedShape ENHANCE_VALUE = TypeDescription.ForLoadedType.of(Enhance.class)</b>
<b class="fc">&nbsp;            .getDeclaredMethods()</b>
<b class="fc">&nbsp;            .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;            .getOnly();</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@code true} if existing fields should be ignored if the field name was explicitly given.
&nbsp;     */
&nbsp;    private final boolean ignoreExistingFields;
&nbsp;
&nbsp;    /**
&nbsp;     * A random string to use for avoid field name collisions.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;    private final RandomString randomString;
&nbsp;
&nbsp;    /**
&nbsp;     * The class file locator to use.
&nbsp;     */
&nbsp;    private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;    /**
&nbsp;     * A map of advice types mapped by their argument type. All advice types are precompiled using Java 6 to allow
&nbsp;     * for releasing Byte Buddy with a Java 5 byte code level where compiled classes do not contain stack map frames.
&nbsp;     * Byte Buddy filters stack map frames when applying advice in newer version but it cannot add stack map frames
&nbsp;     * without explicit frame computation which is expensive which is why precompilation was used. To avoid loading
&nbsp;     * Java classes in incompatible versions, all advice types are resolved using a type pool.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.IGNORE)
&nbsp;    private final Map&lt;TypeDescription, TypeDescription&gt; adviceByType;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a plugin for caching method return values. If a field name exists before applying this plugin, an exception is raised.
&nbsp;     */
&nbsp;    public CachedReturnPlugin() {
<b class="fc">&nbsp;        this(false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a plugin for caching method return values.
&nbsp;     *
&nbsp;     * @param ignoreExistingFields {@code true} if existing fields should be ignored if the field name was explicitly given.
&nbsp;     */
&nbsp;    public CachedReturnPlugin(boolean ignoreExistingFields) {
<b class="fc">&nbsp;        super(declaresMethod(isAnnotatedWith(Enhance.class)));</b>
<b class="fc">&nbsp;        this.ignoreExistingFields = ignoreExistingFields;</b>
<b class="fc">&nbsp;        randomString = new RandomString();</b>
<b class="fc">&nbsp;        classFileLocator = ClassFileLocator.ForClassLoader.of(CachedReturnPlugin.class.getClassLoader());</b>
<b class="fc">&nbsp;        TypePool typePool = TypePool.Default.of(classFileLocator);</b>
<b class="fc">&nbsp;        adviceByType = new HashMap&lt;TypeDescription, TypeDescription&gt;();</b>
<b class="fc">&nbsp;        for (Class&lt;?&gt; type : new Class&lt;?&gt;[]{</b>
&nbsp;                boolean.class,
&nbsp;                byte.class,
&nbsp;                short.class,
&nbsp;                char.class,
&nbsp;                int.class,
&nbsp;                long.class,
&nbsp;                float.class,
&nbsp;                double.class,
&nbsp;                Object.class
&nbsp;        }) {
<b class="fc">&nbsp;            adviceByType.put(TypeDescription.ForLoadedType.ForLoadedType.of(type), typePool.describe(CachedReturnPlugin.class.getName()</b>
&nbsp;                    + ADVICE_INFIX
<b class="fc">&nbsp;                    + type.getSimpleName()).resolve());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Plugin make() {
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Annotation presence is required by matcher.&quot;)
&nbsp;    public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        for (MethodDescription.InDefinedShape methodDescription : typeDescription.getDeclaredMethods()</b>
<b class="fc">&nbsp;                .filter(not(isBridge()).&lt;MethodDescription&gt;and(isAnnotatedWith(Enhance.class)))) {</b>
<b class="fc">&nbsp;            if (methodDescription.isAbstract()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot cache the value of an abstract method: &quot; + methodDescription);</b>
<b class="fc">&nbsp;            } else if (!methodDescription.getParameters().isEmpty()) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot cache the value of a method with parameters: &quot; + methodDescription);</b>
<b class="fc">&nbsp;            } else if (methodDescription.getReturnType().represents(void.class)) {</b>
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;Cannot cache void result for &quot; + methodDescription);</b>
&nbsp;            }
<b class="fc">&nbsp;            String name = methodDescription.getDeclaredAnnotations().ofType(Enhance.class)</b>
<b class="fc">&nbsp;                    .getValue(ENHANCE_VALUE)</b>
<b class="fc">&nbsp;                    .resolve(String.class);</b>
<b class="fc">&nbsp;            if (name.length() == 0) {</b>
<b class="fc">&nbsp;                name = methodDescription.getName() + NAME_INFIX + randomString.nextString();</b>
<b class="fc">&nbsp;            } else if (ignoreExistingFields &amp;&amp; !typeDescription.getDeclaredFields().filter(named(name)).isEmpty()) {</b>
<b class="fc">&nbsp;                return builder;</b>
&nbsp;            }
<b class="fc">&nbsp;            builder = builder</b>
<b class="fc">&nbsp;                    .defineField(name, methodDescription.getReturnType().asErasure(), methodDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? Ownership.STATIC</b>
<b class="fc">&nbsp;                            : Ownership.MEMBER, methodDescription.isStatic()</b>
<b class="fc">&nbsp;                            ? FieldPersistence.PLAIN</b>
<b class="fc">&nbsp;                            : FieldPersistence.TRANSIENT, Visibility.PRIVATE, SyntheticState.SYNTHETIC)</b>
<b class="fc">&nbsp;                    .visit(Advice.withCustomMapping()</b>
<b class="fc">&nbsp;                            .bind(CacheField.class, new CacheFieldOffsetMapping(name))</b>
<b class="fc">&nbsp;                            .to(adviceByType.get(methodDescription.getReturnType().isPrimitive()</b>
<b class="fc">&nbsp;                                    ? methodDescription.getReturnType().asErasure()</b>
<b class="fc">&nbsp;                                    : TypeDescription.ForLoadedType.of(Object.class)), this.classFileLocator)</b>
<b class="fc">&nbsp;                            .on(is(methodDescription)));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public void close() {
&nbsp;        /* do nothing */
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates methods that should be cached, i.e. where the return value is stored in a synthetic field. For this to be
&nbsp;     * possible, the returned value should not be altered and the instance must be thread-safe if the value might be used from
&nbsp;     * multiple threads.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.METHOD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Enhance {
&nbsp;
&nbsp;        /**
&nbsp;         * The fields name or an empty string if the name should be generated randomly.
&nbsp;         *
&nbsp;         * @return The fields name or an empty string if the name should be generated randomly.
&nbsp;         */
&nbsp;        String value() default &quot;&quot;;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates the field that stores the cached value.
&nbsp;     */
&nbsp;    @Target(ElementType.PARAMETER)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    protected @interface CacheField {
&nbsp;        /* empty */
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An offset mapping for the cached field.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class CacheFieldOffsetMapping implements Advice.OffsetMapping {
&nbsp;
&nbsp;        /**
&nbsp;         * The field&#39;s name.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an offset mapping for the cached field.
&nbsp;         *
&nbsp;         * @param name The field&#39;s name.
&nbsp;         */
<b class="fc">&nbsp;        protected CacheFieldOffsetMapping(String name) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Target resolve(TypeDescription instrumentedType,
&nbsp;                              MethodDescription instrumentedMethod,
&nbsp;                              Assigner assigner,
&nbsp;                              Advice.ArgumentHandler argumentHandler,
&nbsp;                              Sort sort) {
<b class="fc">&nbsp;            return new Target.ForField.ReadWrite(instrumentedType.getDeclaredFields().filter(named(name)).getOnly());</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
