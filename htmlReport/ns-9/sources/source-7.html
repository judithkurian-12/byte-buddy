


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > HashCodeAndEqualsPlugin</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.build</a>
</div>

<h1>Coverage Summary for Class: HashCodeAndEqualsPlugin (net.bytebuddy.build)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">HashCodeAndEqualsPlugin</td>
<td class="coverageStat">
  <span class="percent">
    81.8%
  </span>
  <span class="absValue">
    (9/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.4%
  </span>
  <span class="absValue">
    (47/52)
  </span>
</td>
</tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$1</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$AnnotationOrderComparator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Enhance</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Enhance$InvokeSuper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Enhance$InvokeSuper$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    52%
  </span>
  <span class="absValue">
    (13/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Enhance$InvokeSuper$2</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    55.6%
  </span>
  <span class="absValue">
    (5/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Enhance$InvokeSuper$3</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Enhance$InvokeSuper$4</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$Sorted</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$ValueHandling</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$ValueHandling$Sort</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$ValueMatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">HashCodeAndEqualsPlugin$WithNonNullableFields</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (30/35)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.5%
  </span>
  <span class="absValue">
    (95/118)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.build;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.implementation.EqualsMethod;
&nbsp;import net.bytebuddy.implementation.HashCodeMethod;
&nbsp;import net.bytebuddy.implementation.attribute.AnnotationValueFilter;
&nbsp;import net.bytebuddy.implementation.attribute.MethodAttributeAppender;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.AnnotationVisitor;
&nbsp;import org.objectweb.asm.MethodVisitor;
&nbsp;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.util.Comparator;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * A build tool plugin that adds {@link Object#hashCode()} and {@link Object#equals(Object)} methods to a class if the
&nbsp; * {@link Enhance} annotation is present and no explicit method declaration was added. This plugin does not need to be closed.
&nbsp; */
&nbsp;@HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;public class HashCodeAndEqualsPlugin implements Plugin, Plugin.Factory, MethodAttributeAppender.Factory, MethodAttributeAppender {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Enhance#invokeSuper()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape ENHANCE_INVOKE_SUPER;
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Enhance#simpleComparisonsFirst()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape ENHANCE_SIMPLE_COMPARISON_FIRST;
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Enhance#includeSyntheticFields()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape ENHANCE_INCLUDE_SYNTHETIC_FIELDS;
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Enhance#permitSubclassEquality()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape ENHANCE_PERMIT_SUBCLASS_EQUALITY;
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Enhance#useTypeHashConstant()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape ENHANCE_USE_TYPE_HASH_CONSTANT;
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link ValueHandling#value()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape VALUE_HANDLING_VALUE;
&nbsp;
&nbsp;    /**
&nbsp;     * A description of the {@link Sorted#value()} method.
&nbsp;     */
&nbsp;    private static final MethodDescription.InDefinedShape SORTED_VALUE;
&nbsp;
&nbsp;    /*
&nbsp;     * Resolves diverse annotation properties.
&nbsp;     */
&nbsp;    static {
<b class="fc">&nbsp;        MethodList&lt;MethodDescription.InDefinedShape&gt; enhanceMethods = TypeDescription.ForLoadedType.of(Enhance.class).getDeclaredMethods();</b>
<b class="fc">&nbsp;        ENHANCE_INVOKE_SUPER = enhanceMethods.filter(named(&quot;invokeSuper&quot;)).getOnly();</b>
<b class="fc">&nbsp;        ENHANCE_SIMPLE_COMPARISON_FIRST = enhanceMethods.filter(named(&quot;simpleComparisonsFirst&quot;)).getOnly();</b>
<b class="fc">&nbsp;        ENHANCE_INCLUDE_SYNTHETIC_FIELDS = enhanceMethods.filter(named(&quot;includeSyntheticFields&quot;)).getOnly();</b>
<b class="fc">&nbsp;        ENHANCE_PERMIT_SUBCLASS_EQUALITY = enhanceMethods.filter(named(&quot;permitSubclassEquality&quot;)).getOnly();</b>
<b class="fc">&nbsp;        ENHANCE_USE_TYPE_HASH_CONSTANT = enhanceMethods.filter(named(&quot;useTypeHashConstant&quot;)).getOnly();</b>
<b class="fc">&nbsp;        VALUE_HANDLING_VALUE = TypeDescription.ForLoadedType.of(ValueHandling.class).getDeclaredMethods().filter(named(&quot;value&quot;)).getOnly();</b>
<b class="fc">&nbsp;        SORTED_VALUE = TypeDescription.ForLoadedType.of(Sorted.class).getDeclaredMethods().filter(named(&quot;value&quot;)).getOnly();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Defines the binary name of a runtime-visible annotation type that should be added to the parameter of the
&nbsp;     * {@link Object#equals(Object)} method, or {@code null} if no such name should be defined.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @ValueHandling(ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;    private final String annotationType;
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new hash code equals plugin.
&nbsp;     */
&nbsp;    public HashCodeAndEqualsPlugin() {
<b class="fc">&nbsp;        this(null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new hash code equals plugin.
&nbsp;     *
&nbsp;     * @param annotationType Defines the binary name of a runtime-visible annotation type that should be added to the
&nbsp;     *                       parameter of the {@link Object#equals(Object)} method, or {@code null} if no such name
&nbsp;     *                       should be defined.
&nbsp;     */
<b class="fc">&nbsp;    public HashCodeAndEqualsPlugin(@MaybeNull String annotationType) {</b>
<b class="fc">&nbsp;        this.annotationType = annotationType;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public Plugin make() {
<b class="nc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public boolean matches(@MaybeNull TypeDescription target) {
<b class="fc">&nbsp;        return target != null &amp;&amp; target.getDeclaredAnnotations().isAnnotationPresent(Enhance.class);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Annotation presence is required by matcher.&quot;)
&nbsp;    public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;        AnnotationDescription.Loadable&lt;Enhance&gt; enhance = typeDescription.getDeclaredAnnotations().ofType(Enhance.class);</b>
<b class="fc">&nbsp;        if (typeDescription.getDeclaredMethods().filter(isHashCode()).isEmpty()) {</b>
<b class="fc">&nbsp;            builder = builder.method(isHashCode()).intercept(enhance.getValue(ENHANCE_INVOKE_SUPER).load(Enhance.class.getClassLoader()).resolve(Enhance.InvokeSuper.class)</b>
<b class="fc">&nbsp;                    .hashCodeMethod(typeDescription,</b>
<b class="fc">&nbsp;                            enhance.getValue(ENHANCE_USE_TYPE_HASH_CONSTANT).resolve(Boolean.class),</b>
<b class="fc">&nbsp;                            enhance.getValue(ENHANCE_PERMIT_SUBCLASS_EQUALITY).resolve(Boolean.class))</b>
<b class="fc">&nbsp;                    .withIgnoredFields(enhance.getValue(ENHANCE_INCLUDE_SYNTHETIC_FIELDS).resolve(Boolean.class)</b>
<b class="nc">&nbsp;                            ? ElementMatchers.&lt;FieldDescription&gt;none()</b>
<b class="fc">&nbsp;                            : ElementMatchers.&lt;FieldDescription&gt;isSynthetic())</b>
<b class="fc">&nbsp;                    .withIgnoredFields(new ValueMatcher(ValueHandling.Sort.IGNORE))</b>
<b class="fc">&nbsp;                    .withNonNullableFields(nonNullable(new ValueMatcher(ValueHandling.Sort.REVERSE_NULLABILITY))));</b>
&nbsp;        }
<b class="fc">&nbsp;        if (typeDescription.getDeclaredMethods().filter(isEquals()).isEmpty()) {</b>
<b class="fc">&nbsp;            EqualsMethod equalsMethod = enhance.getValue(ENHANCE_INVOKE_SUPER).load(Enhance.class.getClassLoader()).resolve(Enhance.InvokeSuper.class)</b>
<b class="fc">&nbsp;                    .equalsMethod(typeDescription)</b>
<b class="fc">&nbsp;                    .withIgnoredFields(enhance.getValue(ENHANCE_INCLUDE_SYNTHETIC_FIELDS).resolve(Boolean.class)</b>
<b class="nc">&nbsp;                            ? ElementMatchers.&lt;FieldDescription&gt;none()</b>
<b class="fc">&nbsp;                            : ElementMatchers.&lt;FieldDescription&gt;isSynthetic())</b>
<b class="fc">&nbsp;                    .withIgnoredFields(new ValueMatcher(ValueHandling.Sort.IGNORE))</b>
<b class="fc">&nbsp;                    .withNonNullableFields(nonNullable(new ValueMatcher(ValueHandling.Sort.REVERSE_NULLABILITY)))</b>
<b class="fc">&nbsp;                    .withFieldOrder(AnnotationOrderComparator.INSTANCE);</b>
<b class="fc">&nbsp;            if (enhance.getValue(ENHANCE_SIMPLE_COMPARISON_FIRST).resolve(Boolean.class)) {</b>
<b class="fc">&nbsp;                equalsMethod = equalsMethod</b>
<b class="fc">&nbsp;                        .withPrimitiveTypedFieldsFirst()</b>
<b class="fc">&nbsp;                        .withEnumerationTypedFieldsFirst()</b>
<b class="fc">&nbsp;                        .withPrimitiveWrapperTypedFieldsFirst()</b>
<b class="fc">&nbsp;                        .withStringTypedFieldsFirst();</b>
&nbsp;            }
<b class="fc">&nbsp;            builder = builder.method(isEquals()).intercept(enhance.getValue(ENHANCE_PERMIT_SUBCLASS_EQUALITY).resolve(Boolean.class)</b>
<b class="nc">&nbsp;                    ? equalsMethod.withSubclassEquality()</b>
<b class="fc">&nbsp;                    : equalsMethod).attribute(this);</b>
&nbsp;        }
<b class="fc">&nbsp;        return builder;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Resolves the matcher to identify non-nullable fields.
&nbsp;     *
&nbsp;     * @param matcher The matcher that identifies fields that are either nullable or non-nullable.
&nbsp;     * @return The actual matcher to identify non-nullable fields.
&nbsp;     */
&nbsp;    protected ElementMatcher&lt;FieldDescription&gt; nonNullable(ElementMatcher&lt;FieldDescription&gt; matcher) {
<b class="fc">&nbsp;        return matcher;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public void close() {
&nbsp;        /* do nothing */
<b class="nc">&nbsp;    }</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public MethodAttributeAppender make(TypeDescription typeDescription) {
<b class="fc">&nbsp;        return this;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public void apply(MethodVisitor methodVisitor, MethodDescription methodDescription, AnnotationValueFilter annotationValueFilter) {
<b class="fc">&nbsp;        if (annotationType != null) {</b>
<b class="fc">&nbsp;            AnnotationVisitor annotationVisitor = methodVisitor.visitParameterAnnotation(0,</b>
<b class="fc">&nbsp;                    &quot;L&quot; + annotationType.replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;,</b>
&nbsp;                    true);
<b class="fc">&nbsp;            if (annotationVisitor != null) {</b>
<b class="fc">&nbsp;                annotationVisitor.visitEnd();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A version of the {@link HashCodeAndEqualsPlugin} that assumes that all fields are non-nullable unless they are explicitly marked.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    public static class WithNonNullableFields extends HashCodeAndEqualsPlugin {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new hash code equals plugin where fields are assumed nullable by default.
&nbsp;         */
&nbsp;        public WithNonNullableFields() {
<b class="fc">&nbsp;            this(null);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new hash code equals plugin where fields are assumed nullable by default.
&nbsp;         *
&nbsp;         * @param annotationType Defines the binary name of a runtime-visible annotation type that should be added to the
&nbsp;         *                       parameter of the {@link Object#equals(Object)} method, or {@code null} if no such name
&nbsp;         *                       should be defined.
&nbsp;         */
&nbsp;        public WithNonNullableFields(@MaybeNull String annotationType) {
<b class="fc">&nbsp;            super(annotationType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        protected ElementMatcher&lt;FieldDescription&gt; nonNullable(ElementMatcher&lt;FieldDescription&gt; matcher) {
<b class="fc">&nbsp;            return not(matcher);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Instructs the {@link HashCodeAndEqualsPlugin} to generate {@link Object#hashCode()} and {@link Object#equals(Object)} for the annotated
&nbsp;     * class unless these methods are already declared explicitly.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.TYPE)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Enhance {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the base value of any added method, i.e. if hash code or equality is based on the super type or not.
&nbsp;         *
&nbsp;         * @return A strategy for determining the base value.
&nbsp;         */
&nbsp;        InvokeSuper invokeSuper() default InvokeSuper.IF_DECLARED;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if fields with primitive types, then enumeration types, then primtive wrapper types and then {@link String} types
&nbsp;         * should be compared for equality before fields with other types. Before determining such a field order,
&nbsp;         * the {@link Sorted} property is always considered first if it is defined.
&nbsp;         *
&nbsp;         * @return {@code true} if fields with simple comparison methods should be compared first.
&nbsp;         */
&nbsp;        boolean simpleComparisonsFirst() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if synthetic fields should be included in the hash code and equality contract.
&nbsp;         *
&nbsp;         * @return {@code true} if synthetic fields should be included.
&nbsp;         */
&nbsp;        boolean includeSyntheticFields() default false;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if instances subclasses of the instrumented type are accepted upon an equality check.
&nbsp;         *
&nbsp;         * @return {@code true} if instances subclasses of the instrumented type are accepted upon an equality check.
&nbsp;         */
&nbsp;        boolean permitSubclassEquality() default false;
&nbsp;
&nbsp;        /**
&nbsp;         * Determines if the hash code constant should be derived of the instrumented type. If {@link Enhance#permitSubclassEquality()}
&nbsp;         * is set to {@code true}, this constant is derived of the declared class, otherwise the type hash is computed of the active instance.
&nbsp;         *
&nbsp;         * @return {@code true} if the hash code constant should be derived of the instrumented type.
&nbsp;         */
&nbsp;        boolean useTypeHashConstant() default true;
&nbsp;
&nbsp;        /**
&nbsp;         * A strategy for determining the base value of a hash code or equality contract.
&nbsp;         */
<b class="fc">&nbsp;        enum InvokeSuper {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Only invokes the super method&#39;s hash code and equality methods if any super class that is not {@link Object} explicitly defines such a method.
&nbsp;             */
<b class="fc">&nbsp;            IF_DECLARED {</b>
&nbsp;                @Override
&nbsp;                protected HashCodeMethod hashCodeMethod(TypeDescription instrumentedType, boolean typeHash, boolean subclassEquality) {
<b class="fc">&nbsp;                    TypeDefinition typeDefinition = instrumentedType.getSuperClass();</b>
<b class="fc">&nbsp;                    while (typeDefinition != null &amp;&amp; !typeDefinition.represents(Object.class)) {</b>
<b class="nc">&nbsp;                        if (typeDefinition.asErasure().getDeclaredAnnotations().isAnnotationPresent(Enhance.class)) {</b>
<b class="nc">&nbsp;                            return HashCodeMethod.usingSuperClassOffset();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        MethodList&lt;?&gt; hashCode = typeDefinition.getDeclaredMethods().filter(isHashCode());</b>
<b class="nc">&nbsp;                        if (!hashCode.isEmpty()) {</b>
<b class="nc">&nbsp;                            return hashCode.getOnly().isAbstract()</b>
<b class="nc">&nbsp;                                    ? (typeHash ? HashCodeMethod.usingTypeHashOffset(!subclassEquality) : HashCodeMethod.usingDefaultOffset())</b>
<b class="nc">&nbsp;                                    : HashCodeMethod.usingSuperClassOffset();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        typeDefinition = typeDefinition.getSuperClass();</b>
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return typeHash ? HashCodeMethod.usingTypeHashOffset(!subclassEquality) : HashCodeMethod.usingDefaultOffset();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected EqualsMethod equalsMethod(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    TypeDefinition typeDefinition = instrumentedType.getSuperClass();</b>
<b class="fc">&nbsp;                    while (typeDefinition != null &amp;&amp; !typeDefinition.represents(Object.class)) {</b>
<b class="fc">&nbsp;                        if (typeDefinition.asErasure().getDeclaredAnnotations().isAnnotationPresent(Enhance.class)) {</b>
<b class="fc">&nbsp;                            return EqualsMethod.requiringSuperClassEquality();</b>
&nbsp;                        }
<b class="fc">&nbsp;                        MethodList&lt;?&gt; hashCode = typeDefinition.getDeclaredMethods().filter(isHashCode());</b>
<b class="fc">&nbsp;                        if (!hashCode.isEmpty()) {</b>
<b class="fc">&nbsp;                            return hashCode.getOnly().isAbstract()</b>
<b class="nc">&nbsp;                                    ? EqualsMethod.isolated()</b>
<b class="fc">&nbsp;                                    : EqualsMethod.requiringSuperClassEquality();</b>
&nbsp;                        }
<b class="nc">&nbsp;                        typeDefinition = typeDefinition.getSuperClass();</b>
<b class="nc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return EqualsMethod.isolated();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Only invokes the super method&#39;s hash code and equality methods if the super class is also annotated with {@link Enhance}.
&nbsp;             */
<b class="fc">&nbsp;            IF_ANNOTATED {</b>
&nbsp;                @Override
&nbsp;                protected HashCodeMethod hashCodeMethod(TypeDescription instrumentedType, boolean typeHash, boolean subclassEquality) {
<b class="nc">&nbsp;                    TypeDefinition superClass = instrumentedType.getSuperClass();</b>
<b class="nc">&nbsp;                    return superClass != null &amp;&amp; superClass.asErasure().getDeclaredAnnotations().isAnnotationPresent(Enhance.class)</b>
<b class="nc">&nbsp;                            ? HashCodeMethod.usingSuperClassOffset()</b>
<b class="nc">&nbsp;                            : (typeHash ? HashCodeMethod.usingTypeHashOffset(!subclassEquality) : HashCodeMethod.usingDefaultOffset());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected EqualsMethod equalsMethod(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    TypeDefinition superClass = instrumentedType.getSuperClass();</b>
<b class="fc">&nbsp;                    return superClass != null &amp;&amp; superClass.asErasure().getDeclaredAnnotations().isAnnotationPresent(Enhance.class)</b>
<b class="fc">&nbsp;                            ? EqualsMethod.requiringSuperClassEquality()</b>
<b class="fc">&nbsp;                            : EqualsMethod.isolated();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Always invokes the super class&#39;s hash code and equality methods.
&nbsp;             */
<b class="fc">&nbsp;            ALWAYS {</b>
&nbsp;                @Override
&nbsp;                protected HashCodeMethod hashCodeMethod(TypeDescription instrumentedType, boolean typeHash, boolean subclassEquality) {
<b class="nc">&nbsp;                    return HashCodeMethod.usingSuperClassOffset();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected EqualsMethod equalsMethod(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    return EqualsMethod.requiringSuperClassEquality();</b>
&nbsp;                }
&nbsp;            },
&nbsp;
&nbsp;            /**
&nbsp;             * Never invokes the super class&#39;s hash code and equality methods.
&nbsp;             */
<b class="fc">&nbsp;            NEVER {</b>
&nbsp;                @Override
&nbsp;                protected HashCodeMethod hashCodeMethod(TypeDescription instrumentedType, boolean typeHash, boolean subclassEquality) {
<b class="nc">&nbsp;                    return typeHash ? HashCodeMethod.usingTypeHashOffset(!subclassEquality) : HashCodeMethod.usingDefaultOffset();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected EqualsMethod equalsMethod(TypeDescription instrumentedType) {
<b class="fc">&nbsp;                    return EqualsMethod.isolated();</b>
&nbsp;                }
&nbsp;            };
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the hash code method to use.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @param typeHash         {@code true} if the base hash should be based on the instrumented class&#39;s type.
&nbsp;             * @param subclassEquality {@code true} if subclasses can be equal to their base classes.
&nbsp;             * @return The hash code method to use.
&nbsp;             */
&nbsp;            protected abstract HashCodeMethod hashCodeMethod(TypeDescription instrumentedType, boolean typeHash, boolean subclassEquality);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the equals method to use.
&nbsp;             *
&nbsp;             * @param instrumentedType The instrumented type.
&nbsp;             * @return The equals method to use.
&nbsp;             */
&nbsp;            protected abstract EqualsMethod equalsMethod(TypeDescription instrumentedType);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines how a field should be used within generated hash code and equality methods.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.FIELD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface ValueHandling {
&nbsp;
&nbsp;        /**
&nbsp;         * Determines the handling of the annotated field.
&nbsp;         *
&nbsp;         * @return The handling of the annotated field.
&nbsp;         */
&nbsp;        Sort value();
&nbsp;
&nbsp;        /**
&nbsp;         * Determines how a field should be handled.
&nbsp;         */
<b class="fc">&nbsp;        enum Sort {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Excludes the field from hash code and equality methods.
&nbsp;             */
<b class="fc">&nbsp;            IGNORE,</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Reverses the nullability of the field, i.e. assumes this field to be non-null or {@code null} if {@link WithNonNullableFields} is used.
&nbsp;             */
<b class="fc">&nbsp;            REVERSE_NULLABILITY</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the sort order of fields for the equality check when implementing the {@link Object#equals(Object)} method. Any field
&nbsp;     * that is not annotated is considered with a value of {@link Sorted#DEFAULT} where fields with a higher value are checked for equality
&nbsp;     * first. This sort order is applied first after which the type order is considered if {@link Enhance#simpleComparisonsFirst()} is considered
&nbsp;     * as additional sort criteria.
&nbsp;     */
&nbsp;    @Documented
&nbsp;    @Target(ElementType.FIELD)
&nbsp;    @Retention(RetentionPolicy.RUNTIME)
&nbsp;    public @interface Sorted {
&nbsp;
&nbsp;        /**
&nbsp;         * The default sort weight.
&nbsp;         */
&nbsp;        int DEFAULT = 0;
&nbsp;
&nbsp;        /**
&nbsp;         * The value for the sort order where fields with higher values are checked for equality first.
&nbsp;         *
&nbsp;         * @return The value for the sort order where fields with higher values are checked for equality first.
&nbsp;         */
&nbsp;        int value();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A comparator that arranges fields in the order of {@link Sorted}.
&nbsp;     */
<b class="fc">&nbsp;    protected enum AnnotationOrderComparator implements Comparator&lt;FieldDescription.InDefinedShape&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The singleton instance.
&nbsp;         */
<b class="fc">&nbsp;        INSTANCE;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int compare(FieldDescription.InDefinedShape left, FieldDescription.InDefinedShape right) {
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;Sorted&gt; leftAnnotation = left.getDeclaredAnnotations().ofType(Sorted.class);</b>
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;Sorted&gt; rightAnnotation = right.getDeclaredAnnotations().ofType(Sorted.class);</b>
<b class="fc">&nbsp;            int leftValue = leftAnnotation == null ? Sorted.DEFAULT : leftAnnotation.getValue(SORTED_VALUE).resolve(Integer.class);</b>
<b class="fc">&nbsp;            int rightValue = rightAnnotation == null ? Sorted.DEFAULT : rightAnnotation.getValue(SORTED_VALUE).resolve(Integer.class);</b>
<b class="fc">&nbsp;            if (leftValue &gt; rightValue) {</b>
<b class="fc">&nbsp;                return -1;</b>
<b class="fc">&nbsp;            } else if (leftValue &lt; rightValue) {</b>
<b class="fc">&nbsp;                return 1;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An element matcher for a {@link ValueHandling} annotation.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    protected static class ValueMatcher extends ElementMatcher.Junction.ForNonNullValues&lt;FieldDescription&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The matched value.
&nbsp;         */
&nbsp;        private final ValueHandling.Sort sort;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new value matcher.
&nbsp;         *
&nbsp;         * @param sort The matched value.
&nbsp;         */
<b class="fc">&nbsp;        protected ValueMatcher(ValueHandling.Sort sort) {</b>
<b class="fc">&nbsp;            this.sort = sort;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        protected boolean doMatch(FieldDescription target) {
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;ValueHandling&gt; annotation = target.getDeclaredAnnotations().ofType(ValueHandling.class);</b>
<b class="fc">&nbsp;            return annotation != null &amp;&amp; annotation.getValue(VALUE_HANDLING_VALUE).load(ValueHandling.class.getClassLoader()).resolve(ValueHandling.Sort.class) == sort;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
