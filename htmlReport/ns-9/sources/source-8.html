


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > Plugin</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.build</a>
</div>

<h1>Coverage Summary for Class: Plugin (net.bytebuddy.build)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">Plugin$1</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91%
  </span>
  <span class="absValue">
    (101/111)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$0Xy5g0Vq</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$aU0Lrpwk</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$BT4yANzi</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$CPLpgFTc</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$CVfmxydV</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$fOHTWnAv</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$GLYrxc5E</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$hMjZpgHE</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$HzLtXUOk</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$KIfTxVby</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$KUsLXqxn</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$mddj7zmo</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$MwQESt7A</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$v810icGx</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$VpwVgkQE</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$XfRCY7ft</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$MockitoMock$1309138881$auxiliary$YRoGnBIg</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$Preprocessor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.1%
  </span>
  <span class="absValue">
    (20/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$Preprocessor$Ignored</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$Preprocessor$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (37/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Default$Preprocessor$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Factory</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForParallelTransformation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (33/42)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForParallelTransformation$EagerWork</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForParallelTransformation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForParallelTransformation$WithThrowawayExecutorService</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForParallelTransformation$WithThrowawayExecutorService$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForSerialTransformation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.6%
  </span>
  <span class="absValue">
    (25/31)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$ForSerialTransformation$Factory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$ForFailedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$ForRetainedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$ForTransformedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$ForUnresolvedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$MockitoMock$1019426411</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$MockitoMock$1019426411$auxiliary$tQhI4DTi</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Dispatcher$Materializable$MockitoMock$1019426411$auxiliary$xG9wZSJb</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97%
  </span>
  <span class="absValue">
    (32/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Enforcing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Enforcing$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Enforcing$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Enforcing$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Enforcing$4</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Failing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Failing$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Failing$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$Failing$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$MockitoMock$382108089</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$MockitoMock$382108089$auxiliary$06o1zc0y</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$ErrorHandler$MockitoMock$382108089$auxiliary$mtme88qv</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$Adapter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (51/51)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$ForErrorHandler</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$MockitoMock$1421601814</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$MockitoMock$1421601814$auxiliary$4cXKzofM</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$MockitoMock$1421601814$auxiliary$YRGrnQvt</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$StreamWriting</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.5%
  </span>
  <span class="absValue">
    (21/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$WithErrorsOnly</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Listener$WithTransformationsOnly</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$PoolStrategy</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$PoolStrategy$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$PoolStrategy$Eager</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$PoolStrategy$MockitoMock$955094441</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$PoolStrategy$MockitoMock$955094441$auxiliary$HGpCjsGO</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$PoolStrategy$MockitoMock$955094441$auxiliary$kKYnbRwq</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Compound</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (10/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Compound$Origin</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.1%
  </span>
  <span class="absValue">
    (16/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Compound$Origin$CompoundIterator</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (9/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element$ForByteArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element$ForFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element$ForJarEntry</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element$MockitoMock$1203091389</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element$MockitoMock$1203091389$auxiliary$arlsy4UX</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Element$MockitoMock$1203091389$auxiliary$ZDenmeCc</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Empty</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Filtering</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$ForFolder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$ForFolder$FolderIterator</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    58.8%
  </span>
  <span class="absValue">
    (10/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$ForJarFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$InMemory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$InMemory$MapEntryIterator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$MockitoMock$1542218587</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$MockitoMock$1542218587$auxiliary$jEwDWdec</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$MockitoMock$1542218587$auxiliary$wFuV9Cg6</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$Filtering</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$Filtering$FilteringIterator</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (18/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$ForJarFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$ForJarFile$JarFileIterator</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$MockitoMock$1731990895</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$MockitoMock$1731990895$auxiliary$BXymcM5T</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$MockitoMock$1731990895$auxiliary$KHeyqHSo</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$MockitoMock$1731990895$auxiliary$VGw2uc6I</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Source$Origin$MockitoMock$1731990895$auxiliary$YtBVlEVS</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Summary</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$Discarding</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$ForFolder</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.5%
  </span>
  <span class="absValue">
    (37/40)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$ForJarFile</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$InMemory</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (35/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$Sink</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$Sink$ForJarOutputStream</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (19/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$Sink$MockitoMock$543103656</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$Sink$MockitoMock$543103656$auxiliary$KYKHJP0j</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$Target$Sink$MockitoMock$543103656$auxiliary$MgQO9SuZ</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$Default</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$Default$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$Default$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$Default$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$ForEntryPoint</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$MockitoMock$1531784152</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$MockitoMock$1531784152$auxiliary$4OZjKgSl</td>
  </tr>
  <tr>
    <td class="name">Plugin$Engine$TypeStrategy$MockitoMock$1531784152$auxiliary$VXayUmUM</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (24/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$ForIndex</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.5%
  </span>
  <span class="absValue">
    (21/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$ForIndex$WithDynamicType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    73.9%
  </span>
  <span class="absValue">
    (17/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$ForType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$Resolution</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$Resolution$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$ArgumentResolver$Resolution$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$Instantiator</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$Instantiator$Ambiguous</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (11/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$Instantiator$Resolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (16/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$Instantiator$Unresolved</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$Factory$UsingReflection$Priority</td>
  </tr>
  <tr>
    <td class="name">Plugin$ForElementMatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$MockitoMock$2013865085</td>
  </tr>
  <tr>
    <td class="name">Plugin$MockitoMock$2013865085$auxiliary$EW0DG9Aq</td>
  </tr>
  <tr>
    <td class="name">Plugin$MockitoMock$2013865085$auxiliary$lG5F1ean</td>
  </tr>
  <tr>
    <td class="name">Plugin$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">Plugin$WithInitialization</td>
  </tr>
  <tr>
    <td class="name">Plugin$WithPreprocessor</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    95.6%
  </span>
  <span class="absValue">
    (350/366)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91%
  </span>
  <span class="absValue">
    (894/982)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.build;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ByteBuddy;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.DynamicType;
&nbsp;import net.bytebuddy.dynamic.TypeResolutionStrategy;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
&nbsp;import net.bytebuddy.implementation.LoadedTypeInitializer;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.pool.TypePool;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.FileSystem;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.io.*;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.net.URL;
&nbsp;import java.util.*;
&nbsp;import java.util.concurrent.*;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;import java.util.jar.JarOutputStream;
&nbsp;import java.util.jar.Manifest;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.none;
&nbsp;
&nbsp;/**
&nbsp; * &lt;p&gt;
&nbsp; * A plugin that allows for the application of Byte Buddy transformations during a build process. This plugin&#39;s
&nbsp; * transformation is applied to any type matching this plugin&#39;s type matcher. Plugin types must be public,
&nbsp; * non-abstract and must declare a public default constructor to work.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * A plugin is always used within the scope of a single plugin engine application and is disposed after closing. It might be used
&nbsp; * concurrently and must assure its own thread-safety if run outside of a {@link Plugin.Engine} or when using a parallel
&nbsp; * {@link Plugin.Engine.Dispatcher}.
&nbsp; * &lt;/p&gt;
&nbsp; * &lt;p&gt;
&nbsp; * For discoverability, plugin class names can be stored in a file named &lt;i&gt;META-INF/net.bytebuddy/build.plugins&lt;/i&gt; with the fully
&nbsp; * qualified class name of the plugin per line.
&nbsp; * &lt;/p&gt;
&nbsp; */
&nbsp;public interface Plugin extends ElementMatcher&lt;TypeDescription&gt;, Closeable {
&nbsp;
&nbsp;    /**
&nbsp;     * Applies this plugin.
&nbsp;     *
&nbsp;     * @param builder          The builder to use as a basis for the applied transformation.
&nbsp;     * @param typeDescription  The type being transformed.
&nbsp;     * @param classFileLocator A class file locator that can locate other types in the scope of the project.
&nbsp;     * @return The supplied builder with additional transformations registered.
&nbsp;     */
&nbsp;    DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassFileLocator classFileLocator);
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A plugin that applies a preprocessor, i.e. causes a plugin engine&#39;s execution to defer all plugin applications until all types were discovered.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: The registration of a single plugin with preprocessor causes the deferral of all plugins&#39; application that are registered
&nbsp;     * with a particular plugin engine. This will reduce parallel application if a corresponding {@link Engine.Dispatcher} is used and will increase
&nbsp;     * the engine application&#39;s memory consumption. Any alternative application of a plugin outside of a {@link Plugin.Engine} might not be capable
&nbsp;     * of preprocessing where the discovery callback is not invoked.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    interface WithPreprocessor extends Plugin {
&nbsp;
&nbsp;        /**
&nbsp;         * Invoked upon the discovery of a type that is not explicitly ignored.
&nbsp;         *
&nbsp;         * @param typeDescription  The discovered type.
&nbsp;         * @param classFileLocator A class file locator that can locate other types in the scope of the project.
&nbsp;         */
&nbsp;        void onPreprocess(TypeDescription typeDescription, ClassFileLocator classFileLocator);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Allows for the generation of types before a plugin is applied.
&nbsp;     */
&nbsp;    interface WithInitialization extends Plugin {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a mapping of classes that should be created before discovering any types.
&nbsp;         *
&nbsp;         * @param classFileLocator A class file locator that can locate other types in the scope of the project.
&nbsp;         * @return A mapping of types to their binary representation.
&nbsp;         */
&nbsp;        Map&lt;TypeDescription, byte[]&gt; initialize(ClassFileLocator classFileLocator);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A factory for providing a build plugin.
&nbsp;     */
&nbsp;    interface Factory {
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a plugin that can be used for a transformation and which is subsequently closed.
&nbsp;         *
&nbsp;         * @return The plugin to use for type transformations.
&nbsp;         */
&nbsp;        Plugin make();
&nbsp;
&nbsp;        /**
&nbsp;         * A simple factory that returns a preconstructed plugin instance.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class Simple implements Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The plugin to provide.
&nbsp;             */
&nbsp;            private final Plugin plugin;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a simple plugin factory.
&nbsp;             *
&nbsp;             * @param plugin The plugin to provide.
&nbsp;             */
<b class="fc">&nbsp;            public Simple(Plugin plugin) {</b>
<b class="fc">&nbsp;                this.plugin = plugin;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Plugin make() {
<b class="fc">&nbsp;                return plugin;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A plugin factory that uses reflection for instantiating a plugin.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class UsingReflection implements Factory {
&nbsp;
&nbsp;            /**
&nbsp;             * The plugin type.
&nbsp;             */
&nbsp;            private final Class&lt;? extends Plugin&gt; type;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of argument providers that can be used for instantiating the plugin.
&nbsp;             */
&nbsp;            private final List&lt;ArgumentResolver&gt; argumentResolvers;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a plugin factory that uses reflection for creating a plugin.
&nbsp;             *
&nbsp;             * @param type The plugin type.
&nbsp;             */
&nbsp;            public UsingReflection(Class&lt;? extends Plugin&gt; type) {
<b class="fc">&nbsp;                this(type, Collections.&lt;ArgumentResolver&gt;emptyList());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a plugin factory that uses reflection for creating a plugin.
&nbsp;             *
&nbsp;             * @param type              The plugin type.
&nbsp;             * @param argumentResolvers A list of argument providers that can be used for instantiating the plugin.
&nbsp;             */
<b class="fc">&nbsp;            protected UsingReflection(Class&lt;? extends Plugin&gt; type, List&lt;ArgumentResolver&gt; argumentResolvers) {</b>
<b class="fc">&nbsp;                this.type = type;</b>
<b class="fc">&nbsp;                this.argumentResolvers = argumentResolvers;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Appends the supplied argument resolvers.
&nbsp;             *
&nbsp;             * @param argumentResolver A list of argument providers that can be used for instantiating the plugin.
&nbsp;             * @return A new plugin factory that uses reflection for creating a plugin that also uses the supplied argument resolvers.
&nbsp;             */
&nbsp;            public UsingReflection with(ArgumentResolver... argumentResolver) {
<b class="fc">&nbsp;                return with(Arrays.asList(argumentResolver));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Appends the supplied argument resolvers.
&nbsp;             *
&nbsp;             * @param argumentResolvers A list of argument providers that can be used for instantiating the plugin.
&nbsp;             * @return A new plugin factory that uses reflection for creating a plugin that also uses the supplied argument resolvers.
&nbsp;             */
&nbsp;            public UsingReflection with(List&lt;? extends ArgumentResolver&gt; argumentResolvers) {
<b class="fc">&nbsp;                return new UsingReflection(type, CompoundList.of(argumentResolvers, this.argumentResolvers));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public Plugin make() {
<b class="fc">&nbsp;                Instantiator instantiator = new Instantiator.Unresolved(type);</b>
&nbsp;                candidates:
<b class="fc">&nbsp;                for (Constructor&lt;?&gt; constructor : type.getConstructors()) {</b>
<b class="fc">&nbsp;                    if (!constructor.isSynthetic()) {</b>
<b class="fc">&nbsp;                        List&lt;Object&gt; arguments = new ArrayList&lt;Object&gt;(constructor.getParameterTypes().length);</b>
<b class="fc">&nbsp;                        int index = 0;</b>
<b class="fc">&nbsp;                        for (Class&lt;?&gt; type : constructor.getParameterTypes()) {</b>
<b class="fc">&nbsp;                            boolean resolved = false;</b>
<b class="fc">&nbsp;                            for (ArgumentResolver argumentResolver : argumentResolvers) {</b>
<b class="fc">&nbsp;                                ArgumentResolver.Resolution resolution = argumentResolver.resolve(index, type);</b>
<b class="fc">&nbsp;                                if (resolution.isResolved()) {</b>
<b class="fc">&nbsp;                                    arguments.add(resolution.getArgument());</b>
<b class="fc">&nbsp;                                    resolved = true;</b>
<b class="fc">&nbsp;                                    break;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            if (resolved) {</b>
<b class="fc">&nbsp;                                index += 1;</b>
&nbsp;                            } else {
&nbsp;                                continue candidates;
&nbsp;                            }
&nbsp;                        }
<b class="fc">&nbsp;                        instantiator = instantiator.replaceBy(new Instantiator.Resolved((Constructor&lt;? extends Plugin&gt;) constructor, arguments));</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return instantiator.instantiate();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An instantiator is responsible for invoking a plugin constructor reflectively.
&nbsp;             */
&nbsp;            protected interface Instantiator {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns either this instantiator or the supplied instantiator, depending on the instances&#39; states.
&nbsp;                 *
&nbsp;                 * @param instantiator The alternative instantiator.
&nbsp;                 * @return The dominant instantiator.
&nbsp;                 */
&nbsp;                Instantiator replaceBy(Resolved instantiator);
&nbsp;
&nbsp;                /**
&nbsp;                 * Instantiates the represented plugin.
&nbsp;                 *
&nbsp;                 * @return The instantiated plugin.
&nbsp;                 */
&nbsp;                Plugin instantiate();
&nbsp;
&nbsp;                /**
&nbsp;                 * An instantiator that is not resolved for creating an instance.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Unresolved implements Instantiator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type for which no constructor was yet resolved.
&nbsp;                     */
&nbsp;                    private final Class&lt;? extends Plugin&gt; type;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new unresolved constructor.
&nbsp;                     *
&nbsp;                     * @param type The type for which no constructor was yet resolved.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Unresolved(Class&lt;? extends Plugin&gt; type) {</b>
<b class="fc">&nbsp;                        this.type = type;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Instantiator replaceBy(Resolved instantiator) {
<b class="fc">&nbsp;                        return instantiator;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Plugin instantiate() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;No constructor resolvable for &quot; + type);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents an ambiguously resolved instantiator.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Ambiguous implements Instantiator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The left constructor.
&nbsp;                     */
&nbsp;                    private final Constructor&lt;?&gt; left;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The right constructor.
&nbsp;                     */
&nbsp;                    private final Constructor&lt;?&gt; right;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The resolved priority.
&nbsp;                     */
&nbsp;                    private final int priority;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The resolved number of parameters.
&nbsp;                     */
&nbsp;                    private final int parameters;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new ambiguous instantiator.
&nbsp;                     *
&nbsp;                     * @param left       The left constructor.
&nbsp;                     * @param right      The right constructor.
&nbsp;                     * @param priority   The resolved priority.
&nbsp;                     * @param parameters The resolved number of parameters.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Ambiguous(Constructor&lt;?&gt; left, Constructor&lt;?&gt; right, int priority, int parameters) {</b>
<b class="fc">&nbsp;                        this.left = left;</b>
<b class="fc">&nbsp;                        this.right = right;</b>
<b class="fc">&nbsp;                        this.priority = priority;</b>
<b class="fc">&nbsp;                        this.parameters = parameters;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Instantiator replaceBy(Resolved instantiator) {
<b class="fc">&nbsp;                        Priority priority = instantiator.getConstructor().getAnnotation(Priority.class);</b>
<b class="fc">&nbsp;                        if ((priority == null ? Priority.DEFAULT : priority.value()) &gt; this.priority) {</b>
<b class="nc">&nbsp;                            return instantiator;</b>
<b class="fc">&nbsp;                        } else if ((priority == null ? Priority.DEFAULT : priority.value()) &lt; this.priority) {</b>
<b class="nc">&nbsp;                            return this;</b>
<b class="fc">&nbsp;                        } else if (instantiator.getConstructor().getParameterTypes().length &gt; parameters) {</b>
<b class="nc">&nbsp;                            return instantiator;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return this;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Plugin instantiate() {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Ambiguous constructors &quot; + left + &quot; and &quot; + right);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An instantiator that is resolved for a given constructor with arguments.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Resolved implements Instantiator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented constructor.
&nbsp;                     */
&nbsp;                    private final Constructor&lt;? extends Plugin&gt; constructor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The constructor arguments.
&nbsp;                     */
&nbsp;                    private final List&lt;?&gt; arguments;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved constructor.
&nbsp;                     *
&nbsp;                     * @param constructor The represented constructor.
&nbsp;                     * @param arguments   The constructor arguments.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Resolved(Constructor&lt;? extends Plugin&gt; constructor, List&lt;?&gt; arguments) {</b>
<b class="fc">&nbsp;                        this.constructor = constructor;</b>
<b class="fc">&nbsp;                        this.arguments = arguments;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the resolved constructor.
&nbsp;                     *
&nbsp;                     * @return The resolved constructor.
&nbsp;                     */
&nbsp;                    protected Constructor&lt;? extends Plugin&gt; getConstructor() {
<b class="fc">&nbsp;                        return constructor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Instantiator replaceBy(Resolved instantiator) {
<b class="fc">&nbsp;                        Priority left = constructor.getAnnotation(Priority.class), right = instantiator.getConstructor().getAnnotation(Priority.class);</b>
<b class="fc">&nbsp;                        int leftPriority = left == null ? Priority.DEFAULT : left.value(), rightPriority = right == null ? Priority.DEFAULT : right.value();</b>
<b class="fc">&nbsp;                        if (leftPriority &gt; rightPriority) {</b>
<b class="fc">&nbsp;                            return this;</b>
<b class="fc">&nbsp;                        } else if (leftPriority &lt; rightPriority) {</b>
<b class="fc">&nbsp;                            return instantiator;</b>
<b class="fc">&nbsp;                        } else if (constructor.getParameterTypes().length &gt; instantiator.getConstructor().getParameterTypes().length) {</b>
<b class="fc">&nbsp;                            return this;</b>
<b class="fc">&nbsp;                        } else if (constructor.getParameterTypes().length &lt; instantiator.getConstructor().getParameterTypes().length) {</b>
<b class="fc">&nbsp;                            return instantiator;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return new Ambiguous(constructor, instantiator.getConstructor(), leftPriority, constructor.getParameterTypes().length);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Plugin instantiate() {
&nbsp;                        try {
<b class="fc">&nbsp;                            return constructor.newInstance(arguments.toArray(new Object[0]));</b>
<b class="nc">&nbsp;                        } catch (InstantiationException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Failed to instantiate plugin via &quot; + constructor, exception);</b>
<b class="nc">&nbsp;                        } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Failed to access &quot; + constructor, exception);</b>
<b class="nc">&nbsp;                        } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Error during construction of&quot; + constructor, exception.getTargetException());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Indicates that a constructor should be treated with a given priority if several constructors can be resolved.
&nbsp;             */
&nbsp;            @Documented
&nbsp;            @Target(ElementType.CONSTRUCTOR)
&nbsp;            @Retention(RetentionPolicy.RUNTIME)
&nbsp;            public @interface Priority {
&nbsp;
&nbsp;                /**
&nbsp;                 * The default priority that is assumed for non-annotated constructors.
&nbsp;                 */
&nbsp;                int DEFAULT = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates the priority of the annotated constructor.
&nbsp;                 *
&nbsp;                 * @return The priority of the annotated constructor.
&nbsp;                 */
&nbsp;                int value();
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Allows to resolve arguments for a {@link Plugin} constructor.
&nbsp;             */
&nbsp;            public interface ArgumentResolver {
&nbsp;
&nbsp;                /**
&nbsp;                 * Attempts the resolution of an argument for a given parameter.
&nbsp;                 *
&nbsp;                 * @param index The parameter&#39;s index.
&nbsp;                 * @param type  The parameter&#39;s type.
&nbsp;                 * @return The resolution for the parameter.
&nbsp;                 */
&nbsp;                Resolution resolve(int index, Class&lt;?&gt; type);
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolution provided by an argument provider.
&nbsp;                 */
&nbsp;                interface Resolution {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the represented argument is resolved successfully.
&nbsp;                     *
&nbsp;                     * @return {@code true} if the represented argument is resolved successfully.
&nbsp;                     */
&nbsp;                    boolean isResolved();
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the resolved argument if the resolution was successful.
&nbsp;                     *
&nbsp;                     * @return The resolved argument if the resolution was successful.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    Object getArgument();
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents an unresolved argument resolution.
&nbsp;                     */
<b class="fc">&nbsp;                    enum Unresolved implements Resolution {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The singleton instance.
&nbsp;                         */
<b class="fc">&nbsp;                        INSTANCE;</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean isResolved() {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Object getArgument() {
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Cannot get the argument for an unresolved parameter&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Represents a resolved argument resolution.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class Resolved implements Resolution {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The resolved argument which might be {@code null}.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                        private final Object argument;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a resolved argument resolution.
&nbsp;                         *
&nbsp;                         * @param argument The resolved argument which might be {@code null}.
&nbsp;                         */
<b class="fc">&nbsp;                        public Resolved(@MaybeNull Object argument) {</b>
<b class="fc">&nbsp;                            this.argument = argument;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean isResolved() {
<b class="fc">&nbsp;                            return true;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        public Object getArgument() {
<b class="fc">&nbsp;                            return argument;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument resolver that never resolves an argument.
&nbsp;                 */
<b class="nc">&nbsp;                enum NoOp implements ArgumentResolver {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="nc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(int index, Class&lt;?&gt; type) {
<b class="nc">&nbsp;                        return Resolution.Unresolved.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument resolver that resolves parameters for a given type.
&nbsp;                 *
&nbsp;                 * @param &lt;T&gt; The type being resolved.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForType&lt;T&gt; implements ArgumentResolver {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type being resolved.
&nbsp;                     */
&nbsp;                    private final Class&lt;? extends T&gt; type;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The instance to resolve for the represented type.
&nbsp;                     */
&nbsp;                    private final T value;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new argument resolver for a given type.
&nbsp;                     *
&nbsp;                     * @param type  The type being resolved.
&nbsp;                     * @param value The instance to resolve for the represented type.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForType(Class&lt;? extends T&gt; type, T value) {</b>
<b class="fc">&nbsp;                        this.type = type;</b>
<b class="fc">&nbsp;                        this.value = value;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an argument resolver for a given type.
&nbsp;                     *
&nbsp;                     * @param type  The type being resolved.
&nbsp;                     * @param value The instance to resolve for the represented type.
&nbsp;                     * @param &lt;S&gt;   The type being resolved.
&nbsp;                     * @return An appropriate argument resolver.
&nbsp;                     */
&nbsp;                    public static &lt;S&gt; ArgumentResolver of(Class&lt;? extends S&gt; type, S value) {
<b class="fc">&nbsp;                        return new ForType&lt;S&gt;(type, value);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(int index, Class&lt;?&gt; type) {
<b class="fc">&nbsp;                        return type == this.type</b>
<b class="fc">&nbsp;                                ? new Resolution.Resolved(value)</b>
<b class="fc">&nbsp;                                : Resolution.Unresolved.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An argument resolver that resolves an argument for a specific parameter index.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                class ForIndex implements ArgumentResolver {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A mapping of primitive types to their wrapper types.
&nbsp;                     */
&nbsp;                    private static final Map&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt; WRAPPER_TYPES;
&nbsp;
&nbsp;                    /*
&nbsp;                     * Creates the primitive to wrapper type mapping.
&nbsp;                     */
&nbsp;                    static {
<b class="fc">&nbsp;                        WRAPPER_TYPES = new HashMap&lt;Class&lt;?&gt;, Class&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(boolean.class, Boolean.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(byte.class, Byte.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(short.class, Short.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(char.class, Character.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(int.class, Integer.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(long.class, Long.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(float.class, Float.class);</b>
<b class="fc">&nbsp;                        WRAPPER_TYPES.put(double.class, Double.class);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the parameter to resolve.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The value to resolve for the represented index.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                    private final Object value;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an argument resolver for a given index.
&nbsp;                     *
&nbsp;                     * @param index The index of the parameter to resolve.
&nbsp;                     * @param value The value to resolve for the represented index.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForIndex(int index, @MaybeNull Object value) {</b>
<b class="fc">&nbsp;                        this.index = index;</b>
<b class="fc">&nbsp;                        this.value = value;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Resolution resolve(int index, Class&lt;?&gt; type) {
<b class="fc">&nbsp;                        if (this.index != index) {</b>
<b class="fc">&nbsp;                            return Resolution.Unresolved.INSTANCE;</b>
<b class="fc">&nbsp;                        } else if (type.isPrimitive()) {</b>
<b class="fc">&nbsp;                            return WRAPPER_TYPES.get(type).isInstance(value)</b>
<b class="fc">&nbsp;                                    ? new Resolution.Resolved(value)</b>
<b class="nc">&nbsp;                                    : Resolution.Unresolved.INSTANCE;</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            return value == null || type.isInstance(value)</b>
<b class="fc">&nbsp;                                    ? new Resolution.Resolved(value)</b>
<b class="fc">&nbsp;                                    : Resolution.Unresolved.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An argument resolver that resolves an argument for a specific parameter index by attempting a conversion via
&nbsp;                     * invoking a static {@code valueOf} method on the target type, if it exists. As an exception, the {@code char}
&nbsp;                     * and {@link Character} types are resolved if the string value represents a single character.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class WithDynamicType implements ArgumentResolver {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The index of the parameter to resolve.
&nbsp;                         */
&nbsp;                        private final int index;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A string representation of the supplied value.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                        private final String value;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates an argument resolver for a specific parameter index and attempts a dynamic resolution.
&nbsp;                         *
&nbsp;                         * @param index The index of the parameter to resolve.
&nbsp;                         * @param value A string representation of the supplied value.
&nbsp;                         */
<b class="fc">&nbsp;                        public WithDynamicType(int index, @MaybeNull String value) {</b>
<b class="fc">&nbsp;                            this.index = index;</b>
<b class="fc">&nbsp;                            this.value = value;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Resolution resolve(int index, Class&lt;?&gt; type) {
<b class="fc">&nbsp;                            if (this.index != index) {</b>
<b class="fc">&nbsp;                                return Resolution.Unresolved.INSTANCE;</b>
<b class="fc">&nbsp;                            } else if (type == char.class || type == Character.class) {</b>
<b class="fc">&nbsp;                                return value != null &amp;&amp; value.length() == 1</b>
<b class="fc">&nbsp;                                        ? new Resolution.Resolved(value.charAt(0))</b>
<b class="nc">&nbsp;                                        : Resolution.Unresolved.INSTANCE;</b>
<b class="fc">&nbsp;                            } else if (type == String.class) {</b>
<b class="fc">&nbsp;                                return new Resolution.Resolved(value);</b>
<b class="fc">&nbsp;                            } else if (type.isPrimitive()) {</b>
<b class="fc">&nbsp;                                type = WRAPPER_TYPES.get(type);</b>
&nbsp;                            }
&nbsp;                            try {
<b class="fc">&nbsp;                                Method valueOf = type.getMethod(&quot;valueOf&quot;, String.class);</b>
<b class="fc">&nbsp;                                return Modifier.isStatic(valueOf.getModifiers()) &amp;&amp; type.isAssignableFrom(valueOf.getReturnType())</b>
<b class="fc">&nbsp;                                        ? new Resolution.Resolved(valueOf.invoke(null, value))</b>
<b class="nc">&nbsp;                                        : Resolution.Unresolved.INSTANCE;</b>
<b class="nc">&nbsp;                            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(exception);</b>
<b class="nc">&nbsp;                            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                                throw new IllegalStateException(exception.getTargetException());</b>
<b class="fc">&nbsp;                            } catch (NoSuchMethodException ignored) {</b>
<b class="fc">&nbsp;                                return Resolution.Unresolved.INSTANCE;</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A plugin engine allows the application of one or more plugins on class files found at a {@link Source} which are
&nbsp;     * then transferred and consumed by a {@link Target}.
&nbsp;     */
&nbsp;    interface Engine {
&nbsp;
&nbsp;        /**
&nbsp;         * The class file extension.
&nbsp;         */
&nbsp;        String CLASS_FILE_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The module info class file.
&nbsp;         */
&nbsp;        String MODULE_INFO = &quot;module-info&quot; + CLASS_FILE_EXTENSION;
&nbsp;
&nbsp;        /**
&nbsp;         * The package info class file.
&nbsp;         */
&nbsp;        String PACKAGE_INFO = &quot;package-info&quot; + CLASS_FILE_EXTENSION;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the file that contains declares Byte Buddy plugins for discovery.
&nbsp;         */
&nbsp;        String PLUGIN_FILE = &quot;META-INF/net.bytebuddy/build.plugins&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a new Byte Buddy instance for usage for type creation.
&nbsp;         *
&nbsp;         * @param byteBuddy The Byte Buddy instance to use.
&nbsp;         * @return A new plugin engine that is equal to this engine but uses the supplied Byte Buddy instance.
&nbsp;         */
&nbsp;        Engine with(ByteBuddy byteBuddy);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a new type strategy which determines the transformation mode for any instrumented type.
&nbsp;         *
&nbsp;         * @param typeStrategy The type stategy to use.
&nbsp;         * @return A new plugin engine that is equal to this engine but uses the supplied type strategy.
&nbsp;         */
&nbsp;        Engine with(TypeStrategy typeStrategy);
&nbsp;
&nbsp;        /**
&nbsp;         * Defines a new pool strategy that determines how types are being described.
&nbsp;         *
&nbsp;         * @param poolStrategy The pool strategy to use.
&nbsp;         * @return A new plugin engine that is equal to this engine but uses the supplied pool strategy.
&nbsp;         */
&nbsp;        Engine with(PoolStrategy poolStrategy);
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the supplied class file locator to be queried for class files additionally to any previously registered
&nbsp;         * class file locators.
&nbsp;         *
&nbsp;         * @param classFileLocator The class file locator to append.
&nbsp;         * @return A new plugin engine that is equal to this engine but with the supplied class file locator being appended.
&nbsp;         */
&nbsp;        Engine with(ClassFileLocator classFileLocator);
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the supplied listener to this engine.
&nbsp;         *
&nbsp;         * @param listener The listener to append.
&nbsp;         * @return A new plugin engine that is equal to this engine but with the supplied listener being appended.
&nbsp;         */
&nbsp;        Engine with(Listener listener);
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the error handlers of this plugin engine without applying any error handlers.
&nbsp;         *
&nbsp;         * @return A new plugin engine that is equal to this engine but without any error handlers being registered.
&nbsp;         */
&nbsp;        Engine withoutErrorHandlers();
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the error handlers of this plugin engine with the supplied error handlers.
&nbsp;         *
&nbsp;         * @param errorHandler The error handlers to apply.
&nbsp;         * @return A new plugin engine that is equal to this engine but with only the supplied error handlers being applied.
&nbsp;         */
&nbsp;        Engine withErrorHandlers(ErrorHandler... errorHandler);
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the error handlers of this plugin engine with the supplied error handlers.
&nbsp;         *
&nbsp;         * @param errorHandlers The error handlers to apply.
&nbsp;         * @return A new plugin engine that is equal to this engine but with only the supplied error handlers being applied.
&nbsp;         */
&nbsp;        Engine withErrorHandlers(List&lt;? extends ErrorHandler&gt; errorHandlers);
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the dispatcher factory of this plugin engine with a parallel dispatcher factory that uses the given amount of threads.
&nbsp;         *
&nbsp;         * @param threads The amount of threads to use.
&nbsp;         * @return A new plugin engine that is equal to this engine but with a parallel dispatcher factory using the specified amount of threads.
&nbsp;         */
&nbsp;        Engine withParallelTransformation(int threads);
&nbsp;
&nbsp;        /**
&nbsp;         * Replaces the dispatcher factory of this plugin engine with the supplied dispatcher factory.
&nbsp;         *
&nbsp;         * @param dispatcherFactory The dispatcher factory to use.
&nbsp;         * @return A new plugin engine that is equal to this engine but with the supplied dispatcher factory being used.
&nbsp;         */
&nbsp;        Engine with(Dispatcher.Factory dispatcherFactory);
&nbsp;
&nbsp;        /**
&nbsp;         * Ignores all types that are matched by this matcher or any previously registered ignore matcher.
&nbsp;         *
&nbsp;         * @param matcher The ignore matcher to append.
&nbsp;         * @return A new plugin engine that is equal to this engine but which ignores any type that is matched by the supplied matcher.
&nbsp;         */
&nbsp;        Engine ignore(ElementMatcher&lt;? super TypeDescription&gt; matcher);
&nbsp;
&nbsp;        /**
&nbsp;         * Applies this plugin engine onto a given source and target.
&nbsp;         *
&nbsp;         * @param source  The source which is treated as a folder or a jar file, if a folder does not exist.
&nbsp;         * @param target  The target which is treated as a folder or a jar file, if a folder does not exist.
&nbsp;         * @param factory A list of plugin factories to a apply.
&nbsp;         * @return A summary of the applied transformation.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        Summary apply(File source, File target, Plugin.Factory... factory) throws IOException;
&nbsp;
&nbsp;        /**
&nbsp;         * Applies this plugin engine onto a given source and target.
&nbsp;         *
&nbsp;         * @param source    The source which is treated as a folder or a jar file, if a folder does not exist.
&nbsp;         * @param target    The target which is treated as a folder or a jar file, if a folder does not exist.
&nbsp;         * @param factories A list of plugin factories to a apply.
&nbsp;         * @return A summary of the applied transformation.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        Summary apply(File source, File target, List&lt;? extends Plugin.Factory&gt; factories) throws IOException;
&nbsp;
&nbsp;        /**
&nbsp;         * Applies this plugin engine onto a given source and target.
&nbsp;         *
&nbsp;         * @param source  The source to use.
&nbsp;         * @param target  The target to use.
&nbsp;         * @param factory A list of plugin factories to a apply.
&nbsp;         * @return A summary of the applied transformation.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        Summary apply(Source source, Target target, Plugin.Factory... factory) throws IOException;
&nbsp;
&nbsp;        /**
&nbsp;         * Applies this plugin engine onto a given source and target.
&nbsp;         *
&nbsp;         * @param source    The source to use.
&nbsp;         * @param target    The target to use.
&nbsp;         * @param factories A list of plugin factories to a apply.
&nbsp;         * @return A summary of the applied transformation.
&nbsp;         * @throws IOException If an I/O error occurs.
&nbsp;         */
&nbsp;        Summary apply(Source source, Target target, List&lt;? extends Plugin.Factory&gt; factories) throws IOException;
&nbsp;
&nbsp;        /**
&nbsp;         * A type strategy determines the transformation that is applied to a type description.
&nbsp;         */
&nbsp;        interface TypeStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a builder for a given type.
&nbsp;             *
&nbsp;             * @param byteBuddy        The Byte Buddy instance to use.
&nbsp;             * @param typeDescription  The type being transformed.
&nbsp;             * @param classFileLocator A class file locator for finding the type&#39;s class file.
&nbsp;             * @return A dynamic type builder for the provided type.
&nbsp;             */
&nbsp;            DynamicType.Builder&lt;?&gt; builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator);
&nbsp;
&nbsp;            /**
&nbsp;             * Default implementations for type strategies.
&nbsp;             */
<b class="fc">&nbsp;            enum Default implements TypeStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A type strategy that redefines a type&#39;s methods.
&nbsp;                 */
<b class="fc">&nbsp;                REDEFINE {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public DynamicType.Builder&lt;?&gt; builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                        return byteBuddy.redefine(typeDescription, classFileLocator);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A type strategy that rebases a type&#39;s methods.
&nbsp;                 */
<b class="fc">&nbsp;                REBASE {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public DynamicType.Builder&lt;?&gt; builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                        return byteBuddy.rebase(typeDescription, classFileLocator);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A type strategy that decorates a type.
&nbsp;                 */
<b class="fc">&nbsp;                DECORATE {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public DynamicType.Builder&lt;?&gt; builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                        return byteBuddy.decorate(typeDescription, classFileLocator);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A type strategy that represents a given {@link EntryPoint} for a build tool.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForEntryPoint implements TypeStrategy {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented entry point.
&nbsp;                 */
&nbsp;                private final EntryPoint entryPoint;
&nbsp;
&nbsp;                /**
&nbsp;                 * A method name transformer to use for rebasements.
&nbsp;                 */
&nbsp;                private final MethodNameTransformer methodNameTransformer;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new type stratrgy for an entry point.
&nbsp;                 *
&nbsp;                 * @param entryPoint            The represented entry point.
&nbsp;                 * @param methodNameTransformer A method name transformer to use for rebasements.
&nbsp;                 */
<b class="fc">&nbsp;                public ForEntryPoint(EntryPoint entryPoint, MethodNameTransformer methodNameTransformer) {</b>
<b class="fc">&nbsp;                    this.entryPoint = entryPoint;</b>
<b class="fc">&nbsp;                    this.methodNameTransformer = methodNameTransformer;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public DynamicType.Builder&lt;?&gt; builder(ByteBuddy byteBuddy, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                    return entryPoint.transform(typeDescription, byteBuddy, classFileLocator, methodNameTransformer);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A pool strategy determines the creation of a {@link TypePool} for a plugin engine application.
&nbsp;         */
&nbsp;        interface PoolStrategy {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a type pool.
&nbsp;             *
&nbsp;             * @param classFileLocator The class file locator to use.
&nbsp;             * @return An approptiate type pool.
&nbsp;             */
&nbsp;            TypePool typePool(ClassFileLocator classFileLocator);
&nbsp;
&nbsp;            /**
&nbsp;             * A default implementation of a pool strategy where type descriptions are resolved lazily.
&nbsp;             */
<b class="fc">&nbsp;            enum Default implements PoolStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Enables faster class file parsing that does not process debug information of a class file.
&nbsp;                 */
<b class="fc">&nbsp;                FAST(TypePool.Default.ReaderMode.FAST),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Enables extended class file parsing that extracts parameter names from debug information, if available.
&nbsp;                 */
<b class="fc">&nbsp;                EXTENDED(TypePool.Default.ReaderMode.EXTENDED);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * This strategy&#39;s reader mode.
&nbsp;                 */
&nbsp;                private final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a default pool strategy.
&nbsp;                 *
&nbsp;                 * @param readerMode This strategy&#39;s reader mode.
&nbsp;                 */
<b class="fc">&nbsp;                Default(TypePool.Default.ReaderMode readerMode) {</b>
<b class="fc">&nbsp;                    this.readerMode = readerMode;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypePool typePool(ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                    return new TypePool.Default.WithLazyResolution(new TypePool.CacheProvider.Simple(),</b>
&nbsp;                            classFileLocator,
&nbsp;                            readerMode,
<b class="fc">&nbsp;                            TypePool.ClassLoading.ofPlatformLoader());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A pool strategy that resolves type descriptions eagerly. This can avoid additional overhead if the
&nbsp;             * majority of types is assumed to be resolved eventually.
&nbsp;             */
<b class="fc">&nbsp;            enum Eager implements PoolStrategy {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Enables faster class file parsing that does not process debug information of a class file.
&nbsp;                 */
<b class="fc">&nbsp;                FAST(TypePool.Default.ReaderMode.FAST),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Enables extended class file parsing that extracts parameter names from debug information, if available.
&nbsp;                 */
<b class="fc">&nbsp;                EXTENDED(TypePool.Default.ReaderMode.EXTENDED);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * This strategy&#39;s reader mode.
&nbsp;                 */
&nbsp;                private final TypePool.Default.ReaderMode readerMode;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an eager pool strategy.
&nbsp;                 *
&nbsp;                 * @param readerMode This strategy&#39;s reader mode.
&nbsp;                 */
<b class="fc">&nbsp;                Eager(TypePool.Default.ReaderMode readerMode) {</b>
<b class="fc">&nbsp;                    this.readerMode = readerMode;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypePool typePool(ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                    return new TypePool.Default(new TypePool.CacheProvider.Simple(),</b>
&nbsp;                            classFileLocator,
&nbsp;                            readerMode,
<b class="fc">&nbsp;                            TypePool.ClassLoading.ofPlatformLoader());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An error handler that is used during a plugin engine application.
&nbsp;         */
&nbsp;        interface ErrorHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked if an error occured during a plugin&#39;s application on a given type.
&nbsp;             *
&nbsp;             * @param typeDescription The type being matched or transformed.
&nbsp;             * @param plugin          The plugin being applied.
&nbsp;             * @param throwable       The throwable that caused the error.
&nbsp;             */
&nbsp;            void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked after the application of all plugins was attempted if at least one error occured during handling a given type.
&nbsp;             *
&nbsp;             * @param typeDescription The type being transformed.
&nbsp;             * @param throwables      The throwables that caused errors during the application.
&nbsp;             */
&nbsp;            void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked at the end of the build if at least one type transformation failed.
&nbsp;             *
&nbsp;             * @param throwables A mapping of types that failed during transformation to the errors that were caught.
&nbsp;             */
&nbsp;            void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked at the end of the build if a plugin could not be closed.
&nbsp;             *
&nbsp;             * @param plugin    The plugin that could not be closed.
&nbsp;             * @param throwable The error that was caused when the plugin was attempted to be closed.
&nbsp;             */
&nbsp;            void onError(Plugin plugin, Throwable throwable);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked if a type transformation implied a live initializer.
&nbsp;             *
&nbsp;             * @param typeDescription The type that was transformed.
&nbsp;             * @param definingType    The type that implies the initializer which might be the type itself or an auxiliary type.
&nbsp;             */
&nbsp;            void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked if a type could not be resolved.
&nbsp;             *
&nbsp;             * @param typeName The name of the unresolved type.
&nbsp;             */
&nbsp;            void onUnresolved(String typeName);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked when a manifest was found or found missing.
&nbsp;             *
&nbsp;             * @param manifest The located manifest or {@code null} if no manifest was found.
&nbsp;             */
&nbsp;            void onManifest(@MaybeNull Manifest manifest);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked if a resource that is not a class file is discovered.
&nbsp;             *
&nbsp;             * @param name The name of the discovered resource.
&nbsp;             */
&nbsp;            void onResource(String name);
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of an error handler that fails the plugin engine application.
&nbsp;             */
<b class="fc">&nbsp;            enum Failing implements ErrorHandler {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * An error handler that fails the build immediatly on the first error.
&nbsp;                 */
<b class="fc">&nbsp;                FAIL_FAST {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to transform &quot; + typeDescription + &quot; using &quot; + plugin, throwable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to transform &quot; + typeDescription + &quot;: &quot; + throwables);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to transform at least one type: &quot; + throwables);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * An error handler that fails the build after applying all plugins if at least one plugin failed.
&nbsp;                 */
<b class="fc">&nbsp;                FAIL_AFTER_TYPE {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to transform &quot; + typeDescription + &quot;: &quot; + throwables);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to transform at least one type: &quot; + throwables);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * An error handler that fails the build after transforming all types if at least one plugin failed.
&nbsp;                 */
<b class="fc">&nbsp;                FAIL_LAST {</b>
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
&nbsp;                        /* do nothing */
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to transform at least one type: &quot; + throwables);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Failed to close plugin &quot; + plugin, throwable);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(Manifest manifest) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An error handler that enforces certain properties of the transformation.
&nbsp;             */
<b class="fc">&nbsp;            enum Enforcing implements ErrorHandler {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Enforces that all types could be resolved.
&nbsp;                 */
<b class="fc">&nbsp;                ALL_TYPES_RESOLVED {</b>
&nbsp;                    @Override
&nbsp;                    public void onUnresolved(String typeName) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to resolve type description for &quot; + typeName);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Enforces that no type has a live initializer.
&nbsp;                 */
<b class="fc">&nbsp;                NO_LIVE_INITIALIZERS {</b>
&nbsp;                    @Override
&nbsp;                    public void onLiveInitializer(TypeDescription typeDescription, TypeDescription initializedType) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Failed to instrument &quot; + typeDescription + &quot; due to live initializer for &quot; + initializedType);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Enforces that a source only produces class files.
&nbsp;                 */
<b class="fc">&nbsp;                CLASS_FILES_ONLY {</b>
&nbsp;                    @Override
&nbsp;                    public void onResource(String name) {
<b class="fc">&nbsp;                        throw new IllegalStateException(&quot;Discovered a resource when only class files were allowed: &quot; + name);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * Enforces that a manifest is written to a target.
&nbsp;                 */
<b class="fc">&nbsp;                MANIFEST_REQUIRED {</b>
&nbsp;                    @Override
&nbsp;                    public void onManifest(@MaybeNull Manifest manifest) {
<b class="fc">&nbsp;                        if (manifest == null) {</b>
<b class="fc">&nbsp;                            throw new IllegalStateException(&quot;Required a manifest but no manifest was found&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compound error handler.
&nbsp;             */
&nbsp;            class Compound implements ErrorHandler {
&nbsp;
&nbsp;                /**
&nbsp;                 * The error handlers that are represented by this instance.
&nbsp;                 */
&nbsp;                private final List&lt;ErrorHandler&gt; errorHandlers;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound error handler.
&nbsp;                 *
&nbsp;                 * @param errorHandler The error handlers that are represented by this instance.
&nbsp;                 */
&nbsp;                public Compound(ErrorHandler... errorHandler) {
<b class="fc">&nbsp;                    this(Arrays.asList(errorHandler));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound error handler.
&nbsp;                 *
&nbsp;                 * @param errorHandlers The error handlers that are represented by this instance.
&nbsp;                 */
<b class="fc">&nbsp;                public Compound(List&lt;? extends ErrorHandler&gt; errorHandlers) {</b>
<b class="fc">&nbsp;                    this.errorHandlers = new ArrayList&lt;ErrorHandler&gt;();</b>
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        if (errorHandler instanceof Compound) {</b>
<b class="nc">&nbsp;                            this.errorHandlers.addAll(((Compound) errorHandler).errorHandlers);</b>
<b class="fc">&nbsp;                        } else if (!(errorHandler instanceof Listener.NoOp)) {</b>
<b class="fc">&nbsp;                            this.errorHandlers.add(errorHandler);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onError(typeDescription, plugin, throwable);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onError(typeDescription, throwables);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onError(throwables);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onError(plugin, throwable);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onLiveInitializer(typeDescription, definingType);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onUnresolved(typeName);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onManifest(manifest);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
<b class="fc">&nbsp;                    for (ErrorHandler errorHandler : errorHandlers) {</b>
<b class="fc">&nbsp;                        errorHandler.onResource(name);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A listener that is invoked upon any event during a plugin engine application.
&nbsp;         */
&nbsp;        interface Listener extends ErrorHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon discovering a type but prior to its resolution.
&nbsp;             *
&nbsp;             * @param typeName The name of the discovered type.
&nbsp;             */
&nbsp;            void onDiscovery(String typeName);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked after a type was transformed using a specific plugin.
&nbsp;             *
&nbsp;             * @param typeDescription The type being transformed.
&nbsp;             * @param plugin          The plugin that was applied.
&nbsp;             */
&nbsp;            void onTransformation(TypeDescription typeDescription, Plugin plugin);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked after a type was transformed using at least one plugin.
&nbsp;             *
&nbsp;             * @param typeDescription The type being transformed.
&nbsp;             * @param plugins         A list of plugins that were applied.
&nbsp;             */
&nbsp;            void onTransformation(TypeDescription typeDescription, List&lt;Plugin&gt; plugins);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked if a type description is ignored by a given plugin. This callback is not invoked,
&nbsp;             * if the ignore type matcher excluded a type from transformation.
&nbsp;             *
&nbsp;             * @param typeDescription The type being transformed.
&nbsp;             * @param plugin          The plugin that ignored the given type.
&nbsp;             */
&nbsp;            void onIgnored(TypeDescription typeDescription, Plugin plugin);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked if one or more plugins did not transform a type. This callback is also invoked if an
&nbsp;             * ignore matcher excluded a type from transformation.
&nbsp;             *
&nbsp;             * @param typeDescription The type being transformed.
&nbsp;             * @param plugins         the plugins that ignored the type.
&nbsp;             */
&nbsp;            void onIgnored(TypeDescription typeDescription, List&lt;Plugin&gt; plugins);
&nbsp;
&nbsp;            /**
&nbsp;             * Invoked upon completing handling a type that was either transformed or ignored.
&nbsp;             *
&nbsp;             * @param typeDescription The type that was transformed.
&nbsp;             */
&nbsp;            void onComplete(TypeDescription typeDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational listener.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements Listener {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onDiscovery(String typeName) {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(TypeDescription typeDescription) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An adapter that implements all methods non-operational.
&nbsp;             */
<b class="fc">&nbsp;            abstract class Adapter implements Listener {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onDiscovery(String typeName) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(TypeDescription typeDescription) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener that forwards significant events of a plugin engine application to a {@link PrintStream}.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class StreamWriting extends Adapter {
&nbsp;
&nbsp;                /**
&nbsp;                 * The prefix that is appended to all written messages.
&nbsp;                 */
&nbsp;                protected static final String PREFIX = &quot;[Byte Buddy]&quot;;
&nbsp;
&nbsp;                /**
&nbsp;                 * The print stream to delegate to.
&nbsp;                 */
&nbsp;                private final PrintStream printStream;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new stream writing listener.
&nbsp;                 *
&nbsp;                 * @param printStream The print stream to delegate to.
&nbsp;                 */
<b class="fc">&nbsp;                public StreamWriting(PrintStream printStream) {</b>
<b class="fc">&nbsp;                    this.printStream = printStream;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a stream writing listener that prints all events on {@link System#out}.
&nbsp;                 *
&nbsp;                 * @return A listener that writes events to the system output stream.
&nbsp;                 */
&nbsp;                public static StreamWriting toSystemOut() {
<b class="fc">&nbsp;                    return new StreamWriting(System.out);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a stream writing listener that prints all events on {@link System#err}.
&nbsp;                 *
&nbsp;                 * @return A listener that writes events to the system error stream.
&nbsp;                 */
&nbsp;                public static StreamWriting toSystemError() {
<b class="fc">&nbsp;                    return new StreamWriting(System.err);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a new listener that only prints transformation and error events.
&nbsp;                 *
&nbsp;                 * @return A new listener that only prints transformation and error events.
&nbsp;                 */
&nbsp;                public Listener withTransformationsOnly() {
<b class="fc">&nbsp;                    return new WithTransformationsOnly(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a new listener that only prints error events.
&nbsp;                 *
&nbsp;                 * @return A new listener that only prints error events.
&nbsp;                 */
&nbsp;                public Listener withErrorsOnly() {
<b class="fc">&nbsp;                    return new WithErrorsOnly(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onDiscovery(String typeName) {
<b class="nc">&nbsp;                    printStream.printf(PREFIX + &quot; DISCOVERY %s&quot;, typeName);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; TRANSFORM %s for %s&quot;, typeDescription, plugin);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; IGNORE %s for %s&quot;, typeDescription, plugin);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    synchronized (printStream) {</b>
<b class="fc">&nbsp;                        printStream.printf(PREFIX + &quot; ERROR %s for %s&quot;, typeDescription, plugin);</b>
<b class="fc">&nbsp;                        throwable.printStackTrace(printStream);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    synchronized (printStream) {</b>
<b class="fc">&nbsp;                        printStream.printf(PREFIX + &quot; ERROR %s&quot;, plugin);</b>
<b class="fc">&nbsp;                        throwable.printStackTrace(printStream);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; UNRESOLVED %s&quot;, typeName);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; LIVE %s on %s&quot;, typeDescription, definingType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; COMPLETE %s&quot;, typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; MANIFEST %b&quot;, manifest != null);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
<b class="fc">&nbsp;                    printStream.printf(PREFIX + &quot; RESOURCE %s&quot;, name);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A decorator for another listener to only print transformation and error events.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class WithTransformationsOnly extends Adapter {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegate to forward events to.
&nbsp;                 */
&nbsp;                private final Listener delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new listener decorator that filter any event that is not related to transformation or errors.
&nbsp;                 *
&nbsp;                 * @param delegate The delegate to forward events to.
&nbsp;                 */
<b class="fc">&nbsp;                public WithTransformationsOnly(Listener delegate) {</b>
<b class="fc">&nbsp;                    this.delegate = delegate;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
<b class="fc">&nbsp;                    delegate.onTransformation(typeDescription, plugin);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onTransformation(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
<b class="fc">&nbsp;                    delegate.onTransformation(typeDescription, plugins);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    delegate.onError(typeDescription, plugin, throwable);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                    delegate.onError(typeDescription, throwables);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                    delegate.onError(throwables);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    delegate.onError(plugin, throwable);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A decorator for another listener to only print error events.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class WithErrorsOnly extends Adapter {
&nbsp;
&nbsp;                /**
&nbsp;                 * The delegate to forward events to.
&nbsp;                 */
&nbsp;                private final Listener delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new listener decorator that filter any event that is not related to errors.
&nbsp;                 *
&nbsp;                 * @param delegate The delegate to forward events to.
&nbsp;                 */
<b class="fc">&nbsp;                public WithErrorsOnly(Listener delegate) {</b>
<b class="fc">&nbsp;                    this.delegate = delegate;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    delegate.onError(typeDescription, plugin, throwable);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                    delegate.onError(typeDescription, throwables);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                    delegate.onError(throwables);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    delegate.onError(plugin, throwable);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A listener decorator that forwards events to an error handler if they are applicable.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForErrorHandler extends Adapter {
&nbsp;
&nbsp;                /**
&nbsp;                 * The error handler to delegate to.
&nbsp;                 */
&nbsp;                private final ErrorHandler errorHandler;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new listener representation for an error handler.
&nbsp;                 *
&nbsp;                 * @param errorHandler The error handler to delegate to.
&nbsp;                 */
<b class="fc">&nbsp;                public ForErrorHandler(ErrorHandler errorHandler) {</b>
<b class="fc">&nbsp;                    this.errorHandler = errorHandler;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    errorHandler.onError(typeDescription, plugin, throwable);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                    errorHandler.onError(typeDescription, throwables);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                    errorHandler.onError(throwables);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    errorHandler.onError(plugin, throwable);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
<b class="fc">&nbsp;                    errorHandler.onLiveInitializer(typeDescription, definingType);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onUnresolved(String typeName) {
<b class="fc">&nbsp;                    errorHandler.onUnresolved(typeName);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
<b class="fc">&nbsp;                    errorHandler.onManifest(manifest);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public void onResource(String name) {
<b class="fc">&nbsp;                    errorHandler.onResource(name);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compound listener.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Compound implements Listener {
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of listeners that are represented by this compound instance.
&nbsp;                 */
&nbsp;                private final List&lt;Listener&gt; listeners;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound listener.
&nbsp;                 *
&nbsp;                 * @param listener A list of listeners that are represented by this compound instance.
&nbsp;                 */
&nbsp;                public Compound(Listener... listener) {
<b class="fc">&nbsp;                    this(Arrays.asList(listener));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound listener.
&nbsp;                 *
&nbsp;                 * @param listeners A list of listeners that are represented by this compound instance.
&nbsp;                 */
<b class="fc">&nbsp;                public Compound(List&lt;? extends Listener&gt; listeners) {</b>
<b class="fc">&nbsp;                    this.listeners = new ArrayList&lt;Listener&gt;();</b>
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        if (listener instanceof Listener.Compound) {</b>
<b class="fc">&nbsp;                            this.listeners.addAll(((Listener.Compound) listener).listeners);</b>
<b class="fc">&nbsp;                        } else if (!(listener instanceof NoOp)) {</b>
<b class="fc">&nbsp;                            this.listeners.add(listener);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onDiscovery(String typeName) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onDiscovery(typeName);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, Plugin plugin) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onTransformation(typeDescription, plugin);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onTransformation(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onTransformation(typeDescription, plugins);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, Plugin plugin) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onIgnored(typeDescription, plugin);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onIgnored(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onIgnored(typeDescription, plugins);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onError(typeDescription, plugin, throwable);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(TypeDescription typeDescription, List&lt;Throwable&gt; throwables) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onError(typeDescription, throwables);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onError(throwables);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onError(Plugin plugin, Throwable throwable) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onError(plugin, throwable);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onLiveInitializer(typeDescription, definingType);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onComplete(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onComplete(typeDescription);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onUnresolved(String typeName) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onUnresolved(typeName);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onManifest(@MaybeNull Manifest manifest) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onManifest(manifest);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void onResource(String name) {
<b class="fc">&nbsp;                    for (Listener listener : listeners) {</b>
<b class="fc">&nbsp;                        listener.onResource(name);</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A source for a plugin engine provides binary elements to consider for transformation.
&nbsp;         */
&nbsp;        interface Source {
&nbsp;
&nbsp;            /**
&nbsp;             * Initiates reading from a source.
&nbsp;             *
&nbsp;             * @return The origin to read from.
&nbsp;             * @throws IOException If an I/O error occurs.
&nbsp;             */
&nbsp;            Origin read() throws IOException;
&nbsp;
&nbsp;            /**
&nbsp;             * An origin for elements.
&nbsp;             */
&nbsp;            interface Origin extends Iterable&lt;Element&gt;, Closeable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Indicates that no manifest exists.
&nbsp;                 */
&nbsp;                @AlwaysNull
<b class="fc">&nbsp;                Manifest NO_MANIFEST = null;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the manifest file of the source location or {@code null} if no manifest exists.
&nbsp;                 *
&nbsp;                 * @return This source&#39;s manifest or {@code null}.
&nbsp;                 * @throws IOException If an I/O error occurs.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                Manifest getManifest() throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a class file locator for the represented source. If the class file locator needs to be closed, it is the responsibility
&nbsp;                 * of this origin to close the locator or its underlying resources.
&nbsp;                 *
&nbsp;                 * @return A class file locator for locating class files of this instance..
&nbsp;                 */
&nbsp;                ClassFileLocator getClassFileLocator();
&nbsp;
&nbsp;                /**
&nbsp;                 * An origin implementation for a jar file.
&nbsp;                 */
<b class="fc">&nbsp;                class ForJarFile implements Origin {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented file.
&nbsp;                     */
&nbsp;                    private final JarFile file;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new origin for a jar file.
&nbsp;                     *
&nbsp;                     * @param file The represented file.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForJarFile(JarFile file) {</b>
<b class="fc">&nbsp;                        this.file = file;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public Manifest getManifest() throws IOException {
<b class="fc">&nbsp;                        return file.getManifest();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassFileLocator getClassFileLocator() {
<b class="fc">&nbsp;                        return new ClassFileLocator.ForJarFile(file);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() throws IOException {
<b class="fc">&nbsp;                        file.close();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterator&lt;Element&gt; iterator() {
<b class="fc">&nbsp;                        return new JarFileIterator(file.entries());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An iterator for jar file entries.
&nbsp;                     */
&nbsp;                    protected class JarFileIterator implements Iterator&lt;Element&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The represented enumeration.
&nbsp;                         */
&nbsp;                        private final Enumeration&lt;JarEntry&gt; enumeration;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new jar file iterator.
&nbsp;                         *
&nbsp;                         * @param enumeration The represented enumeration.
&nbsp;                         */
<b class="fc">&nbsp;                        protected JarFileIterator(Enumeration&lt;JarEntry&gt; enumeration) {</b>
<b class="fc">&nbsp;                            this.enumeration = enumeration;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean hasNext() {
<b class="fc">&nbsp;                            return enumeration.hasMoreElements();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Element next() {
<b class="fc">&nbsp;                            return new Element.ForJarEntry(file, enumeration.nextElement());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void remove() {
<b class="nc">&nbsp;                            throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An origin that forwards all invocations to a delegate where an {@link ElementMatcher} is applied prior to iteration.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class Filtering implements Origin {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The origin to which invocations are delegated.
&nbsp;                     */
&nbsp;                    private final Origin delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The element matcher being used to filter elements.
&nbsp;                     */
&nbsp;                    private final ElementMatcher&lt;Element&gt; matcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@code true} if the manifest should be retained.
&nbsp;                     */
&nbsp;                    private final boolean manifest;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new filtering origin that retains the delegated origin&#39;s manifest.
&nbsp;                     *
&nbsp;                     * @param delegate The origin to which invocations are delegated.
&nbsp;                     * @param matcher  The element matcher being used to filter elements.
&nbsp;                     */
&nbsp;                    public Filtering(Origin delegate, ElementMatcher&lt;Element&gt; matcher) {
<b class="nc">&nbsp;                        this(delegate, matcher, true);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new filtering origin.
&nbsp;                     *
&nbsp;                     * @param delegate The origin to which invocations are delegated.
&nbsp;                     * @param matcher  The element matcher being used to filter elements.
&nbsp;                     * @param manifest {@code true} if the manifest should be retained.
&nbsp;                     */
<b class="fc">&nbsp;                    public Filtering(Origin delegate, ElementMatcher&lt;Element&gt; matcher, boolean manifest) {</b>
<b class="fc">&nbsp;                        this.delegate = delegate;</b>
<b class="fc">&nbsp;                        this.matcher = matcher;</b>
<b class="fc">&nbsp;                        this.manifest = manifest;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    public Manifest getManifest() throws IOException {
<b class="fc">&nbsp;                        return manifest ? delegate.getManifest() : NO_MANIFEST;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassFileLocator getClassFileLocator() {
<b class="fc">&nbsp;                        return delegate.getClassFileLocator();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() throws IOException {
<b class="fc">&nbsp;                        delegate.close();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterator&lt;Element&gt; iterator() {
<b class="fc">&nbsp;                        return new FilteringIterator(delegate.iterator(), matcher);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * An iterator that applies a filter to observed elements.
&nbsp;                     */
<b class="fc">&nbsp;                    private static class FilteringIterator implements Iterator&lt;Element&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * The underlying iterator.
&nbsp;                         */
&nbsp;                        private final Iterator&lt;Element&gt; iterator;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The element matcher being used to filter elements.
&nbsp;                         */
&nbsp;                        private final ElementMatcher&lt;Element&gt; matcher;
&nbsp;
&nbsp;                        /**
&nbsp;                         * The current element or {@code null} if no further elements are available.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        private Element current;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new filtering iterator.
&nbsp;                         *
&nbsp;                         * @param iterator The underlying iterator.
&nbsp;                         * @param matcher  The element matcher being used to filter elements.
&nbsp;                         */
<b class="fc">&nbsp;                        private FilteringIterator(Iterator&lt;Element&gt; iterator, ElementMatcher&lt;Element&gt; matcher) {</b>
<b class="fc">&nbsp;                            this.iterator = iterator;</b>
<b class="fc">&nbsp;                            this.matcher = matcher;</b>
&nbsp;                            Element element;
<b class="fc">&nbsp;                            while (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                                element = iterator.next();</b>
<b class="fc">&nbsp;                                if (matcher.matches(element)) {</b>
<b class="fc">&nbsp;                                    current = element;</b>
<b class="fc">&nbsp;                                    break;</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean hasNext() {
<b class="fc">&nbsp;                            return current != null;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Element next() {
<b class="fc">&nbsp;                            if (current == null) {</b>
<b class="nc">&nbsp;                                throw new NoSuchElementException();</b>
&nbsp;                            }
&nbsp;                            try {
<b class="fc">&nbsp;                                return current;</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                current = null;</b>
&nbsp;                                Element element;
<b class="fc">&nbsp;                                while (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                                    element = iterator.next();</b>
<b class="fc">&nbsp;                                    if (matcher.matches(element)) {</b>
<b class="fc">&nbsp;                                        current = element;</b>
<b class="fc">&nbsp;                                        break;</b>
&nbsp;                                    }
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void remove() {
<b class="nc">&nbsp;                            iterator.remove();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a binary element found in a source location.
&nbsp;             */
&nbsp;            interface Element {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the element&#39;s relative path and name.
&nbsp;                 *
&nbsp;                 * @return The element&#39;s path and name.
&nbsp;                 */
&nbsp;                String getName();
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns an input stream to read this element&#39;s binary information.
&nbsp;                 *
&nbsp;                 * @return An input stream that represents this element&#39;s binary information.
&nbsp;                 * @throws IOException If an I/O error occurs.
&nbsp;                 */
&nbsp;                InputStream getInputStream() throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Resolves this element to a more specialized form if possible. Doing so allows for performance
&nbsp;                 * optimizations if more specialized formats are available.
&nbsp;                 *
&nbsp;                 * @param type The requested spezialized type.
&nbsp;                 * @param &lt;T&gt;  The requested spezialized type.
&nbsp;                 * @return The resolved element or {@code null} if a transformation is impossible.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                &lt;T&gt; T resolveAs(Class&lt;T&gt; type);
&nbsp;
&nbsp;                /**
&nbsp;                 * An element representation for a byte array.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not modified by class contract.&quot;)
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForByteArray implements Element {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The element&#39;s name.
&nbsp;                     */
&nbsp;                    private final String name;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The element&#39;s binary representation.
&nbsp;                     */
&nbsp;                    private final byte[] binaryRepresentation;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an element that is represented by a byte array.
&nbsp;                     *
&nbsp;                     * @param name                 The element&#39;s name.
&nbsp;                     * @param binaryRepresentation The element&#39;s binary representation.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForByteArray(String name, byte[] binaryRepresentation) {</b>
<b class="fc">&nbsp;                        this.name = name;</b>
<b class="fc">&nbsp;                        this.binaryRepresentation = binaryRepresentation;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getName() {
<b class="fc">&nbsp;                        return name;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public InputStream getInputStream() {
<b class="fc">&nbsp;                        return new ByteArrayInputStream(binaryRepresentation);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @AlwaysNull
&nbsp;                    public &lt;T&gt; T resolveAs(Class&lt;T&gt; type) {
<b class="fc">&nbsp;                        return null;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An element representation for a file.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForFile implements Element {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The root folder of the represented source.
&nbsp;                     */
&nbsp;                    private final File root;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The file location of the represented file that is located within the root directory.
&nbsp;                     */
&nbsp;                    private final File file;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an element representation for a file.
&nbsp;                     *
&nbsp;                     * @param root The root folder of the represented source.
&nbsp;                     * @param file The file location of the represented file that is located within the root directory.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForFile(File root, File file) {</b>
<b class="fc">&nbsp;                        this.root = root;</b>
<b class="fc">&nbsp;                        this.file = file;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getName() {
<b class="fc">&nbsp;                        return root.getAbsoluteFile().toURI().relativize(file.getAbsoluteFile().toURI()).getPath();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public InputStream getInputStream() throws IOException {
<b class="fc">&nbsp;                        return new FileInputStream(file);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                    public &lt;T&gt; T resolveAs(Class&lt;T&gt; type) {
<b class="fc">&nbsp;                        return File.class.isAssignableFrom(type)</b>
<b class="fc">&nbsp;                                ? (T) file</b>
<b class="fc">&nbsp;                                : null;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a jar file entry as an element.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                class ForJarEntry implements Element {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The source&#39;s underlying jar file.
&nbsp;                     */
&nbsp;                    private final JarFile file;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The entry that is represented by this element.
&nbsp;                     */
&nbsp;                    private final JarEntry entry;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new element representation for a jar file entry.
&nbsp;                     *
&nbsp;                     * @param file  The source&#39;s underlying jar file.
&nbsp;                     * @param entry The entry that is represented by this element.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForJarEntry(JarFile file, JarEntry entry) {</b>
<b class="fc">&nbsp;                        this.file = file;</b>
<b class="fc">&nbsp;                        this.entry = entry;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getName() {
<b class="fc">&nbsp;                        return entry.getName();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public InputStream getInputStream() throws IOException {
<b class="fc">&nbsp;                        return file.getInputStream(entry);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                    public &lt;T&gt; T resolveAs(Class&lt;T&gt; type) {
<b class="fc">&nbsp;                        return JarEntry.class.isAssignableFrom(type)</b>
<b class="fc">&nbsp;                                ? (T) entry</b>
<b class="fc">&nbsp;                                : null;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An empty source that does not contain any elements or a manifest.
&nbsp;             */
<b class="fc">&nbsp;            enum Empty implements Source, Origin {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Origin read() {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ClassFileLocator getClassFileLocator() {
<b class="fc">&nbsp;                    return ClassFileLocator.NoOp.INSTANCE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Manifest getManifest() {
<b class="fc">&nbsp;                    return NO_MANIFEST;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterator&lt;Element&gt; iterator() {
<b class="fc">&nbsp;                    return Collections.&lt;Element&gt;emptySet().iterator();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A compound source that combines multiple sources into a single representation.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Compound implements Source {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented sources.
&nbsp;                 */
&nbsp;                private final Collection&lt;? extends Source&gt; sources;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new compound source.
&nbsp;                 *
&nbsp;                 * @param sources The represented sources.
&nbsp;                 */
<b class="fc">&nbsp;                public Compound(Collection&lt;? extends Source&gt; sources) {</b>
<b class="fc">&nbsp;                    this.sources = sources;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Source.Origin read() throws IOException {
<b class="fc">&nbsp;                    if (sources.isEmpty()) {</b>
<b class="fc">&nbsp;                        return Empty.INSTANCE;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    List&lt;Source.Origin&gt; origins = new ArrayList&lt;Source.Origin&gt;(sources.size());</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        for (Source source : sources) {</b>
<b class="fc">&nbsp;                            origins.add(source.read());</b>
<b class="fc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    } catch (IOException exception) {</b>
<b class="nc">&nbsp;                        for (Source.Origin origin : origins) {</b>
<b class="nc">&nbsp;                            origin.close();</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        throw exception;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new Origin(origins);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Implements a compound {@link Source.Origin}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class Origin implements Source.Origin {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of represented origins.
&nbsp;                     */
&nbsp;                    private final List&lt;Source.Origin&gt; origins;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new compound origin.
&nbsp;                     *
&nbsp;                     * @param origins A list of represented origins.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Origin(List&lt;Source.Origin&gt; origins) {</b>
<b class="fc">&nbsp;                        this.origins = origins;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Manifest getManifest() throws IOException {
<b class="fc">&nbsp;                        for (Source.Origin origin : origins) {</b>
<b class="fc">&nbsp;                            Manifest manifest = origin.getManifest();</b>
<b class="fc">&nbsp;                            if (manifest != null) {</b>
<b class="nc">&nbsp;                                return manifest;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return NO_MANIFEST;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public ClassFileLocator getClassFileLocator() {
<b class="fc">&nbsp;                        List&lt;ClassFileLocator&gt; classFileLocators = new ArrayList&lt;ClassFileLocator&gt;(origins.size());</b>
<b class="fc">&nbsp;                        for (Source.Origin origin : origins) {</b>
<b class="fc">&nbsp;                            classFileLocators.add(origin.getClassFileLocator());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new ClassFileLocator.Compound(classFileLocators);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Iterator&lt;Element&gt; iterator() {
<b class="fc">&nbsp;                        return new CompoundIterator(origins);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() throws IOException {
<b class="fc">&nbsp;                        for (Source.Origin origin : origins) {</b>
<b class="fc">&nbsp;                            origin.close();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A compound iterator that combines several iterables.
&nbsp;                     */
&nbsp;                    protected static class CompoundIterator implements Iterator&lt;Element&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The current iterator or {@code null} if no such iterator is defined.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        private Iterator&lt;? extends Element&gt; current;
&nbsp;
&nbsp;                        /**
&nbsp;                         * A backlog of iterables to still consider.
&nbsp;                         */
&nbsp;                        private final List&lt;? extends Iterable&lt;? extends Element&gt;&gt; backlog;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a compound iterator.
&nbsp;                         *
&nbsp;                         * @param iterables The iterables to consider.
&nbsp;                         */
<b class="fc">&nbsp;                        protected CompoundIterator(List&lt;? extends Iterable&lt;? extends Element&gt;&gt; iterables) {</b>
<b class="fc">&nbsp;                            backlog = iterables;</b>
<b class="fc">&nbsp;                            forward();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean hasNext() {
<b class="fc">&nbsp;                            return current != null &amp;&amp; current.hasNext();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Element next() {
&nbsp;                            try {
<b class="fc">&nbsp;                                if (current != null) {</b>
<b class="fc">&nbsp;                                    return current.next();</b>
&nbsp;                                } else {
<b class="nc">&nbsp;                                    throw new NoSuchElementException();</b>
&nbsp;                                }
&nbsp;                            } finally {
<b class="fc">&nbsp;                                forward();</b>
<b class="nc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * Forwards the iterator to the next relevant iterable.
&nbsp;                         */
&nbsp;                        private void forward() {
<b class="fc">&nbsp;                            while ((current == null || !current.hasNext()) &amp;&amp; !backlog.isEmpty()) {</b>
<b class="fc">&nbsp;                                current = backlog.remove(0).iterator();</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public void remove() {
<b class="nc">&nbsp;                            throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A source that represents a collection of in-memory resources that are represented as byte arrays.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class InMemory implements Source, Origin {
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of resource names to their binary representation.
&nbsp;                 */
&nbsp;                private final Map&lt;String, byte[]&gt; storage;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new in-memory source.
&nbsp;                 *
&nbsp;                 * @param storage A mapping of resource names to their binary representation.
&nbsp;                 */
<b class="fc">&nbsp;                public InMemory(Map&lt;String, byte[]&gt; storage) {</b>
<b class="fc">&nbsp;                    this.storage = storage;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a collection of types as a in-memory source.
&nbsp;                 *
&nbsp;                 * @param type The types to represent.
&nbsp;                 * @return A source representing the supplied types.
&nbsp;                 */
&nbsp;                public static Source ofTypes(Class&lt;?&gt;... type) {
<b class="fc">&nbsp;                    return ofTypes(Arrays.asList(type));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a collection of types as a in-memory source.
&nbsp;                 *
&nbsp;                 * @param types The types to represent.
&nbsp;                 * @return A source representing the supplied types.
&nbsp;                 */
&nbsp;                public static Source ofTypes(Collection&lt;? extends Class&lt;?&gt;&gt; types) {
<b class="fc">&nbsp;                    Map&lt;TypeDescription, byte[]&gt; binaryRepresentations = new HashMap&lt;TypeDescription, byte[]&gt;();</b>
<b class="fc">&nbsp;                    for (Class&lt;?&gt; type : types) {</b>
<b class="fc">&nbsp;                        binaryRepresentations.put(TypeDescription.ForLoadedType.of(type), ClassFileLocator.ForClassLoader.read(type));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return ofTypes(binaryRepresentations);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents a map of type names to their binary representation as an in-memory source.
&nbsp;                 *
&nbsp;                 * @param binaryRepresentations A mapping of type names to their binary representation.
&nbsp;                 * @return A source representing the supplied types.
&nbsp;                 */
&nbsp;                public static Source ofTypes(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) {
<b class="fc">&nbsp;                    Map&lt;String, byte[]&gt; storage = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;                    for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : binaryRepresentations.entrySet()) {</b>
<b class="fc">&nbsp;                        storage.put(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION, entry.getValue());</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new InMemory(storage);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Origin read() {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ClassFileLocator getClassFileLocator() {
<b class="fc">&nbsp;                    return ClassFileLocator.Simple.ofResources(storage);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Manifest getManifest() throws IOException {
<b class="fc">&nbsp;                    byte[] binaryRepresentation = storage.get(JarFile.MANIFEST_NAME);</b>
<b class="fc">&nbsp;                    if (binaryRepresentation == null) {</b>
<b class="fc">&nbsp;                        return NO_MANIFEST;</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new Manifest(new ByteArrayInputStream(binaryRepresentation));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterator&lt;Element&gt; iterator() {
<b class="fc">&nbsp;                    return new MapEntryIterator(storage.entrySet().iterator());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * An iterator that represents map entries as sources.
&nbsp;                 */
&nbsp;                protected static class MapEntryIterator implements Iterator&lt;Element&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented iterator.
&nbsp;                     */
&nbsp;                    private final Iterator&lt;Map.Entry&lt;String, byte[]&gt;&gt; iterator;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new map entry iterator.
&nbsp;                     *
&nbsp;                     * @param iterator The represented iterator.
&nbsp;                     */
<b class="fc">&nbsp;                    protected MapEntryIterator(Iterator&lt;Map.Entry&lt;String, byte[]&gt;&gt; iterator) {</b>
<b class="fc">&nbsp;                        this.iterator = iterator;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean hasNext() {
<b class="fc">&nbsp;                        return iterator.hasNext();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Element next() {
<b class="fc">&nbsp;                        Map.Entry&lt;String, byte[]&gt; entry = iterator.next();</b>
<b class="fc">&nbsp;                        return new Element.ForByteArray(entry.getKey(), entry.getValue());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void remove() {
<b class="fc">&nbsp;                        throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents the contents of a folder as class files.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;            class ForFolder implements Source, Origin {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The folder to represent.
&nbsp;                 */
&nbsp;                private final File folder;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new source representation for a given folder.
&nbsp;                 *
&nbsp;                 * @param folder The folder to represent.
&nbsp;                 */
<b class="fc">&nbsp;                public ForFolder(File folder) {</b>
<b class="fc">&nbsp;                    this.folder = folder;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Initializes a reading from this source.
&nbsp;                 *
&nbsp;                 * @return A source that represents the resource of this origin.
&nbsp;                 */
&nbsp;                public Origin read() {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public ClassFileLocator getClassFileLocator() {
<b class="fc">&nbsp;                    return new ClassFileLocator.ForFolder(folder);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Manifest getManifest() throws IOException {
<b class="fc">&nbsp;                    File file = new File(folder, JarFile.MANIFEST_NAME);</b>
<b class="fc">&nbsp;                    if (file.exists()) {</b>
<b class="fc">&nbsp;                        InputStream inputStream = new FileInputStream(file);</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            return new Manifest(inputStream);</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            inputStream.close();</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return NO_MANIFEST;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterator&lt;Element&gt; iterator() {
<b class="fc">&nbsp;                    return new FolderIterator(folder);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * An iterator that exposes all files within a folder structure as elements.
&nbsp;                 */
&nbsp;                protected class FolderIterator implements Iterator&lt;Element&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of files and folders to process with the next processed file at the end of the list.
&nbsp;                     */
&nbsp;                    private final List&lt;File&gt; files;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new iterator representation for all files within a folder.
&nbsp;                     *
&nbsp;                     * @param folder The root folder.
&nbsp;                     */
<b class="fc">&nbsp;                    protected FolderIterator(File folder) {</b>
<b class="fc">&nbsp;                        files = new ArrayList&lt;File&gt;(Collections.singleton(folder));</b>
&nbsp;                        File candidate;
&nbsp;                        do {
<b class="fc">&nbsp;                            candidate = files.remove(files.size() - 1);</b>
<b class="fc">&nbsp;                            File[] file = candidate.listFiles();</b>
<b class="fc">&nbsp;                            if (file != null) {</b>
<b class="fc">&nbsp;                                files.addAll(Arrays.asList(file));</b>
&nbsp;                            }
<b class="fc">&nbsp;                        } while (!files.isEmpty() &amp;&amp; (files.get(files.size() - 1).isDirectory() || files.get(files.size() - 1).equals(new File(folder, JarFile.MANIFEST_NAME))));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public boolean hasNext() {
<b class="fc">&nbsp;                        return !files.isEmpty();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;IT_NO_SUCH_ELEMENT&quot;, justification = &quot;Exception is thrown by invoking removeFirst on an empty list.&quot;)
&nbsp;                    public Element next() {
&nbsp;                        try {
<b class="fc">&nbsp;                            return new Element.ForFile(folder, files.remove(files.size() - 1));</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            while (!files.isEmpty() &amp;&amp; (files.get(files.size() - 1).isDirectory() || files.get(files.size() - 1).equals(new File(folder, JarFile.MANIFEST_NAME)))) {</b>
<b class="nc">&nbsp;                                File folder = files.remove(files.size() - 1);</b>
<b class="nc">&nbsp;                                File[] file = folder.listFiles();</b>
<b class="nc">&nbsp;                                if (file != null) {</b>
<b class="nc">&nbsp;                                    files.addAll(Arrays.asList(file));</b>
&nbsp;                                }
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void remove() {
<b class="nc">&nbsp;                        throw new UnsupportedOperationException(&quot;remove&quot;);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a jar file as a source.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForJarFile implements Source {
&nbsp;
&nbsp;                /**
&nbsp;                 * The jar file being represented by this source.
&nbsp;                 */
&nbsp;                private final File file;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new source for a jar file.
&nbsp;                 *
&nbsp;                 * @param file The jar file being represented by this source.
&nbsp;                 */
<b class="fc">&nbsp;                public ForJarFile(File file) {</b>
<b class="fc">&nbsp;                    this.file = file;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Origin read() throws IOException {
<b class="fc">&nbsp;                    return new Origin.ForJarFile(new JarFile(file));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A source that applies a filter upon iterating elements.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Filtering implements Source {
&nbsp;
&nbsp;                /**
&nbsp;                 * The source to which invocations are delegated.
&nbsp;                 */
&nbsp;                private final Source delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * The element matcher being used to filter elements.
&nbsp;                 */
&nbsp;                private final ElementMatcher&lt;Element&gt; matcher;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if the manifest should be retained.
&nbsp;                 */
&nbsp;                private final boolean manifest;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new filtering source that retains the manifest of the delegated source.
&nbsp;                 *
&nbsp;                 * @param delegate The source to which invocations are delegated.
&nbsp;                 * @param matcher  The element matcher being used to filter elements.
&nbsp;                 */
&nbsp;                public Filtering(Source delegate, ElementMatcher&lt;Element&gt; matcher) {
<b class="fc">&nbsp;                    this(delegate, matcher, true);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new filtering source.
&nbsp;                 *
&nbsp;                 * @param delegate The source to which invocations are delegated.
&nbsp;                 * @param matcher  The element matcher being used to filter elements.
&nbsp;                 * @param manifest {@code true} if the manifest should be retained.
&nbsp;                 */
<b class="fc">&nbsp;                public Filtering(Source delegate, ElementMatcher&lt;Element&gt; matcher, boolean manifest) {</b>
<b class="fc">&nbsp;                    this.delegate = delegate;</b>
<b class="fc">&nbsp;                    this.matcher = matcher;</b>
<b class="fc">&nbsp;                    this.manifest = manifest;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Origin read() throws IOException {
<b class="fc">&nbsp;                    return new Origin.Filtering(delegate.read(), matcher, manifest);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A target for a plugin engine represents a sink container for all elements that are supplied by a {@link Source}.
&nbsp;         */
&nbsp;        interface Target {
&nbsp;
&nbsp;            /**
&nbsp;             * Initializes this target prior to writing.
&nbsp;             *
&nbsp;             * @param manifest The manifest for the target or {@code null} if no manifest was found.
&nbsp;             * @return The sink to write to.
&nbsp;             * @throws IOException If an I/O error occurs.
&nbsp;             */
&nbsp;            Sink write(@MaybeNull Manifest manifest) throws IOException;
&nbsp;
&nbsp;            /**
&nbsp;             * A sink represents an active writing process.
&nbsp;             */
&nbsp;            interface Sink extends Closeable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Stores the supplied binary representation of types in this sink.
&nbsp;                 *
&nbsp;                 * @param binaryRepresentations The binary representations to store.
&nbsp;                 * @throws IOException If an I/O error occurs.
&nbsp;                 */
&nbsp;                void store(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Retains the supplied element in its original form.
&nbsp;                 *
&nbsp;                 * @param element The element to retain.
&nbsp;                 * @throws IOException If an I/O error occurs.
&nbsp;                 */
&nbsp;                void retain(Source.Element element) throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * Implements a sink for a jar file.
&nbsp;                 */
&nbsp;                class ForJarOutputStream implements Sink {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The output stream to write to.
&nbsp;                     */
&nbsp;                    private final JarOutputStream outputStream;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new sink for a jar file.
&nbsp;                     *
&nbsp;                     * @param outputStream The output stream to write to.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForJarOutputStream(JarOutputStream outputStream) {</b>
<b class="fc">&nbsp;                        this.outputStream = outputStream;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void store(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) throws IOException {
<b class="fc">&nbsp;                        for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : binaryRepresentations.entrySet()) {</b>
<b class="fc">&nbsp;                            outputStream.putNextEntry(new JarEntry(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION));</b>
<b class="fc">&nbsp;                            outputStream.write(entry.getValue());</b>
<b class="fc">&nbsp;                            outputStream.closeEntry();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void retain(Source.Element element) throws IOException {
<b class="fc">&nbsp;                        JarEntry entry = element.resolveAs(JarEntry.class);</b>
<b class="fc">&nbsp;                        outputStream.putNextEntry(entry == null</b>
<b class="fc">&nbsp;                                ? new JarEntry(element.getName())</b>
<b class="fc">&nbsp;                                : entry);</b>
<b class="fc">&nbsp;                        InputStream inputStream = element.getInputStream();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            byte[] buffer = new byte[1024];</b>
&nbsp;                            int length;
<b class="fc">&nbsp;                            while ((length = inputStream.read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                                outputStream.write(buffer, 0, length);</b>
&nbsp;                            }
&nbsp;                        } finally {
<b class="fc">&nbsp;                            inputStream.close();</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        outputStream.closeEntry();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void close() throws IOException {
<b class="fc">&nbsp;                        outputStream.close();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A sink that discards any entry.
&nbsp;             */
<b class="fc">&nbsp;            enum Discarding implements Target, Sink {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sink write(@MaybeNull Manifest manifest) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void store(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void retain(Source.Element element) {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A sink that stores all elements in a memory map.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class InMemory implements Target, Sink {
&nbsp;
&nbsp;                /**
&nbsp;                 * The map for storing all elements being received.
&nbsp;                 */
&nbsp;                private final Map&lt;String, byte[]&gt; storage;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new in-memory storage.
&nbsp;                 */
&nbsp;                public InMemory() {
<b class="fc">&nbsp;                    this(new HashMap&lt;String, byte[]&gt;());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new in-memory storage.
&nbsp;                 *
&nbsp;                 * @param storage The map for storing all elements being received.
&nbsp;                 */
<b class="fc">&nbsp;                public InMemory(Map&lt;String, byte[]&gt; storage) {</b>
<b class="fc">&nbsp;                    this.storage = storage;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sink write(@MaybeNull Manifest manifest) throws IOException {
<b class="fc">&nbsp;                    if (manifest != null) {</b>
<b class="fc">&nbsp;                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            manifest.write(outputStream);</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            outputStream.close();</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        storage.put(JarFile.MANIFEST_NAME, outputStream.toByteArray());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void store(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) {
<b class="fc">&nbsp;                    for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : binaryRepresentations.entrySet()) {</b>
<b class="fc">&nbsp;                        storage.put(entry.getKey().getInternalName() + CLASS_FILE_EXTENSION, entry.getValue());</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void retain(Source.Element element) throws IOException {
<b class="fc">&nbsp;                    String name = element.getName();</b>
<b class="fc">&nbsp;                    if (!name.endsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;                        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            InputStream inputStream = element.getInputStream();</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                byte[] buffer = new byte[1024];</b>
&nbsp;                                int length;
<b class="fc">&nbsp;                                while ((length = inputStream.read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                                    outputStream.write(buffer, 0, length);</b>
&nbsp;                                }
&nbsp;                            } finally {
<b class="fc">&nbsp;                                inputStream.close();</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            outputStream.close();</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        storage.put(element.getName(), outputStream.toByteArray());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the in-memory storage.
&nbsp;                 *
&nbsp;                 * @return The in-memory storage.
&nbsp;                 */
&nbsp;                public Map&lt;String, byte[]&gt; getStorage() {
<b class="fc">&nbsp;                    return storage;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the in-memory storage as a type-map where all non-class files are discarded.
&nbsp;                 *
&nbsp;                 * @return The in-memory storage as a type map.
&nbsp;                 */
&nbsp;                public Map&lt;String, byte[]&gt; toTypeMap() {
<b class="fc">&nbsp;                    Map&lt;String, byte[]&gt; binaryRepresentations = new HashMap&lt;String, byte[]&gt;();</b>
<b class="fc">&nbsp;                    for (Map.Entry&lt;String, byte[]&gt; entry : storage.entrySet()) {</b>
<b class="fc">&nbsp;                        if (entry.getKey().endsWith(CLASS_FILE_EXTENSION)) {</b>
<b class="fc">&nbsp;                            binaryRepresentations.put(entry.getKey()</b>
<b class="fc">&nbsp;                                    .substring(0, entry.getKey().length() - CLASS_FILE_EXTENSION.length())</b>
<b class="fc">&nbsp;                                    .replace(&#39;/&#39;, &#39;.&#39;), entry.getValue());</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return binaryRepresentations;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a folder as the target for a plugin engine&#39;s application.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForFolder implements Target, Sink {
&nbsp;
&nbsp;                /**
&nbsp;                 * The folder that is represented by this instance.
&nbsp;                 */
&nbsp;                private final File folder;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target for a folder.
&nbsp;                 *
&nbsp;                 * @param folder The folder that is represented by this instance.
&nbsp;                 */
<b class="fc">&nbsp;                public ForFolder(File folder) {</b>
<b class="fc">&nbsp;                    this.folder = folder;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sink write(@MaybeNull Manifest manifest) throws IOException {
<b class="fc">&nbsp;                    if (manifest != null) {</b>
<b class="fc">&nbsp;                        File target = new File(folder, JarFile.MANIFEST_NAME);</b>
<b class="fc">&nbsp;                        if (!target.getParentFile().isDirectory() &amp;&amp; !target.getParentFile().mkdirs()) {</b>
<b class="nc">&nbsp;                            throw new IOException(&quot;Could not create directory: &quot; + target.getParent());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        OutputStream outputStream = new FileOutputStream(target);</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            manifest.write(outputStream);</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            outputStream.close();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void store(Map&lt;TypeDescription, byte[]&gt; binaryRepresentations) throws IOException {
<b class="fc">&nbsp;                    for (Map.Entry&lt;TypeDescription, byte[]&gt; entry : binaryRepresentations.entrySet()) {</b>
<b class="fc">&nbsp;                        File target = new File(folder, entry.getKey().getInternalName() + CLASS_FILE_EXTENSION);</b>
<b class="fc">&nbsp;                        if (!target.getParentFile().isDirectory() &amp;&amp; !target.getParentFile().mkdirs()) {</b>
<b class="nc">&nbsp;                            throw new IOException(&quot;Could not create directory: &quot; + target.getParent());</b>
&nbsp;                        }
<b class="fc">&nbsp;                        OutputStream outputStream = new FileOutputStream(target);</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            outputStream.write(entry.getValue());</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            outputStream.close();</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void retain(Source.Element element) throws IOException {
<b class="fc">&nbsp;                    String name = element.getName();</b>
<b class="fc">&nbsp;                    if (!name.endsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;                        File target = new File(folder, name), resolved = element.resolveAs(File.class);</b>
<b class="fc">&nbsp;                        if (!target.getCanonicalPath().startsWith(folder.getCanonicalPath() + File.separatorChar)) {</b>
<b class="fc">&nbsp;                            throw new IllegalArgumentException(target + &quot; is not a subdirectory of &quot; + folder);</b>
<b class="fc">&nbsp;                        } else if (!target.getParentFile().isDirectory() &amp;&amp; !target.getParentFile().mkdirs()) {</b>
<b class="nc">&nbsp;                            throw new IOException(&quot;Could not create directory: &quot; + target.getParent());</b>
<b class="fc">&nbsp;                        } else if (resolved != null &amp;&amp; !resolved.equals(target)) {</b>
<b class="fc">&nbsp;                            FileSystem.getInstance().copy(resolved, target);</b>
<b class="fc">&nbsp;                        } else if (!target.equals(resolved)) {</b>
<b class="fc">&nbsp;                            InputStream inputStream = element.getInputStream();</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                OutputStream outputStream = new FileOutputStream(target);</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    byte[] buffer = new byte[1024];</b>
&nbsp;                                    int length;
<b class="fc">&nbsp;                                    while ((length = inputStream.read(buffer)) != -1) {</b>
<b class="fc">&nbsp;                                        outputStream.write(buffer, 0, length);</b>
&nbsp;                                    }
&nbsp;                                } finally {
<b class="fc">&nbsp;                                    outputStream.close();</b>
<b class="fc">&nbsp;                                }</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                inputStream.close();</b>
<b class="fc">&nbsp;                            }</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a jar file as a target.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForJarFile implements Target {
&nbsp;
&nbsp;                /**
&nbsp;                 * The jar file that is represented by this target.
&nbsp;                 */
&nbsp;                private final File file;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new target for a jar file.
&nbsp;                 *
&nbsp;                 * @param file The jar file that is represented by this target.
&nbsp;                 */
<b class="fc">&nbsp;                public ForJarFile(File file) {</b>
<b class="fc">&nbsp;                    this.file = file;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sink write(@MaybeNull Manifest manifest) throws IOException {
<b class="fc">&nbsp;                    return manifest == null</b>
<b class="fc">&nbsp;                            ? new Sink.ForJarOutputStream(new JarOutputStream(new FileOutputStream(file)))</b>
<b class="fc">&nbsp;                            : new Sink.ForJarOutputStream(new JarOutputStream(new FileOutputStream(file), manifest));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher to execute a plugin engine transformation. A dispatcher will receive all work assignments prior to the invocation
&nbsp;         * of complete. After registering and eventually completing the supplied work, the close method will always be called. Any dispatcher
&nbsp;         * will only be used once and from a single thread.
&nbsp;         */
&nbsp;        interface Dispatcher extends Closeable {
&nbsp;
&nbsp;            /**
&nbsp;             * Accepts a new work assignment.
&nbsp;             *
&nbsp;             * @param work  The work to handle prefixed by a preprocessing step.
&nbsp;             * @param eager {@code true} if the processing does not need to be deferred until all preprocessing is complete.
&nbsp;             * @throws IOException If an I/O exception occurs.
&nbsp;             */
&nbsp;            void accept(Callable&lt;? extends Callable&lt;? extends Materializable&gt;&gt; work, boolean eager) throws IOException;
&nbsp;
&nbsp;            /**
&nbsp;             * Completes the work being handled.
&nbsp;             *
&nbsp;             * @throws IOException If an I/O exception occurs.
&nbsp;             */
&nbsp;            void complete() throws IOException;
&nbsp;
&nbsp;            /**
&nbsp;             * The result of a work assignment that needs to be invoked from the main thread that triggers a dispatchers life-cycle methods.
&nbsp;             */
&nbsp;            interface Materializable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Materializes this work result and adds any results to the corresponding collection.
&nbsp;                 *
&nbsp;                 * @param sink        The sink to write any work to.
&nbsp;                 * @param transformed A list of all types that are transformed.
&nbsp;                 * @param failed      A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                 * @param unresolved  A list of type names that could not be resolved.
&nbsp;                 * @throws IOException If an I/O exception occurs.
&nbsp;                 */
&nbsp;                void materialize(Target.Sink sink,
&nbsp;                                 List&lt;TypeDescription&gt; transformed,
&nbsp;                                 Map&lt;TypeDescription,
&nbsp;                                         List&lt;Throwable&gt;&gt; failed,
&nbsp;                                 List&lt;String&gt; unresolved) throws IOException;
&nbsp;
&nbsp;                /**
&nbsp;                 * A materializable for a successfully transformed type.
&nbsp;                 */
&nbsp;                class ForTransformedElement implements Materializable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type that has been transformed.
&nbsp;                     */
&nbsp;                    private final DynamicType dynamicType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new materializable for a successfully transformed type.
&nbsp;                     *
&nbsp;                     * @param dynamicType The type that has been transformed.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForTransformedElement(DynamicType dynamicType) {</b>
<b class="fc">&nbsp;                        this.dynamicType = dynamicType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void materialize(Target.Sink sink,
&nbsp;                                            List&lt;TypeDescription&gt; transformed,
&nbsp;                                            Map&lt;TypeDescription,
&nbsp;                                                    List&lt;Throwable&gt;&gt; failed,
&nbsp;                                            List&lt;String&gt; unresolved) throws IOException {
<b class="fc">&nbsp;                        sink.store(dynamicType.getAllTypes());</b>
<b class="fc">&nbsp;                        transformed.add(dynamicType.getTypeDescription());</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A materializable for an element that is retained in its original state.
&nbsp;                 */
&nbsp;                class ForRetainedElement implements Materializable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The retained element.
&nbsp;                     */
&nbsp;                    private final Source.Element element;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new materializable for a retained element.
&nbsp;                     *
&nbsp;                     * @param element The retained element.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForRetainedElement(Source.Element element) {</b>
<b class="fc">&nbsp;                        this.element = element;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void materialize(Target.Sink sink,
&nbsp;                                            List&lt;TypeDescription&gt; transformed,
&nbsp;                                            Map&lt;TypeDescription,
&nbsp;                                                    List&lt;Throwable&gt;&gt; failed,
&nbsp;                                            List&lt;String&gt; unresolved) throws IOException {
<b class="fc">&nbsp;                        sink.retain(element);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A materializable for an element that failed to be transformed.
&nbsp;                 */
&nbsp;                class ForFailedElement implements Materializable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The element for which the transformation failed.
&nbsp;                     */
&nbsp;                    private final Source.Element element;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type description for the represented type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A non-empty list of errors that occurred when attempting the transformation.
&nbsp;                     */
&nbsp;                    private final List&lt;Throwable&gt; errored;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new materializable for an element that failed to be transformed.
&nbsp;                     *
&nbsp;                     * @param element         The element for which the transformation failed.
&nbsp;                     * @param typeDescription The type description for the represented type.
&nbsp;                     * @param errored         A non-empty list of errors that occurred when attempting the transformation.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForFailedElement(Source.Element element, TypeDescription typeDescription, List&lt;Throwable&gt; errored) {</b>
<b class="fc">&nbsp;                        this.element = element;</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                        this.errored = errored;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void materialize(Target.Sink sink,
&nbsp;                                            List&lt;TypeDescription&gt; transformed,
&nbsp;                                            Map&lt;TypeDescription,
&nbsp;                                                    List&lt;Throwable&gt;&gt; failed,
&nbsp;                                            List&lt;String&gt; unresolved) throws IOException {
<b class="fc">&nbsp;                        sink.retain(element);</b>
<b class="fc">&nbsp;                        failed.put(typeDescription, errored);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A materializable for an element that could not be resolved.
&nbsp;                 */
&nbsp;                class ForUnresolvedElement implements Materializable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The element that could not be resolved.
&nbsp;                     */
&nbsp;                    private final Source.Element element;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the type that was deducted for this element.
&nbsp;                     */
&nbsp;                    private final String typeName;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new materializable for an element that could not be resolved.
&nbsp;                     *
&nbsp;                     * @param element  The element that could not be resolved.
&nbsp;                     * @param typeName The name of the type that was deducted for this element.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForUnresolvedElement(Source.Element element, String typeName) {</b>
<b class="fc">&nbsp;                        this.element = element;</b>
<b class="fc">&nbsp;                        this.typeName = typeName;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public void materialize(Target.Sink sink,
&nbsp;                                            List&lt;TypeDescription&gt; transformed,
&nbsp;                                            Map&lt;TypeDescription,
&nbsp;                                                    List&lt;Throwable&gt;&gt; failed,
&nbsp;                                            List&lt;String&gt; unresolved) throws IOException {
<b class="fc">&nbsp;                        sink.retain(element);</b>
<b class="fc">&nbsp;                        unresolved.add(typeName);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A factory that is used for creating a dispatcher that is used for a specific plugin engine application.
&nbsp;             */
&nbsp;            interface Factory {
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher.
&nbsp;                 *
&nbsp;                 * @param sink        The sink to write any work to.
&nbsp;                 * @param transformed A list of all types that are transformed.
&nbsp;                 * @param failed      A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                 * @param unresolved  A list of type names that could not be resolved.
&nbsp;                 * @return The dispatcher to use.
&nbsp;                 */
&nbsp;                Dispatcher make(Target.Sink sink,
&nbsp;                                List&lt;TypeDescription&gt; transformed,
&nbsp;                                Map&lt;TypeDescription,
&nbsp;                                        List&lt;Throwable&gt;&gt; failed,
&nbsp;                                List&lt;String&gt; unresolved);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher that applies transformation upon discovery.
&nbsp;             */
&nbsp;            class ForSerialTransformation implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The sink to write any work to.
&nbsp;                 */
&nbsp;                private final Target.Sink sink;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of all types that are transformed.
&nbsp;                 */
&nbsp;                private final List&lt;TypeDescription&gt; transformed;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                 */
&nbsp;                private final Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type names that could not be resolved.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; unresolved;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of deferred processings.
&nbsp;                 */
&nbsp;                private final List&lt;Callable&lt;? extends Materializable&gt;&gt; preprocessings;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a dispatcher for a serial transformation.
&nbsp;                 *
&nbsp;                 * @param sink        The sink to write any work to.
&nbsp;                 * @param transformed A list of all types that are transformed.
&nbsp;                 * @param failed      A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                 * @param unresolved  A list of type names that could not be resolved.
&nbsp;                 */
&nbsp;                protected ForSerialTransformation(Target.Sink sink,
&nbsp;                                                  List&lt;TypeDescription&gt; transformed,
&nbsp;                                                  Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed,
<b class="fc">&nbsp;                                                  List&lt;String&gt; unresolved) {</b>
<b class="fc">&nbsp;                    this.sink = sink;</b>
<b class="fc">&nbsp;                    this.transformed = transformed;</b>
<b class="fc">&nbsp;                    this.failed = failed;</b>
<b class="fc">&nbsp;                    this.unresolved = unresolved;</b>
<b class="fc">&nbsp;                    preprocessings = new ArrayList&lt;Callable&lt;? extends Materializable&gt;&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void accept(Callable&lt;? extends Callable&lt;? extends Materializable&gt;&gt; work, boolean eager) throws IOException {
&nbsp;                    try {
<b class="fc">&nbsp;                        Callable&lt;? extends Materializable&gt; preprocessed = work.call();</b>
<b class="fc">&nbsp;                        if (eager) {</b>
<b class="fc">&nbsp;                            preprocessed.call().materialize(sink, transformed, failed, unresolved);</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            preprocessings.add(preprocessed);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    } catch (Exception exception) {</b>
<b class="fc">&nbsp;                        if (exception instanceof IOException) {</b>
<b class="nc">&nbsp;                            throw (IOException) exception;</b>
<b class="fc">&nbsp;                        } else if (exception instanceof RuntimeException) {</b>
<b class="fc">&nbsp;                            throw (RuntimeException) exception;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(exception);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void complete() throws IOException {
<b class="fc">&nbsp;                    for (Callable&lt;? extends Materializable&gt; preprocessing : preprocessings) {</b>
<b class="fc">&nbsp;                        if (Thread.interrupted()) {</b>
<b class="nc">&nbsp;                            Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Interrupted during plugin engine completion&quot;);</b>
&nbsp;                        }
&nbsp;                        try {
<b class="fc">&nbsp;                            preprocessing.call().materialize(sink, transformed, failed, unresolved);</b>
<b class="fc">&nbsp;                        } catch (Exception exception) {</b>
<b class="fc">&nbsp;                            if (exception instanceof IOException) {</b>
<b class="nc">&nbsp;                                throw (IOException) exception;</b>
<b class="fc">&nbsp;                            } else if (exception instanceof RuntimeException) {</b>
<b class="fc">&nbsp;                                throw (RuntimeException) exception;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                throw new IllegalStateException(exception);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
&nbsp;                    /* do nothing */
<b class="fc">&nbsp;                }</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for creating a serial dispatcher.
&nbsp;                 */
<b class="fc">&nbsp;                public enum Factory implements Dispatcher.Factory {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Dispatcher make(Target.Sink sink,
&nbsp;                                           List&lt;TypeDescription&gt; transformed,
&nbsp;                                           Map&lt;TypeDescription,
&nbsp;                                                   List&lt;Throwable&gt;&gt; failed,
&nbsp;                                           List&lt;String&gt; unresolved) {
<b class="fc">&nbsp;                        return new ForSerialTransformation(sink, transformed, failed, unresolved);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A dispatcher that applies transformations within one or more threads in parallel to the default transformer.
&nbsp;             */
&nbsp;            class ForParallelTransformation implements Dispatcher {
&nbsp;
&nbsp;                /**
&nbsp;                 * The target sink.
&nbsp;                 */
&nbsp;                private final Target.Sink sink;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of all types that are transformed.
&nbsp;                 */
&nbsp;                private final List&lt;TypeDescription&gt; transformed;
&nbsp;
&nbsp;                /**
&nbsp;                 * A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                 */
&nbsp;                private final Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed;
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type names that could not be resolved.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; unresolved;
&nbsp;
&nbsp;                /**
&nbsp;                 * A completion service for all preprocessings.
&nbsp;                 */
&nbsp;                private final CompletionService&lt;Callable&lt;Materializable&gt;&gt; preprocessings;
&nbsp;
&nbsp;                /**
&nbsp;                 * A completion service for all materializers.
&nbsp;                 */
&nbsp;                private final CompletionService&lt;Materializable&gt; materializers;
&nbsp;
&nbsp;                /**
&nbsp;                 * A count of deferred processings.
&nbsp;                 */
&nbsp;                private int deferred;
&nbsp;
&nbsp;                /**
&nbsp;                 * A collection of futures that are currently scheduled.
&nbsp;                 */
&nbsp;                private final Set&lt;Future&lt;?&gt;&gt; futures;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new dispatcher that applies transformations in parallel.
&nbsp;                 *
&nbsp;                 * @param executor    The executor to delegate any work to.
&nbsp;                 * @param sink        The target sink.
&nbsp;                 * @param transformed A list of all types that are transformed.
&nbsp;                 * @param failed      A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                 * @param unresolved  A list of type names that could not be resolved.
&nbsp;                 */
&nbsp;                protected ForParallelTransformation(Executor executor,
&nbsp;                                                    Target.Sink sink,
&nbsp;                                                    List&lt;TypeDescription&gt; transformed,
&nbsp;                                                    Map&lt;TypeDescription,
&nbsp;                                                            List&lt;Throwable&gt;&gt; failed,
<b class="fc">&nbsp;                                                    List&lt;String&gt; unresolved) {</b>
<b class="fc">&nbsp;                    this.sink = sink;</b>
<b class="fc">&nbsp;                    this.transformed = transformed;</b>
<b class="fc">&nbsp;                    this.failed = failed;</b>
<b class="fc">&nbsp;                    this.unresolved = unresolved;</b>
<b class="fc">&nbsp;                    preprocessings = new ExecutorCompletionService&lt;Callable&lt;Materializable&gt;&gt;(executor);</b>
<b class="fc">&nbsp;                    materializers = new ExecutorCompletionService&lt;Materializable&gt;(executor);</b>
<b class="fc">&nbsp;                    futures = new HashSet&lt;Future&lt;?&gt;&gt;();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;                public void accept(Callable&lt;? extends Callable&lt;? extends Materializable&gt;&gt; work, boolean eager) {
<b class="fc">&nbsp;                    if (eager) {</b>
<b class="fc">&nbsp;                        futures.add(materializers.submit(new EagerWork(work)));</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        deferred += 1;</b>
<b class="fc">&nbsp;                        futures.add(preprocessings.submit((Callable&lt;Callable&lt;Materializable&gt;&gt;) work));</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void complete() throws IOException {
&nbsp;                    try {
<b class="fc">&nbsp;                        List&lt;Callable&lt;Materializable&gt;&gt; preprocessings = new ArrayList&lt;Callable&lt;Materializable&gt;&gt;(deferred);</b>
<b class="fc">&nbsp;                        while (deferred-- &gt; 0) {</b>
<b class="fc">&nbsp;                            Future&lt;Callable&lt;Materializable&gt;&gt; future = this.preprocessings.take();</b>
<b class="fc">&nbsp;                            futures.remove(future);</b>
<b class="fc">&nbsp;                            preprocessings.add(future.get());</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        for (Callable&lt;Materializable&gt; preprocessing : preprocessings) {</b>
<b class="fc">&nbsp;                            futures.add(materializers.submit(preprocessing));</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        while (!futures.isEmpty()) {</b>
<b class="fc">&nbsp;                            Future&lt;Materializable&gt; future = materializers.take();</b>
<b class="fc">&nbsp;                            futures.remove(future);</b>
<b class="fc">&nbsp;                            future.get().materialize(sink, transformed, failed, unresolved);</b>
<b class="fc">&nbsp;                        }</b>
<b class="nc">&nbsp;                    } catch (InterruptedException exception) {</b>
<b class="nc">&nbsp;                        Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(exception);</b>
<b class="fc">&nbsp;                    } catch (ExecutionException exception) {</b>
<b class="fc">&nbsp;                        Throwable cause = exception.getCause();</b>
<b class="fc">&nbsp;                        if (cause instanceof IOException) {</b>
<b class="nc">&nbsp;                            throw (IOException) cause;</b>
<b class="fc">&nbsp;                        } else if (cause instanceof RuntimeException) {</b>
<b class="fc">&nbsp;                            throw (RuntimeException) cause;</b>
<b class="nc">&nbsp;                        } else if (cause instanceof Error) {</b>
<b class="nc">&nbsp;                            throw (Error) cause;</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            throw new IllegalStateException(cause);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public void close() {
<b class="fc">&nbsp;                    for (Future&lt;?&gt; future : futures) {</b>
<b class="nc">&nbsp;                        future.cancel(true);</b>
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A parallel dispatcher that shuts down its executor service upon completion of a plugin engine&#39;s application.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class WithThrowawayExecutorService extends ForParallelTransformation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The executor service to delegate any work to.
&nbsp;                     */
&nbsp;                    private final ExecutorService executorService;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new dispatcher that applies transformations in parallel and that closes the supplies executor service.
&nbsp;                     *
&nbsp;                     * @param executorService The executor service to delegate any work to.
&nbsp;                     * @param sink            The target sink.
&nbsp;                     * @param transformed     A list of all types that are transformed.
&nbsp;                     * @param failed          A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;                     * @param unresolved      A list of type names that could not be resolved.
&nbsp;                     */
&nbsp;                    protected WithThrowawayExecutorService(ExecutorService executorService,
&nbsp;                                                           Target.Sink sink,
&nbsp;                                                           List&lt;TypeDescription&gt; transformed,
&nbsp;                                                           Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed,
&nbsp;                                                           List&lt;String&gt; unresolved) {
<b class="fc">&nbsp;                        super(executorService, sink, transformed, failed, unresolved);</b>
<b class="fc">&nbsp;                        this.executorService = executorService;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    public void close() {
&nbsp;                        try {
<b class="fc">&nbsp;                            super.close();</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            executorService.shutdown();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A factory for a parallel executor service that creates a new executor service on each plugin engine application.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    public static class Factory implements Dispatcher.Factory {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The amount of threads to create in the throw-away executor service.
&nbsp;                         */
&nbsp;                        private final int threads;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new factory.
&nbsp;                         *
&nbsp;                         * @param threads The amount of threads to create in the throw-away executor service.
&nbsp;                         */
<b class="fc">&nbsp;                        public Factory(int threads) {</b>
<b class="fc">&nbsp;                            this.threads = threads;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Dispatcher make(Target.Sink sink,
&nbsp;                                               List&lt;TypeDescription&gt; transformed,
&nbsp;                                               Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed,
&nbsp;                                               List&lt;String&gt; unresolved) {
<b class="fc">&nbsp;                            return new WithThrowawayExecutorService(Executors.newFixedThreadPool(threads), sink, transformed, failed, unresolved);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A factory for a dispatcher that uses a given executor service for parallel dispatching.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Factory implements Dispatcher.Factory {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The executor to use.
&nbsp;                     */
&nbsp;                    private final Executor executor;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new dispatcher factory for parallel dispatching using the supplied executor.
&nbsp;                     *
&nbsp;                     * @param executor The executor to use.
&nbsp;                     */
<b class="nc">&nbsp;                    public Factory(Executor executor) {</b>
<b class="nc">&nbsp;                        this.executor = executor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Dispatcher make(Target.Sink sink,
&nbsp;                                           List&lt;TypeDescription&gt; transformed,
&nbsp;                                           Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed,
&nbsp;                                           List&lt;String&gt; unresolved) {
<b class="nc">&nbsp;                        return new ForParallelTransformation(executor, sink, transformed, failed, unresolved);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An eager materialization that does not defer processing after preprocessing.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class EagerWork implements Callable&lt;Materializable&gt; {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The work to apply.
&nbsp;                     */
&nbsp;                    private final Callable&lt;? extends Callable&lt;? extends Materializable&gt;&gt; work;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates an eager work resolution.
&nbsp;                     *
&nbsp;                     * @param work The work to apply.
&nbsp;                     */
<b class="fc">&nbsp;                    protected EagerWork(Callable&lt;? extends Callable&lt;? extends Materializable&gt;&gt; work) {</b>
<b class="fc">&nbsp;                        this.work = work;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Materializable call() throws Exception {
<b class="fc">&nbsp;                        return work.call().call();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A summary of the application of a {@link Engine} to a source and target.
&nbsp;         */
&nbsp;        class Summary {
&nbsp;
&nbsp;            /**
&nbsp;             * A list of all types that were transformed.
&nbsp;             */
&nbsp;            private final List&lt;TypeDescription&gt; transformed;
&nbsp;
&nbsp;            /**
&nbsp;             * A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;             */
&nbsp;            private final Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of type names that could not be resolved.
&nbsp;             */
&nbsp;            private final List&lt;String&gt; unresolved;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new summary.
&nbsp;             *
&nbsp;             * @param transformed A list of all types that were transformed.
&nbsp;             * @param failed      A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;             * @param unresolved  A list of type names that could not be resolved.
&nbsp;             */
<b class="fc">&nbsp;            public Summary(List&lt;TypeDescription&gt; transformed, Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed, List&lt;String&gt; unresolved) {</b>
<b class="fc">&nbsp;                this.transformed = transformed;</b>
<b class="fc">&nbsp;                this.failed = failed;</b>
<b class="fc">&nbsp;                this.unresolved = unresolved;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a list of all types that were transformed.
&nbsp;             *
&nbsp;             * @return A list of all types that were transformed.
&nbsp;             */
&nbsp;            public List&lt;TypeDescription&gt; getTransformed() {
<b class="fc">&nbsp;                return transformed;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;             *
&nbsp;             * @return A mapping of all types that failed during transformation to the exceptions that explain the failure.
&nbsp;             */
&nbsp;            public Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; getFailed() {
<b class="fc">&nbsp;                return failed;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a list of type names that could not be resolved.
&nbsp;             *
&nbsp;             * @return A list of type names that could not be resolved.
&nbsp;             */
&nbsp;            public List&lt;String&gt; getUnresolved() {
<b class="fc">&nbsp;                return unresolved;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                int result = transformed.hashCode();</b>
<b class="fc">&nbsp;                result = 31 * result + failed.hashCode();</b>
<b class="fc">&nbsp;                result = 31 * result + unresolved.hashCode();</b>
<b class="fc">&nbsp;                return result;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (other == null || getClass() != other.getClass()) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Summary summary = (Summary) other;</b>
<b class="fc">&nbsp;                return transformed.equals(summary.transformed)</b>
<b class="fc">&nbsp;                        &amp;&amp; failed.equals(summary.failed)</b>
<b class="fc">&nbsp;                        &amp;&amp; unresolved.equals(summary.unresolved);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a plugin engine.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase implements Engine {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine withErrorHandlers(ErrorHandler... errorHandler) {
<b class="fc">&nbsp;                return withErrorHandlers(Arrays.asList(errorHandler));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine withParallelTransformation(int threads) {
<b class="nc">&nbsp;                if (threads &lt; 1) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Number of threads must be positive: &quot; + threads);</b>
&nbsp;                }
<b class="nc">&nbsp;                return with(new Dispatcher.ForParallelTransformation.WithThrowawayExecutorService.Factory(threads));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Summary apply(File source, File target, Factory... factory) throws IOException {
<b class="fc">&nbsp;                return apply(source, target, Arrays.asList(factory));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Summary apply(File source, File target, List&lt;? extends Factory&gt; factories) throws IOException {
<b class="fc">&nbsp;                return apply(source.isDirectory()</b>
<b class="fc">&nbsp;                        ? new Source.ForFolder(source)</b>
<b class="fc">&nbsp;                        : new Source.ForJarFile(source), target.isDirectory()</b>
<b class="fc">&nbsp;                        ? new Target.ForFolder(target)</b>
<b class="fc">&nbsp;                        : new Target.ForJarFile(target), factories);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Summary apply(Source source, Target target, Factory... factory) throws IOException {
<b class="fc">&nbsp;                return apply(source, target, Arrays.asList(factory));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A default implementation of a plugin engine.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;        class Default extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The Byte Buddy instance to use.
&nbsp;             */
&nbsp;            private final ByteBuddy byteBuddy;
&nbsp;
&nbsp;            /**
&nbsp;             * The type strategy to use.
&nbsp;             */
&nbsp;            private final TypeStrategy typeStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The pool strategy to use.
&nbsp;             */
&nbsp;            private final PoolStrategy poolStrategy;
&nbsp;
&nbsp;            /**
&nbsp;             * The class file locator to use.
&nbsp;             */
&nbsp;            private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;            /**
&nbsp;             * The listener to use.
&nbsp;             */
&nbsp;            private final Listener listener;
&nbsp;
&nbsp;            /**
&nbsp;             * The error handler to use.
&nbsp;             */
&nbsp;            private final ErrorHandler errorHandler;
&nbsp;
&nbsp;            /**
&nbsp;             * The dispatcher factory to use.
&nbsp;             */
&nbsp;            private final Dispatcher.Factory dispatcherFactory;
&nbsp;
&nbsp;            /**
&nbsp;             * A matcher for types to exclude from transformation.
&nbsp;             */
&nbsp;            private final ElementMatcher.Junction&lt;? super TypeDescription&gt; ignoredTypeMatcher;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default plugin engine that rebases types and fails fast and on unresolved types and on live initializers.
&nbsp;             */
&nbsp;            public Default() {
<b class="fc">&nbsp;                this(new ByteBuddy());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default plugin engine that rebases types and fails fast and on unresolved types and on live initializers.
&nbsp;             *
&nbsp;             * @param byteBuddy The Byte Buddy instance to use.
&nbsp;             */
&nbsp;            public Default(ByteBuddy byteBuddy) {
<b class="fc">&nbsp;                this(byteBuddy, TypeStrategy.Default.REBASE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default plugin engine.
&nbsp;             *
&nbsp;             * @param byteBuddy    The Byte Buddy instance to use.
&nbsp;             * @param typeStrategy The type strategy to use.
&nbsp;             */
&nbsp;            protected Default(ByteBuddy byteBuddy, TypeStrategy typeStrategy) {
<b class="fc">&nbsp;                this(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        PoolStrategy.Default.FAST,
&nbsp;                        ClassFileLocator.NoOp.INSTANCE,
&nbsp;                        Listener.NoOp.INSTANCE,
&nbsp;                        new ErrorHandler.Compound(ErrorHandler.Failing.FAIL_FAST,
&nbsp;                                ErrorHandler.Enforcing.ALL_TYPES_RESOLVED,
&nbsp;                                ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS),
&nbsp;                        Dispatcher.ForSerialTransformation.Factory.INSTANCE,
<b class="fc">&nbsp;                        none());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new default plugin engine.
&nbsp;             *
&nbsp;             * @param byteBuddy          The Byte Buddy instance to use.
&nbsp;             * @param typeStrategy       The type strategy to use.
&nbsp;             * @param poolStrategy       The pool strategy to use.
&nbsp;             * @param classFileLocator   The class file locator to use.
&nbsp;             * @param listener           The listener to use.
&nbsp;             * @param errorHandler       The error handler to use.
&nbsp;             * @param dispatcherFactory  The dispatcher factory to use.
&nbsp;             * @param ignoredTypeMatcher A matcher for types to exclude from transformation.
&nbsp;             */
&nbsp;            protected Default(ByteBuddy byteBuddy,
&nbsp;                              TypeStrategy typeStrategy,
&nbsp;                              PoolStrategy poolStrategy,
&nbsp;                              ClassFileLocator classFileLocator,
&nbsp;                              Listener listener,
&nbsp;                              ErrorHandler errorHandler,
&nbsp;                              Dispatcher.Factory dispatcherFactory,
<b class="fc">&nbsp;                              ElementMatcher.Junction&lt;? super TypeDescription&gt; ignoredTypeMatcher) {</b>
<b class="fc">&nbsp;                this.byteBuddy = byteBuddy;</b>
<b class="fc">&nbsp;                this.typeStrategy = typeStrategy;</b>
<b class="fc">&nbsp;                this.poolStrategy = poolStrategy;</b>
<b class="fc">&nbsp;                this.classFileLocator = classFileLocator;</b>
<b class="fc">&nbsp;                this.listener = listener;</b>
<b class="fc">&nbsp;                this.errorHandler = errorHandler;</b>
<b class="fc">&nbsp;                this.dispatcherFactory = dispatcherFactory;</b>
<b class="fc">&nbsp;                this.ignoredTypeMatcher = ignoredTypeMatcher;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a plugin engine from an {@link EntryPoint}.
&nbsp;             *
&nbsp;             * @param entryPoint            The entry point to resolve into a plugin engine.
&nbsp;             * @param classFileVersion      The class file version to assume.
&nbsp;             * @param methodNameTransformer The method name transformer to use.
&nbsp;             * @return An appropriate plugin engine.
&nbsp;             */
&nbsp;            public static Engine of(EntryPoint entryPoint, ClassFileVersion classFileVersion, MethodNameTransformer methodNameTransformer) {
<b class="fc">&nbsp;                return new Default(entryPoint.byteBuddy(classFileVersion), new TypeStrategy.ForEntryPoint(entryPoint, methodNameTransformer));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Scans a class loader for plugins declared in a &lt;i&gt;META-INF/net.bytebuddy/build.plugins&lt;/i&gt; file.
&nbsp;             *
&nbsp;             * @param classLoader The class loader to scan.
&nbsp;             * @return A set containing all plugins that were found.
&nbsp;             * @throws IOException If an I/O exception occurred.
&nbsp;             */
&nbsp;            public static Set&lt;String&gt; scan(ClassLoader classLoader) throws IOException {
<b class="fc">&nbsp;                Set&lt;String&gt; plugins = new HashSet&lt;String&gt;();</b>
<b class="fc">&nbsp;                Enumeration&lt;URL&gt; enumeration = classLoader.getResources(PLUGIN_FILE);</b>
<b class="fc">&nbsp;                while (enumeration.hasMoreElements()) {</b>
<b class="fc">&nbsp;                    BufferedReader reader = new BufferedReader(new InputStreamReader(enumeration.nextElement().openStream(), &quot;UTF-8&quot;));</b>
&nbsp;                    try {
&nbsp;                        String line;
<b class="fc">&nbsp;                        while ((line = reader.readLine()) != null) {</b>
<b class="fc">&nbsp;                            plugins.add(line);</b>
&nbsp;                        }
&nbsp;                    } finally {
<b class="fc">&nbsp;                        reader.close();</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return plugins;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Runs a plugin engine using the first and second argument as source and target file location and any additional argument as
&nbsp;             * the fully qualified name of any plugin to apply.
&nbsp;             *
&nbsp;             * @param argument The arguments for running the plugin engine.
&nbsp;             * @throws ClassNotFoundException If a plugin class cannot be found on the system class loader.
&nbsp;             * @throws IOException            If an I/O exception occurs.
&nbsp;             */
&nbsp;            @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;            public static void main(String... argument) throws ClassNotFoundException, IOException {
<b class="fc">&nbsp;                if (argument.length &lt; 2) {</b>
<b class="nc">&nbsp;                    throw new IllegalArgumentException(&quot;Expected arguments: &lt;source&gt; &lt;target&gt; [&lt;plugin&gt;, ...]&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                List&lt;Plugin.Factory&gt; factories = new ArrayList&lt;Factory&gt;(argument.length - 2);</b>
<b class="fc">&nbsp;                for (String plugin : Arrays.asList(argument).subList(2, argument.length)) {</b>
<b class="fc">&nbsp;                    factories.add(new Factory.UsingReflection((Class&lt;? extends Plugin&gt;) Class.forName(plugin)));</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                new Default().apply(new File(argument[0]), new File(argument[1]), factories);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine with(ByteBuddy byteBuddy) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine with(TypeStrategy typeStrategy) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine with(PoolStrategy poolStrategy) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine with(ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        new ClassFileLocator.Compound(this.classFileLocator, classFileLocator),
&nbsp;                        listener,
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine with(Listener listener) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        new Listener.Compound(this.listener, listener),
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine withoutErrorHandlers() {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        Listener.NoOp.INSTANCE,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine withErrorHandlers(List&lt;? extends ErrorHandler&gt; errorHandlers) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        new ErrorHandler.Compound(errorHandlers),
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine with(Dispatcher.Factory dispatcherFactory) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
&nbsp;                        ignoredTypeMatcher);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Engine ignore(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;                return new Default(byteBuddy,</b>
&nbsp;                        typeStrategy,
&nbsp;                        poolStrategy,
&nbsp;                        classFileLocator,
&nbsp;                        listener,
&nbsp;                        errorHandler,
&nbsp;                        dispatcherFactory,
<b class="fc">&nbsp;                        ignoredTypeMatcher.&lt;TypeDescription&gt;or(matcher));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Summary apply(Source source, Target target, List&lt;? extends Plugin.Factory&gt; factories) throws IOException {
<b class="fc">&nbsp;                Listener listener = new Listener.Compound(this.listener, new Listener.ForErrorHandler(errorHandler));</b>
<b class="fc">&nbsp;                List&lt;TypeDescription&gt; transformed = new ArrayList&lt;TypeDescription&gt;();</b>
<b class="fc">&nbsp;                Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; failed = new LinkedHashMap&lt;TypeDescription, List&lt;Throwable&gt;&gt;();</b>
<b class="fc">&nbsp;                List&lt;String&gt; unresolved = new ArrayList&lt;String&gt;();</b>
<b class="fc">&nbsp;                Throwable rethrown = null;</b>
<b class="fc">&nbsp;                List&lt;Plugin&gt; plugins = new ArrayList&lt;Plugin&gt;(factories.size());</b>
<b class="fc">&nbsp;                List&lt;WithInitialization&gt; initializers = new ArrayList&lt;WithInitialization&gt;();</b>
<b class="fc">&nbsp;                List&lt;WithPreprocessor&gt; preprocessors = new ArrayList&lt;WithPreprocessor&gt;();</b>
&nbsp;                try {
<b class="fc">&nbsp;                    for (Plugin.Factory factory : factories) {</b>
<b class="fc">&nbsp;                        Plugin plugin = factory.make();</b>
<b class="fc">&nbsp;                        plugins.add(plugin);</b>
<b class="fc">&nbsp;                        if (plugin instanceof WithPreprocessor) {</b>
<b class="fc">&nbsp;                            preprocessors.add((WithPreprocessor) plugin);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        if (plugin instanceof WithInitialization) {</b>
<b class="fc">&nbsp;                            initializers.add((WithInitialization) plugin);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    Source.Origin origin = source.read();</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        ClassFileLocator classFileLocator = new ClassFileLocator.Compound(origin.getClassFileLocator(), this.classFileLocator);</b>
<b class="fc">&nbsp;                        TypePool typePool = poolStrategy.typePool(classFileLocator);</b>
<b class="fc">&nbsp;                        Manifest manifest = origin.getManifest();</b>
<b class="fc">&nbsp;                        listener.onManifest(manifest);</b>
<b class="fc">&nbsp;                        Target.Sink sink = target.write(manifest);</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            for (WithInitialization initializer : initializers) {</b>
<b class="fc">&nbsp;                                sink.store(initializer.initialize(classFileLocator));</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            Dispatcher dispatcher = dispatcherFactory.make(sink, transformed, failed, unresolved);</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                for (Source.Element element : origin) {</b>
<b class="fc">&nbsp;                                    if (Thread.interrupted()) {</b>
<b class="nc">&nbsp;                                        Thread.currentThread().interrupt();</b>
<b class="nc">&nbsp;                                        throw new IllegalStateException(&quot;Thread interrupted during plugin engine application&quot;);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    String name = element.getName();</b>
<b class="fc">&nbsp;                                    while (name.startsWith(&quot;/&quot;)) {</b>
<b class="nc">&nbsp;                                        name = name.substring(1);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                    if (name.endsWith(CLASS_FILE_EXTENSION) &amp;&amp; !name.endsWith(PACKAGE_INFO) &amp;&amp; !name.equals(MODULE_INFO)) {</b>
<b class="fc">&nbsp;                                        dispatcher.accept(new Preprocessor(element,</b>
<b class="fc">&nbsp;                                                name.substring(0, name.length() - CLASS_FILE_EXTENSION.length()).replace(&#39;/&#39;, &#39;.&#39;),</b>
&nbsp;                                                classFileLocator,
&nbsp;                                                typePool,
&nbsp;                                                listener,
&nbsp;                                                plugins,
<b class="fc">&nbsp;                                                preprocessors), preprocessors.isEmpty());</b>
<b class="fc">&nbsp;                                    } else if (!name.equals(JarFile.MANIFEST_NAME)) {</b>
<b class="fc">&nbsp;                                        listener.onResource(name);</b>
<b class="fc">&nbsp;                                        sink.retain(element);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                dispatcher.complete();</b>
&nbsp;                            } finally {
<b class="fc">&nbsp;                                dispatcher.close();</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            if (!failed.isEmpty()) {</b>
<b class="fc">&nbsp;                                listener.onError(failed);</b>
&nbsp;                            }
&nbsp;                        } finally {
<b class="fc">&nbsp;                            sink.close();</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    } finally {
<b class="fc">&nbsp;                        origin.close();</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                } finally {
<b class="fc">&nbsp;                    for (Plugin plugin : plugins) {</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            plugin.close();</b>
<b class="fc">&nbsp;                        } catch (Throwable throwable) {</b>
&nbsp;                            try {
<b class="fc">&nbsp;                                listener.onError(plugin, throwable);</b>
<b class="fc">&nbsp;                            } catch (Throwable chained) {</b>
<b class="fc">&nbsp;                                rethrown = rethrown == null</b>
<b class="fc">&nbsp;                                        ? chained</b>
<b class="nc">&nbsp;                                        : rethrown;</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (rethrown == null) {</b>
<b class="fc">&nbsp;                    return new Summary(transformed, failed, unresolved);</b>
<b class="nc">&nbsp;                } else if (rethrown instanceof IOException) {</b>
<b class="nc">&nbsp;                    throw (IOException) rethrown;</b>
<b class="nc">&nbsp;                } else if (rethrown instanceof RuntimeException) {</b>
<b class="nc">&nbsp;                    throw (RuntimeException) rethrown;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(rethrown);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A preprocessor for a parallel plugin engine.
&nbsp;             */
<b class="fc">&nbsp;            private class Preprocessor implements Callable&lt;Callable&lt;? extends Dispatcher.Materializable&gt;&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The processed element.
&nbsp;                 */
&nbsp;                private final Source.Element element;
&nbsp;
&nbsp;                /**
&nbsp;                 * The name of the processed type.
&nbsp;                 */
&nbsp;                private final String typeName;
&nbsp;
&nbsp;                /**
&nbsp;                 * The class file locator to use.
&nbsp;                 */
&nbsp;                private final ClassFileLocator classFileLocator;
&nbsp;
&nbsp;                /**
&nbsp;                 * The type pool to use.
&nbsp;                 */
&nbsp;                private final TypePool typePool;
&nbsp;
&nbsp;                /**
&nbsp;                 * The listener to notify.
&nbsp;                 */
&nbsp;                private final Listener listener;
&nbsp;
&nbsp;                /**
&nbsp;                 * The plugins to apply.
&nbsp;                 */
&nbsp;                private final List&lt;Plugin&gt; plugins;
&nbsp;
&nbsp;                /**
&nbsp;                 * The plugins with preprocessors to preprocess.
&nbsp;                 */
&nbsp;                private final List&lt;WithPreprocessor&gt; preprocessors;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new preprocessor.
&nbsp;                 *
&nbsp;                 * @param element          The processed element.
&nbsp;                 * @param typeName         The name of the processed type.
&nbsp;                 * @param classFileLocator The class file locator to use.
&nbsp;                 * @param typePool         The type pool to use.
&nbsp;                 * @param listener         The listener to notify.
&nbsp;                 * @param plugins          The plugins to apply.
&nbsp;                 * @param preprocessors    The plugins with preprocessors to preprocess.
&nbsp;                 */
&nbsp;                private Preprocessor(Source.Element element,
&nbsp;                                     String typeName,
&nbsp;                                     ClassFileLocator classFileLocator,
&nbsp;                                     TypePool typePool,
&nbsp;                                     Listener listener,
&nbsp;                                     List&lt;Plugin&gt; plugins,
<b class="fc">&nbsp;                                     List&lt;WithPreprocessor&gt; preprocessors) {</b>
<b class="fc">&nbsp;                    this.element = element;</b>
<b class="fc">&nbsp;                    this.typeName = typeName;</b>
<b class="fc">&nbsp;                    this.classFileLocator = classFileLocator;</b>
<b class="fc">&nbsp;                    this.typePool = typePool;</b>
<b class="fc">&nbsp;                    this.listener = listener;</b>
<b class="fc">&nbsp;                    this.plugins = plugins;</b>
<b class="fc">&nbsp;                    this.preprocessors = preprocessors;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Callable&lt;Dispatcher.Materializable&gt; call() throws Exception {
<b class="fc">&nbsp;                    listener.onDiscovery(typeName);</b>
<b class="fc">&nbsp;                    TypePool.Resolution resolution = typePool.describe(typeName);</b>
<b class="fc">&nbsp;                    if (resolution.isResolved()) {</b>
<b class="fc">&nbsp;                        TypeDescription typeDescription = resolution.resolve();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            if (!ignoredTypeMatcher.matches(typeDescription)) {</b>
<b class="fc">&nbsp;                                for (WithPreprocessor preprocessor : preprocessors) {</b>
<b class="fc">&nbsp;                                    preprocessor.onPreprocess(typeDescription, classFileLocator);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                                return new Resolved(typeDescription);</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                return new Ignored(typeDescription);</b>
&nbsp;                            }
<b class="nc">&nbsp;                        } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                            listener.onComplete(typeDescription);</b>
<b class="nc">&nbsp;                            if (throwable instanceof Exception) {</b>
<b class="nc">&nbsp;                                throw (Exception) throwable;</b>
<b class="nc">&nbsp;                            } else if (throwable instanceof Error) {</b>
<b class="nc">&nbsp;                                throw (Error) throwable;</b>
&nbsp;                            } else {
<b class="nc">&nbsp;                                throw new IllegalStateException(throwable);</b>
&nbsp;                            }
&nbsp;                        }
&nbsp;                    } else {
<b class="fc">&nbsp;                        return new Unresolved();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A resolved materializable.
&nbsp;                 */
<b class="fc">&nbsp;                private class Resolved implements Callable&lt;Dispatcher.Materializable&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the resolved type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new resolved materializable.
&nbsp;                     *
&nbsp;                     * @param typeDescription A description of the resolved type.
&nbsp;                     */
<b class="fc">&nbsp;                    private Resolved(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Dispatcher.Materializable call() {
<b class="fc">&nbsp;                        List&lt;Plugin&gt; applied = new ArrayList&lt;Plugin&gt;(), ignored = new ArrayList&lt;Plugin&gt;();</b>
<b class="fc">&nbsp;                        List&lt;Throwable&gt; errored = new ArrayList&lt;Throwable&gt;();</b>
&nbsp;                        try {
<b class="fc">&nbsp;                            DynamicType.Builder&lt;?&gt; builder = typeStrategy.builder(byteBuddy, typeDescription, classFileLocator);</b>
<b class="fc">&nbsp;                            for (Plugin plugin : plugins) {</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    if (plugin.matches(typeDescription)) {</b>
<b class="fc">&nbsp;                                        builder = plugin.apply(builder, typeDescription, classFileLocator);</b>
<b class="fc">&nbsp;                                        listener.onTransformation(typeDescription, plugin);</b>
<b class="fc">&nbsp;                                        applied.add(plugin);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        listener.onIgnored(typeDescription, plugin);</b>
<b class="fc">&nbsp;                                        ignored.add(plugin);</b>
&nbsp;                                    }
<b class="fc">&nbsp;                                } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                                    listener.onError(typeDescription, plugin, throwable);</b>
<b class="fc">&nbsp;                                    errored.add(throwable);</b>
<b class="fc">&nbsp;                                }</b>
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            if (!errored.isEmpty()) {</b>
<b class="fc">&nbsp;                                listener.onError(typeDescription, errored);</b>
<b class="fc">&nbsp;                                return new Dispatcher.Materializable.ForFailedElement(element, typeDescription, errored);</b>
<b class="fc">&nbsp;                            } else if (!applied.isEmpty()) {</b>
&nbsp;                                try {
<b class="fc">&nbsp;                                    DynamicType dynamicType = builder.make(TypeResolutionStrategy.Disabled.INSTANCE, typePool);</b>
<b class="fc">&nbsp;                                    listener.onTransformation(typeDescription, applied);</b>
<b class="fc">&nbsp;                                    for (Map.Entry&lt;TypeDescription, LoadedTypeInitializer&gt; entry : dynamicType.getLoadedTypeInitializers().entrySet()) {</b>
<b class="fc">&nbsp;                                        if (entry.getValue().isAlive()) {</b>
<b class="fc">&nbsp;                                            listener.onLiveInitializer(typeDescription, entry.getKey());</b>
&nbsp;                                        }
<b class="fc">&nbsp;                                    }</b>
<b class="fc">&nbsp;                                    return new Dispatcher.Materializable.ForTransformedElement(dynamicType);</b>
<b class="fc">&nbsp;                                } catch (Throwable throwable) {</b>
<b class="fc">&nbsp;                                    errored.add(throwable);</b>
<b class="fc">&nbsp;                                    listener.onError(typeDescription, errored);</b>
<b class="fc">&nbsp;                                    return new Dispatcher.Materializable.ForFailedElement(element, typeDescription, errored);</b>
&nbsp;                                }
&nbsp;                            } else {
<b class="fc">&nbsp;                                listener.onIgnored(typeDescription, ignored);</b>
<b class="fc">&nbsp;                                return new Dispatcher.Materializable.ForRetainedElement(element);</b>
&nbsp;                            }
&nbsp;                        } finally {
<b class="fc">&nbsp;                            listener.onComplete(typeDescription);</b>
<b class="fc">&nbsp;                        }</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A materializable for an ignored element.
&nbsp;                 */
<b class="fc">&nbsp;                private class Ignored implements Callable&lt;Dispatcher.Materializable&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * A description of the ignored type.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A materializable for an ignored element.
&nbsp;                     *
&nbsp;                     * @param typeDescription A description of the ignored type.
&nbsp;                     */
<b class="fc">&nbsp;                    private Ignored(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Dispatcher.Materializable call() {
&nbsp;                        try {
<b class="fc">&nbsp;                            listener.onIgnored(typeDescription, plugins);</b>
&nbsp;                        } finally {
<b class="fc">&nbsp;                            listener.onComplete(typeDescription);</b>
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return new Dispatcher.Materializable.ForRetainedElement(element);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A materializable that represents an unresolved type.
&nbsp;                 */
<b class="fc">&nbsp;                private class Unresolved implements Callable&lt;Dispatcher.Materializable&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Dispatcher.Materializable call() {
<b class="fc">&nbsp;                        listener.onUnresolved(typeName);</b>
<b class="fc">&nbsp;                        return new Dispatcher.Materializable.ForUnresolvedElement(element, typeName);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A non-operational plugin that does not instrument any type. This plugin does not need to be closed.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;    class NoOp implements Plugin, Plugin.Factory {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Plugin make() {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean matches(@MaybeNull TypeDescription target) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public DynamicType.Builder&lt;?&gt; apply(DynamicType.Builder&lt;?&gt; builder, TypeDescription typeDescription, ClassFileLocator classFileLocator) {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot apply non-operational plugin&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void close() {
&nbsp;            /* do nothing */
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base for a {@link Plugin} that matches types by a given {@link ElementMatcher}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    abstract class ForElementMatcher implements Plugin {
&nbsp;
&nbsp;        /**
&nbsp;         * The element matcher to apply.
&nbsp;         */
&nbsp;        private final ElementMatcher&lt;? super TypeDescription&gt; matcher;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new plugin that matches types using an element matcher.
&nbsp;         *
&nbsp;         * @param matcher The element matcher to apply.
&nbsp;         */
<b class="fc">&nbsp;        protected ForElementMatcher(ElementMatcher&lt;? super TypeDescription&gt; matcher) {</b>
<b class="fc">&nbsp;            this.matcher = matcher;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean matches(@MaybeNull TypeDescription target) {
<b class="fc">&nbsp;            return matcher.matches(target);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
