


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ByteBuddyMojo</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.build.maven</a>
</div>

<h1>Coverage Summary for Class: ByteBuddyMojo (net.bytebuddy.build.maven)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">ByteBuddyMojo</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/168)
  </span>
</td>
</tr>
  <tr>
    <td class="name">ByteBuddyMojo$1</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$Coordinate</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$FilePrefixMatcher</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$ForProductionTypes</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$ForProductionTypes$WithExtendedDependencies</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$ForProductionTypes$WithoutRuntimeDependencies</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$ForProductionTypes$WithRuntimeDependencies</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$ForTestTypes</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$MavenBuildLogger</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$StalenessFilter</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$TransformationLogger</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$Transformer</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$Transformer$ForConfiguredPlugin</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$Transformer$ForDiscoveredPlugin</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ByteBuddyMojo$Transformer$ForDiscoveredPlugin$FromClassLoader</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/9)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/272)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.build.maven;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.BuildLogger;
&nbsp;import net.bytebuddy.build.EntryPoint;
&nbsp;import net.bytebuddy.build.Plugin;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.dynamic.ClassFileLocator;
&nbsp;import net.bytebuddy.dynamic.scaffold.inline.MethodNameTransformer;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.nullability.UnknownNull;
&nbsp;import org.apache.maven.artifact.Artifact;
&nbsp;import org.apache.maven.artifact.DependencyResolutionRequiredException;
&nbsp;import org.apache.maven.model.Dependency;
&nbsp;import org.apache.maven.model.PluginManagement;
&nbsp;import org.apache.maven.plugin.AbstractMojo;
&nbsp;import org.apache.maven.plugin.MojoExecution;
&nbsp;import org.apache.maven.plugin.MojoExecutionException;
&nbsp;import org.apache.maven.plugin.MojoFailureException;
&nbsp;import org.apache.maven.plugin.logging.Log;
&nbsp;import org.apache.maven.plugins.annotations.Component;
&nbsp;import org.apache.maven.plugins.annotations.LifecyclePhase;
&nbsp;import org.apache.maven.plugins.annotations.Mojo;
&nbsp;import org.apache.maven.plugins.annotations.Parameter;
&nbsp;import org.apache.maven.plugins.annotations.ResolutionScope;
&nbsp;import org.apache.maven.project.MavenProject;
&nbsp;import org.apache.maven.repository.internal.MavenRepositorySystemUtils;
&nbsp;import org.codehaus.plexus.util.Scanner;
&nbsp;import org.codehaus.plexus.util.xml.Xpp3Dom;
&nbsp;import org.eclipse.aether.RepositorySystem;
&nbsp;import org.eclipse.aether.RepositorySystemSession;
&nbsp;import org.sonatype.plexus.build.incremental.BuildContext;
&nbsp;
&nbsp;import java.io.BufferedReader;
&nbsp;import java.io.File;
&nbsp;import java.io.FileInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.InputStreamReader;
&nbsp;import java.net.MalformedURLException;
&nbsp;import java.net.URL;
&nbsp;import java.net.URLClassLoader;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.Enumeration;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Set;
&nbsp;import java.util.jar.JarEntry;
&nbsp;import java.util.jar.JarFile;
&nbsp;
&nbsp;/**
&nbsp; * A Maven plugin for applying Byte Buddy transformations during a build.
&nbsp; */
<b class="nc">&nbsp;public abstract class ByteBuddyMojo extends AbstractMojo {</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The file extension for Java source files.
&nbsp;     */
&nbsp;    private static final String JAVA_FILE_EXTENSION = &quot;.java&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The file extension for Java class files.
&nbsp;     */
&nbsp;    private static final String JAVA_CLASS_EXTENSION = &quot;.class&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The build context to support incremental builds.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @Component
&nbsp;    public BuildContext context;
&nbsp;
&nbsp;    /**
&nbsp;     * The Maven project.
&nbsp;     */
&nbsp;    @UnknownNull
&nbsp;    @Parameter(defaultValue = &quot;${project}&quot;, readonly = true)
&nbsp;    public MavenProject project;
&nbsp;
&nbsp;    /**
&nbsp;     * The current execution of this plugin.
&nbsp;     */
&nbsp;    @UnknownNull
&nbsp;    @Parameter(defaultValue = &quot;${mojoExecution}&quot;, readonly = true)
&nbsp;    public MojoExecution execution;
&nbsp;
&nbsp;    /**
&nbsp;     * The currently used repository system.
&nbsp;     */
&nbsp;    @UnknownNull
&nbsp;    @Component
&nbsp;    public RepositorySystem repositorySystem;
&nbsp;
&nbsp;    /**
&nbsp;     * The currently used system session for the repository system.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @Parameter(defaultValue = &quot;${repositorySystemSession}&quot;, readonly = true)
&nbsp;    public RepositorySystemSession repositorySystemSession;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * The list of transformations. A transformation &lt;b&gt;must&lt;/b&gt; specify the {@code plugin} property, containing the name of a class to apply.
&nbsp;     * Additionally, it is possible to optionally specify Maven coordinates for a project that contains this plugin class as {@code groupId},
&nbsp;     * {@code artifactId} and {@code version}. If any of the latter properties is not set, this projects coordinate is used.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * For example, the following configuration applies the {@code foo.Bar} class which must implement {@link Plugin} from artifact
&nbsp;     * {@code transform-artifact} with this project&#39;s group and version:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
&nbsp;     * &lt;transformations&gt;
&nbsp;     *   &lt;transformation&gt;
&nbsp;     *     &lt;plugin&gt;foo.Bar&lt; /plugin&gt;
&nbsp;     *     &lt;artifactId&gt;transform-artifact&lt; /artifactId&gt;
&nbsp;     *   &lt; /transformation&gt;
&nbsp;     * &lt; /transformations&gt;
&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * If the list of {@code transformations} is empty or is not supplied at all, this plugin does not apply but prints a warning.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @Parameter
&nbsp;    public List&lt;Transformation&gt; transformations;
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * The initializer used for creating a {@link net.bytebuddy.ByteBuddy} instance and for applying a transformation. By default,
&nbsp;     * a type is rebased. The initializer&#39;s {@code entryPoint} property can be set to any constant name of {@link EntryPoint.Default}
&nbsp;     * or to a class name. If the latter applies, it is possible to set Maven coordinates for a Maven plugin which defines this
&nbsp;     * class where any property defaults to this project&#39;s coordinates.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * For example, the following configuration applies the {@code foo.Qux} class which must implement {@link EntryPoint} from
&nbsp;     * artifact {@code initialization-artifact} with this project&#39;s group and version:
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;blockquote&gt;&lt;pre&gt;{@code
&nbsp;     * &lt;initialization&gt;
&nbsp;     *   &lt;entryPoint&gt;foo.Qux&lt; /entryPoint&gt;
&nbsp;     *   &lt;artifactId&gt;initialization-artifact&lt; /artifactId&gt;
&nbsp;     * &lt; /initialization&gt;
&nbsp;     * }&lt;/pre&gt;&lt;/blockquote&gt;
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @Parameter
&nbsp;    public Initialization initialization;
&nbsp;
&nbsp;    /**
&nbsp;     * Specifies the method name suffix that is used when type&#39;s method need to be rebased. If this property is not
&nbsp;     * set or is empty, a random suffix will be appended to any rebased method. If this property is set, the supplied
&nbsp;     * value is appended to the original method name.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @Parameter
&nbsp;    public String suffix;
&nbsp;
&nbsp;    /**
&nbsp;     * When transforming classes during build time, it is not possible to apply any transformations which require a class
&nbsp;     * in its loaded state. Such transformations might imply setting a type&#39;s static field to a user interceptor or similar
&nbsp;     * transformations. If this property is set to {@code false}, this plugin does not throw an exception if such a live
&nbsp;     * initializer is defined during a transformation process.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;true&quot;, required = true)
&nbsp;    public boolean failOnLiveInitializer;
&nbsp;
&nbsp;    /**
&nbsp;     * When set to {@code true}, this mojo is not applied to the current module.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;false&quot;, required = true)
&nbsp;    public boolean skip;
&nbsp;
&nbsp;    /**
&nbsp;     * When set to {@code true}, this mojo warns of an non-existent output directory.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;true&quot;, required = true)
&nbsp;    public boolean warnOnMissingOutputDirectory;
&nbsp;
&nbsp;    /**
&nbsp;     * When set to {@code true}, this mojo warns of not having transformed any types.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;true&quot;, required = true)
&nbsp;    public boolean warnOnEmptyTypeSet;
&nbsp;
&nbsp;    /**
&nbsp;     * When set to {@code true}, this mojo fails immediately if a plugin cannot be applied.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;true&quot;, required = true)
&nbsp;    public boolean failFast;
&nbsp;
&nbsp;    /**
&nbsp;     * When set to {@code true}, the debug information of class files should be parsed to extract parameter names.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;false&quot;, required = true)
&nbsp;    public boolean extendedParsing;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if the build should discover Byte Buddy build plugins on this Maven plugin&#39;s class loader.
&nbsp;     * Discovered plugins are stored by their name in the &lt;i&gt;/META-INF/net.bytebuddy/build.plugins&lt;/i&gt; file
&nbsp;     * where each line contains the fully qualified class name. Discovered plugins are not provided with any
&nbsp;     * explicit constructor arguments.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    @Parameter(defaultValue = &quot;EMPTY&quot;, required = true)
&nbsp;    public Discovery discovery;
&nbsp;
&nbsp;    /**
&nbsp;     * Scans the class path (or test class path) for Byte Buddy plugins to apply. This is not normally recommended as
&nbsp;     * it might cause a spurious application of plugins that are accidentally configured on the class path. It can
&nbsp;     * however serve as a convenience in projects with few dependencies where this allows for the use of Maven&#39;s
&nbsp;     * dependency version management.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;false&quot;, required = true)
&nbsp;    public boolean classPathDiscovery;
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates the amount of threads used for parallel type processing or {@code 0} for serial processing.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;0&quot;, required = true)
&nbsp;    public int threads;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines if plugins are attempted to be built incrementally.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;false&quot;, required = true)
&nbsp;    public boolean incremental;
&nbsp;
&nbsp;    /**
&nbsp;     * Determines the tolerance of many milliseconds between this plugin run and the last edit are permitted
&nbsp;     * for considering a file as stale if the plugin was executed before. Can be set to {@code -1} to disable.
&nbsp;     */
&nbsp;    @Parameter(defaultValue = &quot;0&quot;, required = true)
&nbsp;    public int staleMilliseconds;
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    public void execute() throws MojoExecutionException, MojoFailureException {
<b class="nc">&nbsp;        if (project == null || repositorySystem == null || discovery == null) {</b>
<b class="nc">&nbsp;            throw new MojoExecutionException(&quot;Plugin is not initialized correctly&quot;);</b>
<b class="nc">&nbsp;        } else if (skip) {</b>
<b class="nc">&nbsp;            getLog().info(&quot;Not applying instrumentation as a result of plugin configuration.&quot;);</b>
&nbsp;            return;
&nbsp;        }
<b class="nc">&nbsp;        List&lt;Transformer&gt; transformers = new ArrayList&lt;Transformer&gt;();</b>
<b class="nc">&nbsp;        Set&lt;String&gt; undiscoverable = new HashSet&lt;String&gt;();</b>
<b class="nc">&nbsp;        if (transformations != null) {</b>
<b class="nc">&nbsp;            for (Transformation transformation : transformations) {</b>
<b class="nc">&nbsp;                transformers.add(new Transformer.ForConfiguredPlugin(transformation));</b>
<b class="nc">&nbsp;                if (discovery.isRecordConfiguration()) {</b>
<b class="nc">&nbsp;                    undiscoverable.add(transformation.getPlugin());</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (discovery.isDiscover(transformers)) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                Enumeration&lt;URL&gt; plugins = ByteBuddyMojo.class.getClassLoader().getResources(Plugin.Engine.Default.PLUGIN_FILE);</b>
<b class="nc">&nbsp;                while (plugins.hasMoreElements()) {</b>
<b class="nc">&nbsp;                    discover(plugins.nextElement().openStream(), undiscoverable, transformers, null);</b>
&nbsp;                }
<b class="nc">&nbsp;                if (classPathDiscovery) {</b>
<b class="nc">&nbsp;                    List&lt;String&gt; elements = getClassPathElements();</b>
<b class="nc">&nbsp;                    for (String element : elements) {</b>
<b class="nc">&nbsp;                        File artifact = new File(element);</b>
<b class="nc">&nbsp;                        if (artifact.isFile()) {</b>
<b class="nc">&nbsp;                            JarFile file = new JarFile(artifact);</b>
&nbsp;                            try {
<b class="nc">&nbsp;                                JarEntry entry = file.getJarEntry(Plugin.Engine.Default.PLUGIN_FILE);</b>
<b class="nc">&nbsp;                                if (entry != null) {</b>
<b class="nc">&nbsp;                                    discover(file.getInputStream(entry), undiscoverable, transformers, elements);</b>
&nbsp;                                }
&nbsp;                            } finally {
<b class="nc">&nbsp;                                file.close();</b>
<b class="nc">&nbsp;                            }</b>
<b class="nc">&nbsp;                        } else {</b>
<b class="nc">&nbsp;                            File file = new File(artifact, Plugin.Engine.Default.PLUGIN_FILE);</b>
<b class="nc">&nbsp;                            if (file.exists()) {</b>
<b class="nc">&nbsp;                                discover(new FileInputStream(file), undiscoverable, transformers, elements);</b>
&nbsp;                            }
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (IOException exception) {</b>
<b class="nc">&nbsp;                throw new MojoExecutionException(&quot;Failed plugin discovery&quot;, exception);</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        if (transformers.isEmpty()) {</b>
<b class="nc">&nbsp;            getLog().warn(&quot;No transformations are specified or discovered. Skipping plugin application.&quot;);</b>
&nbsp;            return;
&nbsp;        } else {
<b class="nc">&nbsp;            getLog().debug(transformers.size() + &quot; plugins are being applied via configuration and discovery&quot;);</b>
&nbsp;        }
&nbsp;        try {
<b class="nc">&nbsp;            String sourceDirectory = getSourceDirectory();</b>
<b class="nc">&nbsp;            if (incremental &amp;&amp; context != null &amp;&amp; sourceDirectory != null) {</b>
<b class="nc">&nbsp;                getLog().debug(&quot;Considering incremental build with context: &quot; + context);</b>
&nbsp;                Plugin.Engine.Source source;
<b class="nc">&nbsp;                if (context.isIncremental()) {</b>
<b class="nc">&nbsp;                    Scanner scanner = context.newScanner(new File(sourceDirectory));</b>
<b class="nc">&nbsp;                    scanner.scan();</b>
<b class="nc">&nbsp;                    List&lt;String&gt; names = new ArrayList&lt;String&gt;();</b>
<b class="nc">&nbsp;                    for (String file : scanner.getIncludedFiles()) {</b>
<b class="nc">&nbsp;                        if (file.endsWith(JAVA_FILE_EXTENSION)) {</b>
<b class="nc">&nbsp;                            names.add(file.substring(0, file.length() - JAVA_FILE_EXTENSION.length()));</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                    source = new Plugin.Engine.Source.Filtering(new Plugin.Engine.Source.ForFolder(new File(getOutputDirectory())), new FilePrefixMatcher(names));</b>
<b class="nc">&nbsp;                    getLog().debug(&quot;Incrementally processing: &quot; + names);</b>
<b class="nc">&nbsp;                } else {</b>
<b class="nc">&nbsp;                    source = new Plugin.Engine.Source.ForFolder(new File(getOutputDirectory()));</b>
<b class="nc">&nbsp;                    getLog().debug(&quot;Cannot build incrementally - all class files are processed&quot;);</b>
&nbsp;                }
<b class="nc">&nbsp;                Plugin.Engine.Summary summary = apply(new File(getOutputDirectory()), getClassPathElements(), transformers, source, true);</b>
<b class="nc">&nbsp;                for (TypeDescription typeDescription : summary.getTransformed()) {</b>
<b class="nc">&nbsp;                    context.refresh(new File(getOutputDirectory(), typeDescription.getName() + JAVA_CLASS_EXTENSION));</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            } else {</b>
<b class="nc">&nbsp;                getLog().debug(&quot;Not applying incremental build with context: &quot; + context);</b>
<b class="nc">&nbsp;                apply(new File(getOutputDirectory()), getClassPathElements(), transformers, new Plugin.Engine.Source.ForFolder(new File(getOutputDirectory())), false);</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (IOException exception) {</b>
<b class="nc">&nbsp;            throw new MojoFailureException(&quot;Error during writing process&quot;, exception);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the output directory to search for class files.
&nbsp;     *
&nbsp;     * @return The output directory to search for class files.
&nbsp;     */
&nbsp;    protected abstract String getOutputDirectory();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the source directory that determines the class files to process.
&nbsp;     *
&nbsp;     * @return The source directory that serves as an input for the transformation.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    protected abstract String getSourceDirectory();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the class path elements of the relevant output directory.
&nbsp;     *
&nbsp;     * @return The class path elements of the relevant output directory.
&nbsp;     * @throws MojoFailureException If the class path cannot be resolved.
&nbsp;     */
&nbsp;    protected abstract List&lt;String&gt; getClassPathElements() throws MojoFailureException;
&nbsp;
&nbsp;    /**
&nbsp;     * Applies the instrumentation.
&nbsp;     *
&nbsp;     * @param root         The root folder that contains all class files.
&nbsp;     * @param classPath    An iterable over all class path elements.
&nbsp;     * @param transformers The transformers to apply.
&nbsp;     * @param source       The source for the plugin&#39;s application.
&nbsp;     * @param filtered     {@code true} if files are already filtered and should not be checked for staleness.
&nbsp;     * @return A summary of the applied transformation.
&nbsp;     * @throws MojoExecutionException If the plugin cannot be applied.
&nbsp;     * @throws IOException            If an I/O exception occurs.
&nbsp;     */
&nbsp;    @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;    private Plugin.Engine.Summary apply(File root,
&nbsp;                                        List&lt;? extends String&gt; classPath,
&nbsp;                                        List&lt;Transformer&gt; transformers,
&nbsp;                                        Plugin.Engine.Source source,
&nbsp;                                        boolean filtered) throws MojoExecutionException, IOException {
<b class="nc">&nbsp;        if (!root.exists()) {</b>
<b class="nc">&nbsp;            if (warnOnMissingOutputDirectory) {</b>
<b class="nc">&nbsp;                getLog().warn(&quot;Skipping instrumentation due to missing directory: &quot; + root);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                getLog().info(&quot;Skipping instrumentation due to missing directory: &quot; + root);</b>
&nbsp;            }
<b class="nc">&nbsp;            return new Plugin.Engine.Summary(Collections.&lt;TypeDescription&gt;emptyList(), Collections.&lt;TypeDescription, List&lt;Throwable&gt;&gt;emptyMap(), Collections.&lt;String&gt;emptyList());</b>
<b class="nc">&nbsp;        } else if (!root.isDirectory()) {</b>
<b class="nc">&nbsp;            throw new MojoExecutionException(&quot;Not a directory: &quot; + root);</b>
&nbsp;        }
<b class="nc">&nbsp;        File staleness = new File(project.getBuild().getDirectory(), &quot;maven-status&quot;</b>
<b class="nc">&nbsp;                + File.separator + execution.getArtifactId()</b>
<b class="nc">&nbsp;                + File.separator + execution.getGoal()</b>
<b class="nc">&nbsp;                + File.separator + execution.getExecutionId()</b>
&nbsp;                + File.separator + &quot;staleness&quot;);
&nbsp;        StalenessFilter stalenessFilter;
<b class="nc">&nbsp;        if (filtered || staleMilliseconds &lt; 0) {</b>
<b class="nc">&nbsp;            stalenessFilter = null;</b>
<b class="nc">&nbsp;            getLog().debug(&quot;Stale file detection is disabled&quot;);</b>
<b class="nc">&nbsp;        } else if (staleness.exists()) {</b>
<b class="nc">&nbsp;            stalenessFilter = new StalenessFilter(getLog(), staleness.lastModified() + staleMilliseconds);</b>
<b class="nc">&nbsp;            source = new Plugin.Engine.Source.Filtering(source, stalenessFilter);</b>
<b class="nc">&nbsp;            getLog().debug(&quot;Using stale file detection with a margin of &quot; + staleMilliseconds + &quot; milliseconds&quot;);</b>
&nbsp;        } else {
<b class="nc">&nbsp;            stalenessFilter = null;</b>
<b class="nc">&nbsp;            getLog().debug(&quot;Did not discover previous staleness file&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        Map&lt;Coordinate, String&gt; coordinates = new HashMap&lt;Coordinate, String&gt;();</b>
<b class="nc">&nbsp;        if (project.getDependencyManagement() != null) {</b>
<b class="nc">&nbsp;            for (Dependency dependency : project.getDependencyManagement().getDependencies()) {</b>
<b class="nc">&nbsp;                coordinates.put(new Coordinate(dependency.getGroupId(), dependency.getArtifactId()), dependency.getVersion());</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="nc">&nbsp;        ClassLoaderResolver classLoaderResolver = new ClassLoaderResolver(getLog(), repositorySystem, repositorySystemSession == null ? MavenRepositorySystemUtils.newSession() : repositorySystemSession, project.getRemotePluginRepositories());</b>
&nbsp;        try {
<b class="nc">&nbsp;            List&lt;Plugin.Factory&gt; factories = new ArrayList&lt;Plugin.Factory&gt;(transformers.size());</b>
<b class="nc">&nbsp;            for (Transformer transformer : transformers) {</b>
<b class="nc">&nbsp;                String plugin = transformer.getPlugin();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    factories.add(new Plugin.Factory.UsingReflection((Class&lt;? extends Plugin&gt;) Class.forName(plugin, false, transformer.toClassLoader(classLoaderResolver, coordinates, project.getGroupId(), project.getArtifactId(), project.getVersion(), project.getPackaging())))</b>
<b class="nc">&nbsp;                            .with(transformer.toArgumentResolvers())</b>
<b class="nc">&nbsp;                            .with(Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(File.class, root),</b>
<b class="nc">&nbsp;                                    Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(Log.class, getLog()),</b>
<b class="nc">&nbsp;                                    Plugin.Factory.UsingReflection.ArgumentResolver.ForType.of(BuildLogger.class, new MavenBuildLogger(getLog()))));</b>
<b class="nc">&nbsp;                    getLog().info(&quot;Resolved plugin: &quot; + plugin);</b>
<b class="nc">&nbsp;                } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                    throw new MojoExecutionException(&quot;Cannot resolve plugin: &quot; + plugin, throwable);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            String managed = coordinates.get(new Coordinate(project.getGroupId(), project.getArtifactId()));</b>
<b class="nc">&nbsp;            EntryPoint entryPoint = (initialization == null ? new Initialization() : initialization).getEntryPoint(classLoaderResolver, project.getGroupId(), project.getArtifactId(), managed == null ? project.getVersion() : managed, project.getPackaging());</b>
<b class="nc">&nbsp;            getLog().info(&quot;Resolved entry point: &quot; + entryPoint);</b>
<b class="nc">&nbsp;            List&lt;ClassFileLocator&gt; classFileLocators = new ArrayList&lt;ClassFileLocator&gt;(classPath.size());</b>
<b class="nc">&nbsp;            classFileLocators.add(ClassFileLocator.ForClassLoader.ofPlatformLoader());</b>
<b class="nc">&nbsp;            for (String target : classPath) {</b>
<b class="nc">&nbsp;                File artifact = new File(target);</b>
<b class="nc">&nbsp;                classFileLocators.add(artifact.isFile() ? ClassFileLocator.ForJarFile.of(artifact) : new ClassFileLocator.ForFolder(artifact));</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            ClassFileLocator classFileLocator = new ClassFileLocator.Compound(classFileLocators);</b>
&nbsp;            Plugin.Engine.Summary summary;
&nbsp;            try {
<b class="nc">&nbsp;                getLog().info(&quot;Processing class files located in in: &quot; + root);</b>
&nbsp;                Plugin.Engine pluginEngine;
&nbsp;                try {
<b class="nc">&nbsp;                    String javaVersionString = findJavaVersionString(project, &quot;release&quot;);</b>
<b class="nc">&nbsp;                    if (javaVersionString == null) {</b>
<b class="nc">&nbsp;                        javaVersionString = findJavaVersionString(project, &quot;target&quot;);</b>
&nbsp;                    }
&nbsp;                    ClassFileVersion classFileVersion;
<b class="nc">&nbsp;                    if (javaVersionString == null) {</b>
<b class="nc">&nbsp;                        classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);</b>
<b class="nc">&nbsp;                        getLog().warn(&quot;Could not locate Java target version, build is JDK dependant: &quot; + classFileVersion.getMajorVersion());</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        classFileVersion = ClassFileVersion.ofJavaVersionString(javaVersionString);</b>
<b class="nc">&nbsp;                        getLog().debug(&quot;Java version detected: &quot; + javaVersionString);</b>
&nbsp;                    }
<b class="nc">&nbsp;                    pluginEngine = Plugin.Engine.Default.of(entryPoint, classFileVersion, suffix == null || suffix.length() == 0 ? MethodNameTransformer.Suffixing.withRandomSuffix() : new MethodNameTransformer.Suffixing(suffix));</b>
<b class="nc">&nbsp;                } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                    throw new MojoExecutionException(&quot;Cannot create plugin engine&quot;, throwable);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;                try {
<b class="nc">&nbsp;                    summary = pluginEngine.with(extendedParsing ? Plugin.Engine.PoolStrategy.Default.EXTENDED : Plugin.Engine.PoolStrategy.Default.FAST).with(classFileLocator).with(new TransformationLogger(getLog())).withErrorHandlers(Plugin.Engine.ErrorHandler.Enforcing.ALL_TYPES_RESOLVED, failOnLiveInitializer ? Plugin.Engine.ErrorHandler.Enforcing.NO_LIVE_INITIALIZERS : Plugin.Engine.Listener.NoOp.INSTANCE, failFast ? Plugin.Engine.ErrorHandler.Failing.FAIL_FAST : Plugin.Engine.ErrorHandler.Failing.FAIL_LAST).with(threads == 0 ? Plugin.Engine.Dispatcher.ForSerialTransformation.Factory.INSTANCE : new Plugin.Engine.Dispatcher.ForParallelTransformation.WithThrowawayExecutorService.Factory(threads)).apply(source, new Plugin.Engine.Target.ForFolder(root), factories);</b>
<b class="nc">&nbsp;                } catch (Throwable throwable) {</b>
<b class="nc">&nbsp;                    throw new MojoExecutionException(&quot;Failed to transform class files in &quot; + root, throwable);</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            } finally {
<b class="nc">&nbsp;                classFileLocator.close();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            if (!summary.getFailed().isEmpty()) {</b>
<b class="nc">&nbsp;                throw new MojoExecutionException(summary.getFailed() + &quot; type transformation(s) have failed&quot;);</b>
<b class="nc">&nbsp;            } else if (warnOnEmptyTypeSet &amp;&amp; summary.getTransformed().isEmpty()) {</b>
<b class="nc">&nbsp;                if (stalenessFilter != null &amp;&amp; stalenessFilter.getFiltered() &gt; 0) {</b>
<b class="nc">&nbsp;                    getLog().info(&quot;No types were transformed during plugin execution but &quot; + stalenessFilter.getFiltered() + &quot; class file(s) were considered stale&quot;);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    getLog().warn(&quot;No types were transformed during plugin execution&quot;);</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                getLog().info(&quot;Transformed &quot; + summary.getTransformed().size() + &quot; type(s)&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (!(staleness.getParentFile().isDirectory() || staleness.getParentFile().mkdirs()) || (!staleness.createNewFile() &amp;&amp; (!staleness.delete() || !staleness.createNewFile()))) {</b>
<b class="nc">&nbsp;                throw new MojoExecutionException(&quot;Failed to define instrumentation staleness: &quot; + staleness.getAbsolutePath());</b>
&nbsp;            }
<b class="nc">&nbsp;            return summary;</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            classLoaderResolver.close();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Discovers plugins from an input stream representing a &lt;i&gt;META-INF/net.bytebuddy/build.plugins&lt;/i&gt; file.
&nbsp;     *
&nbsp;     * @param inputStream    The input stream to read from.
&nbsp;     * @param undiscoverable A set of undiscoverable plugins.
&nbsp;     * @param transformers   The list of transformers to add discovered plugins to.
&nbsp;     * @param classPath      The class path elements to add if a plugin is loaded from the class path or {@code null} if the plugin is discovered as a dependency
&nbsp;     * @throws IOException If an I/O exception occurs.
&nbsp;     */
&nbsp;    private void discover(InputStream inputStream, Set&lt;String&gt; undiscoverable, List&lt;Transformer&gt; transformers, @MaybeNull List&lt;String&gt; classPath) throws IOException {
<b class="nc">&nbsp;        BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream, &quot;UTF-8&quot;));</b>
&nbsp;        try {
&nbsp;            String line;
<b class="nc">&nbsp;            while ((line = reader.readLine()) != null) {</b>
<b class="nc">&nbsp;                if (undiscoverable.add(line)) {</b>
<b class="nc">&nbsp;                    transformers.add(classPath == null</b>
<b class="nc">&nbsp;                            ? new Transformer.ForDiscoveredPlugin(line)</b>
<b class="nc">&nbsp;                            : new Transformer.ForDiscoveredPlugin.FromClassLoader(line, classPath));</b>
<b class="nc">&nbsp;                    getLog().debug(&quot;Registered discovered plugin: &quot; + line);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    getLog().info(&quot;Skipping discovered plugin &quot; + line + &quot; which was previously discovered or registered&quot;);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        } finally {
<b class="nc">&nbsp;            reader.close();</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Makes a best effort of locating the configured Java version.
&nbsp;     *
&nbsp;     * @param project  The relevant Maven project.
&nbsp;     * @param property The targeted Maven property.
&nbsp;     * @return The Java version string of the configured build Java version or {@code null} if no explicit configuration was detected.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    private static String findJavaVersionString(MavenProject project, String property) {
&nbsp;        do {
<b class="nc">&nbsp;            String value = project.getProperties().getProperty(&quot;maven.compiler.&quot; + property);</b>
<b class="nc">&nbsp;            if (value != null) {</b>
<b class="nc">&nbsp;                return value;</b>
&nbsp;            }
<b class="nc">&nbsp;            PluginManagement management = project.getPluginManagement();</b>
<b class="nc">&nbsp;            for (org.apache.maven.model.Plugin plugin : management == null ? project.getBuildPlugins() : CompoundList.of(project.getBuildPlugins(), management.getPlugins())) {</b>
<b class="nc">&nbsp;                if (&quot;maven-compiler-plugin&quot;.equals(plugin.getArtifactId())) {</b>
<b class="nc">&nbsp;                    if (plugin.getConfiguration() instanceof Xpp3Dom) {</b>
<b class="nc">&nbsp;                        Xpp3Dom node = ((Xpp3Dom) plugin.getConfiguration()).getChild(property);</b>
<b class="nc">&nbsp;                        if (node != null) {</b>
<b class="nc">&nbsp;                            return node.getValue();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            project = project.getParent();</b>
<b class="nc">&nbsp;        } while (project != null);</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Matches elements which represent a Java class that is represented in the list or an inner class of the classes represented in the list.
&nbsp;     */
<b class="nc">&nbsp;    private static class FilePrefixMatcher extends ElementMatcher.Junction.ForNonNullValues&lt;Plugin.Engine.Source.Element&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A list of names to match.
&nbsp;         */
&nbsp;        private final List&lt;String&gt; names;
&nbsp;
&nbsp;        /**
&nbsp;         * Create a new matcher for a list of names.
&nbsp;         *
&nbsp;         * @param names A list of included names.
&nbsp;         */
<b class="nc">&nbsp;        private FilePrefixMatcher(List&lt;String&gt; names) {</b>
<b class="nc">&nbsp;            this.names = names;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        protected boolean doMatch(Plugin.Engine.Source.Element target) {
<b class="nc">&nbsp;            for (String name : names) {</b>
<b class="nc">&nbsp;                if (target.getName().equals(name + JAVA_CLASS_EXTENSION) || target.getName().startsWith(name + &quot;$&quot;) &amp;&amp; target.getName().endsWith(JAVA_CLASS_EXTENSION)) {</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A Byte Buddy plugin that transforms a project&#39;s production class files.
&nbsp;     */
<b class="nc">&nbsp;    public abstract static class ForProductionTypes extends ByteBuddyMojo {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        protected String getOutputDirectory() {
<b class="nc">&nbsp;            return project.getBuild().getOutputDirectory();</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        @Override
&nbsp;        protected String getSourceDirectory() {
<b class="nc">&nbsp;            return project.getBuild().getSourceDirectory();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A Byte Buddy plugin that transforms a project&#39;s production class files where runtime class
&nbsp;         * path elements are not included.
&nbsp;         */
&nbsp;        @Mojo(name = &quot;transform&quot;, defaultPhase = LifecyclePhase.PROCESS_CLASSES, threadSafe = true, requiresDependencyResolution = ResolutionScope.COMPILE)
<b class="nc">&nbsp;        public static class WithoutRuntimeDependencies extends ForProductionTypes {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;String&gt; getClassPathElements() throws MojoFailureException {
&nbsp;                try {
<b class="nc">&nbsp;                    return project.getCompileClasspathElements();</b>
<b class="nc">&nbsp;                } catch (DependencyResolutionRequiredException e) {</b>
<b class="nc">&nbsp;                    throw new MojoFailureException(&quot;Could not resolve class path&quot;, e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A Byte Buddy plugin that transforms a project&#39;s production class files where runtime class
&nbsp;         * path elements are included.
&nbsp;         */
&nbsp;        @Mojo(name = &quot;transform-runtime&quot;, defaultPhase = LifecyclePhase.PROCESS_CLASSES, threadSafe = true, requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)
<b class="nc">&nbsp;        public static class WithRuntimeDependencies extends ForProductionTypes {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;String&gt; getClassPathElements() {
&nbsp;                try {
<b class="nc">&nbsp;                    return project.getRuntimeClasspathElements();</b>
<b class="nc">&nbsp;                } catch (DependencyResolutionRequiredException e) {</b>
<b class="nc">&nbsp;                    throw new RuntimeException(e);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A Byte Buddy plugin that transforms a project&#39;s production class files where all scopes but the test scope are included.
&nbsp;         */
&nbsp;        @Mojo(name = &quot;transform-extended&quot;, defaultPhase = LifecyclePhase.PROCESS_CLASSES, threadSafe = true, requiresDependencyResolution = ResolutionScope.COMPILE_PLUS_RUNTIME)
<b class="nc">&nbsp;        public static class WithExtendedDependencies extends ForProductionTypes {</b>
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;String&gt; getClassPathElements() {
<b class="nc">&nbsp;                List&lt;String&gt; classPath = new ArrayList&lt;String&gt;(project.getArtifacts().size() + 1);</b>
<b class="nc">&nbsp;                String directory = project.getBuild().getOutputDirectory();</b>
<b class="nc">&nbsp;                if (directory != null) {</b>
<b class="nc">&nbsp;                    classPath.add(directory);</b>
&nbsp;                }
<b class="nc">&nbsp;                for (Artifact artifact : project.getArtifacts()) {</b>
<b class="nc">&nbsp;                    if (artifact.getArtifactHandler().isAddedToClasspath()</b>
<b class="nc">&nbsp;                            &amp;&amp; !Artifact.SCOPE_TEST.equals(artifact.getScope())</b>
<b class="nc">&nbsp;                            &amp;&amp; !Artifact.SCOPE_IMPORT.equals(artifact.getScope())) {</b>
<b class="nc">&nbsp;                        File file = artifact.getFile();</b>
<b class="nc">&nbsp;                        if (file != null) {</b>
<b class="nc">&nbsp;                            classPath.add(file.getPath());</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                return classPath;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A Byte Buddy plugin that transforms a project&#39;s test class files.
&nbsp;     */
&nbsp;    @Mojo(name = &quot;transform-test&quot;, defaultPhase = LifecyclePhase.PROCESS_TEST_CLASSES, threadSafe = true, requiresDependencyResolution = ResolutionScope.TEST)
<b class="nc">&nbsp;    public static class ForTestTypes extends ByteBuddyMojo {</b>
&nbsp;
&nbsp;        @Override
&nbsp;        protected String getOutputDirectory() {
<b class="nc">&nbsp;            return project.getBuild().getTestOutputDirectory();</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        @Override
&nbsp;        protected String getSourceDirectory() {
<b class="nc">&nbsp;            return project.getBuild().getTestSourceDirectory();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected List&lt;String&gt; getClassPathElements() throws MojoFailureException {
&nbsp;            try {
<b class="nc">&nbsp;                return project.getTestClasspathElements();</b>
<b class="nc">&nbsp;            } catch (DependencyResolutionRequiredException e) {</b>
<b class="nc">&nbsp;                throw new MojoFailureException(&quot;Could not resolve test class path&quot;, e);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link BuildLogger} implementation for a Maven {@link Log}.
&nbsp;     */
&nbsp;    protected static class MavenBuildLogger implements BuildLogger {
&nbsp;
&nbsp;        /**
&nbsp;         * The logger to delegate to.
&nbsp;         */
&nbsp;        private final Log log;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new Maven build logger.
&nbsp;         *
&nbsp;         * @param log The logger to delegate to.
&nbsp;         */
<b class="nc">&nbsp;        protected MavenBuildLogger(Log log) {</b>
<b class="nc">&nbsp;            this.log = log;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isDebugEnabled() {
<b class="nc">&nbsp;            return log.isDebugEnabled();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void debug(String message) {
<b class="nc">&nbsp;            log.debug(message);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void debug(String message, Throwable throwable) {
<b class="nc">&nbsp;            log.debug(message, throwable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInfoEnabled() {
<b class="nc">&nbsp;            return log.isInfoEnabled();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void info(String message) {
<b class="nc">&nbsp;            log.info(message);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void info(String message, Throwable throwable) {
<b class="nc">&nbsp;            log.info(message, throwable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isWarnEnabled() {
<b class="nc">&nbsp;            return log.isWarnEnabled();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void warn(String message) {
<b class="nc">&nbsp;            log.warn(message);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void warn(String message, Throwable throwable) {
<b class="nc">&nbsp;            log.warn(message, throwable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isErrorEnabled() {
<b class="nc">&nbsp;            return log.isErrorEnabled();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void error(String message) {
<b class="nc">&nbsp;            log.error(message);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public void error(String message, Throwable throwable) {
<b class="nc">&nbsp;            log.error(message, throwable);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A {@link Plugin.Engine.Listener} that logs several relevant events during the build.
&nbsp;     */
&nbsp;    protected static class TransformationLogger extends Plugin.Engine.Listener.Adapter {
&nbsp;
&nbsp;        /**
&nbsp;         * The logger to delegate to.
&nbsp;         */
&nbsp;        private final Log log;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new transformation logger.
&nbsp;         *
&nbsp;         * @param log The logger to delegate to.
&nbsp;         */
<b class="nc">&nbsp;        protected TransformationLogger(Log log) {</b>
<b class="nc">&nbsp;            this.log = log;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onTransformation(TypeDescription typeDescription, List&lt;Plugin&gt; plugins) {
<b class="nc">&nbsp;            log.debug(&quot;Transformed &quot; + typeDescription + &quot; using &quot; + plugins);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(TypeDescription typeDescription, Plugin plugin, Throwable throwable) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to transform &quot; + typeDescription + &quot; using &quot; + plugin, throwable);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Map&lt;TypeDescription, List&lt;Throwable&gt;&gt; throwables) {
<b class="nc">&nbsp;            log.warn(&quot;Failed to transform &quot; + throwables.size() + &quot; types&quot;);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onError(Plugin plugin, Throwable throwable) {
<b class="nc">&nbsp;            log.error(&quot;Failed to close &quot; + plugin, throwable);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public void onLiveInitializer(TypeDescription typeDescription, TypeDescription definingType) {
<b class="nc">&nbsp;            log.debug(&quot;Discovered live initializer for &quot; + definingType + &quot; as a result of transforming &quot; + typeDescription);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A transformer that is applied during the plugin&#39;s execution.
&nbsp;     */
<b class="nc">&nbsp;    protected abstract static class Transformer {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the plugin to apply.
&nbsp;         *
&nbsp;         * @return The name of the plugin to apply.
&nbsp;         * @throws MojoExecutionException If the plugin name was not set.
&nbsp;         */
&nbsp;        protected abstract String getPlugin() throws MojoExecutionException;
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the argument resolvers to use.
&nbsp;         *
&nbsp;         * @return The argument resolvers to use.
&nbsp;         */
&nbsp;        protected abstract List&lt;? extends Plugin.Factory.UsingReflection.ArgumentResolver&gt; toArgumentResolvers();
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves the class loader to use for resolving the plugin.
&nbsp;         *
&nbsp;         * @param classLoaderResolver The class loader resolver to use.
&nbsp;         * @param coordinates         The managed coordinates of this project.
&nbsp;         * @param groupId             The group id of this project.
&nbsp;         * @param artifactId          The artifact id of this project.
&nbsp;         * @param version             The version of this project.
&nbsp;         * @param packaging           The packaging of this project.
&nbsp;         * @return The class loader to use.
&nbsp;         * @throws MojoFailureException   If the class loader resolution yields a failure.
&nbsp;         * @throws MojoExecutionException The the class loader resolution is incorrect.
&nbsp;         */
&nbsp;        protected abstract ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map&lt;Coordinate, String&gt; coordinates, String groupId, String artifactId, String version, String packaging) throws MojoFailureException, MojoExecutionException;
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for an explicitly configured plugin.
&nbsp;         */
&nbsp;        protected static class ForConfiguredPlugin extends Transformer {
&nbsp;
&nbsp;            /**
&nbsp;             * The configured transformation.
&nbsp;             */
&nbsp;            private final Transformation transformation;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new transformer for an explicitly configured plugin.
&nbsp;             *
&nbsp;             * @param transformation The configured transformation.
&nbsp;             */
<b class="nc">&nbsp;            protected ForConfiguredPlugin(Transformation transformation) {</b>
<b class="nc">&nbsp;                this.transformation = transformation;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected String getPlugin() throws MojoExecutionException {
<b class="nc">&nbsp;                return transformation.getPlugin();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;? extends Plugin.Factory.UsingReflection.ArgumentResolver&gt; toArgumentResolvers() {
<b class="nc">&nbsp;                return transformation.makeArgumentResolvers();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map&lt;Coordinate, String&gt; coordinates, String groupId, String artifactId, String version, String packaging) throws MojoFailureException, MojoExecutionException {
<b class="nc">&nbsp;                String managed = coordinates.get(new Coordinate(transformation.getGroupId(groupId), transformation.getArtifactId(artifactId)));</b>
<b class="nc">&nbsp;                return classLoaderResolver.resolve(transformation.asCoordinate(groupId, artifactId, managed == null ? version : managed, packaging));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A transformer for a discovered plugin.
&nbsp;         */
&nbsp;        protected static class ForDiscoveredPlugin extends Transformer {
&nbsp;
&nbsp;            /**
&nbsp;             * The name of the discovered plugin.
&nbsp;             */
&nbsp;            private final String plugin;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new transformer for a discovered plugin.
&nbsp;             *
&nbsp;             * @param plugin The name of the discovered plugin.
&nbsp;             */
<b class="nc">&nbsp;            protected ForDiscoveredPlugin(String plugin) {</b>
<b class="nc">&nbsp;                this.plugin = plugin;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected String getPlugin() {
<b class="nc">&nbsp;                return plugin;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected List&lt;? extends Plugin.Factory.UsingReflection.ArgumentResolver&gt; toArgumentResolvers() {
<b class="nc">&nbsp;                return Collections.emptyList();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map&lt;Coordinate, String&gt; coordinates, String groupId, String artifactId, String version, String packaging) {
<b class="nc">&nbsp;                return ByteBuddyMojo.class.getClassLoader();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A transformer for a discovered plugin from the class path.
&nbsp;             */
&nbsp;            protected static class FromClassLoader extends ForDiscoveredPlugin {
&nbsp;
&nbsp;                /**
&nbsp;                 * The class path elements for loading this plugin.
&nbsp;                 */
&nbsp;                private final List&lt;String&gt; classPath;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new transformer for a discovered plugin from the class path.
&nbsp;                 *
&nbsp;                 * @param plugin    The name of the discovered plugin.
&nbsp;                 * @param classPath The class path elements for loading this plugin.
&nbsp;                 */
&nbsp;                protected FromClassLoader(String plugin, List&lt;String&gt; classPath) {
<b class="nc">&nbsp;                    super(plugin);</b>
<b class="nc">&nbsp;                    this.classPath = classPath;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @SuppressFBWarnings(value = &quot;DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED&quot;, justification = &quot;The security manager is not normally used within Maven&quot;)
&nbsp;                protected ClassLoader toClassLoader(ClassLoaderResolver classLoaderResolver, Map&lt;Coordinate, String&gt; coordinates, String groupId, String artifactId, String version, String packaging) {
<b class="nc">&nbsp;                    URL[] url = new URL[classPath.size()];</b>
<b class="nc">&nbsp;                    for (int index = 0; index &lt; classPath.size(); index++) {</b>
&nbsp;                        try {
<b class="nc">&nbsp;                            url[index] = new File(classPath.get(index)).toURI().toURL();</b>
<b class="nc">&nbsp;                        } catch (MalformedURLException exception) {</b>
<b class="nc">&nbsp;                            throw new IllegalStateException(&quot;Failed to resolve class path element to URL: &quot; + classPath.get(index), exception);</b>
<b class="nc">&nbsp;                        }</b>
&nbsp;                    }
<b class="nc">&nbsp;                    return new URLClassLoader(url, ByteBuddyMojo.class.getClassLoader());</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A coordinate to locate a managed dependency.
&nbsp;     */
&nbsp;    protected static class Coordinate {
&nbsp;
&nbsp;        /**
&nbsp;         * The managed dependency&#39;s group id.
&nbsp;         */
&nbsp;        private final String groupId;
&nbsp;
&nbsp;        /**
&nbsp;         * The managed dependency&#39;s artifact id.
&nbsp;         */
&nbsp;        private final String artifactId;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new coordinate for a managed dependency.
&nbsp;         *
&nbsp;         * @param groupId    The managed depencency&#39;s group id.
&nbsp;         * @param artifactId The managed depencency&#39;s artifact id.
&nbsp;         */
<b class="nc">&nbsp;        protected Coordinate(String groupId, String artifactId) {</b>
<b class="nc">&nbsp;            this.groupId = groupId;</b>
<b class="nc">&nbsp;            this.artifactId = artifactId;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = groupId.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + artifactId.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(Object other) {
<b class="nc">&nbsp;            if (this == other) return true;</b>
<b class="nc">&nbsp;            if (other == null || getClass() != other.getClass()) return false;</b>
&nbsp;
<b class="nc">&nbsp;            Coordinate that = (Coordinate) other;</b>
&nbsp;
<b class="nc">&nbsp;            if (!groupId.equals(that.groupId)) return false;</b>
<b class="nc">&nbsp;            return artifactId.equals(that.artifactId);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A filter for files that were written before a given timestamp, to avoid duplicate application.
&nbsp;     */
&nbsp;    protected static class StalenessFilter extends ElementMatcher.Junction.ForNonNullValues&lt;Plugin.Engine.Source.Element&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The logger to use.
&nbsp;         */
&nbsp;        private final Log log;
&nbsp;
&nbsp;        /**
&nbsp;         * The timestamp for files to be filtered if they were created before it.
&nbsp;         */
&nbsp;        private final long latestTimestamp;
&nbsp;
&nbsp;        /**
&nbsp;         * A count of class files that were filtered.
&nbsp;         */
&nbsp;        private int filtered;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new staleness filter.
&nbsp;         *
&nbsp;         * @param log             The logger to use.
&nbsp;         * @param latestTimestamp The timestamp for files to be filtered if they were created before it.
&nbsp;         */
<b class="nc">&nbsp;        protected StalenessFilter(Log log, long latestTimestamp) {</b>
<b class="nc">&nbsp;            this.log = log;</b>
<b class="nc">&nbsp;            this.latestTimestamp = latestTimestamp;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        protected boolean doMatch(Plugin.Engine.Source.Element target) {
<b class="nc">&nbsp;            File file = target.resolveAs(File.class);</b>
<b class="nc">&nbsp;            if (file == null) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Expected &quot; + target + &quot; to resolve to a file&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (file.lastModified() &lt; latestTimestamp) {</b>
<b class="nc">&nbsp;                filtered += 1;</b>
<b class="nc">&nbsp;                log.debug(&quot;Filtering &quot; + file + &quot; due to staleness: &quot; + file.lastModified());</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a count of class files that were filtered as they were created prior to the last build.
&nbsp;         *
&nbsp;         * @return The amount of filtered classes.
&nbsp;         */
&nbsp;        protected int getFiltered() {
<b class="nc">&nbsp;            return filtered;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
