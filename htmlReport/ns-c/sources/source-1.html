


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > AnnotationDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.annotation</a>
</div>

<h1>Coverage Summary for Class: AnnotationDescription (net.bytebuddy.description.annotation)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">AnnotationDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">AnnotationDescription$1</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (77/77)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$AnnotationInvocationHandler</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.6%
  </span>
  <span class="absValue">
    (71/87)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$Builder</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (36/38)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.8%
  </span>
  <span class="absValue">
    (59/68)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (11/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    94.7%
  </span>
  <span class="absValue">
    (90/95)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$0SUJwjVo</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$bFcoKNhO</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$ETWnEk95</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$foGGqzLj</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$GzDfjFFG</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$jUJ0lrbE</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$kUjd963p</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$LeDfmXDD</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$lyxkQkNs</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$nw68PMTR</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$RfKZetFr</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$Sawf28bd</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$ForLoadedAnnotation$MockitoMock$734744940$auxiliary$ZaZAgiff</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (17/17)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$Latent$Loadable</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$Loadable</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$MockitoMock$1698966055</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$MockitoMock$1698966055$auxiliary$Bg75l72f</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$MockitoMock$1698966055$auxiliary$OjG0Npw8</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$RenderingDispatcher</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$RenderingDispatcher$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">AnnotationDescription$RenderingDispatcher$2</td>
<td class="coverageStat">
  <span class="percent">
    33.3%
  </span>
  <span class="absValue">
    (1/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    25%
  </span>
  <span class="absValue">
    (1/4)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (84/90)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.3%
  </span>
  <span class="absValue">
    (334/370)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.annotation;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.privilege.SetAccessibleAction;
&nbsp;
&nbsp;import java.lang.annotation.*;
&nbsp;import java.lang.reflect.InvocationHandler;
&nbsp;import java.lang.reflect.InvocationTargetException;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Proxy;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.*;
&nbsp;
&nbsp;/**
&nbsp; * An annotation description describes {@link java.lang.annotation.Annotation} meta data of a class without this class
&nbsp; * being required to be loaded. All values of an annotation are therefore represented in unloaded state:
&nbsp; * &lt;ul&gt;
&nbsp; * &lt;li&gt;{@link java.lang.Class} instances are represented as {@link TypeDescription}s.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link java.lang.Enum} instances are represented as
&nbsp; * {@link net.bytebuddy.description.enumeration.EnumerationDescription}s.&lt;/li&gt;
&nbsp; * &lt;li&gt;{@link java.lang.annotation.Annotation}s are described as
&nbsp; * {@link AnnotationDescription}s.&lt;/li&gt;
&nbsp; * &lt;li&gt;All primitive types are represented as their wrapper types.&lt;/li&gt;
&nbsp; * &lt;/ul&gt;
&nbsp; * An annotation can however be loaded in order to access unwrapped values. This will cause a loading of the classes
&nbsp; * of these values.
&nbsp; */
&nbsp;public interface AnnotationDescription {
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates a nonexistent annotation in a type-safe manner.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    AnnotationDescription.Loadable&lt;?&gt; UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a value of this annotation.
&nbsp;     *
&nbsp;     * @param property The name of the property being accessed.
&nbsp;     * @return The value for the supplied property.
&nbsp;     */
&nbsp;    AnnotationValue&lt;?, ?&gt; getValue(String property);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a value of this annotation.
&nbsp;     *
&nbsp;     * @param property The property being accessed.
&nbsp;     * @return The value for the supplied property.
&nbsp;     */
&nbsp;    AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of the annotation type of this annotation.
&nbsp;     *
&nbsp;     * @return A description of the annotation type of this annotation.
&nbsp;     */
&nbsp;    TypeDescription getAnnotationType();
&nbsp;
&nbsp;    /**
&nbsp;     * Links this annotation description to a given annotation type such that it can be loaded. This does not cause
&nbsp;     * the values of this annotation to be loaded.
&nbsp;     *
&nbsp;     * @param annotationType The loaded annotation type of this annotation description.
&nbsp;     * @param &lt;T&gt;            The type of the annotation.
&nbsp;     * @return A loadable version of this annotation description.
&nbsp;     */
&nbsp;    &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this annotation&#39;s retention policy.
&nbsp;     *
&nbsp;     * @return This annotation&#39;s retention policy.
&nbsp;     */
&nbsp;    RetentionPolicy getRetention();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a set of all {@link ElementType}s that can declare this annotation.
&nbsp;     *
&nbsp;     * @return A set of all element types that can declare this annotation.
&nbsp;     */
&nbsp;    Set&lt;ElementType&gt; getElementTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this annotation is supported on the supplied element type.
&nbsp;     *
&nbsp;     * @param elementType The element type to check.
&nbsp;     * @return {@code true} if the supplied element type is supported by this annotation.
&nbsp;     */
&nbsp;    boolean isSupportedOn(ElementType elementType);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this annotation is supported on the supplied element type.
&nbsp;     *
&nbsp;     * @param elementType The element type to check.
&nbsp;     * @return {@code true} if the supplied element type is supported by this annotation.
&nbsp;     */
&nbsp;    boolean isSupportedOn(String elementType);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this annotation is inherited.
&nbsp;     *
&nbsp;     * @return {@code true} if this annotation is inherited.
&nbsp;     * @see Inherited
&nbsp;     */
&nbsp;    boolean isInherited();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this annotation is documented.
&nbsp;     *
&nbsp;     * @return {@code true} if this annotation is documented.
&nbsp;     * @see Documented
&nbsp;     */
&nbsp;    boolean isDocumented();
&nbsp;
&nbsp;    /**
&nbsp;     * An annotation description that is linked to a given loaded annotation type which allows its representation
&nbsp;     * as a fully loaded instance.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The annotation type.
&nbsp;     */
&nbsp;    interface Loadable&lt;S extends Annotation&gt; extends AnnotationDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * Loads this annotation description. This causes all classes referenced by the annotation value to be loaded.
&nbsp;         * Without specifying a class loader, the annotation&#39;s class loader which was used to prepare this instance
&nbsp;         * is used.
&nbsp;         *
&nbsp;         * @return A loaded version of this annotation description.
&nbsp;         */
&nbsp;        S load();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A rendering dispatcher is responsible for resolving annotation descriptions to {@link String} representations.
&nbsp;     */
<b class="fc">&nbsp;    enum RenderingDispatcher {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for any VM previous to Java 14.
&nbsp;         */
<b class="fc">&nbsp;        LEGACY_VM,</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 14 until Java 18.
&nbsp;         */
<b class="fc">&nbsp;        JAVA_14_CAPABLE_VM {</b>
&nbsp;            @Override
&nbsp;            public void appendPrefix(StringBuilder toString, String key, int count) {
<b class="fc">&nbsp;                if (count &gt; 1 || !key.equals(&quot;value&quot;)) {</b>
<b class="fc">&nbsp;                    super.appendPrefix(toString, key, count);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        },
&nbsp;
&nbsp;        /**
&nbsp;         * A rendering dispatcher for Java 19 onward.
&nbsp;         */
<b class="fc">&nbsp;        JAVA_19_CAPABLE_VM {</b>
&nbsp;            @Override
&nbsp;            public void appendPrefix(StringBuilder toString, String key, int count) {
<b class="nc">&nbsp;                if (count &gt; 1 || !key.equals(&quot;value&quot;)) {</b>
<b class="nc">&nbsp;                    super.appendPrefix(toString, key, count);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public void appendType(StringBuilder toString, TypeDescription typeDescription) {
<b class="nc">&nbsp;                toString.append(typeDescription.getCanonicalName());</b>
&nbsp;            }
&nbsp;        };
&nbsp;
&nbsp;        /**
&nbsp;         * The rendering dispatcher for the current VM.
&nbsp;         */
&nbsp;        public static final RenderingDispatcher CURRENT;
&nbsp;
&nbsp;        /*
&nbsp;         * Initializes the rendering dispatcher.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            ClassFileVersion classFileVersion = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5);</b>
<b class="fc">&nbsp;            if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V19)) {</b>
<b class="nc">&nbsp;                CURRENT = RenderingDispatcher.JAVA_19_CAPABLE_VM;</b>
<b class="fc">&nbsp;            } else if (classFileVersion.isAtLeast(ClassFileVersion.JAVA_V14)) {</b>
<b class="fc">&nbsp;                CURRENT = RenderingDispatcher.JAVA_14_CAPABLE_VM;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                CURRENT = RenderingDispatcher.LEGACY_VM;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the key property prefix to a string builder representing an annotation&#39;s string representation.
&nbsp;         *
&nbsp;         * @param toString The string builder that creates the string representation.
&nbsp;         * @param key      The key&#39;s name.
&nbsp;         * @param count    The property count.
&nbsp;         */
&nbsp;        public void appendPrefix(StringBuilder toString, String key, int count) {
<b class="fc">&nbsp;            toString.append(key).append(&#39;=&#39;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Appends the type name of the annotation being rendered.
&nbsp;         *
&nbsp;         * @param toString        The string builder that creates the string representation.
&nbsp;         * @param typeDescription The annotation type being rendered.
&nbsp;         */
&nbsp;        public void appendType(StringBuilder toString, TypeDescription typeDescription) {
<b class="fc">&nbsp;            toString.append(typeDescription.getName());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An {@link java.lang.reflect.InvocationHandler} for implementing annotations.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the handled annotation.
&nbsp;     */
&nbsp;    class AnnotationInvocationHandler&lt;T extends Annotation&gt; implements InvocationHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Object#hashCode()} method.
&nbsp;         */
&nbsp;        private static final String HASH_CODE = &quot;hashCode&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Object#equals(Object)} method.
&nbsp;         */
&nbsp;        private static final String EQUALS = &quot;equals&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Object#toString()} method.
&nbsp;         */
&nbsp;        private static final String TO_STRING = &quot;toString&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the {@link Annotation#annotationType()} method.
&nbsp;         */
&nbsp;        private static final String ANNOTATION_TYPE = &quot;annotationType&quot;;
&nbsp;
&nbsp;        /**
&nbsp;         * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object[] NO_ARGUMENT = new Object[0];</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded annotation type.
&nbsp;         */
&nbsp;        private final Class&lt;? extends Annotation&gt; annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * A sorted list of values of this annotation.
&nbsp;         */
&nbsp;        private final LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; values;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new invocation handler.
&nbsp;         *
&nbsp;         * @param annotationType The loaded annotation type.
&nbsp;         * @param values         A sorted list of values of this annotation.
&nbsp;         */
<b class="fc">&nbsp;        protected AnnotationInvocationHandler(Class&lt;T&gt; annotationType, LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; values) {</b>
<b class="fc">&nbsp;            this.annotationType = annotationType;</b>
<b class="fc">&nbsp;            this.values = values;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a proxy instance for the supplied annotation type and values.
&nbsp;         *
&nbsp;         * @param classLoader    The class loader that should be used for loading the annotation&#39;s values.
&nbsp;         * @param annotationType The annotation&#39;s type.
&nbsp;         * @param values         The values that the annotation contains.
&nbsp;         * @param &lt;S&gt;            The type of the handled annotation.
&nbsp;         * @return A proxy for the annotation type and values.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public static &lt;S extends Annotation&gt; S of(@MaybeNull ClassLoader classLoader,
&nbsp;                                                  Class&lt;S&gt; annotationType,
&nbsp;                                                  Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; values) {
<b class="fc">&nbsp;            LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; loadedValues = new LinkedHashMap&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Method method : annotationType.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                AnnotationValue&lt;?, ?&gt; annotationValue = values.get(method.getName());</b>
<b class="fc">&nbsp;                if (annotationValue == null) {</b>
<b class="fc">&nbsp;                    Object defaultValue = method.getDefaultValue();</b>
<b class="fc">&nbsp;                    loadedValues.put(method, (defaultValue == null</b>
<b class="fc">&nbsp;                            ? new AnnotationValue.ForMissingValue&lt;Void, Void&gt;(new TypeDescription.ForLoadedType(method.getDeclaringClass()), method.getName())</b>
<b class="fc">&nbsp;                            : AnnotationDescription.ForLoadedAnnotation.asValue(defaultValue, method.getReturnType())).load(classLoader));</b>
<b class="fc">&nbsp;                } else {</b>
<b class="fc">&nbsp;                    loadedValues.put(method, annotationValue.filter(new MethodDescription.ForLoadedMethod(method)).load(classLoader));</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return (S) Proxy.newProxyInstance(classLoader, new Class&lt;?&gt;[]{annotationType}, new AnnotationInvocationHandler&lt;S&gt;(annotationType, loadedValues));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) {
<b class="fc">&nbsp;            if (method.getDeclaringClass() != annotationType) {</b>
<b class="fc">&nbsp;                if (method.getName().equals(HASH_CODE)) {</b>
<b class="fc">&nbsp;                    return hashCodeRepresentation();</b>
<b class="fc">&nbsp;                } else if (method.getName().equals(EQUALS) &amp;&amp; method.getParameterTypes().length == 1) {</b>
<b class="fc">&nbsp;                    return equalsRepresentation(proxy, argument[0]);</b>
<b class="fc">&nbsp;                } else if (method.getName().equals(TO_STRING)) {</b>
<b class="fc">&nbsp;                    return toStringRepresentation();</b>
<b class="fc">&nbsp;                } else if (method.getName().equals(ANNOTATION_TYPE)) {</b>
<b class="fc">&nbsp;                    return annotationType;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected method: &quot; + method);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return values.get(method).resolve();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the string representation of the represented annotation.
&nbsp;         *
&nbsp;         * @return The string representation of the represented annotation.
&nbsp;         */
&nbsp;        protected String toStringRepresentation() {
<b class="fc">&nbsp;            StringBuilder toString = new StringBuilder();</b>
<b class="fc">&nbsp;            toString.append(&#39;@&#39;);</b>
<b class="fc">&nbsp;            RenderingDispatcher.CURRENT.appendType(toString, TypeDescription.ForLoadedType.of(annotationType));</b>
<b class="fc">&nbsp;            toString.append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            boolean firstMember = true;</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {</b>
<b class="fc">&nbsp;                if (!entry.getValue().getState().isDefined()) {</b>
<b class="fc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                if (firstMember) {</b>
<b class="fc">&nbsp;                    firstMember = false;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    toString.append(&quot;, &quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                RenderingDispatcher.CURRENT.appendPrefix(toString, entry.getKey().getName(), values.entrySet().size());</b>
<b class="fc">&nbsp;                toString.append(entry.getValue().toString());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            toString.append(&#39;)&#39;);</b>
<b class="fc">&nbsp;            return toString.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the hash code of the represented annotation.
&nbsp;         *
&nbsp;         * @return The hash code of the represented annotation.
&nbsp;         */
&nbsp;        private int hashCodeRepresentation() {
<b class="fc">&nbsp;            int hashCode = 0;</b>
<b class="fc">&nbsp;            for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {</b>
<b class="fc">&nbsp;                if (!entry.getValue().getState().isDefined()) {</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                hashCode += (127 * entry.getKey().getName().hashCode()) ^ entry.getValue().hashCode();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return hashCode;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if another instance is equal to this instance.
&nbsp;         *
&nbsp;         * @param self  The annotation proxy instance.
&nbsp;         * @param other The instance to be examined for equality to the represented instance.
&nbsp;         * @return {@code true} if the given instance is equal to the represented instance.
&nbsp;         */
&nbsp;        private boolean equalsRepresentation(Object self, Object other) {
<b class="fc">&nbsp;            if (self == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!annotationType.isInstance(other)) {</b>
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            } else if (Proxy.isProxyClass(other.getClass())) {</b>
<b class="fc">&nbsp;                InvocationHandler invocationHandler = Proxy.getInvocationHandler(other);</b>
<b class="fc">&nbsp;                if (invocationHandler instanceof AnnotationInvocationHandler) {</b>
<b class="fc">&nbsp;                    return invocationHandler.equals(this);</b>
&nbsp;                }
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {</b>
&nbsp;                    try {
<b class="fc">&nbsp;                        if (!entry.getValue().represents(entry.getKey().invoke(other, NO_ARGUMENT))) {</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    } catch (RuntimeException exception) {</b>
<b class="nc">&nbsp;                        return false; // Incomplete annotations are not equal to one another.</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } catch (InvocationTargetException ignored) {</b>
<b class="fc">&nbsp;                return false;</b>
<b class="nc">&nbsp;            } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Could not access annotation property&quot;, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = annotationType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + values.hashCode();</b>
<b class="nc">&nbsp;            for (Map.Entry&lt;Method, ?&gt; entry : values.entrySet()) {</b>
<b class="nc">&nbsp;                result = 31 * result + entry.getValue().hashCode();</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof AnnotationInvocationHandler)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationInvocationHandler&lt;?&gt; that = (AnnotationInvocationHandler&lt;?&gt;) other;</b>
<b class="fc">&nbsp;            if (!annotationType.equals(that.annotationType)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            for (Map.Entry&lt;Method, AnnotationValue.Loaded&lt;?&gt;&gt; entry : values.entrySet()) {</b>
<b class="fc">&nbsp;                if (!entry.getValue().equals(that.values.get(entry.getKey()))) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An adapter implementation of an annotation.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase implements AnnotationDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * An array containing all element types that are a legal annotation target when such a target
&nbsp;         * is not specified explicitly.
&nbsp;         */
&nbsp;        private static final Set&lt;ElementType&gt; DEFAULT_TARGET;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the {@link Retention#value()} method.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape RETENTION_VALUE;
&nbsp;
&nbsp;        /**
&nbsp;         * A description of the {@link Target#value()} method.
&nbsp;         */
&nbsp;        private static final MethodDescription.InDefinedShape TARGET_VALUE;
&nbsp;
&nbsp;        /*
&nbsp;         * Resolves common annotation properties.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            DEFAULT_TARGET = new HashSet&lt;ElementType&gt;();</b>
<b class="fc">&nbsp;            for (ElementType elementType : ElementType.values()) {</b>
<b class="fc">&nbsp;                if (!elementType.name().equals(&quot;TYPE_PARAMETER&quot;)) {</b>
<b class="fc">&nbsp;                    DEFAULT_TARGET.add(elementType);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            RETENTION_VALUE = TypeDescription.ForLoadedType.of(Retention.class)</b>
<b class="fc">&nbsp;                    .getDeclaredMethods()</b>
<b class="fc">&nbsp;                    .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;                    .getOnly();</b>
<b class="fc">&nbsp;            TARGET_VALUE = TypeDescription.ForLoadedType.of(Target.class)</b>
<b class="fc">&nbsp;                    .getDeclaredMethods()</b>
<b class="fc">&nbsp;                    .filter(named(&quot;value&quot;))</b>
<b class="fc">&nbsp;                    .getOnly();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(String property) {
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; candidates = getAnnotationType().getDeclaredMethods().filter(named(property)</b>
<b class="fc">&nbsp;                    .and(takesArguments(0))</b>
<b class="fc">&nbsp;                    .and(isPublic())</b>
<b class="fc">&nbsp;                    .and(not(isStatic())));</b>
<b class="fc">&nbsp;            if (candidates.size() == 1) {</b>
<b class="fc">&nbsp;                return getValue(candidates.getOnly());</b>
&nbsp;            } else {
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Unknown property of &quot; + getAnnotationType() + &quot;: &quot; + property);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RetentionPolicy getRetention() {
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;Retention&gt; retention = getAnnotationType().getDeclaredAnnotations().ofType(Retention.class);</b>
<b class="fc">&nbsp;            return retention == null</b>
<b class="fc">&nbsp;                    ? RetentionPolicy.CLASS</b>
<b class="fc">&nbsp;                    : retention.getValue(RETENTION_VALUE).load(ClassLoadingStrategy.BOOTSTRAP_LOADER).resolve(RetentionPolicy.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Set&lt;ElementType&gt; getElementTypes() {
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;Target&gt; target = getAnnotationType().getDeclaredAnnotations().ofType(Target.class);</b>
<b class="fc">&nbsp;            return target == null</b>
<b class="fc">&nbsp;                    ? Collections.unmodifiableSet(DEFAULT_TARGET)</b>
<b class="fc">&nbsp;                    : new HashSet&lt;ElementType&gt;(Arrays.asList(target.getValue(TARGET_VALUE).load(ClassLoadingStrategy.BOOTSTRAP_LOADER).resolve(ElementType[].class)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSupportedOn(ElementType elementType) {
<b class="fc">&nbsp;            return isSupportedOn(elementType.name());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSupportedOn(String elementType) {
<b class="fc">&nbsp;            AnnotationDescription.Loadable&lt;Target&gt; target = getAnnotationType().getDeclaredAnnotations().ofType(Target.class);</b>
<b class="fc">&nbsp;            if (target == null) {</b>
<b class="fc">&nbsp;                if (elementType.equals(&quot;TYPE_USE&quot;)) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
<b class="fc">&nbsp;                for (ElementType candidate : DEFAULT_TARGET) {</b>
<b class="fc">&nbsp;                    if (candidate.name().equals(elementType)) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            } else {
<b class="fc">&nbsp;                for (EnumerationDescription enumerationDescription : target.getValue(TARGET_VALUE).resolve(EnumerationDescription[].class)) {</b>
<b class="fc">&nbsp;                    if (enumerationDescription.getValue().equals(elementType)) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInherited() {
<b class="fc">&nbsp;            return getAnnotationType().getDeclaredAnnotations().isAnnotationPresent(Inherited.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isDocumented() {
<b class="fc">&nbsp;            return getAnnotationType().getDeclaredAnnotations().isAnnotationPresent(Documented.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int hashCode = 0;</b>
<b class="fc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : getAnnotationType().getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                hashCode += 31 * getValue(methodDescription).hashCode();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return hashCode;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof AnnotationDescription)) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationDescription annotationDescription = ((AnnotationDescription) other);</b>
<b class="fc">&nbsp;            TypeDescription annotationType = getAnnotationType();</b>
<b class="fc">&nbsp;            if (!annotationDescription.getAnnotationType().equals(annotationType)) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                if (!getValue(methodDescription).equals(annotationDescription.getValue(methodDescription))) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            TypeDescription annotationType = getAnnotationType();</b>
<b class="fc">&nbsp;            StringBuilder toString = new StringBuilder().append(&#39;@&#39;);</b>
<b class="fc">&nbsp;            RenderingDispatcher.CURRENT.appendType(toString, annotationType);</b>
<b class="fc">&nbsp;            toString.append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            boolean firstMember = true;</b>
<b class="fc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                AnnotationValue&lt;?, ?&gt; value = getValue(methodDescription);</b>
<b class="fc">&nbsp;                if (value.getState() == AnnotationValue.State.UNDEFINED) {</b>
<b class="fc">&nbsp;                    continue;</b>
<b class="fc">&nbsp;                } else if (firstMember) {</b>
<b class="fc">&nbsp;                    firstMember = false;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    toString.append(&quot;, &quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                RenderingDispatcher.CURRENT.appendPrefix(toString, methodDescription.getName(), annotationType.getDeclaredMethods().size());</b>
<b class="fc">&nbsp;                toString.append(value);</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return toString.append(&#39;)&#39;).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A description of an already loaded annotation.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of the annotation.
&nbsp;     */
&nbsp;    class ForLoadedAnnotation&lt;S extends Annotation&gt; extends AbstractBase implements Loadable&lt;S&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * An empty array that can be used to indicate no arguments to avoid an allocation on a reflective call.
&nbsp;         */
<b class="fc">&nbsp;        private static final Object[] NO_ARGUMENT = new Object[0];</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The represented annotation value.
&nbsp;         */
&nbsp;        private final S annotation;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation&#39;s loaded type which might be loaded by a different class loader than the value&#39;s
&nbsp;         * annotation type but must be structurally equal to it.
&nbsp;         */
&nbsp;        private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation description for a loaded annotation.
&nbsp;         *
&nbsp;         * @param annotation The annotation to represent.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        protected ForLoadedAnnotation(S annotation) {
<b class="fc">&nbsp;            this(annotation, (Class&lt;S&gt;) annotation.annotationType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new annotation description for a loaded annotation.
&nbsp;         *
&nbsp;         * @param annotation     The annotation to represent.
&nbsp;         * @param annotationType The annotation&#39;s loaded type which might be loaded by a different class loader than the value&#39;s
&nbsp;         *                       annotation type but must be structurally equal to it.
&nbsp;         */
<b class="fc">&nbsp;        private ForLoadedAnnotation(S annotation, Class&lt;S&gt; annotationType) {</b>
<b class="fc">&nbsp;            this.annotation = annotation;</b>
<b class="fc">&nbsp;            this.annotationType = annotationType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a description of the given annotation.
&nbsp;         *
&nbsp;         * @param annotation The annotation to be described.
&nbsp;         * @param &lt;U&gt;        The type of the annotation.
&nbsp;         * @return A description of the given annotation.
&nbsp;         */
&nbsp;        public static &lt;U extends Annotation&gt; Loadable&lt;U&gt; of(U annotation) {
<b class="fc">&nbsp;            return new ForLoadedAnnotation&lt;U&gt;(annotation);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public S load() {
<b class="fc">&nbsp;            return annotationType == annotation.annotationType()</b>
<b class="fc">&nbsp;                    ? annotation</b>
<b class="fc">&nbsp;                    : AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, asValue(annotation));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Extracts the annotation values of an annotation into a property map.
&nbsp;         *
&nbsp;         * @param annotation The annotation to convert.
&nbsp;         * @return A mapping of property names to their annotation value.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;rawtypes&quot;)
&nbsp;        private static Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; asValue(Annotation annotation) {
<b class="fc">&nbsp;            Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;();</b>
<b class="fc">&nbsp;            for (Method property : annotation.annotationType().getDeclaredMethods()) {</b>
&nbsp;                try {
<b class="fc">&nbsp;                    annotationValues.put(property.getName(), asValue(property.invoke(annotation, NO_ARGUMENT), property.getReturnType()));</b>
<b class="fc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                    Throwable cause = exception.getTargetException();</b>
<b class="fc">&nbsp;                    if (cause instanceof TypeNotPresentException) {</b>
<b class="fc">&nbsp;                        annotationValues.put(property.getName(), new AnnotationValue.ForMissingType&lt;Void, Void&gt;(((TypeNotPresentException) cause).typeName()));</b>
<b class="fc">&nbsp;                    } else if (cause instanceof EnumConstantNotPresentException) {</b>
<b class="fc">&nbsp;                        annotationValues.put(property.getName(), new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(</b>
<b class="fc">&nbsp;                                new TypeDescription.ForLoadedType(((EnumConstantNotPresentException) cause).enumType()),</b>
<b class="fc">&nbsp;                                ((EnumConstantNotPresentException) cause).constantName()));</b>
<b class="fc">&nbsp;                    } else if (cause instanceof AnnotationTypeMismatchException) {</b>
<b class="fc">&nbsp;                        annotationValues.put(property.getName(), new AnnotationValue.ForMismatchedType&lt;Void, Void&gt;(</b>
<b class="fc">&nbsp;                                new MethodDescription.ForLoadedMethod(((AnnotationTypeMismatchException) cause).element()),</b>
<b class="fc">&nbsp;                                ((AnnotationTypeMismatchException) cause).foundType()));</b>
<b class="fc">&nbsp;                    } else if (!(cause instanceof IncompleteAnnotationException)) {</b>
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Cannot read &quot; + property, cause);</b>
&nbsp;                    }
<b class="nc">&nbsp;                } catch (IllegalAccessException exception) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Cannot access &quot; + property, exception);</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return annotationValues;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Transforms an annotation property to an annotation value.
&nbsp;         *
&nbsp;         * @param type  The annotation&#39;s type.
&nbsp;         * @param value The annotations value.
&nbsp;         * @return An annotation value representation.
&nbsp;         */
&nbsp;        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;        public static AnnotationValue&lt;?, ?&gt; asValue(Object value, Class&lt;?&gt; type) {
&nbsp;            // Because enums can implement annotation interfaces, the enum property needs to be checked first.
<b class="fc">&nbsp;            if (Enum.class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                return AnnotationValue.ForEnumerationDescription.&lt;Enum&gt;of(new EnumerationDescription.ForLoadedEnumeration((Enum) value));</b>
<b class="fc">&nbsp;            } else if (Enum[].class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                Enum&lt;?&gt;[] element = (Enum&lt;?&gt;[]) value;</b>
<b class="fc">&nbsp;                EnumerationDescription[] enumerationDescription = new EnumerationDescription[element.length];</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                for (Enum&lt;?&gt; anElement : element) {</b>
<b class="fc">&nbsp;                    enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(anElement);</b>
&nbsp;                }
<b class="fc">&nbsp;                return AnnotationValue.ForDescriptionArray.&lt;Enum&gt;of(TypeDescription.ForLoadedType.of(type.getComponentType()), enumerationDescription);</b>
<b class="fc">&nbsp;            } else if (Annotation.class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                return AnnotationValue.ForAnnotationDescription.&lt;Annotation&gt;of(TypeDescription.ForLoadedType.of(type), asValue((Annotation) value));</b>
<b class="fc">&nbsp;            } else if (Annotation[].class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                Annotation[] element = (Annotation[]) value;</b>
<b class="fc">&nbsp;                AnnotationDescription[] annotationDescription = new AnnotationDescription[element.length];</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                for (Annotation anElement : element) {</b>
<b class="fc">&nbsp;                    annotationDescription[index++] = new AnnotationDescription.Latent(TypeDescription.ForLoadedType.of(type.getComponentType()), asValue(anElement));</b>
&nbsp;                }
<b class="fc">&nbsp;                return AnnotationValue.ForDescriptionArray.of(TypeDescription.ForLoadedType.of(type.getComponentType()), annotationDescription);</b>
<b class="fc">&nbsp;            } else if (Class.class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                return AnnotationValue.ForTypeDescription.&lt;Class&gt;of(TypeDescription.ForLoadedType.of((Class&lt;?&gt;) value));</b>
<b class="fc">&nbsp;            } else if (Class[].class.isAssignableFrom(type)) {</b>
<b class="fc">&nbsp;                Class&lt;?&gt;[] element = (Class&lt;?&gt;[]) value;</b>
<b class="fc">&nbsp;                TypeDescription[] typeDescription = new TypeDescription[element.length];</b>
<b class="fc">&nbsp;                int index = 0;</b>
<b class="fc">&nbsp;                for (Class&lt;?&gt; anElement : element) {</b>
<b class="fc">&nbsp;                    typeDescription[index++] = TypeDescription.ForLoadedType.of(anElement);</b>
&nbsp;                }
<b class="fc">&nbsp;                return AnnotationValue.ForDescriptionArray.of(typeDescription);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return AnnotationValue.ForConstant.of(value);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings({&quot;deprecation&quot;, &quot;rawtypes&quot;})
&nbsp;        @SuppressFBWarnings(value = &quot;REC_CATCH_EXCEPTION&quot;, justification = &quot;Exception should always be wrapped for clarity.&quot;)
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
<b class="fc">&nbsp;            if (!property.getDeclaringType().represents(annotation.annotationType())) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(property + &quot; does not represent &quot; + annotation.annotationType());</b>
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                boolean accessible = property.getDeclaringType().isPublic(); // method is required to be public</b>
<b class="fc">&nbsp;                Method method = property instanceof MethodDescription.ForLoadedMethod</b>
<b class="fc">&nbsp;                        ? ((MethodDescription.ForLoadedMethod) property).getLoadedMethod()</b>
<b class="fc">&nbsp;                        : null;</b>
<b class="fc">&nbsp;                if (method == null || method.getDeclaringClass() != annotation.annotationType() || (!accessible &amp;&amp; !method.isAccessible())) {</b>
<b class="fc">&nbsp;                    method = annotation.annotationType().getMethod(property.getName());</b>
<b class="fc">&nbsp;                    if (!accessible) {</b>
<b class="fc">&nbsp;                        doPrivileged(new SetAccessibleAction&lt;Method&gt;(method));</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return asValue(method.invoke(annotation, NO_ARGUMENT), method.getReturnType()).filter(property);</b>
<b class="fc">&nbsp;            } catch (InvocationTargetException exception) {</b>
<b class="fc">&nbsp;                Throwable cause = exception.getTargetException();</b>
<b class="fc">&nbsp;                if (cause instanceof TypeNotPresentException) {</b>
<b class="fc">&nbsp;                    return new AnnotationValue.ForMissingType&lt;Void, Void&gt;(((TypeNotPresentException) cause).typeName());</b>
<b class="fc">&nbsp;                } else if (cause instanceof EnumConstantNotPresentException) {</b>
<b class="fc">&nbsp;                    return new AnnotationValue.ForEnumerationDescription.WithUnknownConstant(</b>
<b class="fc">&nbsp;                            new TypeDescription.ForLoadedType(((EnumConstantNotPresentException) cause).enumType()),</b>
<b class="fc">&nbsp;                            ((EnumConstantNotPresentException) cause).constantName());</b>
<b class="fc">&nbsp;                } else if (cause instanceof AnnotationTypeMismatchException) {</b>
<b class="fc">&nbsp;                    return new AnnotationValue.ForMismatchedType&lt;Void, Void&gt;(</b>
<b class="fc">&nbsp;                            new MethodDescription.ForLoadedMethod(((AnnotationTypeMismatchException) cause).element()),</b>
<b class="fc">&nbsp;                            ((AnnotationTypeMismatchException) cause).foundType());</b>
<b class="fc">&nbsp;                } else if (cause instanceof IncompleteAnnotationException) {</b>
<b class="fc">&nbsp;                    return new AnnotationValue.ForMissingValue&lt;Void, Void&gt;(</b>
<b class="fc">&nbsp;                            new TypeDescription.ForLoadedType(((IncompleteAnnotationException) cause).annotationType()),</b>
<b class="fc">&nbsp;                            ((IncompleteAnnotationException) cause).elementName());</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Error reading annotation property &quot; + property, cause);</b>
&nbsp;                }
<b class="nc">&nbsp;            } catch (Exception exception) {</b>
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;Cannot access annotation property &quot; + property, exception);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
<b class="fc">&nbsp;            if (!annotation.annotationType().getName().equals(annotationType.getName())) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + annotation.annotationType());</b>
&nbsp;            }
<b class="fc">&nbsp;            return annotationType == annotation.annotationType()</b>
<b class="fc">&nbsp;                    ? (Loadable&lt;T&gt;) this</b>
<b class="fc">&nbsp;                    : new ForLoadedAnnotation&lt;T&gt;((T) annotation, annotationType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getAnnotationType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(annotation.annotationType());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent description of an annotation value that is defined explicitly.
&nbsp;     */
<b class="fc">&nbsp;    class Latent extends AbstractBase {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the annotation.
&nbsp;         */
&nbsp;        private final TypeDescription annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * The values of the annotation mapped by their property name.
&nbsp;         */
&nbsp;        private final Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent annotation description.
&nbsp;         *
&nbsp;         * @param annotationType   The type of the annotation.
&nbsp;         * @param annotationValues The values of the annotation mapped by their property name.
&nbsp;         */
<b class="fc">&nbsp;        protected Latent(TypeDescription annotationType, Map&lt;String, ? extends AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {</b>
<b class="fc">&nbsp;            this.annotationType = annotationType;</b>
<b class="fc">&nbsp;            this.annotationValues = annotationValues;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
<b class="fc">&nbsp;            if (!property.getDeclaringType().equals(annotationType)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Not a property of &quot; + annotationType + &quot;: &quot; + property);</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationValue&lt;?, ?&gt; value = annotationValues.get(property.getName());</b>
<b class="fc">&nbsp;            if (value != null) {</b>
<b class="fc">&nbsp;                return value.filter(property);</b>
&nbsp;            }
<b class="fc">&nbsp;            AnnotationValue&lt;?, ?&gt; defaultValue = property.getDefaultValue();</b>
<b class="fc">&nbsp;            return defaultValue == null</b>
<b class="fc">&nbsp;                    ? new AnnotationValue.ForMissingValue&lt;Void, Void&gt;(annotationType, property.getName())</b>
<b class="fc">&nbsp;                    : defaultValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getAnnotationType() {
<b class="fc">&nbsp;            return annotationType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
<b class="fc">&nbsp;            if (!this.annotationType.represents(annotationType)) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not represent &quot; + this.annotationType);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Loadable&lt;T&gt;(annotationType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A loadable annotation description of a latent annotation description.
&nbsp;         *
&nbsp;         * @param &lt;S&gt; The annotation type.
&nbsp;         */
&nbsp;        protected class Loadable&lt;S extends Annotation&gt; extends AbstractBase implements AnnotationDescription.Loadable&lt;S&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The annotation type.
&nbsp;             */
&nbsp;            private final Class&lt;S&gt; annotationType;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a loadable version of a latent annotation description.
&nbsp;             *
&nbsp;             * @param annotationType The annotation type.
&nbsp;             */
<b class="fc">&nbsp;            protected Loadable(Class&lt;S&gt; annotationType) {</b>
<b class="fc">&nbsp;                this.annotationType = annotationType;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public S load() {
<b class="fc">&nbsp;                return AnnotationDescription.AnnotationInvocationHandler.of(annotationType.getClassLoader(), annotationType, annotationValues);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationValue&lt;?, ?&gt; getValue(MethodDescription.InDefinedShape property) {
<b class="fc">&nbsp;                return Latent.this.getValue(property);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription getAnnotationType() {
<b class="fc">&nbsp;                return TypeDescription.ForLoadedType.of(annotationType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T extends Annotation&gt; Loadable&lt;T&gt; prepare(Class&lt;T&gt; annotationType) {
<b class="nc">&nbsp;                return Latent.this.prepare(annotationType);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A builder for pragmatically creating {@link net.bytebuddy.description.annotation.AnnotationDescription}.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class Builder {
&nbsp;
&nbsp;        /**
&nbsp;         * The annotation type.
&nbsp;         */
&nbsp;        private final TypeDescription annotationType;
&nbsp;
&nbsp;        /**
&nbsp;         * A mapping of annotation properties to their annotation values.
&nbsp;         */
&nbsp;        private final Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a builder for an annotation description.
&nbsp;         *
&nbsp;         * @param annotationType   The annotation type.
&nbsp;         * @param annotationValues A mapping of annotation properties to their annotation values.
&nbsp;         */
<b class="fc">&nbsp;        protected Builder(TypeDescription annotationType, Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues) {</b>
<b class="fc">&nbsp;            this.annotationType = annotationType;</b>
<b class="fc">&nbsp;            this.annotationValues = annotationValues;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a builder for creating an annotation of the given type.
&nbsp;         *
&nbsp;         * @param annotationType The annotation type.
&nbsp;         * @return A builder for creating an annotation of the given type.
&nbsp;         */
&nbsp;        public static Builder ofType(Class&lt;? extends Annotation&gt; annotationType) {
<b class="fc">&nbsp;            return ofType(TypeDescription.ForLoadedType.of(annotationType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a builder for creating an annotation of the given type.
&nbsp;         *
&nbsp;         * @param annotationType A description of the annotation type.
&nbsp;         * @return A builder for creating an annotation of the given type.
&nbsp;         */
&nbsp;        public static Builder ofType(TypeDescription annotationType) {
<b class="fc">&nbsp;            if (!annotationType.isAnnotation()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Not an annotation type: &quot; + annotationType);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Builder(annotationType, Collections.&lt;String, AnnotationValue&lt;?, ?&gt;&gt;emptyMap());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional, given property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    An explicit description of the annotation value.
&nbsp;         * @return A builder with the additional, given property.
&nbsp;         */
&nbsp;        public Builder define(String property, AnnotationValue&lt;?, ?&gt; value) {
<b class="fc">&nbsp;            MethodList&lt;MethodDescription.InDefinedShape&gt; methodDescriptions = annotationType.getDeclaredMethods().filter(named(property));</b>
<b class="fc">&nbsp;            if (methodDescriptions.isEmpty()) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(annotationType + &quot; does not define a property named &quot; + property);</b>
&nbsp;            }
<b class="fc">&nbsp;            Map&lt;String, AnnotationValue&lt;?, ?&gt;&gt; annotationValues = new HashMap&lt;String, AnnotationValue&lt;?, ?&gt;&gt;(this.annotationValues);</b>
<b class="fc">&nbsp;            if (annotationValues.put(methodDescriptions.getOnly().getName(), value) != null) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Property already defined: &quot; + property);</b>
&nbsp;            }
<b class="fc">&nbsp;            return new Builder(annotationType, annotationValues);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The enumeration value to define.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        public Builder define(String property, Enum&lt;?&gt; value) {
<b class="fc">&nbsp;            return define(property, new EnumerationDescription.ForLoadedEnumeration(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumeration.
&nbsp;         * @param value           The enumeration value to define.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        public Builder define(String property, TypeDescription enumerationType, String value) {
<b class="nc">&nbsp;            return define(property, new EnumerationDescription.Latent(enumerationType, value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    A description of the enumeration value to define.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;        public Builder define(String property, EnumerationDescription value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForEnumerationDescription.&lt;Enum&gt;of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation property.
&nbsp;         *
&nbsp;         * @param property   The name of the property to define.
&nbsp;         * @param annotation The annotation value to define.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        public Builder define(String property, Annotation annotation) {
<b class="fc">&nbsp;            return define(property, new ForLoadedAnnotation&lt;Annotation&gt;(annotation));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation property.
&nbsp;         *
&nbsp;         * @param property              The name of the property to define.
&nbsp;         * @param annotationDescription A description of the annotation value to define.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        public Builder define(String property, AnnotationDescription annotationDescription) {
<b class="fc">&nbsp;            return define(property, new AnnotationValue.ForAnnotationDescription&lt;Annotation&gt;(annotationDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional class property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param type     The class value to define.
&nbsp;         * @return A builder with the additional class property.
&nbsp;         */
&nbsp;        public Builder define(String property, Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return define(property, TypeDescription.ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional class property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param typeDescription A description of the type to define as a property value.
&nbsp;         * @return A builder with the additional class property.
&nbsp;         */
&nbsp;        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;        public Builder define(String property, TypeDescription typeDescription) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForTypeDescription.&lt;Class&gt;of(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumeration, i.e. the component type of the enumeration array.
&nbsp;         * @param value           The enumeration values to be contained by the array.
&nbsp;         * @param &lt;T&gt;             The enumeration type.
&nbsp;         * @return A builder with the additional class property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Enum&lt;?&gt;&gt; Builder defineEnumerationArray(String property, Class&lt;T&gt; enumerationType, T... value) {
<b class="fc">&nbsp;            EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];</b>
<b class="fc">&nbsp;            int index = 0;</b>
<b class="fc">&nbsp;            for (T aValue : value) {</b>
<b class="fc">&nbsp;                enumerationDescription[index++] = new EnumerationDescription.ForLoadedEnumeration(aValue);</b>
&nbsp;            }
<b class="fc">&nbsp;            return defineEnumerationArray(property, TypeDescription.ForLoadedType.of(enumerationType), enumerationDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumerations, i.e. is the component type of the enumeration array.
&nbsp;         * @param value           The enumeration values to be contained by the array.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        public Builder defineEnumerationArray(String property, TypeDescription enumerationType, String... value) {
<b class="nc">&nbsp;            if (!enumerationType.isEnum()) {</b>
<b class="nc">&nbsp;                throw new IllegalArgumentException(&quot;Not an enumeration type: &quot; + enumerationType);</b>
&nbsp;            }
<b class="nc">&nbsp;            EnumerationDescription[] enumerationDescription = new EnumerationDescription[value.length];</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; value.length; i++) {</b>
<b class="nc">&nbsp;                enumerationDescription[i] = new EnumerationDescription.Latent(enumerationType, value[i]);</b>
&nbsp;            }
<b class="nc">&nbsp;            return defineEnumerationArray(property, enumerationType, enumerationDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional enumeration array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param enumerationType The type of the enumerations, i.e. the component type of the enumeration array.
&nbsp;         * @param value           Descriptions of the enumerations to be contained by the array.
&nbsp;         * @return A builder with the additional enumeration property.
&nbsp;         */
&nbsp;        @SuppressWarnings({&quot;unchecked&quot;, &quot;rawtypes&quot;})
&nbsp;        public Builder defineEnumerationArray(String property, TypeDescription enumerationType, EnumerationDescription... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForDescriptionArray.&lt;Enum&gt;of(enumerationType, value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation array property.
&nbsp;         *
&nbsp;         * @param property       The name of the property to define.
&nbsp;         * @param annotationType The type of the annotations, i.e. the component type of the enumeration array.
&nbsp;         * @param annotation     The annotation values to be contained by the array.
&nbsp;         * @param &lt;T&gt;            The annotation type.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public &lt;T extends Annotation&gt; Builder defineAnnotationArray(String property, Class&lt;T&gt; annotationType, T... annotation) {
<b class="fc">&nbsp;            return defineAnnotationArray(property,</b>
<b class="fc">&nbsp;                    TypeDescription.ForLoadedType.of(annotationType),</b>
<b class="fc">&nbsp;                    new AnnotationList.ForLoadedAnnotations(annotation).toArray(new AnnotationDescription[0]));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional annotation array property.
&nbsp;         *
&nbsp;         * @param property              The name of the property to define.
&nbsp;         * @param annotationType        The type of the annotations, i.e. the component type of the enumeration array.
&nbsp;         * @param annotationDescription Descriptions of the annotation values to be contained by the array.
&nbsp;         * @return A builder with the additional annotation property.
&nbsp;         */
&nbsp;        public Builder defineAnnotationArray(String property, TypeDescription annotationType, AnnotationDescription... annotationDescription) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForDescriptionArray.of(annotationType, annotationDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional type array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param type     The types that should be contained by the array.
&nbsp;         * @return A builder with the additional type array property.
&nbsp;         */
&nbsp;        public Builder defineTypeArray(String property, Class&lt;?&gt;... type) {
<b class="fc">&nbsp;            return defineTypeArray(property, new TypeList.ForLoadedTypes(type).toArray(new TypeDescription[0]));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional type array property.
&nbsp;         *
&nbsp;         * @param property        The name of the property to define.
&nbsp;         * @param typeDescription Descriptions of the types that should be contained by the array.
&nbsp;         * @return A builder with the additional type array property.
&nbsp;         */
&nbsp;        public Builder defineTypeArray(String property, TypeDescription... typeDescription) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForDescriptionArray.of(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code boolean} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code boolean} value to define for the property.
&nbsp;         * @return A builder with the additional {@code boolean} property.
&nbsp;         */
&nbsp;        public Builder define(String property, boolean value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code byte} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code byte} value to define for the property.
&nbsp;         * @return A builder with the additional {@code byte} property.
&nbsp;         */
&nbsp;        public Builder define(String property, byte value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code char} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code char} value to define for the property.
&nbsp;         * @return A builder with the additional {@code char} property.
&nbsp;         */
&nbsp;        public Builder define(String property, char value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code short} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code short} value to define for the property.
&nbsp;         * @return A builder with the additional {@code short} property.
&nbsp;         */
&nbsp;        public Builder define(String property, short value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code int} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code int} value to define for the property.
&nbsp;         * @return A builder with the additional {@code int} property.
&nbsp;         */
&nbsp;        public Builder define(String property, int value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code long} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code long} value to define for the property.
&nbsp;         * @return A builder with the additional {@code long} property.
&nbsp;         */
&nbsp;        public Builder define(String property, long value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code float} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code float} value to define for the property.
&nbsp;         * @return A builder with the additional {@code float} property.
&nbsp;         */
&nbsp;        public Builder define(String property, float value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code double} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code double} value to define for the property.
&nbsp;         * @return A builder with the additional {@code double} property.
&nbsp;         */
&nbsp;        public Builder define(String property, double value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@link java.lang.String} property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@link java.lang.String} value to define for the property.
&nbsp;         * @return A builder with the additional {@link java.lang.String} property.
&nbsp;         */
&nbsp;        public Builder define(String property, String value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code boolean} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code boolean} values to define for the property.
&nbsp;         * @return A builder with the additional {@code boolean} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, boolean... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code byte} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code byte} values to define for the property.
&nbsp;         * @return A builder with the additional {@code byte} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, byte... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code char} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code char} values to define for the property.
&nbsp;         * @return A builder with the additional {@code char} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, char... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code short} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code short} values to define for the property.
&nbsp;         * @return A builder with the additional {@code short} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, short... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code int} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code int} values to define for the property.
&nbsp;         * @return A builder with the additional {@code int} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, int... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code long} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code long} values to define for the property.
&nbsp;         * @return A builder with the additional {@code long} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, long... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code float} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code float} values to define for the property.
&nbsp;         * @return A builder with the additional {@code float} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, float... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@code double} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@code double} values to define for the property.
&nbsp;         * @return A builder with the additional {@code double} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, double... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a builder with the additional {@link java.lang.String} array property.
&nbsp;         *
&nbsp;         * @param property The name of the property to define.
&nbsp;         * @param value    The {@link java.lang.String} array value to define for the property.
&nbsp;         * @return A builder with the additional {@link java.lang.String} array property.
&nbsp;         */
&nbsp;        public Builder defineArray(String property, String... value) {
<b class="fc">&nbsp;            return define(property, AnnotationValue.ForConstant.of(value));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation description for the values that were defined for this builder. It is validated that all
&nbsp;         * properties are defined if no default value is set for an annotation property.
&nbsp;         *
&nbsp;         * @return An appropriate annotation description.
&nbsp;         */
&nbsp;        public AnnotationDescription build() {
<b class="fc">&nbsp;            for (MethodDescription.InDefinedShape methodDescription : annotationType.getDeclaredMethods()) {</b>
<b class="fc">&nbsp;                AnnotationValue&lt;?, ?&gt; annotationValue = annotationValues.get(methodDescription.getName());</b>
<b class="fc">&nbsp;                if (annotationValue == null &amp;&amp; methodDescription.getDefaultValue() == null) {</b>
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;No value or default value defined for &quot; + methodDescription.getName());</b>
<b class="fc">&nbsp;                } else if (annotationValue != null &amp;&amp; annotationValue.filter(methodDescription).getState() != AnnotationValue.State.RESOLVED) {</b>
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Illegal annotation value for &quot; + methodDescription + &quot;: &quot; + annotationValue);</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Latent(annotationType, annotationValues);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an annotation description for the values that were defined for this builder.
&nbsp;         *
&nbsp;         * @param validated {@code true} if the annotation description should be validated for having included all values.
&nbsp;         * @return An appropriate annotation description.
&nbsp;         */
&nbsp;        public AnnotationDescription build(boolean validated) {
<b class="fc">&nbsp;            return validated</b>
<b class="nc">&nbsp;                    ? build()</b>
<b class="fc">&nbsp;                    : new Latent(annotationType, annotationValues);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
