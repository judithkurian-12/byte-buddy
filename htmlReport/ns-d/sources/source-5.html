


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > TypeDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.type</a>
</div>

<h1>Coverage Summary for Class: TypeDescription (net.bytebuddy.description.type)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">TypeDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
</tr>
  <tr>
    <td class="name">TypeDescription$1</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    96.2%
  </span>
  <span class="absValue">
    (50/52)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.8%
  </span>
  <span class="absValue">
    (210/260)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$2DBQFGUk</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$3drvKD1u</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$3TYjPNZu</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$582H9G2d</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$6CKTuFqd</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$6Ec4zJ1J</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$6zMI9rx4</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$75mxDO5e</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$7p7oVuep</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$8ah5LpPD</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$8TNbEvq4</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$8XZ4O3pf</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$AcMJkg0K</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$atSrx2Xx</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$bB9zRmN4</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$BdsY0Zvc</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$CaZLp4Bb</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$D2pTpm2K</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$e05kQ8OV</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$e8jf4aFV</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$eCFQlTzr</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$eHZ1r89u</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$f9g9zMME</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$G8eZcuyK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$gHQKAMDs</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$gkZi1PKN</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$GNjOHuZz</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$goNTQM0O</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$hw2bBwvE</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$IBFpbzfg</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$IBzQFCW0</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$iIyxGJl6</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$iqrQvOv1</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$IWYxzBzd</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$jyhE4GKf</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$KPCsXG44</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$KTdkqF2g</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$l22CaAPt</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$lab4BRHI</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$lMkXf3O2</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$lqfKRyKM</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$mUKrLxmt</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$MYttReLb</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$nF8S3y7f</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$OjD2znHP</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$OoJpHiV1</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$os6FbvSw</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$OUHdEKuM</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$oVP4Au5j</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$p3ebSuaP</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$p4UWXiRZ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$P9xzbw4C</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$PiDzTZRR</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$pVCEIFlv</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$qc1brQVa</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$qmEj7ptK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$QpNpKVO8</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$rh5kzlAB</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$rO2XhdpE</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$s15vjh53</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$sefe9vcK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$SRaWN5pX</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$SRUH3vyJ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$Syt2Cbsj</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$T6AYU4ST</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$T7nwOa5L</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$TFCDIUJu</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$TI7g0T86</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$TYygtcXj</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$UH6pDDmK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$ukLYaG3u</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$UvcFEb2g</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$ViQOMjwQ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$voNyY3Fb</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$VwPsg9KK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$W9I7KDXs</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$wKzoKYFU</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$x28aR5Zi</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$XFhBfDdg</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$Xxp5rlNs</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$y4Stk97G</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$yX9pVaUp</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$MockitoMock$378360284$auxiliary$ZMCdOzOo</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$OfSimpleType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (23/23)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$AbstractBase$OfSimpleType$WithDelegation</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.8%
  </span>
  <span class="absValue">
    (23/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ArrayProjection</td>
<td class="coverageStat">
  <span class="percent">
    68.8%
  </span>
  <span class="absValue">
    (22/32)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.9%
  </span>
  <span class="absValue">
    (52/62)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (48/48)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80.8%
  </span>
  <span class="absValue">
    (126/156)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForLoadedType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$ForPackageDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Chained</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableExceptionType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableExceptionType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableParameterType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedExecutableParameterType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedField$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedInterface</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedMethodReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedMethodReturnType$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$ForLoadedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$Delegator$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForComponentType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForComponentType$AnnotatedParameterizedType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForOwnerType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForOwnerType$AnnotatedType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeArgument$AnnotatedParameterizedType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType$AnnotatedTypeVariable</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType$OfFormalTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForTypeVariableBoundType$OfFormalTypeVariable$FormalTypeVariable</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForWildcardLowerBoundType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    62.5%
  </span>
  <span class="absValue">
    (5/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForWildcardLowerBoundType$AnnotatedWildcardType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForWildcardUpperBoundType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.6%
  </span>
  <span class="absValue">
    (7/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$ForWildcardUpperBoundType$AnnotatedWildcardType</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$AnnotationReader$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.3%
  </span>
  <span class="absValue">
    (14/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Builder</td>
<td class="coverageStat">
  <span class="percent">
    70.7%
  </span>
  <span class="absValue">
    (29/41)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    82.6%
  </span>
  <span class="absValue">
    (57/69)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Builder$OfGenericArrayType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Builder$OfNonGenericType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Builder$OfParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Builder$OfTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Builder$Visitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (24/24)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (24/24)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedFieldType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedReturnType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$ForLoadedSuperClass</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfConstructorParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfMethodParameter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$OfRecordComponent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithEagerNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation$LazyInterfaceList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation$LazyInterfaceType</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation$LazySuperClass</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithLazyNavigation$OfAnnotatedElement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProjection$WithResolvedErasure</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$LazyProxy</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$MockitoMock$1019146100</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$MockitoMock$1019146100$auxiliary$85850moh</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$MockitoMock$1019146100$auxiliary$94PAS5M2</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$MockitoMock$1019146100$auxiliary$jSQyBTpR</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$MockitoMock$1019146100$auxiliary$YQjwl1ea</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray</td>
<td class="coverageStat">
  <span class="percent">
    92.3%
  </span>
  <span class="absValue">
    (24/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    86.7%
  </span>
  <span class="absValue">
    (39/45)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (4/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfGenericArray$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (20/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    72.1%
  </span>
  <span class="absValue">
    (31/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForErasure</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (43/43)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$ForReifiedErasure</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    59.1%
  </span>
  <span class="absValue">
    (13/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$06KrL7YK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$0dZO1jAn</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$0n97K5CZ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$1E3DCcIj</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$2Af9ez2o</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$46eeMD4p</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$4N54Zp5S</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$4SNVzobw</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$4YsAwdFZ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$6PusufvP</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$742CuGZw</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$7AVzcF8I</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$7e19tNyB</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$993kNsvz</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$9JSk1FCC</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$9NJPbDIy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$B6S4Hp9X</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$brw24PpP</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$BuceSXDV</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$cEm59kjv</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$Ch7pnN67</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$ctMCpFwW</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$Cyf3RSXw</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$CyztI7lL</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$D0m3TNzl</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$DfJ7jCC3</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$ErYY9yl7</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$HOLZlSmR</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$i8eQxLmB</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$JOXtmHGZ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$k3goUXDD</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$KM8V3Ve1</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$kMPfPIcO</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$L0xSPpek</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$lCvNQZdo</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$LE7BwqTW</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$Ltf6rXaD</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$m1KuZ6ng</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$m2czJmlX</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$MegDCdSb</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$nU7y7YUU</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$oafzxjF8</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$OJU19QNz</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$pEiVrBCQ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$phlJnOID</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$PzqXXFbM</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$QW0ks1nA</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$rITJcSJ5</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$Rt6JsaPL</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$Sba7Hdgu</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$TIiccmtM</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$tKVefTW9</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$uAdxhLTh</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$um61DQpy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$uqRCl48L</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$vNYAonDE</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$wFQoc50A</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$WIvJ6Wju</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$XPSIevAZ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfNonGenericType$MockitoMock$209692220$auxiliary$yKV2FVyy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    96%
  </span>
  <span class="absValue">
    (24/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    96.9%
  </span>
  <span class="absValue">
    (63/65)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForGenerifiedErasure</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.7%
  </span>
  <span class="absValue">
    (11/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForLoadedType$ParameterArgumentTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$ForReifiedType</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (8/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.8%
  </span>
  <span class="absValue">
    (15/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$RenderingDelegate</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$RenderingDelegate$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfParameterizedType$RenderingDelegate$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    92%
  </span>
  <span class="absValue">
    (23/25)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    91.4%
  </span>
  <span class="absValue">
    (32/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    85.7%
  </span>
  <span class="absValue">
    (6/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (12/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$ForLoadedType$TypeVariableBoundList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$0iE0e1gg</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$0jkUgo0L</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$0mmMlqSC</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$286xGVwS</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$3xAsIayC</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$4KAzJkxn</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$4vyjTMvC</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$4X5ggodC</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$4ZrEXY9a</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$6niAqYFy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$7JimBmVJ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$9yjJ1NC0</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$asCfdToR</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$Bal1o13N</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$BbLdaoAE</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$bNLY7TIn</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$cdAtRfmy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$cnR7AxWQ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$D1maR2K1</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$dWllt4tH</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$DYQ8jsLn</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$DZfrc3od</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$FQvnLxSm</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$FWGvDmJL</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$GmpVXkbm</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$H8P30bAr</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$Hex18XaG</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$idpDtk2f</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$iJRncfKR</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$ixxIa2Q1</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$lVgsQiRw</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$O0nWVEVt</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$o5fwnEOf</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$oUWmJchM</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$pz5T8NCx</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$qnxyCfrE</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$R0jSJ1lG</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$rxjy2E7n</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$SCxedfAQ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$sI0n9vYI</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$SWoJ2Hdb</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$t0fZ6pLj</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$TCUbYv57</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$tT5kyUKB</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$TU3vTIU8</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$u1N8WRPa</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$uH39rWjX</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$uvBkIzqJ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$uvbZxMAf</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$vGdZC32V</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$vzj7kvlH</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$w6X7l39O</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$WFcRuF79</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$xCpQZXbQ</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$xdRX7FSy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$xrQu5NeY</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$yemPXFMS</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$YIUvupzK</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$ykzLvmI8</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$MockitoMock$1653358855$auxiliary$zhhp7Kwt</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$Symbolic</td>
<td class="coverageStat">
  <span class="percent">
    86.2%
  </span>
  <span class="absValue">
    (25/29)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.5%
  </span>
  <span class="absValue">
    (34/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfTypeVariable$WithAnnotationOverlay</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType</td>
<td class="coverageStat">
  <span class="percent">
    76.9%
  </span>
  <span class="absValue">
    (20/26)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (40/48)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$ForLoadedType</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$ForLoadedType$WildcardLowerBoundTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$ForLoadedType$WildcardUpperBoundTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$OfWildcardType$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$AnnotationStripper</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    92.9%
  </span>
  <span class="absValue">
    (13/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$AnnotationStripper$NonAnnotatedTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    60%
  </span>
  <span class="absValue">
    (3/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (4/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForGenericArray</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForNonGenericType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForParameterizedType</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.4%
  </span>
  <span class="absValue">
    (37/38)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForParameterizedType$ParameterAssigner</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (4/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    70%
  </span>
  <span class="absValue">
    (7/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForParameterizedType$ParameterAssigner$ContravariantBinding</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForParameterizedType$ParameterAssigner$CovariantBinding</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForParameterizedType$ParameterAssigner$InvariantBinding</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Assigner$Dispatcher$ForTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForRawType</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    84.6%
  </span>
  <span class="absValue">
    (11/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$ForSignatureVisitor$OfTypeArgument</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$MockitoMock$567592840</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$MockitoMock$567592840$auxiliary$BFAxPL1C</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$MockitoMock$567592840$auxiliary$zPETBKsx</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$NoOp</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reducing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (25/25)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Reifying$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForAttachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (13/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForDetachment</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForReplacement</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForTokenNormalization</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForTypeVariableBinding</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForTypeVariableBinding$RetainedMethodTypeVariable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$ForTypeVariableBinding$TypeVariableSubstitutor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Substitutor$WithoutTypeSubstitution</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$TypeErasing</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (21/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$2</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$3</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Generic$Visitor$Validator$ForTypeAnnotations</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.9%
  </span>
  <span class="absValue">
    (31/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    72.7%
  </span>
  <span class="absValue">
    (16/22)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    76.7%
  </span>
  <span class="absValue">
    (23/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$LazyProxy</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (3/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1100152646</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1100152646$auxiliary$euqHPiIE</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1100152646$auxiliary$gqTiLNZy</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1100152646$auxiliary$IdecLO8X</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1100152646$auxiliary$Il94FubU</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1550305804</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1550305804$auxiliary$Kr1KDJPg</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1550305804$auxiliary$RLJMRuBW</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1550305804$auxiliary$UdL4jxY8</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$MockitoMock$1550305804$auxiliary$ZDJ7ficl</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$SuperTypeLoading</td>
<td class="coverageStat">
  <span class="percent">
    96.8%
  </span>
  <span class="absValue">
    (30/31)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    97.3%
  </span>
  <span class="absValue">
    (36/37)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$SuperTypeLoading$ClassLoadingDelegate</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$SuperTypeLoading$ClassLoadingDelegate$Simple</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$SuperTypeLoading$ClassLoadingTypeList</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">TypeDescription$SuperTypeLoading$ClassLoadingTypeProjection</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (5/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (10/22)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    91.6%
  </span>
  <span class="absValue">
    (841/918)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88%
  </span>
  <span class="absValue">
    (1685/1914)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.type;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.ClassFileVersion;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.field.FieldDescription;
&nbsp;import net.bytebuddy.description.field.FieldList;
&nbsp;import net.bytebuddy.description.method.MethodDescription;
&nbsp;import net.bytebuddy.description.method.MethodList;
&nbsp;import net.bytebuddy.description.method.ParameterDescription;
&nbsp;import net.bytebuddy.dynamic.TargetType;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.CompoundList;
&nbsp;import net.bytebuddy.utility.FieldComparator;
&nbsp;import net.bytebuddy.utility.GraalImageCode;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import net.bytebuddy.utility.privilege.GetSystemPropertyAction;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;import org.objectweb.asm.signature.SignatureVisitor;
&nbsp;import org.objectweb.asm.signature.SignatureWriter;
&nbsp;
&nbsp;import java.io.Serializable;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.is;
&nbsp;
&nbsp;/**
&nbsp; * Implementations of this interface represent a Java type, i.e. a class or interface. Instances of this interface always
&nbsp; * represent non-generic types of sort {@link Generic.Sort#NON_GENERIC}.
&nbsp; */
&nbsp;public interface TypeDescription extends TypeDefinition, ByteCodeElement, TypeVariableSource {
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.Object} type.
&nbsp;     *
&nbsp;     * @deprecated Use {@link TypeDescription.ForLoadedType#of(Class)} instead.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    TypeDescription OBJECT = LazyProxy.of(Object.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.String} type.
&nbsp;     *
&nbsp;     * @deprecated Use {@link TypeDescription.ForLoadedType#of(Class)} instead.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    TypeDescription STRING = LazyProxy.of(String.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.Class} type.
&nbsp;     *
&nbsp;     * @deprecated Use {@link TypeDescription.ForLoadedType#of(Class)} instead.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    TypeDescription CLASS = LazyProxy.of(Class.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@link java.lang.Throwable} type.
&nbsp;     *
&nbsp;     * @deprecated Use {@link TypeDescription.ForLoadedType#of(Class)} instead.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    TypeDescription THROWABLE = LazyProxy.of(Throwable.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A representation of the {@code void} non-type.
&nbsp;     *
&nbsp;     * @deprecated Use {@link TypeDescription.ForLoadedType#of(Class)} instead.
&nbsp;     */
&nbsp;    @Deprecated
<b class="fc">&nbsp;    TypeDescription VOID = LazyProxy.of(void.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * A list of interfaces that are implicitly implemented by any array type.
&nbsp;     */
<b class="fc">&nbsp;    TypeList.Generic ARRAY_INTERFACES = new TypeList.Generic.ForLoadedTypes(Cloneable.class, Serializable.class);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Represents any undefined property representing a type description that is instead represented as {@code null} in order
&nbsp;     * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    TypeDescription UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields();
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if {@code value} is an instance of the type represented by this instance.
&nbsp;     *
&nbsp;     * @param value The object of interest.
&nbsp;     * @return {@code true} if the object is an instance of the type described by this instance.
&nbsp;     */
&nbsp;    boolean isInstance(Object value);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Foo.class.isAssignableFrom(Bar.class)}.
&nbsp;     *
&nbsp;     * @param type The type of interest.
&nbsp;     * @return {@code true} if this type is assignable from {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableFrom(Class&lt;?&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Foo.class.isAssignableFrom(Bar.class)}.
&nbsp;     * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;     * Implementations of this methods are allowed to delegate to
&nbsp;     * {@link TypeDescription#isAssignableFrom(Class)}
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type is assignable from {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableFrom(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Bar.class.isAssignableTo(Foo.class)}.
&nbsp;     *
&nbsp;     * @param type The type of interest.
&nbsp;     * @return {@code true} if this type is assignable to {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableTo(Class&lt;?&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type is assignable from the type described by this instance, for example for
&nbsp;     * {@code class Foo} and {@code class Bar extends Foo}, this method would return {@code true} for
&nbsp;     * {@code Bar.class.isAssignableFrom(Foo.class)}.
&nbsp;     * &lt;p&gt;&amp;nbsp;&lt;/p&gt;
&nbsp;     * Implementations of this methods are allowed to delegate to
&nbsp;     * {@link TypeDescription#isAssignableTo(Class)}
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type is assignable to {@code type}.
&nbsp;     */
&nbsp;    boolean isAssignableTo(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this type and the supplied type are in a type hierarchy with each other, i.e. if this type is assignable
&nbsp;     * to the supplied type or the other way around.
&nbsp;     *
&nbsp;     * @param type The type of interest.
&nbsp;     * @return {@code true} if this type and the supplied type are in a type hierarchy with each other.
&nbsp;     */
&nbsp;    boolean isInHierarchyWith(Class&lt;?&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this type and the supplied type are in a type hierarchy with each other, i.e. if this type is assignable
&nbsp;     * to the supplied type or the other way around.
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type and the supplied type are in a type hierarchy with each other.
&nbsp;     */
&nbsp;    boolean isInHierarchyWith(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    TypeDescription getComponentType();
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    TypeDescription getDeclaringType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of types that are declared by this type. This list does not normally include anonymous types but might
&nbsp;     * include additional types if they are explicitly added to an instrumented type.
&nbsp;     *
&nbsp;     * @return A list of types that are declared within this type.
&nbsp;     */
&nbsp;    TypeList getDeclaredTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of the method that encloses this type. If this method is not enclosed by any type or is
&nbsp;     * enclosed by the type initializer, {@code null} is returned by this method.
&nbsp;     *
&nbsp;     * @return A description of the enclosing method of this type or {@code null} if there is no such method.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    MethodDescription.InDefinedShape getEnclosingMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of this type&#39;s enclosing type if any.
&nbsp;     *
&nbsp;     * @return A description of the enclosing type of this type or {@code null} if there is no such type.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    TypeDescription getEnclosingType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the type&#39;s actual modifiers as present in the class file. For example, a type cannot be {@code private}.
&nbsp;     * but it modifiers might reflect this property nevertheless if a class was defined as a private inner class. The
&nbsp;     * returned modifiers take also into account if the type is marked as {@link Deprecated}. Anonymous classes that are
&nbsp;     * enclosed in a static method or the type initializer are additionally marked as {@code final} as it is also done
&nbsp;     * by the Java compiler.
&nbsp;     *
&nbsp;     * @param superFlag {@code true} if the modifier&#39;s super flag should be set.
&nbsp;     * @return The type&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers(boolean superFlag);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the simple name of this type.
&nbsp;     *
&nbsp;     * @return The simple name of this type.
&nbsp;     */
&nbsp;    String getSimpleName();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a form of a type&#39;s simple name which only shortens the package name but not the names of outer classes.
&nbsp;     *
&nbsp;     * @return The long form of the simple name of this type.
&nbsp;     */
&nbsp;    String getLongSimpleName();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the canonical name of this type if it exists.
&nbsp;     *
&nbsp;     * @return The canonical name of this type. Might be {@code null}.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    String getCanonicalName();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type description represents an anonymous type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type description represents an anonymous type.
&nbsp;     */
&nbsp;    boolean isAnonymousType();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type description represents a local type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type description represents a local type.
&nbsp;     */
&nbsp;    boolean isLocalType();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type description represents a member type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type description represents a member type.
&nbsp;     */
&nbsp;    boolean isMemberType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the package of the type described by this instance or {@code null} if the described type
&nbsp;     * is a primitive type or an array.
&nbsp;     *
&nbsp;     * @return The package of the type described by this instance or {@code null} if the described type
&nbsp;     * is a primitive type or an array.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    PackageDescription getPackage();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the annotations that this type declares or inherits from super types.
&nbsp;     *
&nbsp;     * @return A list of all inherited annotations.
&nbsp;     */
&nbsp;    AnnotationList getInheritedAnnotations();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if two types are defined in the same package.
&nbsp;     *
&nbsp;     * @param typeDescription The type of interest.
&nbsp;     * @return {@code true} if this type and the given type are in the same package.
&nbsp;     */
&nbsp;    boolean isSamePackage(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type represents a wrapper type for a primitive type. The {@link java.lang.Void} type is
&nbsp;     * not considered to be a wrapper type.
&nbsp;     *
&nbsp;     * @return {@code true} if this type represents a wrapper type.
&nbsp;     */
&nbsp;    boolean isPrimitiveWrapper();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be returned from an annotation method.
&nbsp;     *
&nbsp;     * @return {@code true} if instances of this type can be returned from an annotation method.
&nbsp;     */
&nbsp;    boolean isAnnotationReturnType();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be used for describing an annotation value.
&nbsp;     *
&nbsp;     * @return {@code true} if instances of this type can be used for describing an annotation value.
&nbsp;     */
&nbsp;    boolean isAnnotationValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if instances of this type can be used for describing the given annotation value.
&nbsp;     *
&nbsp;     * @param value The value that is supposed to describe the annotation value for this instance.
&nbsp;     * @return {@code true} if instances of this type can be used for describing the given annotation value..
&nbsp;     */
&nbsp;    boolean isAnnotationValue(Object value);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type represents a class that is a place holder for a package description.
&nbsp;     *
&nbsp;     * @return {@code true} if this type represents a package description.
&nbsp;     */
&nbsp;    boolean isPackageType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the amount of outer classes this type defines. If this type is not an inner type of another class, {@code 0} is returned.
&nbsp;     *
&nbsp;     * @return The number of outer classes relatively to this type.
&nbsp;     */
&nbsp;    int getInnerClassCount();
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if this class is an inner class.
&nbsp;     *
&nbsp;     * @return {@code true} if this class is an inner class.
&nbsp;     */
&nbsp;    boolean isInnerClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if this class is a nested class.
&nbsp;     *
&nbsp;     * @return {@code true} if this class is a nested class.
&nbsp;     */
&nbsp;    boolean isNestedClass();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of this type that represents this type as a boxed type for primitive types, unless its {@code void}.
&nbsp;     *
&nbsp;     * @return A description of this type in its boxed form.
&nbsp;     */
&nbsp;    TypeDescription asBoxed();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a description of this type that represents this type as an unboxed type for boxing types, unless its {@link Void}.
&nbsp;     *
&nbsp;     * @return A description of this type in its unboxed form.
&nbsp;     */
&nbsp;    TypeDescription asUnboxed();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default value for this type, i.e. the zero value for a primitive type and {@code null} for a reference type.
&nbsp;     * For {@code void}, {@code null} is returned.
&nbsp;     *
&nbsp;     * @return This types default value.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    Object getDefaultValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the nest host of this type. For types prior to Java 11, this type is returned which is the default nest host.
&nbsp;     *
&nbsp;     * @return The nest host of this type.
&nbsp;     */
&nbsp;    TypeDescription getNestHost();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of members that are part of a nesting group. Prior to Java 11, a list that only contains this type is returned which is
&nbsp;     * the default nest group.
&nbsp;     *
&nbsp;     * @return A list of members of this nest group.
&nbsp;     */
&nbsp;    TypeList getNestMembers();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this class is the host of a nest group.
&nbsp;     *
&nbsp;     * @return {@code true} if this class is a nest group&#39;s host.
&nbsp;     */
&nbsp;    boolean isNestHost();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type and the supplied type are members of the same nest group.
&nbsp;     *
&nbsp;     * @param type The type for which to check if it is a member of the same nest group.
&nbsp;     * @return {@code true} if this type and the supplied type are members of the same nest group.
&nbsp;     */
&nbsp;    boolean isNestMateOf(Class&lt;?&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this type and the supplied type are members of the same nest group.
&nbsp;     *
&nbsp;     * @param typeDescription The type for which to check if it is a member of the same nest group.
&nbsp;     * @return {@code true} if this type and the supplied type are members of the same nest group.
&nbsp;     */
&nbsp;    boolean isNestMateOf(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Indicates if this type represents a compile-time constant, i.e. {@code int}, {@code long}, {@code float}, {@code double},
&nbsp;     * {@link String}, {@link Class} or {@code java.lang.invoke.MethodHandle} or {@code java.lang.invoke.MethodType}. Since Java 11&#39;s
&nbsp;     * *constantdynamic* any type can be considered a constant value; this method does however only consider classical compile time
&nbsp;     * constants.
&nbsp;     *
&nbsp;     * @return {@code true} if this type represents a compile-time constant.
&nbsp;     */
&nbsp;    boolean isCompileTimeConstant();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the list of permitted direct subclasses if this class is a sealed class. Permitted subclasses might or might not be
&nbsp;     * resolvable, where unresolvable subclasses might also be missing from the list. For returned types, methods that return the
&nbsp;     * class&#39;s name will always be invokable without errors. If this type is not sealed, an empty list is returned. Note that an empty
&nbsp;     * list might also be returned for a sealed type, if no type permitted subtype is resolvable.
&nbsp;     *
&nbsp;     * @return The list of permitted subtypes or an empty list if this type is not sealed.
&nbsp;     */
&nbsp;    TypeList getPermittedSubtypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns {@code true} if this class is a sealed class that only permitts a specified range of subclasses.
&nbsp;     *
&nbsp;     * @return {@code true} if this class is a sealed class that only permitts a specified range of subclasses.
&nbsp;     */
&nbsp;    boolean isSealed();
&nbsp;
&nbsp;    /**
&nbsp;     * Attempts to resolve the class file version of this type. If this description is not based on a class file
&nbsp;     * or if the class file version cannot be resolved, {@code null} is returned.
&nbsp;     *
&nbsp;     * @return This type&#39;s class file version or {@code null} if it cannot be resolved.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    ClassFileVersion getClassFileVersion();
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * Represents a generic type of the Java programming language. A non-generic {@link TypeDescription} is considered to be
&nbsp;     * a specialization of a generic type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * Note that annotations that are declared on an annotated type refer to any type annotations that are declared by this
&nbsp;     * generic type. For reading annotations of the erasure type, {@link TypeDefinition#asErasure()} must be called before.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    interface Generic extends TypeDefinition, AnnotationSource {
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@link Object} type.
&nbsp;         *
&nbsp;         * @deprecated Use {@link OfNonGenericType.ForLoadedType#of(Class)} instead.
&nbsp;         */
&nbsp;        @Deprecated
<b class="fc">&nbsp;        Generic OBJECT = LazyProxy.of(Object.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@link Class} non-type.
&nbsp;         *
&nbsp;         * @deprecated Use {@link OfNonGenericType.ForLoadedType#of(Class)} instead.
&nbsp;         */
&nbsp;        @Deprecated
<b class="fc">&nbsp;        Generic CLASS = LazyProxy.of(Class.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@code void} non-type.
&nbsp;         *
&nbsp;         * @deprecated Use {@link OfNonGenericType.ForLoadedType#of(Class)} instead.
&nbsp;         */
&nbsp;        @Deprecated
<b class="fc">&nbsp;        Generic VOID = LazyProxy.of(void.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A representation of the {@link Annotation} type.
&nbsp;         *
&nbsp;         * @deprecated Use {@link OfNonGenericType.ForLoadedType#of(Class)} instead.J
&nbsp;         */
&nbsp;        @Deprecated
<b class="fc">&nbsp;        Generic ANNOTATION = LazyProxy.of(Annotation.class);</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Represents any undefined property representing a generic type description that is instead represented as {@code null} in order
&nbsp;         * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        Generic UNDEFINED = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this type as a raw type. This resembles calling {@code asErasure().asGenericType()}.
&nbsp;         *
&nbsp;         * @return This type as a raw type.
&nbsp;         */
&nbsp;        Generic asRawType();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the upper bounds of this type. Any type with a well-defined upper bound is bound by at least one type. If no such
&nbsp;         * type is defined, the bound is implicitly {@link Object}.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Only non-symbolic type variables ({@link net.bytebuddy.description.type.TypeDefinition.Sort#VARIABLE}, and wildcard types
&nbsp;         * ({@link net.bytebuddy.description.type.TypeDefinition.Sort#WILDCARD}) have well-defined upper bounds. For other
&nbsp;         * types, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return The upper bounds of this type.
&nbsp;         */
&nbsp;        TypeList.Generic getUpperBounds();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the lower bounds of this type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Only wildcard types ({@link Sort#WILDCARD}) define a lower bound. For other
&nbsp;         * types, an {@link IllegalStateException} is thrown.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return The lower bounds of this type.
&nbsp;         */
&nbsp;        TypeList.Generic getLowerBounds();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the type arguments of this type.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * Parameters are only well-defined for parameterized types ({@link Sort#PARAMETERIZED}).
&nbsp;         * For all other types, this method throws an {@link IllegalStateException}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return A list of this type&#39;s type parameters.
&nbsp;         */
&nbsp;        TypeList.Generic getTypeArguments();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the owner type of this type. A type&#39;s owner type describes a nested type&#39;s declaring type.
&nbsp;         * If it exists, the returned type can be a non-generic or parameterized type. If a class has no
&nbsp;         * declaring type, {@code null} is returned.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * An owner type is only well-defined for parameterized types ({@link Sort#PARAMETERIZED}),
&nbsp;         * for non-generic types ({@link Sort#NON_GENERIC}) and for generic arrays ({@link Sort#GENERIC_ARRAY}).
&nbsp;         * For all other types, this method throws an {@link IllegalStateException}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @return This type&#39;s owner type or {@code null} if no owner type exists.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Generic getOwnerType();
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * Returns the parameter binding of the supplied type variable.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * This method must only be called for parameterized types ({@link Sort#PARAMETERIZED}). For all other types,
&nbsp;         * this method throws an {@link IllegalStateException}.
&nbsp;         * &lt;/p&gt;
&nbsp;         *
&nbsp;         * @param typeVariable The type variable for which a value should be located.
&nbsp;         * @return The value that is bound to the supplied type variable or {@code null} if the type variable
&nbsp;         * is not bound by this parameterized type.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Generic findBindingOf(Generic typeVariable);
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the source of this type variable. A type variable source is only well-defined for an attached type variable
&nbsp;         * ({@link Sort#VARIABLE}. For other types, this method
&nbsp;         * throws an {@link IllegalStateException}.
&nbsp;         *
&nbsp;         * @return This type&#39;s type variable source.
&nbsp;         */
&nbsp;        TypeVariableSource getTypeVariableSource();
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the symbol of this type variable. A symbol is only well-defined for type variables
&nbsp;         * ({@link Sort#VARIABLE}, {@link Sort#VARIABLE_SYMBOLIC}). For other types, this method
&nbsp;         * throws an {@link IllegalStateException}.
&nbsp;         *
&nbsp;         * @return This type&#39;s type variable symbol.
&nbsp;         */
&nbsp;        String getSymbol();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        Generic getComponentType();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents();
&nbsp;
&nbsp;        /**
&nbsp;         * Applies a visitor to this generic type description.
&nbsp;         *
&nbsp;         * @param visitor The visitor to apply.
&nbsp;         * @param &lt;T&gt;     The value that this visitor yields.
&nbsp;         * @return The visitor&#39;s return value.
&nbsp;         */
&nbsp;        &lt;T&gt; T accept(Visitor&lt;T&gt; visitor);
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that can be applied to a {@link Generic} for differentiating on the sort of the visited type.
&nbsp;         *
&nbsp;         * @param &lt;T&gt; The visitor&#39;s return value&#39;s type.
&nbsp;         */
&nbsp;        interface Visitor&lt;T&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a generic array type ({@link Sort#GENERIC_ARRAY}).
&nbsp;             *
&nbsp;             * @param genericArray The generic array type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onGenericArray(Generic genericArray);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a wildcard ({@link Sort#WILDCARD}).
&nbsp;             *
&nbsp;             * @param wildcard The wildcard.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onWildcard(Generic wildcard);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a parameterized type ({@link Sort#PARAMETERIZED}).
&nbsp;             *
&nbsp;             * @param parameterizedType The generic array type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onParameterizedType(Generic parameterizedType);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a type variable ({@link Sort#VARIABLE}, {@link Sort#VARIABLE_SYMBOLIC}).
&nbsp;             *
&nbsp;             * @param typeVariable The generic array type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onTypeVariable(Generic typeVariable);
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a non-generic type ({@link Sort#NON_GENERIC}).
&nbsp;             *
&nbsp;             * @param typeDescription The non-generic type.
&nbsp;             * @return The visitor&#39;s return value.
&nbsp;             */
&nbsp;            T onNonGenericType(Generic typeDescription);
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational generic type visitor. Any visited type is returned in its existing form.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return genericArray;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    return wildcard;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return parameterizedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return typeVariable;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that returns the erasure of any visited type. For wildcard types, an exception is thrown.
&nbsp;             */
<b class="fc">&nbsp;            enum TypeErasing implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return genericArray.asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot erase a wildcard type: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return parameterizedType.asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return typeVariable.asRawType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.asRawType();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that strips all type annotations of all types.
&nbsp;             */
<b class="fc">&nbsp;            enum AnnotationStripper implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return new OfGenericArray.Latent(genericArray.getComponentType().accept(this), Empty.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), Empty.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                    return new OfParameterizedType.Latent(parameterizedType.asErasure(),</b>
<b class="fc">&nbsp;                            ownerType == null</b>
<b class="fc">&nbsp;                                    ? UNDEFINED</b>
<b class="nc">&nbsp;                                    : ownerType.accept(this),</b>
<b class="fc">&nbsp;                            parameterizedType.getTypeArguments().accept(this),</b>
&nbsp;                            Empty.INSTANCE);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return new NonAnnotatedTypeVariable(typeVariable);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.isArray()</b>
<b class="fc">&nbsp;                            ? new OfGenericArray.Latent(onNonGenericType(typeDescription.getComponentType()), Empty.INSTANCE)</b>
<b class="fc">&nbsp;                            : new OfNonGenericType.Latent(typeDescription.asErasure(), Empty.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Representation of a type variable without annotations.
&nbsp;                 */
&nbsp;                protected static class NonAnnotatedTypeVariable extends OfTypeVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented type variable.
&nbsp;                     */
&nbsp;                    private final Generic typeVariable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new non-annotated type variable.
&nbsp;                     *
&nbsp;                     * @param typeVariable The represented type variable.
&nbsp;                     */
<b class="fc">&nbsp;                    protected NonAnnotatedTypeVariable(Generic typeVariable) {</b>
<b class="fc">&nbsp;                        this.typeVariable = typeVariable;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeList.Generic getUpperBounds() {
<b class="nc">&nbsp;                        return typeVariable.getUpperBounds();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                        return typeVariable.getTypeVariableSource();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public String getSymbol() {
<b class="fc">&nbsp;                        return typeVariable.getSymbol();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                        return new AnnotationList.Empty();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that determines the direct assignability of a type to another generic type. This visitor only checks
&nbsp;             * for strict assignability and does not perform any form of boxing or primitive type widening that are allowed
&nbsp;             * in the Java language.
&nbsp;             */
<b class="fc">&nbsp;            enum Assigner implements Visitor&lt;Assigner.Dispatcher&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return new Dispatcher.ForGenericArray(genericArray);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;A wildcard is not a first level type: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return new Dispatcher.ForParameterizedType(parameterizedType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return new Dispatcher.ForTypeVariable(typeVariable);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Dispatcher onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return new Dispatcher.ForNonGenericType(typeDescription.asErasure());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher that allows to check if the visited generic type is assignable to the supplied type.
&nbsp;                 */
&nbsp;                public interface Dispatcher {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Checks if the represented type is a super type of the type that is supplied as an argument.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type to check for being assignable to the represented type.
&nbsp;                     * @return {@code true} if the represented type is assignable to the supplied type.
&nbsp;                     */
&nbsp;                    boolean isAssignableFrom(Generic typeDescription);
&nbsp;
&nbsp;                    /**
&nbsp;                     * An abstract base implementation of a dispatcher that forwards the decision to a visitor implementation.
&nbsp;                     */
<b class="fc">&nbsp;                    abstract class AbstractBase implements Dispatcher, Visitor&lt;Boolean&gt; {</b>
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public boolean isAssignableFrom(Generic typeDescription) {
<b class="fc">&nbsp;                            return typeDescription.accept(this);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a non-generic type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForNonGenericType extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The description of the type to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final TypeDescription typeDescription;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher of a non-generic type.
&nbsp;                         *
&nbsp;                         * @param typeDescription The description of the type to which another type is assigned.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ForNonGenericType(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                            this.typeDescription = typeDescription;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                            return typeDescription.isArray()</b>
<b class="fc">&nbsp;                                    ? genericArray.getComponentType().accept(new ForNonGenericType(typeDescription.getComponentType()))</b>
<b class="fc">&nbsp;                                    : typeDescription.represents(Object.class) || TypeDescription.ARRAY_INTERFACES.contains(typeDescription.asGenericType());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                            if (typeDescription.equals(parameterizedType.asErasure())) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            Generic superClass = parameterizedType.getSuperClass();</b>
<b class="fc">&nbsp;                            if (superClass != null &amp;&amp; isAssignableFrom(superClass)) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (Generic interfaceType : parameterizedType.getInterfaces()) {</b>
<b class="fc">&nbsp;                                if (isAssignableFrom(interfaceType)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return typeDescription.represents(Object.class);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                            for (Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                                if (isAssignableFrom(upperBound)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                            return this.typeDescription.isAssignableFrom(typeDescription.asErasure());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a type variable.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForTypeVariable extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The description of the type variable to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher of a type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariable The description of the type variable to which another type is assigned.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ForTypeVariable(Generic typeVariable) {</b>
<b class="fc">&nbsp;                            this.typeVariable = typeVariable;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                            if (typeVariable.equals(this.typeVariable)) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                                if (isAssignableFrom(upperBound)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a parameterized type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForParameterizedType extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The parameterized type to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final Generic parameterizedType;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher for checking the assignability of a parameterized type.
&nbsp;                         *
&nbsp;                         * @param parameterizedType The parameterized type to which another type is assigned.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ForParameterizedType(Generic parameterizedType) {</b>
<b class="fc">&nbsp;                            this.parameterizedType = parameterizedType;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                            if (this.parameterizedType.asErasure().equals(parameterizedType.asErasure())) {</b>
<b class="fc">&nbsp;                                Generic fromOwner = this.parameterizedType.getOwnerType(), toOwner = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                                if (fromOwner != null &amp;&amp; toOwner != null &amp;&amp; !fromOwner.accept(Assigner.INSTANCE).isAssignableFrom(toOwner)) {</b>
<b class="nc">&nbsp;                                    return false;</b>
&nbsp;                                }
<b class="fc">&nbsp;                                TypeList.Generic fromArguments = this.parameterizedType.getTypeArguments(), toArguments = parameterizedType.getTypeArguments();</b>
<b class="fc">&nbsp;                                if (fromArguments.size() == toArguments.size()) {</b>
<b class="fc">&nbsp;                                    for (int index = 0; index &lt; fromArguments.size(); index++) {</b>
<b class="fc">&nbsp;                                        if (!fromArguments.get(index).accept(ParameterAssigner.INSTANCE).isAssignableFrom(toArguments.get(index))) {</b>
<b class="fc">&nbsp;                                            return false;</b>
&nbsp;                                        }
&nbsp;                                    }
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                } else {
<b class="fc">&nbsp;                                    throw new IllegalArgumentException(&quot;Incompatible generic types: &quot; + parameterizedType + &quot; and &quot; + this.parameterizedType);</b>
&nbsp;                                }
&nbsp;                            }
<b class="fc">&nbsp;                            Generic superClass = parameterizedType.getSuperClass();</b>
<b class="fc">&nbsp;                            if (superClass != null &amp;&amp; isAssignableFrom(superClass)) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (Generic interfaceType : parameterizedType.getInterfaces()) {</b>
<b class="fc">&nbsp;                                if (isAssignableFrom(interfaceType)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                            for (Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                                if (isAssignableFrom(upperBound)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                            if (parameterizedType.asErasure().equals(typeDescription.asErasure())) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            Generic superClass = typeDescription.getSuperClass();</b>
<b class="fc">&nbsp;                            if (superClass != null &amp;&amp; isAssignableFrom(superClass)) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                            for (Generic interfaceType : typeDescription.getInterfaces()) {</b>
<b class="fc">&nbsp;                                if (isAssignableFrom(interfaceType)) {</b>
<b class="fc">&nbsp;                                    return true;</b>
&nbsp;                                }
<b class="fc">&nbsp;                            }</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * An assigner for a parameter of a parameterized type.
&nbsp;                         */
<b class="fc">&nbsp;                        protected enum ParameterAssigner implements Visitor&lt;Dispatcher&gt; {</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * The singleton instance.
&nbsp;                             */
<b class="fc">&nbsp;                            INSTANCE;</b>
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Dispatcher onGenericArray(Generic genericArray) {
<b class="nc">&nbsp;                                return new InvariantBinding(genericArray);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Dispatcher onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                                TypeList.Generic lowerBounds = wildcard.getLowerBounds();</b>
<b class="fc">&nbsp;                                return lowerBounds.isEmpty()</b>
<b class="fc">&nbsp;                                        ? new CovariantBinding(wildcard.getUpperBounds().getOnly())</b>
<b class="fc">&nbsp;                                        : new ContravariantBinding(lowerBounds.getOnly());</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Dispatcher onParameterizedType(Generic parameterizedType) {
<b class="nc">&nbsp;                                return new InvariantBinding(parameterizedType);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Dispatcher onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                                return new InvariantBinding(typeVariable);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * {@inheritDoc}
&nbsp;                             */
&nbsp;                            public Dispatcher onNonGenericType(Generic typeDescription) {
<b class="nc">&nbsp;                                return new InvariantBinding(typeDescription);</b>
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A dispatcher for an invariant parameter of a parameterized type, i.e. a type without a wildcard.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class InvariantBinding implements Dispatcher {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The invariant type of the parameter.
&nbsp;                                 */
&nbsp;                                private final Generic typeDescription;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new dispatcher for an invariant parameter of a parameterized type.
&nbsp;                                 *
&nbsp;                                 * @param typeDescription The invariant type of the parameter.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected InvariantBinding(Generic typeDescription) {</b>
<b class="fc">&nbsp;                                    this.typeDescription = typeDescription;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
<b class="fc">&nbsp;                                    return typeDescription.equals(this.typeDescription);</b>
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A dispatcher for an covariant parameter of a parameterized type, i.e. a type that is the lower bound of a wildcard.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class CovariantBinding implements Dispatcher {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The lower bound type of a covariant parameter.
&nbsp;                                 */
&nbsp;                                private final Generic upperBound;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new dispatcher for covariant parameter of a parameterized type.
&nbsp;                                 *
&nbsp;                                 * @param upperBound The upper bound type of a covariant parameter.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected CovariantBinding(Generic upperBound) {</b>
<b class="fc">&nbsp;                                    this.upperBound = upperBound;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
<b class="fc">&nbsp;                                    if (typeDescription.getSort().isWildcard()) {</b>
<b class="fc">&nbsp;                                        return typeDescription.getLowerBounds().isEmpty() &amp;&amp; upperBound.accept(Assigner.INSTANCE)</b>
<b class="fc">&nbsp;                                                .isAssignableFrom(typeDescription.getUpperBounds().getOnly());</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        return upperBound.accept(Assigner.INSTANCE).isAssignableFrom(typeDescription);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;
&nbsp;                            /**
&nbsp;                             * A dispatcher for an contravariant parameter of a parameterized type, i.e. a type that is the lower bound of a wildcard.
&nbsp;                             */
&nbsp;                            @HashCodeAndEqualsPlugin.Enhance
&nbsp;                            protected static class ContravariantBinding implements Dispatcher {
&nbsp;
&nbsp;                                /**
&nbsp;                                 * The lower bound type of a contravariant parameter.
&nbsp;                                 */
&nbsp;                                private final Generic lowerBound;
&nbsp;
&nbsp;                                /**
&nbsp;                                 * Creates a new dispatcher for contravariant parameter of a parameterized type.
&nbsp;                                 *
&nbsp;                                 * @param lowerBound The lower bound type of a contravariant parameter.
&nbsp;                                 */
<b class="fc">&nbsp;                                protected ContravariantBinding(Generic lowerBound) {</b>
<b class="fc">&nbsp;                                    this.lowerBound = lowerBound;</b>
&nbsp;                                }
&nbsp;
&nbsp;                                /**
&nbsp;                                 * {@inheritDoc}
&nbsp;                                 */
&nbsp;                                public boolean isAssignableFrom(Generic typeDescription) {
<b class="fc">&nbsp;                                    if (typeDescription.getSort().isWildcard()) {</b>
<b class="fc">&nbsp;                                        TypeList.Generic lowerBounds = typeDescription.getLowerBounds();</b>
<b class="fc">&nbsp;                                        return !lowerBounds.isEmpty() &amp;&amp; lowerBounds.getOnly().accept(Assigner.INSTANCE).isAssignableFrom(lowerBound);</b>
&nbsp;                                    } else {
<b class="fc">&nbsp;                                        return typeDescription.getSort().isWildcard() || typeDescription.accept(Assigner.INSTANCE).isAssignableFrom(lowerBound);</b>
&nbsp;                                    }
&nbsp;                                }
&nbsp;                            }
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for checking the assignability of a generic array type.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance
&nbsp;                    class ForGenericArray extends AbstractBase {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The generic array type to which another type is assigned.
&nbsp;                         */
&nbsp;                        private final Generic genericArray;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new dispatcher for checking the assignability of a generic array type.
&nbsp;                         *
&nbsp;                         * @param genericArray The generic array type to which another type is assigned.
&nbsp;                         */
<b class="fc">&nbsp;                        protected ForGenericArray(Generic genericArray) {</b>
<b class="fc">&nbsp;                            this.genericArray = genericArray;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                        public Boolean onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                            return this.genericArray.getComponentType().accept(Assigner.INSTANCE).isAssignableFrom(genericArray.getComponentType());</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                            throw new IllegalArgumentException(&quot;A wildcard is not a first-level type: &quot; + wildcard);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                        public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                            return typeDescription.isArray()</b>
<b class="fc">&nbsp;                                    &amp;&amp; genericArray.getComponentType().accept(Assigner.INSTANCE).isAssignableFrom(typeDescription.getComponentType());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A validator for Java types that are defined for a specified type use within a Java class file.
&nbsp;             */
<b class="fc">&nbsp;            enum Validator implements Visitor&lt;Boolean&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for checking a type&#39;s non-null super class.
&nbsp;                 */
<b class="fc">&nbsp;                SUPER_CLASS(false, false, false, false) {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; !typeDescription.isInterface();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        return !parameterizedType.isInterface();</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for an interface type.
&nbsp;                 */
<b class="fc">&nbsp;                INTERFACE(false, false, false, false) {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        return super.onNonGenericType(typeDescription) &amp;&amp; typeDescription.isInterface();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        return parameterizedType.isInterface();</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a type variable.
&nbsp;                 */
<b class="fc">&nbsp;                TYPE_VARIABLE(false, false, true, false),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a field type.
&nbsp;                 */
<b class="fc">&nbsp;                FIELD(true, true, true, false),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method return type.
&nbsp;                 */
<b class="fc">&nbsp;                METHOD_RETURN(true, true, true, true),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method parameter type.
&nbsp;                 */
<b class="fc">&nbsp;                METHOD_PARAMETER(true, true, true, false),</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method exception type.
&nbsp;                 */
<b class="fc">&nbsp;                EXCEPTION(false, false, true, false) {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        for (TypeDescription.Generic bound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                            if (bound.accept(this)) {</b>
<b class="fc">&nbsp;                                return true;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription.asErasure().isAssignableTo(Throwable.class);</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A validator for a method receiver type.
&nbsp;                 */
<b class="fc">&nbsp;                RECEIVER(false, false, false, false);</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts array types.
&nbsp;                 */
&nbsp;                private final boolean acceptsArray;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts primitive types.
&nbsp;                 */
&nbsp;                private final boolean acceptsPrimitive;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts type variables.
&nbsp;                 */
&nbsp;                private final boolean acceptsVariable;
&nbsp;
&nbsp;                /**
&nbsp;                 * {@code true} if this validator accepts the {@code void} type.
&nbsp;                 */
&nbsp;                private final boolean acceptsVoid;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new validator.
&nbsp;                 *
&nbsp;                 * @param acceptsArray     {@code true} if this validator accepts array types.
&nbsp;                 * @param acceptsPrimitive {@code true} if this validator accepts primitive types.
&nbsp;                 * @param acceptsVariable  {@code true} if this validator accepts type variables.
&nbsp;                 * @param acceptsVoid      {@code true} if this validator accepts the {@code void} type.
&nbsp;                 */
<b class="fc">&nbsp;                Validator(boolean acceptsArray, boolean acceptsPrimitive, boolean acceptsVariable, boolean acceptsVoid) {</b>
<b class="fc">&nbsp;                    this.acceptsArray = acceptsArray;</b>
<b class="fc">&nbsp;                    this.acceptsPrimitive = acceptsPrimitive;</b>
<b class="fc">&nbsp;                    this.acceptsVariable = acceptsVariable;</b>
<b class="fc">&nbsp;                    this.acceptsVoid = acceptsVoid;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Boolean onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return acceptsArray;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return acceptsVariable;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return (acceptsArray || !typeDescription.isArray())</b>
<b class="fc">&nbsp;                            &amp;&amp; (acceptsPrimitive || !typeDescription.isPrimitive())</b>
<b class="fc">&nbsp;                            &amp;&amp; (acceptsVoid || !typeDescription.represents(void.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type validator for checking type annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public enum ForTypeAnnotations implements Visitor&lt;Boolean&gt; {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The singleton instance.
&nbsp;                     */
<b class="fc">&nbsp;                    INSTANCE;</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the {@code ElementType#TYPE_USE} element.
&nbsp;                     */
&nbsp;                    private static final String TYPE_USE = &quot;TYPE_USE&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The name of the {@code ElementType#TYPE_PARAMETER} element.
&nbsp;                     */
&nbsp;                    private static final String TYPE_PARAMETER = &quot;TYPE_PARAMETER&quot;;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Validates the type annotations on a formal type variable but not on its bounds..
&nbsp;                     *
&nbsp;                     * @param typeVariable The type variable to validate.
&nbsp;                     * @return {@code true} if the formal type variable declares invalid type annotations.
&nbsp;                     */
&nbsp;                    public static boolean ofFormalTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="fc">&nbsp;                        for (AnnotationDescription annotationDescription : typeVariable.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                            if (!annotationDescription.isSupportedOn(TYPE_PARAMETER) || !annotationTypes.add(annotationDescription.getAnnotationType())) {</b>
<b class="fc">&nbsp;                                return false;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                    public Boolean onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                        return isValid(genericArray) &amp;&amp; genericArray.getComponentType().accept(this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Boolean onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                        if (!isValid(wildcard)) {</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        TypeList.Generic lowerBounds = wildcard.getLowerBounds();</b>
<b class="fc">&nbsp;                        return (lowerBounds.isEmpty()</b>
<b class="fc">&nbsp;                                ? wildcard.getUpperBounds()</b>
<b class="fc">&nbsp;                                : lowerBounds).getOnly().accept(this);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Boolean onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        if (!isValid(parameterizedType)) {</b>
<b class="fc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        Generic ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                        if (ownerType != null &amp;&amp; !ownerType.accept(this)) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="fc">&nbsp;                        for (Generic typeArgument : parameterizedType.getTypeArguments()) {</b>
<b class="fc">&nbsp;                            if (!typeArgument.accept(this)) {</b>
<b class="nc">&nbsp;                                return false;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Boolean onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        return isValid(typeVariable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                    public Boolean onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        return isValid(typeDescription) &amp;&amp; (!typeDescription.isArray() || typeDescription.getComponentType().accept(this));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Checks if the supplied type&#39;s type annotations are valid.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type to validate.
&nbsp;                     * @return {@code true} if the supplied type&#39;s type annotations are valid.
&nbsp;                     */
&nbsp;                    private boolean isValid(Generic typeDescription) {
<b class="fc">&nbsp;                        Set&lt;TypeDescription&gt; annotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="fc">&nbsp;                        for (AnnotationDescription annotationDescription : typeDescription.getDeclaredAnnotations()) {</b>
<b class="fc">&nbsp;                            if (!annotationDescription.isSupportedOn(TYPE_USE) || !annotationTypes.add(annotationDescription.getAnnotationType())) {</b>
<b class="fc">&nbsp;                                return false;</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that reifies type descriptions if they represent raw types.
&nbsp;             */
<b class="fc">&nbsp;            enum Reifying implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor that reifies non-generic types if they represent raw types. This visitor should be applied when
&nbsp;                 * visiting a potential raw type.
&nbsp;                 */
<b class="fc">&nbsp;                INITIATING {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        return parameterizedType;</b>
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor that reifies non-generic types if they represent raw types or are parameterized types. This visitor
&nbsp;                 * should only be applied when a type was inherited from a reified type.
&nbsp;                 */
<b class="fc">&nbsp;                INHERITING {</b>
&nbsp;                    /** {@inheritDoc} */
&nbsp;                    public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        return new OfParameterizedType.ForReifiedType(parameterizedType);</b>
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a generic array: &quot; + genericArray);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a wildcard: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot reify a type variable: &quot; + typeVariable);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    TypeDescription erasure = typeDescription.asErasure();</b>
<b class="fc">&nbsp;                    return erasure.isGenerified()</b>
<b class="fc">&nbsp;                            ? new OfNonGenericType.ForReifiedErasure(erasure)</b>
<b class="fc">&nbsp;                            : typeDescription;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Visits a generic type and appends the discovered type to the supplied signature visitor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForSignatureVisitor implements Visitor&lt;SignatureVisitor&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * Index of a {@link String}&#39;s only character to improve code readability.
&nbsp;                 */
&nbsp;                private static final int ONLY_CHARACTER = 0;
&nbsp;
&nbsp;                /**
&nbsp;                 * The signature visitor that receives the discovered generic type.
&nbsp;                 */
&nbsp;                protected final SignatureVisitor signatureVisitor;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new visitor for the given signature visitor.
&nbsp;                 *
&nbsp;                 * @param signatureVisitor The signature visitor that receives the discovered generic type.
&nbsp;                 */
<b class="fc">&nbsp;                public ForSignatureVisitor(SignatureVisitor signatureVisitor) {</b>
<b class="fc">&nbsp;                    this.signatureVisitor = signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public SignatureVisitor onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    genericArray.getComponentType().accept(new ForSignatureVisitor(signatureVisitor.visitArrayType()));</b>
<b class="fc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Unexpected wildcard: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    onOwnableType(parameterizedType);</b>
<b class="fc">&nbsp;                    signatureVisitor.visitEnd();</b>
<b class="fc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Visits a type which might define an owner type.
&nbsp;                 *
&nbsp;                 * @param ownableType The visited generic type.
&nbsp;                 */
&nbsp;                private void onOwnableType(Generic ownableType) {
<b class="fc">&nbsp;                    Generic ownerType = ownableType.getOwnerType();</b>
<b class="fc">&nbsp;                    if (ownerType != null &amp;&amp; ownerType.getSort().isParameterized()) {</b>
<b class="fc">&nbsp;                        onOwnableType(ownerType);</b>
<b class="fc">&nbsp;                        signatureVisitor.visitInnerClassType(ownableType.asErasure().getSimpleName());</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        signatureVisitor.visitClassType(ownableType.asErasure().getInternalName());</b>
&nbsp;                    }
<b class="fc">&nbsp;                    for (Generic typeArgument : ownableType.getTypeArguments()) {</b>
<b class="fc">&nbsp;                        typeArgument.accept(new OfTypeArgument(signatureVisitor));</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public SignatureVisitor onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    signatureVisitor.visitTypeVariable(typeVariable.getSymbol());</b>
<b class="fc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public SignatureVisitor onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    if (typeDescription.isArray()) {</b>
<b class="fc">&nbsp;                        typeDescription.getComponentType().accept(new ForSignatureVisitor(signatureVisitor.visitArrayType()));</b>
<b class="fc">&nbsp;                    } else if (typeDescription.isPrimitive()) {</b>
<b class="fc">&nbsp;                        signatureVisitor.visitBaseType(typeDescription.asErasure().getDescriptor().charAt(ONLY_CHARACTER));</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        signatureVisitor.visitClassType(typeDescription.asErasure().getInternalName());</b>
<b class="fc">&nbsp;                        signatureVisitor.visitEnd();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return signatureVisitor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Visits a parameter while visiting a generic type for delegating discoveries to a signature visitor.
&nbsp;                 */
&nbsp;                protected static class OfTypeArgument extends ForSignatureVisitor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new parameter visitor.
&nbsp;                     *
&nbsp;                     * @param signatureVisitor The signature visitor which is notified over visited types.
&nbsp;                     */
&nbsp;                    protected OfTypeArgument(SignatureVisitor signatureVisitor) {
<b class="fc">&nbsp;                        super(signatureVisitor);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                        TypeList.Generic upperBounds = wildcard.getUpperBounds(), lowerBounds = wildcard.getLowerBounds();</b>
<b class="fc">&nbsp;                        if (lowerBounds.isEmpty() &amp;&amp; upperBounds.getOnly().represents(Object.class)) {</b>
<b class="fc">&nbsp;                            signatureVisitor.visitTypeArgument();</b>
<b class="fc">&nbsp;                        } else if (!lowerBounds.isEmpty() /* &amp;&amp; upperBounds.isEmpty() */) {</b>
<b class="fc">&nbsp;                            lowerBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.SUPER)));</b>
&nbsp;                        } else /* if (!upperBounds.isEmpty() &amp;&amp; lowerBounds.isEmpty()) */ {
<b class="fc">&nbsp;                            upperBounds.getOnly().accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.EXTENDS)));</b>
&nbsp;                        }
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                        genericArray.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                        parameterizedType.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        typeVariable.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public SignatureVisitor onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        typeDescription.accept(new ForSignatureVisitor(signatureVisitor.visitTypeArgument(SignatureVisitor.INSTANCEOF)));</b>
<b class="fc">&nbsp;                        return signatureVisitor;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An abstract implementation of a visitor that substitutes generic types by replacing (nested)
&nbsp;             * type variables and/or non-generic component types.
&nbsp;             */
<b class="fc">&nbsp;            abstract class Substitutor implements Visitor&lt;Generic&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                    List&lt;Generic&gt; typeArguments = new ArrayList&lt;Generic&gt;(parameterizedType.getTypeArguments().size());</b>
<b class="fc">&nbsp;                    for (Generic typeArgument : parameterizedType.getTypeArguments()) {</b>
<b class="fc">&nbsp;                        typeArguments.add(typeArgument.accept(this));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return new OfParameterizedType.Latent(parameterizedType.asRawType().accept(this).asErasure(),</b>
<b class="fc">&nbsp;                            ownerType == null</b>
<b class="fc">&nbsp;                                    ? UNDEFINED</b>
<b class="fc">&nbsp;                                    : ownerType.accept(this),</b>
&nbsp;                            typeArguments,
&nbsp;                            parameterizedType);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return new OfGenericArray.Latent(genericArray.getComponentType().accept(this), genericArray);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    return new OfWildcardType.Latent(wildcard.getUpperBounds().accept(this), wildcard.getLowerBounds().accept(this), wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.isArray()</b>
<b class="fc">&nbsp;                            ? new OfGenericArray.Latent(typeDescription.getComponentType().accept(this), typeDescription)</b>
<b class="fc">&nbsp;                            : onSimpleType(typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Visits a simple, non-generic type, i.e. either a component type of an array or a non-array type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type that is visited.
&nbsp;                 * @return The substituted type.
&nbsp;                 */
&nbsp;                protected abstract Generic onSimpleType(Generic typeDescription);
&nbsp;
&nbsp;                /**
&nbsp;                 * A {@link Substitutor} that only substitutes type variables but fully preserves non-generic type definitions.
&nbsp;                 */
<b class="fc">&nbsp;                public abstract static class WithoutTypeSubstitution extends Substitutor {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A substitutor that attaches type variables to a type variable source and replaces representations of
&nbsp;                 * {@link TargetType} with a given declaring type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForAttachment extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The declaring type which is filled in for {@link TargetType}.
&nbsp;                     */
&nbsp;                    private final TypeDescription declaringType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The source which is used for locating type variables.
&nbsp;                     */
&nbsp;                    private final TypeVariableSource typeVariableSource;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a visitor for attaching type variables.
&nbsp;                     *
&nbsp;                     * @param declaringType      The declaring type which is filled in for {@link TargetType} in its erased form.
&nbsp;                     * @param typeVariableSource The source which is used for locating type variables.
&nbsp;                     */
&nbsp;                    protected ForAttachment(TypeDefinition declaringType, TypeVariableSource typeVariableSource) {
<b class="fc">&nbsp;                        this(declaringType.asErasure(), typeVariableSource);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a visitor for attaching type variables.
&nbsp;                     *
&nbsp;                     * @param declaringType      The declaring type which is filled in for {@link TargetType}.
&nbsp;                     * @param typeVariableSource The source which is used for locating type variables.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForAttachment(TypeDescription declaringType, TypeVariableSource typeVariableSource) {</b>
<b class="fc">&nbsp;                        this.declaringType = declaringType;</b>
<b class="fc">&nbsp;                        this.typeVariableSource = typeVariableSource;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given type description.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given type&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(TypeDescription typeDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(typeDescription, typeDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given field description.
&nbsp;                     *
&nbsp;                     * @param fieldDescription The field description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given field&#39;s type context.
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;                    public static ForAttachment of(FieldDescription fieldDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(fieldDescription.getDeclaringType(), fieldDescription.getDeclaringType().asErasure());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given method description.
&nbsp;                     *
&nbsp;                     * @param methodDescription The method description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given method&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(MethodDescription methodDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(methodDescription.getDeclaringType(), methodDescription);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given parameter description.
&nbsp;                     *
&nbsp;                     * @param parameterDescription The parameter description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given parameter&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(ParameterDescription parameterDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(parameterDescription.getDeclaringMethod().getDeclaringType(), parameterDescription.getDeclaringMethod());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Attaches all types to the given record component description.
&nbsp;                     *
&nbsp;                     * @param recordComponentDescription The record component description to which visited types should be attached to.
&nbsp;                     * @return A substitutor that attaches visited types to the given record component&#39;s type context.
&nbsp;                     */
&nbsp;                    public static ForAttachment of(RecordComponentDescription recordComponentDescription) {
<b class="fc">&nbsp;                        return new ForAttachment(recordComponentDescription.getDeclaringType(), recordComponentDescription.getDeclaringType().asErasure());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        return new OfTypeVariable.WithAnnotationOverlay(typeVariableSource.findExpectedVariable(typeVariable.getSymbol()), typeVariable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription.represents(TargetType.class)</b>
<b class="fc">&nbsp;                                ? new OfNonGenericType.Latent(declaringType, typeDescription)</b>
<b class="fc">&nbsp;                                : typeDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor for detaching a type from its declaration context by detaching type variables. This is achieved by
&nbsp;                 * detaching type variables and by replacing the declaring type which is identified by a provided {@link ElementMatcher}
&nbsp;                 * with {@link TargetType}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForDetachment extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A type matcher for identifying the declaring type.
&nbsp;                     */
&nbsp;                    private final ElementMatcher&lt;? super TypeDescription&gt; typeMatcher;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a visitor for detaching a type.
&nbsp;                     *
&nbsp;                     * @param typeMatcher A type matcher for identifying the declaring type.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForDetachment(ElementMatcher&lt;? super TypeDescription&gt; typeMatcher) {</b>
<b class="fc">&nbsp;                        this.typeMatcher = typeMatcher;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns a new detachment visitor that detaches any type matching the supplied type description.
&nbsp;                     *
&nbsp;                     * @param typeDefinition The type to detach.
&nbsp;                     * @return A detachment visitor for the supplied type description.
&nbsp;                     */
&nbsp;                    public static Visitor&lt;Generic&gt; of(TypeDefinition typeDefinition) {
<b class="fc">&nbsp;                        return new ForDetachment(is(typeDefinition));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeMatcher.matches(typeDescription.asErasure())</b>
<b class="fc">&nbsp;                                ? new OfNonGenericType.Latent(TargetType.DESCRIPTION, typeDescription.getOwnerType(), typeDescription)</b>
<b class="fc">&nbsp;                                : typeDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A visitor for binding type variables to their values.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
<b class="fc">&nbsp;                public static class ForTypeVariableBinding extends WithoutTypeSubstitution {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The parameterized type for which type variables are bound.
&nbsp;                     */
&nbsp;                    private final Generic parameterizedType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new visitor for binding a parameterized type&#39;s type arguments to its type variables.
&nbsp;                     *
&nbsp;                     * @param parameterizedType The parameterized type for which type variables are bound.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ForTypeVariableBinding(Generic parameterizedType) {</b>
<b class="fc">&nbsp;                        this.parameterizedType = parameterizedType;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        return typeVariable.getTypeVariableSource().accept(new TypeVariableSubstitutor(typeVariable));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Substitutes a type variable, either with a new binding if the variable is defined by a type or with a
&nbsp;                     * retained type variable if the variable is defined by a method.
&nbsp;                     */
&nbsp;                    @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                    protected class TypeVariableSubstitutor implements TypeVariableSource.Visitor&lt;Generic&gt; {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The discovered type variable.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new type variable substitutor.
&nbsp;                         *
&nbsp;                         * @param typeVariable The discovered type variable.
&nbsp;                         */
<b class="fc">&nbsp;                        protected TypeVariableSubstitutor(Generic typeVariable) {</b>
<b class="fc">&nbsp;                            this.typeVariable = typeVariable;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic onType(TypeDescription typeDescription) {
&nbsp;                            // A type variable might be undeclared due to breaking inner class semantics or due to incorrect scoping by a compiler.
<b class="fc">&nbsp;                            Generic typeArgument = parameterizedType.findBindingOf(typeVariable);</b>
<b class="fc">&nbsp;                            return typeArgument == null</b>
<b class="fc">&nbsp;                                    ? typeVariable.asRawType()</b>
<b class="fc">&nbsp;                                    : typeArgument;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public Generic onMethod(MethodDescription.InDefinedShape methodDescription) {
<b class="fc">&nbsp;                            return new RetainedMethodTypeVariable(typeVariable);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Implementation of a type variable on a method that is not substituted.
&nbsp;                     */
&nbsp;                    protected class RetainedMethodTypeVariable extends OfTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * The discovered type variable.
&nbsp;                         */
&nbsp;                        private final Generic typeVariable;
&nbsp;
&nbsp;                        /**
&nbsp;                         * Creates a new retained type variable.
&nbsp;                         *
&nbsp;                         * @param typeVariable The discovered type variable.
&nbsp;                         */
<b class="fc">&nbsp;                        protected RetainedMethodTypeVariable(Generic typeVariable) {</b>
<b class="fc">&nbsp;                            this.typeVariable = typeVariable;</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                            return typeVariable.getUpperBounds().accept(ForTypeVariableBinding.this);</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                            return typeVariable.getTypeVariableSource();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public String getSymbol() {
<b class="fc">&nbsp;                            return typeVariable.getSymbol();</b>
&nbsp;                        }
&nbsp;
&nbsp;                        /**
&nbsp;                         * {@inheritDoc}
&nbsp;                         */
&nbsp;                        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                            return typeVariable.getDeclaredAnnotations();</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A substitutor that normalizes a token to represent all {@link TargetType} by a given type and that symbolizes all type variables.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForTokenNormalization extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type description to substitute all {@link TargetType} representations with.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new token normalization visitor.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type description to substitute all {@link TargetType}
&nbsp;                     */
<b class="fc">&nbsp;                    public ForTokenNormalization(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription.represents(TargetType.class)</b>
<b class="fc">&nbsp;                                ? new OfNonGenericType.Latent(this.typeDescription, typeDescription)</b>
<b class="fc">&nbsp;                                : typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        return new OfTypeVariable.Symbolic(typeVariable.getSymbol(), typeVariable);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A substitutor that replaces a type description with an equal type description.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForReplacement extends Substitutor {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type description to substitute.
&nbsp;                     */
&nbsp;                    private final TypeDescription typeDescription;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new substitutor for a type description replacement.
&nbsp;                     *
&nbsp;                     * @param typeDescription The type description to substitute.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForReplacement(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                        this.typeDescription = typeDescription;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                        return typeVariable;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    protected Generic onSimpleType(Generic typeDescription) {
<b class="fc">&nbsp;                        return typeDescription.asErasure().equals(this.typeDescription)</b>
<b class="fc">&nbsp;                                ? new OfNonGenericType.Latent(this.typeDescription, typeDescription)</b>
<b class="fc">&nbsp;                                : typeDescription;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that transforms any type into a raw type if declaring type is generified. If the declaring type is
&nbsp;             * not generified, the original type description is returned.
&nbsp;             */
&nbsp;            class ForRawType implements Visitor&lt;Generic&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type description that is potentially a raw type.
&nbsp;                 */
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a visitor for representing declared types of a potentially raw type.
&nbsp;                 *
&nbsp;                 * @param declaringType The type description that is potentially a raw type.
&nbsp;                 */
<b class="fc">&nbsp;                public ForRawType(TypeDescription declaringType) {</b>
<b class="fc">&nbsp;                    this.declaringType = declaringType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return declaringType.isGenerified()</b>
<b class="nc">&nbsp;                            ? new Generic.OfNonGenericType.Latent(genericArray.asErasure(), genericArray)</b>
<b class="fc">&nbsp;                            : genericArray;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onWildcard(Generic wildcard) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;Did not expect wildcard on top-level: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return declaringType.isGenerified()</b>
<b class="fc">&nbsp;                            ? new Generic.OfNonGenericType.Latent(parameterizedType.asErasure(), parameterizedType)</b>
<b class="fc">&nbsp;                            : parameterizedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return declaringType.isGenerified()</b>
<b class="fc">&nbsp;                            ? new Generic.OfNonGenericType.Latent(typeVariable.asErasure(), typeVariable)</b>
<b class="fc">&nbsp;                            : typeVariable;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor that reduces a detached generic type to its erasure.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class Reducing implements Visitor&lt;TypeDescription&gt; {
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic type&#39;s declaring type.
&nbsp;                 */
&nbsp;                private final TypeDescription declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Any type variables that are directly declared by the member that declares the type being reduced.
&nbsp;                 */
&nbsp;                private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reducing type visitor.
&nbsp;                 *
&nbsp;                 * @param declaringType     The generic type&#39;s declaring type.
&nbsp;                 * @param typeVariableToken Any type variables that are directly declared by the member that declares the type being reduced.
&nbsp;                 */
&nbsp;                public Reducing(TypeDescription declaringType, TypeVariableToken... typeVariableToken) {
<b class="fc">&nbsp;                    this(declaringType, Arrays.asList(typeVariableToken));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reducing type visitor.
&nbsp;                 *
&nbsp;                 * @param declaringType      The generic type&#39;s declaring type.
&nbsp;                 * @param typeVariableTokens Any type variables that are directly declared by the member that declares the type being reduced.
&nbsp;                 */
<b class="fc">&nbsp;                public Reducing(TypeDescription declaringType, List&lt;? extends TypeVariableToken&gt; typeVariableTokens) {</b>
<b class="fc">&nbsp;                    this.declaringType = declaringType;</b>
<b class="fc">&nbsp;                    this.typeVariableTokens = typeVariableTokens;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public TypeDescription onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    Generic targetType = genericArray;</b>
<b class="fc">&nbsp;                    int arity = 0;</b>
&nbsp;                    do {
<b class="fc">&nbsp;                        targetType = targetType.getComponentType();</b>
<b class="fc">&nbsp;                        arity++;</b>
<b class="fc">&nbsp;                    } while (targetType.isArray());</b>
<b class="fc">&nbsp;                    if (targetType.getSort().isTypeVariable()) {</b>
<b class="fc">&nbsp;                        for (TypeVariableToken typeVariableToken : typeVariableTokens) {</b>
<b class="fc">&nbsp;                            if (targetType.getSymbol().equals(typeVariableToken.getSymbol())) {</b>
<b class="fc">&nbsp;                                return TypeDescription.ArrayProjection.of(typeVariableToken.getBounds().get(0).accept(this), arity);</b>
&nbsp;                            }
<b class="fc">&nbsp;                        }</b>
<b class="fc">&nbsp;                        return TargetType.resolve(TypeDescription.ArrayProjection.of(</b>
<b class="fc">&nbsp;                                declaringType.findExpectedVariable(targetType.getSymbol()).asErasure(),</b>
&nbsp;                                arity), declaringType);
&nbsp;                    } else {
<b class="fc">&nbsp;                        return TargetType.resolve(genericArray.asErasure(), declaringType);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A wildcard cannot be a top-level type: &quot; + wildcard);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return TargetType.resolve(parameterizedType.asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    for (TypeVariableToken typeVariableToken : typeVariableTokens) {</b>
<b class="fc">&nbsp;                        if (typeVariable.getSymbol().equals(typeVariableToken.getSymbol())) {</b>
<b class="fc">&nbsp;                            return typeVariableToken.getBounds().get(0).accept(this);</b>
&nbsp;                        }
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    return TargetType.resolve(declaringType.findExpectedVariable(typeVariable.getSymbol()).asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return TargetType.resolve(typeDescription.asErasure(), declaringType);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An annotation reader is responsible for lazily evaluating type annotations if this language
&nbsp;         * feature is available on the current JVM.
&nbsp;         */
&nbsp;        interface AnnotationReader {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the underlying {@link AnnotatedElement}.
&nbsp;             *
&nbsp;             * @return The underlying annotated element.
&nbsp;             */
&nbsp;            AnnotatedElement resolve();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the underlying type annotations as a list.
&nbsp;             *
&nbsp;             * @return The underlying type annotations as a list.
&nbsp;             */
&nbsp;            AnnotationList asList();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of an represented element&#39;s wildcard upper bound.
&nbsp;             *
&nbsp;             * @param index The wildcard bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated upper bound.
&nbsp;             */
&nbsp;            AnnotationReader ofWildcardUpperBoundType(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of an represented element&#39;s wildcard lower bound.
&nbsp;             *
&nbsp;             * @param index The wildcard bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated lower bound.
&nbsp;             */
&nbsp;            AnnotationReader ofWildcardLowerBoundType(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of a type variable&#39;s bound.
&nbsp;             *
&nbsp;             * @param index The bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated bound.
&nbsp;             */
&nbsp;            AnnotationReader ofTypeVariableBoundType(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of a parameterized type&#39;s type argument.
&nbsp;             *
&nbsp;             * @param index The bound&#39;s index.
&nbsp;             * @return An annotation reader for the underlying annotated bound..
&nbsp;             */
&nbsp;            AnnotationReader ofTypeArgument(int index);
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Returns a reader for type annotations of a parameterized type&#39;s owner type.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Important&lt;/b&gt;: This feature is not currently implemented by the Java reflection API.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @return An annotation reader for the underlying owner type.
&nbsp;             */
&nbsp;            AnnotationReader ofOwnerType();
&nbsp;
&nbsp;            /**
&nbsp;             * &lt;p&gt;
&nbsp;             * Returns a reader for type annotations of an inner class type&#39;s outer type.
&nbsp;             * &lt;/p&gt;
&nbsp;             * &lt;p&gt;
&nbsp;             * &lt;b&gt;Important&lt;/b&gt;: This feature is not currently implemented by the Java reflection API.
&nbsp;             * &lt;/p&gt;
&nbsp;             *
&nbsp;             * @return An annotation reader for the underlying owner type.
&nbsp;             */
&nbsp;            AnnotationReader ofOuterClass();
&nbsp;
&nbsp;            /**
&nbsp;             * Returns a reader for type annotations of an array&#39;s component type.
&nbsp;             *
&nbsp;             * @return An annotation reader for the underlying component type.
&nbsp;             */
&nbsp;            AnnotationReader ofComponentType();
&nbsp;
&nbsp;            /**
&nbsp;             * A non-operational annotation reader.
&nbsp;             */
<b class="fc">&nbsp;            enum NoOp implements AnnotationReader, AnnotatedElement {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotatedElement resolve() {
<b class="nc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList asList() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofOwnerType() {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofOuterClass() {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofComponentType() {
<b class="fc">&nbsp;                    return this;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass) {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Annotation[] getAnnotations() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;Cannot resolve annotations for no-op reader: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Annotation[] getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new Annotation[0];</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A delegating annotation reader that delegates all invocations to an annotation reader that wraps the previous one.
&nbsp;             */
<b class="fc">&nbsp;            abstract class Delegator implements AnnotationReader {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;                 *
&nbsp;                 * @param action The action to execute from a privileged context.
&nbsp;                 * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;                 * @return The action&#39;s resolved value.
&nbsp;                 */
&nbsp;                @AccessControllerPlugin.Enhance
&nbsp;                static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;                    return action.run();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofWildcardUpperBoundType(int index) {
<b class="fc">&nbsp;                    return new ForWildcardUpperBoundType(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofWildcardLowerBoundType(int index) {
<b class="fc">&nbsp;                    return new ForWildcardLowerBoundType(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofTypeVariableBoundType(int index) {
<b class="fc">&nbsp;                    return new ForTypeVariableBoundType(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofTypeArgument(int index) {
<b class="fc">&nbsp;                    return new ForTypeArgument(this, index);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofOwnerType() {
<b class="fc">&nbsp;                    return new ForOwnerType(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofOuterClass() {
<b class="fc">&nbsp;                    return new ForOwnerType(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationReader ofComponentType() {
<b class="fc">&nbsp;                    return new ForComponentType(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList asList() {
<b class="fc">&nbsp;                    return new AnnotationList.ForLoadedAnnotations(resolve().getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A simple delegator for a given {@link AnnotatedElement}.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class Simple extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented {@link AnnotatedElement}.
&nbsp;                     */
&nbsp;                    private final AnnotatedElement annotatedElement;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new simple delegator.
&nbsp;                     *
&nbsp;                     * @param annotatedElement The represented {@link AnnotatedElement}.
&nbsp;                     */
<b class="fc">&nbsp;                    public Simple(AnnotatedElement annotatedElement) {</b>
<b class="fc">&nbsp;                        this.annotatedElement = annotatedElement;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        return annotatedElement;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A chained delegator that bases its result on an underlying annotation reader.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected abstract static class Chained extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The underlying annotation reader.
&nbsp;                     */
&nbsp;                    protected final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new chained annotation reader.
&nbsp;                     *
&nbsp;                     * @param annotationReader The underlying annotation reader.
&nbsp;                     */
<b class="fc">&nbsp;                    protected Chained(AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        return resolve(annotationReader.resolve());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves the type annotations from a given annotated element into the annotated element that this instance represents.
&nbsp;                     *
&nbsp;                     * @param annotatedElement The original annotated element.
&nbsp;                     * @return The resolved annotated element.
&nbsp;                     */
&nbsp;                    protected abstract AnnotatedElement resolve(AnnotatedElement annotatedElement);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated type variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                public static class ForLoadedTypeVariable extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented type variable.
&nbsp;                     */
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for the given type variable.
&nbsp;                     *
&nbsp;                     * @param typeVariable The represented type variable.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedTypeVariable(TypeVariable&lt;?&gt; typeVariable) {</b>
<b class="fc">&nbsp;                        this.typeVariable = typeVariable;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;BC_VACUOUS_INSTANCEOF&quot;, justification = &quot;Cast is required for JVMs before Java 8.&quot;)
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        // Older JVMs require this check and cast as the hierarchy was introduced in a later version.
<b class="fc">&nbsp;                        return typeVariable instanceof AnnotatedElement</b>
<b class="fc">&nbsp;                                ? (AnnotatedElement) typeVariable</b>
<b class="nc">&nbsp;                                : NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationReader ofTypeVariableBoundType(int index) {
<b class="fc">&nbsp;                        return new ForTypeVariableBoundType.OfFormalTypeVariable(typeVariable, index);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated super type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                public static class ForLoadedSuperClass extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented type.
&nbsp;                     */
&nbsp;                    private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for an annotated super type.
&nbsp;                     *
&nbsp;                     * @param type The represented type.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedSuperClass(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                        this.type = type;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        AnnotatedElement element = ForLoadedType.DISPATCHER.getAnnotatedSuperclass(type);</b>
<b class="fc">&nbsp;                        return element == null</b>
<b class="nc">&nbsp;                                ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                                : element;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated interface type.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                public static class ForLoadedInterface extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented interface type.
&nbsp;                     */
&nbsp;                    private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The interface type&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for an annotated interface type.
&nbsp;                     *
&nbsp;                     * @param type  The represented interface type.
&nbsp;                     * @param index The interface type&#39;s index.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedInterface(Class&lt;?&gt; type, int index) {</b>
<b class="fc">&nbsp;                        this.type = type;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        AnnotatedElement[] element = ForLoadedType.DISPATCHER.getAnnotatedInterfaces(type);</b>
<b class="fc">&nbsp;                        return element.length == 0 ? NoOp.INSTANCE : element[index];</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated field variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                public static class ForLoadedField extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for interacting with {@link Field}.
&nbsp;                     */
<b class="fc">&nbsp;                    protected static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented field.
&nbsp;                     */
&nbsp;                    private final Field field;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for an annotated field type.
&nbsp;                     *
&nbsp;                     * @param field The represented field.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedField(Field field) {</b>
<b class="fc">&nbsp;                        this.field = field;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        AnnotatedElement element = DISPATCHER.getAnnotatedType(field);</b>
<b class="fc">&nbsp;                        return element == null</b>
<b class="nc">&nbsp;                                ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                                : element;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for interacting with {@link Field}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Proxied(&quot;java.lang.reflect.Field&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the supplied method&#39;s annotated field type.
&nbsp;                         *
&nbsp;                         * @param field The field for which to resolve the annotated type.
&nbsp;                         * @return The field type annotations or {@code null} if this feature is not supported.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        @JavaDispatcher.Defaults
&nbsp;                        AnnotatedElement getAnnotatedType(Field field);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated return variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                public static class ForLoadedMethodReturnType extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for interacting with {@link Method}.
&nbsp;                     */
<b class="fc">&nbsp;                    protected static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented method.
&nbsp;                     */
&nbsp;                    private final Method method;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for an annotated return type.
&nbsp;                     *
&nbsp;                     * @param method The represented method.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedMethodReturnType(Method method) {</b>
<b class="fc">&nbsp;                        this.method = method;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        AnnotatedElement element = DISPATCHER.getAnnotatedReturnType(method);</b>
<b class="fc">&nbsp;                        return element == null</b>
<b class="nc">&nbsp;                                ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                                : element;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for interacting with {@link Method}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Proxied(&quot;java.lang.reflect.Method&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the supplied method&#39;s annotated return type.
&nbsp;                         *
&nbsp;                         * @param method The executable for which to resolve the annotated return type.
&nbsp;                         * @return The return type annotations or {@code null} if this feature is not supported.
&nbsp;                         */
&nbsp;                        @MaybeNull
&nbsp;                        @JavaDispatcher.Defaults
&nbsp;                        AnnotatedElement getAnnotatedReturnType(Method method);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated parameter variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                public static class ForLoadedExecutableParameterType extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for interacting with {@code java.lang.reflect.Executable}.
&nbsp;                     */
<b class="fc">&nbsp;                    protected static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented executable.
&nbsp;                     */
&nbsp;                    private final AccessibleObject executable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type argument&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for an annotated type argument type.
&nbsp;                     *
&nbsp;                     * @param executable The represented executable.
&nbsp;                     * @param index      The type argument&#39;s index.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedExecutableParameterType(AccessibleObject executable, int index) {</b>
<b class="fc">&nbsp;                        this.executable = executable;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        AnnotatedElement[] element = DISPATCHER.getAnnotatedParameterTypes(executable);</b>
<b class="fc">&nbsp;                        return element.length == 0 ? NoOp.INSTANCE : element[index];</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A type for interacting with {@code java.lang.reflect.Executable}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the supplied {@code java.lang.reflect.Executable}&#39;s annotated parameter types.
&nbsp;                         *
&nbsp;                         * @param executable The executable for which to resolve its annotated parameter types.
&nbsp;                         * @return An array of parameter type annotations or an empty array if this feature is not supported.
&nbsp;                         */
&nbsp;                        @JavaDispatcher.Defaults
&nbsp;                        AnnotatedElement[] getAnnotatedParameterTypes(Object executable);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A delegating annotation reader for an annotated exception variable.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance(includeSyntheticFields = true)
&nbsp;                public static class ForLoadedExecutableExceptionType extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher for interacting with {@code java.lang.reflect.Executable}.
&nbsp;                     */
<b class="fc">&nbsp;                    protected static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented executable.
&nbsp;                     */
&nbsp;                    private final AccessibleObject executable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The exception type&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for an annotated exception type.
&nbsp;                     *
&nbsp;                     * @param executable The represented executable.
&nbsp;                     * @param index      The exception type&#39;s index.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedExecutableExceptionType(AccessibleObject executable, int index) {</b>
<b class="fc">&nbsp;                        this.executable = executable;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        AnnotatedElement[] element = DISPATCHER.getAnnotatedExceptionTypes(executable);</b>
<b class="fc">&nbsp;                        return element.length == 0 ? NoOp.INSTANCE : element[index];</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A proxy type for interacting with {@code java.lang.reflect.Executable}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;                    protected interface Dispatcher {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Resolves the supplied {@code java.lang.reflect.Executable}&#39;s annotated exception types.
&nbsp;                         *
&nbsp;                         * @param executable The executable for which to resolve its annotated exception types.
&nbsp;                         * @return An array of exception type annotations or an empty array if this feature is not supported.
&nbsp;                         */
&nbsp;                        @JavaDispatcher.Defaults
&nbsp;                        AnnotatedElement[] getAnnotatedExceptionTypes(Object executable);
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * An annotation reader for a {@code java.lang.reflect.RecordComponent}.
&nbsp;                 */
&nbsp;                public static class ForLoadedRecordComponent extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented {@code java.lang.reflect.RecordComponent}.
&nbsp;                     */
&nbsp;                    private final Object recordComponent;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new annotation reader for a {@code java.lang.reflect.RecordComponent}.
&nbsp;                     *
&nbsp;                     * @param recordComponent The represented {@code java.lang.reflect.RecordComponent}.
&nbsp;                     */
<b class="fc">&nbsp;                    public ForLoadedRecordComponent(Object recordComponent) {</b>
<b class="fc">&nbsp;                        this.recordComponent = recordComponent;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
<b class="fc">&nbsp;                        return RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getAnnotatedType(recordComponent);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a wildcard type&#39;s upper bound type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForWildcardUpperBoundType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                 */
<b class="fc">&nbsp;                private static final AnnotatedWildcardType ANNOTATED_WILDCARD_TYPE = doPrivileged(JavaDispatcher.of(AnnotatedWildcardType.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a upper-bound wildcard&#39;s bound type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                protected ForWildcardUpperBoundType(AnnotationReader annotationReader, int index) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
<b class="fc">&nbsp;                    if (!ANNOTATED_WILDCARD_TYPE.isInstance(annotatedElement)) { // Avoid problem with Kotlin compiler.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        AnnotatedElement[] annotatedUpperBound = ANNOTATED_WILDCARD_TYPE.getAnnotatedUpperBounds(annotatedElement);</b>
<b class="fc">&nbsp;                        return annotatedUpperBound.length == 0 // Wildcards with a lower bound do not define annotations for their implicit upper bound.</b>
<b class="nc">&nbsp;                                ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                                : annotatedUpperBound[index];</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid a bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.reflect.AnnotatedWildcardType&quot;)
&nbsp;                protected interface AnnotatedWildcardType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the supplied instance implements {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to consider.
&nbsp;                     * @return {@code true} if the supplied instance is of type {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Instance
&nbsp;                    boolean isInstance(AnnotatedElement value);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the supplied annotated element&#39;s annotated upper bounds.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to resolve.
&nbsp;                     * @return An array of annotated upper bounds for the supplied annotated elements.
&nbsp;                     */
&nbsp;                    AnnotatedElement[] getAnnotatedUpperBounds(AnnotatedElement value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a wildcard type&#39;s lower bound type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForWildcardLowerBoundType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher to interact with {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                 */
<b class="fc">&nbsp;                private static final AnnotatedWildcardType ANNOTATED_WILDCARD_TYPE = doPrivileged(JavaDispatcher.of(AnnotatedWildcardType.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a lower-bound wildcard&#39;s bound type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The wildcard bound&#39;s index.
&nbsp;                 */
&nbsp;                protected ForWildcardLowerBoundType(AnnotationReader annotationReader, int index) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
<b class="fc">&nbsp;                    if (!ANNOTATED_WILDCARD_TYPE.isInstance(annotatedElement)) {</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return ANNOTATED_WILDCARD_TYPE.getAnnotatedLowerBounds(annotatedElement)[index];</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid a bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.reflect.AnnotatedWildcardType&quot;)
&nbsp;                protected interface AnnotatedWildcardType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the supplied instance implements {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to consider.
&nbsp;                     * @return {@code true} if the supplied instance is of type {@code java.lang.reflect.AnnotatedWildcardType}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Instance
&nbsp;                    boolean isInstance(AnnotatedElement value);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the supplied annotated element&#39;s annotated lower bounds.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to resolve.
&nbsp;                     * @return An array of annotated lower bounds for the supplied annotated elements.
&nbsp;                     */
&nbsp;                    AnnotatedElement[] getAnnotatedLowerBounds(AnnotatedElement value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a type variable&#39;s type argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForTypeVariableBoundType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher to interact with {@code java.lang.reflect.AnnotatedTypeVariable}.
&nbsp;                 */
<b class="fc">&nbsp;                private static final AnnotatedTypeVariable ANNOTATED_TYPE_VARIABLE = doPrivileged(JavaDispatcher.of(AnnotatedTypeVariable.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type variable&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a type variable&#39;s bound type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The type variable&#39;s index.
&nbsp;                 */
&nbsp;                protected ForTypeVariableBoundType(AnnotationReader annotationReader, int index) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
<b class="fc">&nbsp;                    if (!ANNOTATED_TYPE_VARIABLE.isInstance(annotatedElement)) { // Avoid problem with Kotlin compiler.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return ANNOTATED_TYPE_VARIABLE.getAnnotatedBounds(annotatedElement)[index];</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedTypeVariable}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.reflect.AnnotatedTypeVariable&quot;)
&nbsp;                protected interface AnnotatedTypeVariable {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the supplied instance implements {@code java.lang.reflect.AnnotatedTypeVariable}.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to consider.
&nbsp;                     * @return {@code true} if the supplied instance is of type {@code java.lang.reflect.AnnotatedTypeVariable}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Instance
&nbsp;                    boolean isInstance(AnnotatedElement value);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the supplied annotated type variable&#39;s annotated bounds.
&nbsp;                     *
&nbsp;                     * @param value The annotated type variable to resolve.
&nbsp;                     * @return An array of annotated upper bounds for the supplied annotated type variable.
&nbsp;                     */
&nbsp;                    AnnotatedElement[] getAnnotatedBounds(AnnotatedElement value);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A chained annotation reader for reading a formal type variable&#39;s type argument.
&nbsp;                 */
&nbsp;                @HashCodeAndEqualsPlugin.Enhance
&nbsp;                protected static class OfFormalTypeVariable extends Delegator {
&nbsp;
&nbsp;                    /**
&nbsp;                     * A dispatcher to interact with {@code java.lang.reflect.TypeVariable}.
&nbsp;                     */
<b class="fc">&nbsp;                    private static final FormalTypeVariable TYPE_VARIABLE = doPrivileged(JavaDispatcher.of(FormalTypeVariable.class));</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented type variable.
&nbsp;                     */
&nbsp;                    private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable&#39;s index.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a chained annotation reader for reading a formal type variable&#39;s bound type.
&nbsp;                     *
&nbsp;                     * @param typeVariable The represented type variable.
&nbsp;                     * @param index        The type variable&#39;s index.
&nbsp;                     */
<b class="fc">&nbsp;                    protected OfFormalTypeVariable(TypeVariable&lt;?&gt; typeVariable, int index) {</b>
<b class="fc">&nbsp;                        this.typeVariable = typeVariable;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotatedElement resolve() {
&nbsp;                        try {
<b class="fc">&nbsp;                            AnnotatedElement[] annotatedBound = TYPE_VARIABLE.getAnnotatedBounds(typeVariable);</b>
<b class="fc">&nbsp;                            return annotatedBound.length == 0</b>
<b class="nc">&nbsp;                                    ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                                    : annotatedBound[index];</b>
<b class="nc">&nbsp;                        } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                            return NoOp.INSTANCE;</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * A proxy to interact with {@code java.lang.reflect.TypeVariable}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Proxied(&quot;java.lang.reflect.TypeVariable&quot;)
&nbsp;                    protected interface FormalTypeVariable {
&nbsp;
&nbsp;                        /**
&nbsp;                         * Returns the supplied annotated type variable&#39;s annotated bounds or an empty array if this
&nbsp;                         * feature is not supported.
&nbsp;                         *
&nbsp;                         * @param value The annotated type variable to resolve.
&nbsp;                         * @return An array of annotated upper bounds for the supplied annotated type variable or an
&nbsp;                         * empty array if this feature is not supported.
&nbsp;                         */
&nbsp;                        @JavaDispatcher.Defaults
&nbsp;                        AnnotatedElement[] getAnnotatedBounds(Object value);
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a parameterized type&#39;s type argument.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForTypeArgument extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher to interact with {@code java.lang.reflect.AnnotatedParameterizedType}.
&nbsp;                 */
<b class="fc">&nbsp;                private static final AnnotatedParameterizedType ANNOTATED_PARAMETERIZED_TYPE = doPrivileged(JavaDispatcher.of(AnnotatedParameterizedType.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The type argument&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a component type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 * @param index            The type argument&#39;s index.
&nbsp;                 */
&nbsp;                protected ForTypeArgument(AnnotationReader annotationReader, int index) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
<b class="fc">&nbsp;                    this.index = index;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
<b class="fc">&nbsp;                    if (!ANNOTATED_PARAMETERIZED_TYPE.isInstance(annotatedElement)) { // Avoid problem with Kotlin compiler.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return ANNOTATED_PARAMETERIZED_TYPE.getAnnotatedActualTypeArguments(annotatedElement)[index];</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedParameterizedType}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.reflect.AnnotatedParameterizedType&quot;)
&nbsp;                protected interface AnnotatedParameterizedType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the supplied instance implements {@code java.lang.reflect.AnnotatedParameterizedType}.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to consider.
&nbsp;                     * @return {@code true} if the supplied instance is of type {@code java.lang.reflect.AnnotatedParameterizedType}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Instance
&nbsp;                    boolean isInstance(AnnotatedElement value);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the supplied annotated parameterize type&#39;s annotated actual type arguments.
&nbsp;                     *
&nbsp;                     * @param value The annotated type variable to resolve.
&nbsp;                     * @return The supplied annotated parameterize type&#39;s annotated actual type arguments.
&nbsp;                     */
&nbsp;                    AnnotatedElement[] getAnnotatedActualTypeArguments(AnnotatedElement value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading a component type.
&nbsp;             */
&nbsp;            class ForComponentType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for interacting with {@code java.lang.reflect.AnnotatedArrayType}.
&nbsp;                 */
<b class="fc">&nbsp;                private static final AnnotatedParameterizedType ANNOTATED_PARAMETERIZED_TYPE = doPrivileged(JavaDispatcher.of(AnnotatedParameterizedType.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading a component type.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 */
&nbsp;                protected ForComponentType(AnnotationReader annotationReader) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
<b class="fc">&nbsp;                    if (!ANNOTATED_PARAMETERIZED_TYPE.isInstance(annotatedElement)) { // Avoid problem with Kotlin compiler.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                    try {
<b class="fc">&nbsp;                        return ANNOTATED_PARAMETERIZED_TYPE.getAnnotatedGenericComponentType(annotatedElement);</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedArrayType}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.reflect.AnnotatedArrayType&quot;)
&nbsp;                protected interface AnnotatedParameterizedType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns {@code true} if the supplied instance implements {@code java.lang.reflect.AnnotatedArrayType}.
&nbsp;                     *
&nbsp;                     * @param value The annotated element to consider.
&nbsp;                     * @return {@code true} if the supplied instance is of type {@code java.lang.reflect.AnnotatedArrayType}.
&nbsp;                     */
&nbsp;                    @JavaDispatcher.Instance
&nbsp;                    boolean isInstance(AnnotatedElement value);
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the supplied annotated array type&#39;s annotated component type.
&nbsp;                     *
&nbsp;                     * @param value The annotated array type to resolve.
&nbsp;                     * @return The supplied annotated array type&#39;s annotated component type.
&nbsp;                     */
&nbsp;                    AnnotatedElement getAnnotatedGenericComponentType(AnnotatedElement value);
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A chained annotation reader for reading an owner type.
&nbsp;             */
&nbsp;            class ForOwnerType extends Delegator.Chained {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for interacting with {@code java.lang.reflect.AnnotatedType}.
&nbsp;                 */
<b class="fc">&nbsp;                private static final AnnotatedType ANNOTATED_TYPE = doPrivileged(JavaDispatcher.of(AnnotatedType.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a chained annotation reader for reading an owner type if it is accessible.
&nbsp;                 *
&nbsp;                 * @param annotationReader The annotation reader from which to delegate.
&nbsp;                 */
&nbsp;                protected ForOwnerType(AnnotationReader annotationReader) {
<b class="fc">&nbsp;                    super(annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotatedElement resolve(AnnotatedElement annotatedElement) {
&nbsp;                    try {
<b class="fc">&nbsp;                        AnnotatedElement annotatedOwnerType = ANNOTATED_TYPE.getAnnotatedOwnerType(annotatedElement);</b>
<b class="fc">&nbsp;                        return annotatedOwnerType == null</b>
<b class="nc">&nbsp;                                ? NoOp.INSTANCE</b>
<b class="fc">&nbsp;                                : annotatedOwnerType;</b>
<b class="nc">&nbsp;                    } catch (ClassCastException ignored) { // To avoid bug on early releases of Java 8.</b>
<b class="nc">&nbsp;                        return NoOp.INSTANCE;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy to interact with {@code java.lang.reflect.AnnotatedType}.
&nbsp;                 */
&nbsp;                @JavaDispatcher.Proxied(&quot;java.lang.reflect.AnnotatedType&quot;)
&nbsp;                protected interface AnnotatedType {
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the type&#39;s annotated owner type or {@code null} if this feature is not supported.
&nbsp;                     *
&nbsp;                     * @param value The annotated type to resolve.
&nbsp;                     * @return The annotated owner type for the supplied annotated type or {@code null} if this feature is not supported.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    @JavaDispatcher.Defaults
&nbsp;                    AnnotatedElement getAnnotatedOwnerType(AnnotatedElement value);
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a generic type description.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends ModifierReviewable.AbstractBase implements Generic {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getModifiers() {
<b class="fc">&nbsp;                return asErasure().getModifiers();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic asGenericType() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic asRawType() {
<b class="fc">&nbsp;                return asErasure().asGenericType();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return equals(Sort.describe(type));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A lazy proxy for representing a {@link Generic} for a loaded type. This proxy is used to
&nbsp;         * avoid locks when Byte Buddy is loaded circularly.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        class LazyProxy implements InvocationHandler {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented loaded type.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt; type;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new lazy proxy.
&nbsp;             *
&nbsp;             * @param type The represented loaded type.
&nbsp;             */
<b class="fc">&nbsp;            protected LazyProxy(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                this.type = type;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a lazy proxy for a loaded type as a generic type description.
&nbsp;             *
&nbsp;             * @param type The represented loaded type.
&nbsp;             * @return The lazy proxy.
&nbsp;             */
&nbsp;            protected static Generic of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return (Generic) Proxy.newProxyInstance(Generic.class.getClassLoader(),</b>
&nbsp;                        new Class&lt;?&gt;[]{Generic.class},
&nbsp;                        new LazyProxy(type));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) throws Throwable {
&nbsp;                try {
<b class="nc">&nbsp;                    return method.invoke(OfNonGenericType.ForLoadedType.of(type), argument);</b>
<b class="nc">&nbsp;                } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                    throw exception.getTargetException();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * &lt;p&gt;
&nbsp;         * A raw type representation of a non-generic type. This raw type differs from a raw type in the Java programming language by
&nbsp;         * representing a minimal erasure compared to Java&#39;s full erasure. This means that generic types are preserved as long as they
&nbsp;         * do not involve a type variable. Nested type variables are erased on the deepest possible level.
&nbsp;         * &lt;/p&gt;
&nbsp;         * &lt;p&gt;
&nbsp;         * All fields, methods, interfaces and the super type that are returned from this instance represent appropriately erased types.
&nbsp;         * &lt;/p&gt;
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfNonGenericType extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.NON_GENERIC;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="fc">&nbsp;                Generic superClass = erasure.getSuperClass();</b>
<b class="fc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return superClass;</b>
&nbsp;                }
<b class="fc">&nbsp;                return superClass == null</b>
<b class="fc">&nbsp;                        ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                        : new Generic.LazyProjection.WithResolvedErasure(superClass, new Visitor.ForRawType(erasure), Empty.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="fc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return erasure.getInterfaces();</b>
&nbsp;                }
<b class="fc">&nbsp;                return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(erasure.getInterfaces(), new Visitor.ForRawType(erasure));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="fc">&nbsp;                return new FieldList.TypeSubstituting(this, erasure.getDeclaredFields(), TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                        ? Visitor.NoOp.INSTANCE</b>
<b class="fc">&nbsp;                        : new Visitor.ForRawType(erasure));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="fc">&nbsp;                return new MethodList.TypeSubstituting(this, erasure.getDeclaredMethods(), TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                        ? Visitor.NoOp.INSTANCE</b>
<b class="fc">&nbsp;                        : new Visitor.ForRawType(erasure));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="nc">&nbsp;                TypeDescription erasure = asErasure();</b>
<b class="nc">&nbsp;                return new RecordComponentList.TypeSubstituting(this, erasure.getRecordComponents(), TypeDescription.AbstractBase.RAW_TYPES</b>
<b class="nc">&nbsp;                        ? Visitor.NoOp.INSTANCE</b>
<b class="nc">&nbsp;                        : new Visitor.ForRawType(erasure));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return visitor.onNonGenericType(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getTypeName() {
<b class="fc">&nbsp;                return asErasure().getTypeName();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply upper type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply lower type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSymbol() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A non-generic type does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return asErasure().getStackSize();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getActualName() {
<b class="nc">&nbsp;                return asErasure().getActualName();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return asErasure().isArray();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return asErasure().isPrimitive();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="nc">&nbsp;                return asErasure().isRecord();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return asErasure().represents(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return asErasure().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, justification = &quot;Type check is performed by erasure implementation.&quot;)
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                return this == other || asErasure().equals(other);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return asErasure().toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents a non-generic type for a loaded {@link Class}.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * A cache of generic type descriptions for commonly used types to avoid unnecessary allocations.
&nbsp;                 */
&nbsp;                private static final Map&lt;Class&lt;?&gt;, Generic&gt; TYPE_CACHE;
&nbsp;
&nbsp;                /*
&nbsp;                 * Initializes the type cache.
&nbsp;                 */
&nbsp;                static {
<b class="fc">&nbsp;                    TYPE_CACHE = new HashMap&lt;Class&lt;?&gt;, Generic&gt;();</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Class.class, new ForLoadedType(Class.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Throwable.class, new ForLoadedType(Throwable.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Annotation.class, new ForLoadedType(Annotation.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(String.class, new ForLoadedType(String.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(void.class, new ForLoadedType(void.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(boolean.class, new ForLoadedType(boolean.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(byte.class, new ForLoadedType(byte.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(short.class, new ForLoadedType(short.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(char.class, new ForLoadedType(char.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(int.class, new ForLoadedType(int.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(long.class, new ForLoadedType(long.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(float.class, new ForLoadedType(float.class));</b>
<b class="fc">&nbsp;                    TYPE_CACHE.put(double.class, new ForLoadedType(double.class));</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * The type that this instance represents.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the non-generic type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new description of a generic type of a loaded type. This constructor should not normally be used.
&nbsp;                 * Use {@link ForLoadedType#of(Class)} instead.
&nbsp;                 *
&nbsp;                 * @param type The represented type.
&nbsp;                 */
&nbsp;                public ForLoadedType(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                    this(type, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * /**
&nbsp;                 * Creates a new description of a generic type of a loaded type.
&nbsp;                 *
&nbsp;                 * @param type             The represented type.
&nbsp;                 * @param annotationReader The annotation reader to query for the non-generic type&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(Class&lt;?&gt; type, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.type = type;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns a new immutable generic type description for a loaded type.
&nbsp;                 *
&nbsp;                 * @param type The type to be represented by this generic type description.
&nbsp;                 * @return The generic type description representing the given type.
&nbsp;                 */
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                    Generic typeDescription = TYPE_CACHE.get(type);</b>
<b class="fc">&nbsp;                    return typeDescription == null</b>
<b class="fc">&nbsp;                            ? new ForLoadedType(type)</b>
<b class="fc">&nbsp;                            : typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    Class&lt;?&gt; declaringClass = this.type.getDeclaringClass();</b>
<b class="fc">&nbsp;                    return declaringClass == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : new ForLoadedType(declaringClass, annotationReader.ofOuterClass());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    Class&lt;?&gt; componentType = type.getComponentType();</b>
<b class="fc">&nbsp;                    return componentType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : new ForLoadedType(componentType, annotationReader.ofComponentType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                    return this.type == type || super.represents(type);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A type description for a type erasure. Compared to a {@link Latent} representation, this
&nbsp;             * representation does not allow for the specification of any complex properties but does
&nbsp;             * not require any form of navigation on the type.
&nbsp;             */
&nbsp;            public static class ForErasure extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new description of a non-generic type as an erasure.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented type erasure.
&nbsp;                 */
<b class="fc">&nbsp;                public ForErasure(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="fc">&nbsp;                    return declaringType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="nc">&nbsp;                            : declaringType.asGenericType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    TypeDescription componentType = typeDescription.getComponentType();</b>
<b class="fc">&nbsp;                    return componentType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : componentType.asGenericType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent description of a non-generic type.
&nbsp;             */
&nbsp;            public static class Latent extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The non-generic type&#39;s raw type.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The non-generic type&#39;s declaring type.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final TypeDescription.Generic declaringType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-generic type with an implicit owner type.
&nbsp;                 *
&nbsp;                 * @param typeDescription  The non-generic type&#39;s raw type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                public Latent(TypeDescription typeDescription, AnnotationSource annotationSource) {
<b class="fc">&nbsp;                    this(typeDescription, typeDescription.getDeclaringType(), annotationSource);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-generic type with a raw owner type.
&nbsp;                 *
&nbsp;                 * @param typeDescription  The non-generic type&#39;s raw type.
&nbsp;                 * @param declaringType    The non-generic type&#39;s declaring type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private Latent(TypeDescription typeDescription, @MaybeNull TypeDescription declaringType, AnnotationSource annotationSource) {
<b class="fc">&nbsp;                    this(typeDescription,</b>
<b class="fc">&nbsp;                            declaringType == null</b>
<b class="fc">&nbsp;                                    ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                                    : declaringType.asGenericType(),</b>
&nbsp;                            annotationSource);
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription  The non-generic type&#39;s raw type.
&nbsp;                 * @param declaringType    The non-generic type&#39;s declaring type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected Latent(TypeDescription typeDescription, @MaybeNull Generic declaringType, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
<b class="fc">&nbsp;                    this.declaringType = declaringType;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    return declaringType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    TypeDescription componentType = typeDescription.getComponentType();</b>
<b class="fc">&nbsp;                    return componentType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="nc">&nbsp;                            : componentType.asGenericType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A representation of a raw type that preserves its generic super types&#39; generic information with a minimum
&nbsp;             * but erases all of their members&#39; types.
&nbsp;             */
&nbsp;            public static class ForReifiedErasure extends OfNonGenericType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reified non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented type erasure.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForReifiedErasure(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new generic type representation for an erasure where any generified type is reified.
&nbsp;                 *
&nbsp;                 * @param typeDescription The erasure to represent.
&nbsp;                 * @return An appropriate generic type representation where any generified type is reified.
&nbsp;                 */
&nbsp;                protected static Generic of(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.isGenerified()</b>
<b class="fc">&nbsp;                            ? new ForReifiedErasure(typeDescription)</b>
<b class="fc">&nbsp;                            : new ForErasure(typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
<b class="fc">&nbsp;                    Generic superClass = typeDescription.getSuperClass();</b>
<b class="fc">&nbsp;                    return superClass == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : new LazyProjection.WithResolvedErasure(superClass, Visitor.Reifying.INHERITING);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                    return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(typeDescription.getInterfaces(), Visitor.Reifying.INHERITING);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                    return new FieldList.TypeSubstituting(this, typeDescription.getDeclaredFields(), Visitor.TypeErasing.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                    return new MethodList.TypeSubstituting(this, typeDescription.getDeclaredMethods(), Visitor.TypeErasing.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="nc">&nbsp;                    TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="nc">&nbsp;                    return declaringType == null</b>
<b class="nc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="nc">&nbsp;                            : of(declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
<b class="nc">&nbsp;                    TypeDescription componentType = typeDescription.getComponentType();</b>
<b class="nc">&nbsp;                    return componentType == null</b>
<b class="nc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="nc">&nbsp;                            : of(componentType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a potentially generic array. Instances represent a non-generic type
&nbsp;         * if the given component type is non-generic.
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfGenericArray extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return getComponentType().getSort().isNonGeneric()</b>
<b class="fc">&nbsp;                        ? Sort.NON_GENERIC</b>
<b class="fc">&nbsp;                        : Sort.GENERIC_ARRAY;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            public TypeDescription asErasure() {
<b class="fc">&nbsp;                return ArrayProjection.of(getComponentType().asErasure(), 1);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                return ARRAY_INTERFACES;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                return new FieldList.Empty&lt;FieldDescription.InGenericShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                return new MethodList.Empty&lt;MethodDescription.InGenericShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="nc">&nbsp;                return new RecordComponentList.Empty&lt;RecordComponentDescription.InGenericShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply upper type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply lower type bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getOwnerType() {
<b class="fc">&nbsp;                return Generic.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSymbol() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A generic array type does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getTypeName() {
<b class="fc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().getTypeName()</b>
<b class="fc">&nbsp;                        : toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getActualName() {
<b class="fc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().getActualName()</b>
<b class="fc">&nbsp;                        : toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="fc">&nbsp;                        ? visitor.onNonGenericType(this)</b>
<b class="fc">&nbsp;                        : visitor.onGenericArray(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().hashCode()</b>
<b class="fc">&nbsp;                        : getComponentType().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(
&nbsp;                    value = {&quot;EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS&quot;, &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;},
&nbsp;                    justification = &quot;Type check is performed by erasure implementation. Assuming component type for array type.&quot;)
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (getSort().isNonGeneric()) {</b>
<b class="fc">&nbsp;                    return asErasure().equals(other);</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!(other instanceof Generic)) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Generic typeDescription = (Generic) other;</b>
<b class="fc">&nbsp;                return typeDescription.getSort().isGenericArray() &amp;&amp; getComponentType().equals(typeDescription.getComponentType());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return getSort().isNonGeneric()</b>
<b class="nc">&nbsp;                        ? asErasure().toString()</b>
<b class="fc">&nbsp;                        : getComponentType().getTypeName() + &quot;[]&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A description of a loaded generic array type.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfGenericArray {
&nbsp;
&nbsp;                /**
&nbsp;                 * The loaded generic array type.
&nbsp;                 */
&nbsp;                private final GenericArrayType genericArrayType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the generic array type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type description of the given generic array type.
&nbsp;                 *
&nbsp;                 * @param genericArrayType The loaded generic array type.
&nbsp;                 */
&nbsp;                public ForLoadedType(GenericArrayType genericArrayType) {
<b class="nc">&nbsp;                    this(genericArrayType, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type description of the given generic array type.
&nbsp;                 *
&nbsp;                 * @param genericArrayType The loaded generic array type.
&nbsp;                 * @param annotationReader The annotation reader to query for the generic array type&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(GenericArrayType genericArrayType, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.genericArrayType = genericArrayType;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    return Sort.describe(genericArrayType.getGenericComponentType(), annotationReader.ofComponentType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                    return genericArrayType == type || super.represents(type);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent implementation of a generic array type.
&nbsp;             */
&nbsp;            public static class Latent extends OfGenericArray {
&nbsp;
&nbsp;                /**
&nbsp;                 * The component type of the generic array.
&nbsp;                 */
&nbsp;                private final Generic componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a latent representation of a generic array type.
&nbsp;                 *
&nbsp;                 * @param componentType    The component type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public Latent(Generic componentType, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.componentType = componentType;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    return componentType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a wildcard type.
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfWildcardType extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The source code representation of a wildcard.
&nbsp;             */
&nbsp;            public static final String SYMBOL = &quot;?&quot;;
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.WILDCARD;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription asErasure() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not represent an erasable type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an interface type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply field definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply method definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply record component definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic getComponentType() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a component type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic getOwnerType() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an owner type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSymbol() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getTypeName() {
<b class="fc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getActualName() {
<b class="nc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="nc">&nbsp;                return equals(Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply a super type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return visitor.onWildcard(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A wildcard does not imply an operand stack size: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                int lowerHash = 1, upperHash = 1;</b>
<b class="fc">&nbsp;                for (Generic lowerBound : getLowerBounds()) {</b>
<b class="fc">&nbsp;                    lowerHash = 31 * lowerHash + lowerBound.hashCode();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (Generic upperBound : getUpperBounds()) {</b>
<b class="fc">&nbsp;                    upperHash = 31 * upperHash + upperBound.hashCode();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return lowerHash ^ upperHash;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="nc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof Generic)) {</b>
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Generic typeDescription = (Generic) other;</b>
<b class="fc">&nbsp;                return typeDescription.getSort().isWildcard()</b>
<b class="fc">&nbsp;                        &amp;&amp; getUpperBounds().equals(typeDescription.getUpperBounds())</b>
<b class="fc">&nbsp;                        &amp;&amp; getLowerBounds().equals(typeDescription.getLowerBounds());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder(SYMBOL);</b>
<b class="fc">&nbsp;                TypeList.Generic bounds = getLowerBounds();</b>
<b class="fc">&nbsp;                if (!bounds.isEmpty()) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&quot; super &quot;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    bounds = getUpperBounds();</b>
<b class="fc">&nbsp;                    if (bounds.getOnly().equals(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class))) {</b>
<b class="fc">&nbsp;                        return SYMBOL;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    stringBuilder.append(&quot; extends &quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stringBuilder.append(bounds.getOnly().getTypeName()).toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Description of a loaded wildcard.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfWildcardType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented loaded wildcard type.
&nbsp;                 */
&nbsp;                private final WildcardType wildcardType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the wildcard type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded wildcard.
&nbsp;                 *
&nbsp;                 * @param wildcardType The represented loaded wildcard type.
&nbsp;                 */
&nbsp;                public ForLoadedType(WildcardType wildcardType) {
<b class="nc">&nbsp;                    this(wildcardType, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded wildcard.
&nbsp;                 *
&nbsp;                 * @param wildcardType     The represented loaded wildcard type.
&nbsp;                 * @param annotationReader The annotation reader to query for the wildcard type&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(WildcardType wildcardType, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.wildcardType = wildcardType;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                    return new WildcardUpperBoundTypeList(wildcardType.getUpperBounds(), annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                    return new WildcardLowerBoundTypeList(wildcardType.getLowerBounds(), annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="nc">&nbsp;                    return wildcardType == type || super.represents(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type list representing an upper-bound type variable&#39;s bound types.
&nbsp;                 */
&nbsp;                protected static class WildcardUpperBoundTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented upper bounds.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] upperBound;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a type list for a wildcard type&#39;s upper bounds.
&nbsp;                     *
&nbsp;                     * @param upperBound       The represented upper bounds.
&nbsp;                     * @param annotationReader The annotation reader to query for type annotations.
&nbsp;                     */
<b class="fc">&nbsp;                    protected WildcardUpperBoundTypeList(java.lang.reflect.Type[] upperBound, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.upperBound = upperBound;</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return Sort.describe(upperBound[index], annotationReader.ofWildcardUpperBoundType(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return upperBound.length;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type list representing an upper-bound type variable&#39;s bound types.
&nbsp;                 */
&nbsp;                protected static class WildcardLowerBoundTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented lower bounds.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] lowerBound;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a type list for a wildcard type&#39;s lower bounds.
&nbsp;                     *
&nbsp;                     * @param lowerBound       The represented lower bounds.
&nbsp;                     * @param annotationReader The annotation reader to query for type annotations.
&nbsp;                     */
<b class="fc">&nbsp;                    protected WildcardLowerBoundTypeList(java.lang.reflect.Type[] lowerBound, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.lowerBound = lowerBound;</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return Sort.describe(lowerBound[index], annotationReader.ofWildcardLowerBoundType(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return lowerBound.length;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent description of a wildcard type.
&nbsp;             */
&nbsp;            public static class Latent extends OfWildcardType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard&#39;s upper bounds.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; upperBounds;
&nbsp;
&nbsp;                /**
&nbsp;                 * The wildcard&#39;s lower bounds.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; lowerBounds;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a latent wildcard.
&nbsp;                 *
&nbsp;                 * @param upperBounds      The wildcard&#39;s upper bounds.
&nbsp;                 * @param lowerBounds      The wildcard&#39;s lower bounds.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected Latent(List&lt;? extends Generic&gt; upperBounds, List&lt;? extends Generic&gt; lowerBounds, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.upperBounds = upperBounds;</b>
<b class="fc">&nbsp;                    this.lowerBounds = lowerBounds;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates an unbounded wildcard. Such a wildcard is implicitly bound above by the {@link Object} type.
&nbsp;                 *
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 * @return A description of an unbounded wildcard.
&nbsp;                 */
&nbsp;                public static Generic unbounded(AnnotationSource annotationSource) {
<b class="fc">&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)), Collections.&lt;Generic&gt;emptyList(), annotationSource);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a wildcard with an upper bound.
&nbsp;                 *
&nbsp;                 * @param upperBound       The upper bound of the wildcard.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 * @return A wildcard with the given upper bound.
&nbsp;                 */
&nbsp;                public static Generic boundedAbove(Generic upperBound, AnnotationSource annotationSource) {
<b class="fc">&nbsp;                    return new Latent(Collections.singletonList(upperBound), Collections.&lt;Generic&gt;emptyList(), annotationSource);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a wildcard with a lower bound. Such a wildcard is implicitly bounded above by the {@link Object} type.
&nbsp;                 *
&nbsp;                 * @param lowerBound       The lower bound of the wildcard.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 * @return A wildcard with the given lower bound.
&nbsp;                 */
&nbsp;                public static Generic boundedBelow(Generic lowerBound, AnnotationSource annotationSource) {
<b class="fc">&nbsp;                    return new Latent(Collections.singletonList(TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class)), Collections.singletonList(lowerBound), annotationSource);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Explicit(upperBounds);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Explicit(lowerBounds);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a parameterized type.
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfParameterizedType extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.PARAMETERIZED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                Generic superClass = asErasure().getSuperClass();</b>
<b class="fc">&nbsp;                return superClass == null</b>
<b class="fc">&nbsp;                        ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                        : new LazyProjection.WithResolvedErasure(superClass, new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(asErasure().getInterfaces(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                return new FieldList.TypeSubstituting(this, asErasure().getDeclaredFields(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                return new MethodList.TypeSubstituting(this, asErasure().getDeclaredMethods(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="fc">&nbsp;                return new RecordComponentList.TypeSubstituting(this, asErasure().getRecordComponents(), new Visitor.Substitutor.ForTypeVariableBinding(this));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                Generic typeDescription = this;</b>
&nbsp;                do {
<b class="fc">&nbsp;                    TypeList.Generic typeArguments = typeDescription.getTypeArguments(), typeVariables = typeDescription.asErasure().getTypeVariables();</b>
<b class="fc">&nbsp;                    for (int index = 0; index &lt; Math.min(typeArguments.size(), typeVariables.size()); index++) {</b>
<b class="fc">&nbsp;                        if (typeVariable.equals(typeVariables.get(index))) {</b>
<b class="fc">&nbsp;                            return typeArguments.get(index);</b>
&nbsp;                        }
&nbsp;                    }
<b class="fc">&nbsp;                    typeDescription = typeDescription.getOwnerType();</b>
<b class="fc">&nbsp;                } while (typeDescription != null &amp;&amp; typeDescription.getSort().isParameterized());</b>
<b class="fc">&nbsp;                return Generic.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply upper bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply lower bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic getComponentType() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a component type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a type variable source: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSymbol() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A parameterized type does not imply a symbol: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getTypeName() {
<b class="fc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getActualName() {
<b class="fc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="nc">&nbsp;                return asErasure().isRecord();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return equals(Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return visitor.onParameterizedType(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                int result = 1;</b>
<b class="fc">&nbsp;                for (Generic typeArgument : getTypeArguments()) {</b>
<b class="fc">&nbsp;                    result = 31 * result + typeArgument.hashCode();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                Generic ownerType = getOwnerType();</b>
<b class="fc">&nbsp;                return result ^ (ownerType == null</b>
<b class="fc">&nbsp;                        ? asErasure().hashCode()</b>
<b class="fc">&nbsp;                        : ownerType.hashCode());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof Generic)) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Generic typeDescription = (Generic) other;</b>
<b class="fc">&nbsp;                if (!typeDescription.getSort().isParameterized()) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Generic ownerType = getOwnerType(), otherOwnerType = typeDescription.getOwnerType();</b>
<b class="fc">&nbsp;                return asErasure().equals(typeDescription.asErasure())</b>
<b class="fc">&nbsp;                        &amp;&amp; !(ownerType == null &amp;&amp; otherOwnerType != null) &amp;&amp; !(ownerType != null &amp;&amp; !ownerType.equals(otherOwnerType))</b>
<b class="fc">&nbsp;                        &amp;&amp; getTypeArguments().equals(typeDescription.getTypeArguments());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;                RenderingDelegate.CURRENT.apply(stringBuilder, asErasure(), getOwnerType());</b>
<b class="fc">&nbsp;                TypeList.Generic typeArguments = getTypeArguments();</b>
<b class="fc">&nbsp;                if (!typeArguments.isEmpty()) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&#39;&lt;&#39;);</b>
<b class="fc">&nbsp;                    boolean multiple = false;</b>
<b class="fc">&nbsp;                    for (Generic typeArgument : typeArguments) {</b>
<b class="fc">&nbsp;                        if (multiple) {</b>
<b class="nc">&nbsp;                            stringBuilder.append(&quot;, &quot;);</b>
&nbsp;                        }
<b class="fc">&nbsp;                        stringBuilder.append(typeArgument.getTypeName());</b>
<b class="fc">&nbsp;                        multiple = true;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    stringBuilder.append(&#39;&gt;&#39;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stringBuilder.toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A rendering delegate for resolving a parameterized type&#39;s {@link Object#toString()} representation.
&nbsp;             */
<b class="fc">&nbsp;            protected enum RenderingDelegate {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * A rendering delegate for any VM prior to Java 9 where types are concatenated using a {@code .} character
&nbsp;                 * and where the fully qualified names are appended to non-parameterized types.
&nbsp;                 */
<b class="fc">&nbsp;                FOR_LEGACY_VM {</b>
&nbsp;                    @Override
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, @MaybeNull Generic ownerType) {
<b class="fc">&nbsp;                        if (ownerType != null) {</b>
<b class="fc">&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;.&#39;).append(ownerType.getSort().isParameterized()</b>
<b class="fc">&nbsp;                                    ? erasure.getSimpleName()</b>
<b class="fc">&nbsp;                                    : erasure.getName());</b>
&nbsp;                        } else {
<b class="fc">&nbsp;                            stringBuilder.append(erasure.getName());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                },
&nbsp;
&nbsp;                /**
&nbsp;                 * A rendering delegate for any VM supporting Java 8 or newer where a type&#39;s simple name is appended.
&nbsp;                 */
<b class="fc">&nbsp;                FOR_JAVA_8_CAPABLE_VM {</b>
&nbsp;                    @Override
&nbsp;                    protected void apply(StringBuilder stringBuilder, TypeDescription erasure, @MaybeNull Generic ownerType) {
<b class="fc">&nbsp;                        if (ownerType != null) {</b>
<b class="fc">&nbsp;                            stringBuilder.append(ownerType.getTypeName()).append(&#39;$&#39;);</b>
<b class="fc">&nbsp;                            if (ownerType.getSort().isParameterized()) {</b>
<b class="fc">&nbsp;                                stringBuilder.append(erasure.getName().replace(ownerType.asErasure().getName() + &quot;$&quot;, &quot;&quot;));</b>
&nbsp;                            } else {
<b class="fc">&nbsp;                                stringBuilder.append(erasure.getSimpleName());</b>
&nbsp;                            }
&nbsp;                        } else {
<b class="fc">&nbsp;                            stringBuilder.append(erasure.getName());</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                };
&nbsp;
&nbsp;                /**
&nbsp;                 * A rendering delegate for the current VM.
&nbsp;                 */
<b class="fc">&nbsp;                protected static final RenderingDelegate CURRENT = ClassFileVersion.ofThisVm(ClassFileVersion.JAVA_V5).isAtLeast(ClassFileVersion.JAVA_V8)</b>
<b class="fc">&nbsp;                        ? RenderingDelegate.FOR_JAVA_8_CAPABLE_VM</b>
<b class="nc">&nbsp;                        : RenderingDelegate.FOR_LEGACY_VM;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Applies this rendering delegate.
&nbsp;                 *
&nbsp;                 * @param stringBuilder The string builder which is used for creating a parameterized type&#39;s string representation.
&nbsp;                 * @param erasure       The rendered type&#39;s erasure.
&nbsp;                 * @param ownerType     The rendered type&#39;s owner type which might be {@code null}.
&nbsp;                 */
&nbsp;                protected abstract void apply(StringBuilder stringBuilder, TypeDescription erasure, @MaybeNull Generic ownerType);
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Description of a loaded parameterized type.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented parameterized type.
&nbsp;                 */
&nbsp;                private final ParameterizedType parameterizedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the parameterized type&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of the loaded parameterized type.
&nbsp;                 *
&nbsp;                 * @param parameterizedType The represented parameterized type.
&nbsp;                 */
&nbsp;                public ForLoadedType(ParameterizedType parameterizedType) {
<b class="nc">&nbsp;                    this(parameterizedType, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of the loaded parameterized type.
&nbsp;                 *
&nbsp;                 * @param parameterizedType The represented parameterized type.
&nbsp;                 * @param annotationReader  The annotation reader to query for the parameterized type&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(ParameterizedType parameterizedType, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.parameterizedType = parameterizedType;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    return new ParameterArgumentTypeList(parameterizedType.getActualTypeArguments(), annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    java.lang.reflect.Type ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                    return ownerType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : Sort.describe(ownerType, annotationReader.ofOwnerType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of((Class&lt;?&gt;) parameterizedType.getRawType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                    return parameterizedType == type || super.represents(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A type list that represents a loaded parameterized type&#39;s parameter types.
&nbsp;                 */
&nbsp;                protected static class ParameterArgumentTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The represented argument types.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] argumentType;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for type annotations.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a list representing a parameterized type&#39;s type arguments.
&nbsp;                     *
&nbsp;                     * @param argumentType     The represented argument types.
&nbsp;                     * @param annotationReader The annotation reader to query for type annotations.
&nbsp;                     */
<b class="fc">&nbsp;                    protected ParameterArgumentTypeList(java.lang.reflect.Type[] argumentType, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.argumentType = argumentType;</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
&nbsp;                        // Obfuscators sometimes render parameterized type arguments as null values.
<b class="fc">&nbsp;                        return Sort.describe(argumentType[index], annotationReader.ofTypeArgument(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return argumentType.length;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A latent description of a parameterized type.
&nbsp;             */
&nbsp;            public static class Latent extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The raw type of the described parameterized type.
&nbsp;                 */
&nbsp;                private final TypeDescription rawType;
&nbsp;
&nbsp;                /**
&nbsp;                 * This parameterized type&#39;s owner type or {@code null} if no owner type exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameters of this parameterized type.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; parameters;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a latent parameterized type.
&nbsp;                 *
&nbsp;                 * @param rawType          The raw type of the described parameterized type.
&nbsp;                 * @param ownerType        This parameterized type&#39;s owner type or {@code null} if no owner type exists.
&nbsp;                 * @param parameters       The parameters of this parameterized type.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                public Latent(TypeDescription rawType,
&nbsp;                              @MaybeNull Generic ownerType,
&nbsp;                              List&lt;? extends Generic&gt; parameters,
<b class="fc">&nbsp;                              AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.rawType = rawType;</b>
<b class="fc">&nbsp;                    this.ownerType = ownerType;</b>
<b class="fc">&nbsp;                    this.parameters = parameters;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return rawType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    return ownerType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    return new TypeList.Generic.Explicit(parameters);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A representation of a parameterized type that is a super type of a raw type but preserves the minimal type information
&nbsp;             * that is required for allowing creating correct erasures for overridden methods. All members&#39; types are erased and all
&nbsp;             * type arguments are reduced to their erasure.
&nbsp;             */
&nbsp;            public static class ForReifiedType extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented parameterized type.
&nbsp;                 */
&nbsp;                private final Generic parameterizedType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new reified parameterized type.
&nbsp;                 *
&nbsp;                 * @param parameterizedType The represented parameterized type.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForReifiedType(Generic parameterizedType) {</b>
<b class="fc">&nbsp;                    this.parameterizedType = parameterizedType;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
<b class="fc">&nbsp;                    Generic superClass = super.getSuperClass();</b>
<b class="fc">&nbsp;                    return superClass == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : new LazyProjection.WithResolvedErasure(superClass, Visitor.Reifying.INHERITING);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                    return new TypeList.Generic.ForDetachedTypes.WithResolvedErasure(super.getInterfaces(), Visitor.Reifying.INHERITING);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                    return new FieldList.TypeSubstituting(this, super.getDeclaredFields(), Visitor.TypeErasing.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                    return new MethodList.TypeSubstituting(this, super.getDeclaredMethods(), Visitor.TypeErasing.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    return new TypeList.Generic.ForDetachedTypes(parameterizedType.getTypeArguments(), Visitor.TypeErasing.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    Generic ownerType = parameterizedType.getOwnerType();</b>
<b class="fc">&nbsp;                    return ownerType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : ownerType.accept(Visitor.Reifying.INHERITING);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return parameterizedType.asErasure();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an erasure as a generic type where all type variables are representing their own arguments.
&nbsp;             */
&nbsp;            public static class ForGenerifiedErasure extends OfParameterizedType {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new generified erasure.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented erasure.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForGenerifiedErasure(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Represents the supplied type description as a generified erasure if it is generified or as a non-generic type if not so.
&nbsp;                 *
&nbsp;                 * @param typeDescription The represented erasure.
&nbsp;                 * @return An appropriate generic type.
&nbsp;                 */
&nbsp;                public static Generic of(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.isGenerified()</b>
<b class="fc">&nbsp;                            ? new ForGenerifiedErasure(typeDescription)</b>
<b class="fc">&nbsp;                            : new OfNonGenericType.ForErasure(typeDescription);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    return new TypeList.Generic.ForDetachedTypes(typeDescription.getTypeVariables(), Visitor.AnnotationStripper.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    TypeDescription declaringType = typeDescription.getDeclaringType();</b>
<b class="fc">&nbsp;                    return declaringType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="nc">&nbsp;                            : of(declaringType);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return new AnnotationList.Empty();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A base implementation of a generic type description that represents a type variable.
&nbsp;         */
<b class="fc">&nbsp;        abstract class OfTypeVariable extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return Sort.VARIABLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription asErasure() {
<b class="fc">&nbsp;                TypeList.Generic upperBounds = getUpperBounds();</b>
<b class="fc">&nbsp;                return upperBounds.isEmpty()</b>
<b class="nc">&nbsp;                        ? TypeDescription.ForLoadedType.of(Object.class)</b>
<b class="fc">&nbsp;                        : upperBounds.get(0).asErasure();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an interface type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply field definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply method definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="nc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply record component definitions: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic getComponentType() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a component type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply type arguments: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply lower bounds: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic getOwnerType() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply an owner type: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getTypeName() {
<b class="fc">&nbsp;                return toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getActualName() {
<b class="fc">&nbsp;                return getSymbol();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return visitor.onTypeVariable(this);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return equals(Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                throw new IllegalStateException(&quot;A type variable does not imply a super type definition: &quot; + this);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return getTypeVariableSource().hashCode() ^ getSymbol().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                if (this == other) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="fc">&nbsp;                } else if (!(other instanceof Generic)) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;                Generic typeDescription = (Generic) other;</b>
<b class="fc">&nbsp;                return typeDescription.getSort().isTypeVariable()</b>
<b class="fc">&nbsp;                        &amp;&amp; getSymbol().equals(typeDescription.getSymbol())</b>
<b class="fc">&nbsp;                        &amp;&amp; getTypeVariableSource().equals(typeDescription.getTypeVariableSource());</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return getSymbol();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Implementation of a symbolic type variable.
&nbsp;             */
&nbsp;            public static class Symbolic extends Generic.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * The symbol of the symbolic type variable.
&nbsp;                 */
&nbsp;                private final String symbol;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a symbolic type variable.
&nbsp;                 *
&nbsp;                 * @param symbol           The symbol of the symbolic type variable.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public Symbolic(String symbol, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.symbol = symbol;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Sort getSort() {
<b class="fc">&nbsp;                    return Sort.VARIABLE_SYMBOLIC;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getSymbol() {
<b class="fc">&nbsp;                    return symbol;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an erasure: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an upper type bound: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a variable source: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an interface type definition: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply field definitions: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply method definitions: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply record component definitions: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getComponentType() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a component type: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic findBindingOf(Generic typeVariable) {
<b class="nc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply type arguments: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply lower bounds: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getOwnerType() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply an owner type: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getTypeName() {
<b class="fc">&nbsp;                    return toString();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getActualName() {
<b class="nc">&nbsp;                    return getSymbol();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                    return visitor.onTypeVariable(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public StackSize getStackSize() {
<b class="fc">&nbsp;                    return StackSize.SINGLE;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isArray() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isPrimitive() {
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isRecord() {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                    if (type == null) {</b>
<b class="fc">&nbsp;                        throw new NullPointerException();</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                    throw new IllegalStateException(&quot;A symbolic type variable does not imply a super type definition: &quot; + this);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int hashCode() {
<b class="fc">&nbsp;                    return symbol.hashCode();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                    if (this == other) {</b>
<b class="fc">&nbsp;                        return true;</b>
<b class="fc">&nbsp;                    } else if (!(other instanceof Generic)) {</b>
<b class="fc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    Generic typeDescription = (Generic) other;</b>
<b class="fc">&nbsp;                    return typeDescription.getSort().isTypeVariable() &amp;&amp; getSymbol().equals(typeDescription.getSymbol());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public String toString() {
<b class="fc">&nbsp;                    return getSymbol();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Description of a loaded type variable.
&nbsp;             */
&nbsp;            public static class ForLoadedType extends OfTypeVariable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented type variable.
&nbsp;                 */
&nbsp;                private final TypeVariable&lt;?&gt; typeVariable;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation reader to query for the variable&#39;s annotations.
&nbsp;                 */
&nbsp;                private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded type variable.
&nbsp;                 *
&nbsp;                 * @param typeVariable The represented type variable.
&nbsp;                 */
&nbsp;                public ForLoadedType(TypeVariable&lt;?&gt; typeVariable) {
<b class="nc">&nbsp;                    this(typeVariable, AnnotationReader.NoOp.INSTANCE);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a description of a loaded type variable with an annotation.
&nbsp;                 *
&nbsp;                 * @param typeVariable     The represented type variable.
&nbsp;                 * @param annotationReader The annotation reader to query for the variable&#39;s annotations.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedType(TypeVariable&lt;?&gt; typeVariable, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                    this.typeVariable = typeVariable;</b>
<b class="fc">&nbsp;                    this.annotationReader = annotationReader;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                    GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();</b>
<b class="fc">&nbsp;                    if (genericDeclaration instanceof Class) {</b>
<b class="fc">&nbsp;                        return TypeDescription.ForLoadedType.of((Class&lt;?&gt;) genericDeclaration);</b>
<b class="fc">&nbsp;                    } else if (genericDeclaration instanceof Method) {</b>
<b class="fc">&nbsp;                        return new MethodDescription.ForLoadedMethod((Method) genericDeclaration);</b>
<b class="nc">&nbsp;                    } else if (genericDeclaration instanceof Constructor) {</b>
<b class="nc">&nbsp;                        return new MethodDescription.ForLoadedConstructor((Constructor&lt;?&gt;) genericDeclaration);</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        throw new IllegalStateException(&quot;Unknown declaration: &quot; + genericDeclaration);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                    return new TypeVariableBoundList(typeVariable.getBounds(), annotationReader);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getSymbol() {
<b class="fc">&nbsp;                    return typeVariable.getName();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationReader.asList();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                    return typeVariable == type || super.represents(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A list of type variable bounds for a loaded {@link TypeVariable} that resolves annotations..
&nbsp;                 */
&nbsp;                protected static class TypeVariableBoundList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The type variable bounds.
&nbsp;                     */
&nbsp;                    private final java.lang.reflect.Type[] bound;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The annotation reader to query for the type bounds.
&nbsp;                     */
&nbsp;                    private final AnnotationReader annotationReader;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new list for a {@link TypeVariable}&#39;s bound.
&nbsp;                     *
&nbsp;                     * @param bound            The type variable bounds.
&nbsp;                     * @param annotationReader The annotation reader to query for the type bounds.
&nbsp;                     */
<b class="fc">&nbsp;                    protected TypeVariableBoundList(java.lang.reflect.Type[] bound, AnnotationReader annotationReader) {</b>
<b class="fc">&nbsp;                        this.bound = bound;</b>
<b class="fc">&nbsp;                        this.annotationReader = annotationReader;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return Sort.describe(bound[index], annotationReader.ofTypeVariableBoundType(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return bound.length;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A type variable with explicit annotations that replace the annotations that are declared by the provided type variable.
&nbsp;             */
&nbsp;            public static class WithAnnotationOverlay extends OfTypeVariable {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type variable to represent.
&nbsp;                 */
&nbsp;                private final Generic typeVariable;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to query for the declared annotations.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new type definition for a type variable with explicit annotations.
&nbsp;                 *
&nbsp;                 * @param typeVariable     The type variable to represent.
&nbsp;                 * @param annotationSource The annotation source to query for the declared annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public WithAnnotationOverlay(Generic typeVariable, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.typeVariable = typeVariable;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                    return typeVariable.getUpperBounds();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                    return typeVariable.getTypeVariableSource();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public String getSymbol() {
<b class="fc">&nbsp;                    return typeVariable.getSymbol();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A lazy projection of a generic type. Such projections allow to only read generic type information in case it is required. This
&nbsp;         * is meaningful as the Java virtual needs to process generic type information which requires extra resources. Also, this allows
&nbsp;         * the extraction of non-generic type information even if the generic type information is invalid.
&nbsp;         */
<b class="fc">&nbsp;        abstract class LazyProjection extends AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the actual generic type.
&nbsp;             *
&nbsp;             * @return An actual description of the represented generic type.
&nbsp;             */
&nbsp;            protected abstract Generic resolve();
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Sort getSort() {
<b class="fc">&nbsp;                return resolve().getSort();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public FieldList&lt;FieldDescription.InGenericShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                return resolve().getDeclaredFields();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodList&lt;MethodDescription.InGenericShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                return resolve().getDeclaredMethods();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public RecordComponentList&lt;RecordComponentDescription.InGenericShape&gt; getRecordComponents() {
<b class="fc">&nbsp;                return resolve().getRecordComponents();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getUpperBounds() {
<b class="fc">&nbsp;                return resolve().getUpperBounds();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getLowerBounds() {
<b class="fc">&nbsp;                return resolve().getLowerBounds();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getComponentType() {
<b class="fc">&nbsp;                return resolve().getComponentType();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeArguments() {
<b class="fc">&nbsp;                return resolve().getTypeArguments();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic findBindingOf(Generic typeVariable) {
<b class="fc">&nbsp;                return resolve().findBindingOf(typeVariable);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeVariableSource getTypeVariableSource() {
<b class="fc">&nbsp;                return resolve().getTypeVariableSource();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public Generic getOwnerType() {
<b class="fc">&nbsp;                return resolve().getOwnerType();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getTypeName() {
<b class="fc">&nbsp;                return resolve().getTypeName();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSymbol() {
<b class="fc">&nbsp;                return resolve().getSymbol();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getActualName() {
<b class="fc">&nbsp;                return resolve().getActualName();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public &lt;T&gt; T accept(Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;                return resolve().accept(visitor);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return asErasure().getStackSize();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return asErasure().isArray();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return asErasure().isPrimitive();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isRecord() {
<b class="fc">&nbsp;                return asErasure().isRecord();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;                return resolve().represents(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;            public int hashCode() {
<b class="fc">&nbsp;                return resolve().hashCode();</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;                return this == other || other instanceof TypeDefinition &amp;&amp; resolve().equals(other);</b>
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            public String toString() {
<b class="fc">&nbsp;                return resolve().toString();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a type with a lazy resolution of super class and interface types. A lazy navigation
&nbsp;             * must only be used for describing types that are guaranteed to define a super class and interface types,
&nbsp;             * i.e. non-generic types and parameterized types. Lazy navigation can also be applied to array types where
&nbsp;             * the usage does however make little sense as those properties are never generic.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class WithLazyNavigation extends LazyProjection {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
<b class="fc">&nbsp;                    return LazySuperClass.of(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                    return LazyInterfaceList.of(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                    return new TypeDefinition.SuperClassIterator(this);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy super class description for a lazy projection.
&nbsp;                 */
&nbsp;                protected static class LazySuperClass extends WithLazyNavigation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy super class description.
&nbsp;                     *
&nbsp;                     * @param delegate The lazy projection for which this description is a delegate.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LazySuperClass(LazyProjection delegate) {</b>
<b class="fc">&nbsp;                        this.delegate = delegate;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a lazy super class description.
&nbsp;                     *
&nbsp;                     * @param delegate The lazy projection for which this description is a delegate.
&nbsp;                     * @return A lazy description of the super class or {@code null} if the delegate does not define a super class.
&nbsp;                     */
&nbsp;                    @MaybeNull
&nbsp;                    protected static Generic of(LazyProjection delegate) {
<b class="fc">&nbsp;                        return delegate.asErasure().getSuperClass() == null</b>
<b class="fc">&nbsp;                                ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                                : new LazySuperClass(delegate);</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        return resolve().getDeclaredAnnotations();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming super class for given instance.&quot;)
&nbsp;                    public TypeDescription asErasure() {
<b class="fc">&nbsp;                        return delegate.asErasure().getSuperClass().asErasure();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming super class for given instance.&quot;)
&nbsp;                    protected Generic resolve() {
<b class="fc">&nbsp;                        return delegate.resolve().getSuperClass();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy interface type description for a lazy projection.
&nbsp;                 */
&nbsp;                protected static class LazyInterfaceType extends WithLazyNavigation {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The index of the interface in question.
&nbsp;                     */
&nbsp;                    private final int index;
&nbsp;
&nbsp;                    /**
&nbsp;                     * The raw interface that is declared by the erasure of the represented lazy projection.
&nbsp;                     */
&nbsp;                    private final TypeDescription.Generic rawInterface;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy interface type.
&nbsp;                     *
&nbsp;                     * @param delegate     The lazy projection for which this description is a delegate.
&nbsp;                     * @param index        The index of the interface in question.
&nbsp;                     * @param rawInterface The raw interface that is declared by the erasure of the represented lazy projection.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LazyInterfaceType(LazyProjection delegate, int index, Generic rawInterface) {</b>
<b class="fc">&nbsp;                        this.delegate = delegate;</b>
<b class="fc">&nbsp;                        this.index = index;</b>
<b class="fc">&nbsp;                        this.rawInterface = rawInterface;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                        return resolve().getDeclaredAnnotations();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public TypeDescription asErasure() {
<b class="fc">&nbsp;                        return rawInterface.asErasure();</b>
&nbsp;                    }
&nbsp;
&nbsp;                    @Override
&nbsp;                    @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                    protected Generic resolve() {
<b class="fc">&nbsp;                        return delegate.resolve().getInterfaces().get(index);</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A lazy representation of a lazy projection&#39;s interfaces.
&nbsp;                 */
&nbsp;                protected static class LazyInterfaceList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;                    /**
&nbsp;                     * The lazy projection for which this description is a delegate.
&nbsp;                     */
&nbsp;                    private final LazyProjection delegate;
&nbsp;
&nbsp;                    /**
&nbsp;                     * A list of raw interface types declared by the lazy projection&#39;s erasure.
&nbsp;                     */
&nbsp;                    private final TypeList.Generic rawInterfaces;
&nbsp;
&nbsp;                    /**
&nbsp;                     * Creates a new lazy interface list.
&nbsp;                     *
&nbsp;                     * @param delegate      The lazy projection for which this description is a delegate.
&nbsp;                     * @param rawInterfaces A list of raw interface types declared by the lazy projection&#39;s erasure.
&nbsp;                     */
<b class="fc">&nbsp;                    protected LazyInterfaceList(LazyProjection delegate, TypeList.Generic rawInterfaces) {</b>
<b class="fc">&nbsp;                        this.delegate = delegate;</b>
<b class="fc">&nbsp;                        this.rawInterfaces = rawInterfaces;</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * Resolves a lazy interface list.
&nbsp;                     *
&nbsp;                     * @param delegate The delegate for which to represent interfaces.
&nbsp;                     * @return A lazy list representing the delegate&#39;s interfaces lazily.
&nbsp;                     */
&nbsp;                    protected static TypeList.Generic of(LazyProjection delegate) {
<b class="fc">&nbsp;                        return new LazyInterfaceList(delegate, delegate.asErasure().getInterfaces());</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public Generic get(int index) {
<b class="fc">&nbsp;                        return new LazyInterfaceType(delegate, index, rawInterfaces.get(index));</b>
&nbsp;                    }
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public int size() {
<b class="fc">&nbsp;                        return rawInterfaces.size();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of an annotated lazy type with lazy navigation.
&nbsp;                 */
<b class="fc">&nbsp;                protected abstract static class OfAnnotatedElement extends WithLazyNavigation {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the current type&#39;s annotation reader.
&nbsp;                     *
&nbsp;                     * @return The current type&#39;s annotation reader.
&nbsp;                     */
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                        return getAnnotationReader().asList();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a type that resolves super class and interface types eagerly.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class WithEagerNavigation extends LazyProjection {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public Generic getSuperClass() {
<b class="fc">&nbsp;                    return resolve().getSuperClass();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                    return resolve().getInterfaces();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;                    return resolve().iterator();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A description of an annotated lazy type with eager navigation.
&nbsp;                 */
<b class="fc">&nbsp;                protected abstract static class OfAnnotatedElement extends WithEagerNavigation {</b>
&nbsp;
&nbsp;                    /**
&nbsp;                     * Returns the current type&#39;s annotation reader.
&nbsp;                     *
&nbsp;                     * @return The current type&#39;s annotation reader.
&nbsp;                     */
&nbsp;                    protected abstract AnnotationReader getAnnotationReader();
&nbsp;
&nbsp;                    /**
&nbsp;                     * {@inheritDoc}
&nbsp;                     */
&nbsp;                    public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                        return getAnnotationReader().asList();</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a generic super type.
&nbsp;             */
&nbsp;            public static class ForLoadedSuperClass extends LazyProjection.WithLazyNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type of which the super class is represented.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt; type;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy projection of a type&#39;s super class.
&nbsp;                 *
&nbsp;                 * @param type The type of which the super class is represented.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedSuperClass(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;                    this.type = type;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy projection of a type&#39;s super class.
&nbsp;                 *
&nbsp;                 * @param type The type of which the super class is represented.
&nbsp;                 * @return A representation of the supplied type&#39;s super class or {@code null} if no such class exists.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public static Generic of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                    return type.getSuperclass() == null</b>
<b class="fc">&nbsp;                            ? TypeDescription.Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : new Generic.LazyProjection.ForLoadedSuperClass(type);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return Sort.describe(type.getGenericSuperclass(), getAnnotationReader());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return ForLoadedType.of(type.getSuperclass());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return new AnnotationReader.Delegator.ForLoadedSuperClass(type);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a field&#39;s type.
&nbsp;             */
&nbsp;            public static class ForLoadedFieldType extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The field of which the type is represented.
&nbsp;                 */
&nbsp;                private final Field field;
&nbsp;
&nbsp;                /**
&nbsp;                 * Create&#39;s a lazy projection of a field type.
&nbsp;                 *
&nbsp;                 * @param field The field of which the type is represented.
&nbsp;                 */
<b class="fc">&nbsp;                public ForLoadedFieldType(Field field) {</b>
<b class="fc">&nbsp;                    this.field = field;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return Sort.describe(field.getGenericType(), getAnnotationReader());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return ForLoadedType.of(field.getType());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return new AnnotationReader.Delegator.ForLoadedField(field);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a method&#39;s generic return type.
&nbsp;             */
&nbsp;            public static class ForLoadedReturnType extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method which defines the return type.
&nbsp;                 */
&nbsp;                private final Method method;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new lazy projection of a method&#39;s return type.
&nbsp;                 *
&nbsp;                 * @param method The method which defines the return type.
&nbsp;                 */
<b class="fc">&nbsp;                public ForLoadedReturnType(Method method) {</b>
<b class="fc">&nbsp;                    this.method = method;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return Sort.describe(method.getGenericReturnType(), getAnnotationReader());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return ForLoadedType.of(method.getReturnType());</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return new AnnotationReader.Delegator.ForLoadedMethodReturnType(method);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of the parameter type of a {@link Constructor}.
&nbsp;             */
&nbsp;            public static class OfConstructorParameter extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The constructor of which a parameter type is represented.
&nbsp;                 */
&nbsp;                private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The erasure of the parameter type.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection of a constructor&#39;s parameter.
&nbsp;                 *
&nbsp;                 * @param constructor The constructor of which a parameter type is represented.
&nbsp;                 * @param index       The parameter&#39;s index.
&nbsp;                 * @param erasure     The erasure of the parameter type.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not modified by class contract.&quot;)
<b class="fc">&nbsp;                public OfConstructorParameter(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] erasure) {</b>
<b class="fc">&nbsp;                    this.constructor = constructor;</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.erasure = erasure;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;delegate&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    java.lang.reflect.Type[] type = constructor.getGenericParameterTypes();</b>
<b class="fc">&nbsp;                    return erasure.length == type.length</b>
<b class="fc">&nbsp;                            ? Sort.describe(type[index], getAnnotationReader())</b>
<b class="fc">&nbsp;                            : OfNonGenericType.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return new AnnotationReader.Delegator.ForLoadedExecutableParameterType(constructor, index);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of the parameter type of a {@link Method}.
&nbsp;             */
&nbsp;            public static class OfMethodParameter extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method of which a parameter type is represented.
&nbsp;                 */
&nbsp;                private final Method method;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter&#39;s index.
&nbsp;                 */
&nbsp;                private final int index;
&nbsp;
&nbsp;                /**
&nbsp;                 * The erasures of the method&#39;s parameter types.
&nbsp;                 */
&nbsp;                private final Class&lt;?&gt;[] erasure;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection of a constructor&#39;s parameter.
&nbsp;                 *
&nbsp;                 * @param method  The method of which a parameter type is represented.
&nbsp;                 * @param index   The parameter&#39;s index.
&nbsp;                 * @param erasure The erasures of the method&#39;s parameter types.
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;EI_EXPOSE_REP2&quot;, justification = &quot;The array is not modified by class contract.&quot;)
<b class="fc">&nbsp;                public OfMethodParameter(Method method, int index, Class&lt;?&gt;[] erasure) {</b>
<b class="fc">&nbsp;                    this.method = method;</b>
<b class="fc">&nbsp;                    this.index = index;</b>
<b class="fc">&nbsp;                    this.erasure = erasure;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    java.lang.reflect.Type[] type = method.getGenericParameterTypes();</b>
<b class="fc">&nbsp;                    return erasure.length == type.length</b>
<b class="fc">&nbsp;                            ? Sort.describe(type[index], getAnnotationReader())</b>
<b class="fc">&nbsp;                            : OfNonGenericType.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return TypeDescription.ForLoadedType.of(erasure[index]);</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return new AnnotationReader.Delegator.ForLoadedExecutableParameterType(method, index);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection of a {@code java.lang.reflect.RecordComponent}&#39;s type.
&nbsp;             */
&nbsp;            public static class OfRecordComponent extends LazyProjection.WithEagerNavigation.OfAnnotatedElement {
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented record component.
&nbsp;                 */
&nbsp;                private final Object recordComponent;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection of a {@code java.lang.reflect.RecordComponent}&#39;s type.
&nbsp;                 *
&nbsp;                 * @param recordComponent The represented record component.
&nbsp;                 */
<b class="fc">&nbsp;                protected OfRecordComponent(Object recordComponent) {</b>
<b class="fc">&nbsp;                    this.recordComponent = recordComponent;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return Sort.describe(RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getGenericType(recordComponent), getAnnotationReader());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return ForLoadedType.of(RecordComponentDescription.ForLoadedRecordComponent.RECORD_COMPONENT.getType(recordComponent));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected AnnotationReader getAnnotationReader() {
<b class="fc">&nbsp;                    return new AnnotationReader.Delegator.ForLoadedRecordComponent(recordComponent);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A lazy projection that applies a visitor only when resolving the generic type but not when reading the erasure.
&nbsp;             */
&nbsp;            public static class WithResolvedErasure extends LazyProjection.WithEagerNavigation {
&nbsp;
&nbsp;                /**
&nbsp;                 * The unresolved generic type.
&nbsp;                 */
&nbsp;                private final Generic delegate;
&nbsp;
&nbsp;                /**
&nbsp;                 * The visitor to apply for resolving the generic type.
&nbsp;                 */
&nbsp;                private final Visitor&lt;? extends Generic&gt; visitor;
&nbsp;
&nbsp;                /**
&nbsp;                 * The annotation source to apply.
&nbsp;                 */
&nbsp;                private final AnnotationSource annotationSource;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection with a resolved erasure that retains the delegates type annotations.
&nbsp;                 *
&nbsp;                 * @param delegate The unresolved generic type.
&nbsp;                 * @param visitor  The visitor to apply for resolving the generic type.
&nbsp;                 */
&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor) {
<b class="fc">&nbsp;                    this(delegate, visitor, delegate);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a lazy projection with a resolved erasure.
&nbsp;                 *
&nbsp;                 * @param delegate         The unresolved generic type.
&nbsp;                 * @param visitor          The visitor to apply for resolving the generic type.
&nbsp;                 * @param annotationSource The annotation source representing this type&#39;s type annotations.
&nbsp;                 */
<b class="fc">&nbsp;                public WithResolvedErasure(Generic delegate, Visitor&lt;? extends Generic&gt; visitor, AnnotationSource annotationSource) {</b>
<b class="fc">&nbsp;                    this.delegate = delegate;</b>
<b class="fc">&nbsp;                    this.visitor = visitor;</b>
<b class="fc">&nbsp;                    this.annotationSource = annotationSource;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                    return annotationSource.getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription asErasure() {
<b class="fc">&nbsp;                    return delegate.asErasure();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @CachedReturnPlugin.Enhance(&quot;resolved&quot;)
&nbsp;                protected Generic resolve() {
<b class="fc">&nbsp;                    return delegate.accept(visitor);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A builder for creating describing a generic type as a {@link Generic}.
&nbsp;         */
&nbsp;        @HashCodeAndEqualsPlugin.Enhance
&nbsp;        abstract class Builder {
&nbsp;
&nbsp;            /**
&nbsp;             * Represents an undefined {@link java.lang.reflect.Type} within a build step.
&nbsp;             */
&nbsp;            @AlwaysNull
<b class="fc">&nbsp;            private static final java.lang.reflect.Type UNDEFINED = null;</b>
&nbsp;
&nbsp;            /**
&nbsp;             * The type annotations of the current annotated type.
&nbsp;             */
&nbsp;            protected final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new builder for a generic type description.
&nbsp;             *
&nbsp;             * @param annotations The type annotations of the current annotated type.
&nbsp;             */
<b class="fc">&nbsp;            protected Builder(List&lt;? extends AnnotationDescription&gt; annotations) {</b>
<b class="fc">&nbsp;                this.annotations = annotations;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a generic type to a builder of the same type.
&nbsp;             *
&nbsp;             * @param type The type to resolve.
&nbsp;             * @return A builder for the given type.
&nbsp;             */
&nbsp;            public static Builder of(java.lang.reflect.Type type) {
<b class="nc">&nbsp;                return of(Sort.describe(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a generic type description to a builder of the same type.
&nbsp;             *
&nbsp;             * @param typeDescription The type to resolve.
&nbsp;             * @return A builder for the given type.
&nbsp;             */
&nbsp;            public static Builder of(TypeDescription.Generic typeDescription) {
<b class="fc">&nbsp;                return typeDescription.accept(Visitor.INSTANCE);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description.
&nbsp;             *
&nbsp;             * @param type The type to represent as a raw type.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(Class&lt;?&gt; type) {
<b class="fc">&nbsp;                return rawType(ForLoadedType.of(type));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description.
&nbsp;             *
&nbsp;             * @param type The type to represent as a raw type.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(TypeDescription type) {
<b class="fc">&nbsp;                return new Builder.OfNonGenericType(type);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description where the supplied owner type is used as .
&nbsp;             *
&nbsp;             * @param type      The type to represent as a raw type.
&nbsp;             * @param ownerType The raw type&#39;s (annotated) declaring type or {@code null} if no owner type should be declared.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(Class&lt;?&gt; type, @MaybeNull Generic ownerType) {
<b class="fc">&nbsp;                return rawType(ForLoadedType.of(type), ownerType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a raw type of a type description.
&nbsp;             *
&nbsp;             * @param type      The type to represent as a raw type.
&nbsp;             * @param ownerType The raw type&#39;s (annotated) declaring type or {@code null} if no owner type should be declared.
&nbsp;             * @return A builder for creating a raw type.
&nbsp;             */
&nbsp;            public static Builder rawType(TypeDescription type, @MaybeNull Generic ownerType) {
<b class="fc">&nbsp;                TypeDescription declaringType = type.getDeclaringType();</b>
<b class="fc">&nbsp;                if (declaringType == null &amp;&amp; ownerType != null) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(type + &quot; does not have a declaring type: &quot; + ownerType);</b>
<b class="fc">&nbsp;                } else if (declaringType != null &amp;&amp; (ownerType == null || !declaringType.equals(ownerType.asErasure()))) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(ownerType + &quot; is not the declaring type of &quot; + type);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Builder.OfNonGenericType(type, ownerType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard without type annotations.
&nbsp;             *
&nbsp;             * @return A description of an unbound wildcard without type annotations.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard() {
<b class="fc">&nbsp;                return unboundWildcard(Collections.&lt;AnnotationDescription&gt;emptySet());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotation The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(Annotation... annotation) {
<b class="nc">&nbsp;                return unboundWildcard(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotations The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                return unboundWildcard(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotation The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                return unboundWildcard(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates an unbound wildcard.
&nbsp;             *
&nbsp;             * @param annotations The type annotations of the unbound wildcard.
&nbsp;             * @return A description of an unbound wildcard.
&nbsp;             */
&nbsp;            public static Generic unboundWildcard(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                return OfWildcardType.Latent.unbounded(new Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a symbolic type variable of the given name.
&nbsp;             *
&nbsp;             * @param symbol The symbolic name of the type variable.
&nbsp;             * @return A builder for creating a type variable.
&nbsp;             */
&nbsp;            public static Builder typeVariable(String symbol) {
<b class="fc">&nbsp;                return new OfTypeVariable(symbol);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType   A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameter The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, java.lang.reflect.Type... parameter) {
<b class="fc">&nbsp;                return parameterizedType(rawType, Arrays.asList(parameter));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType, List&lt;? extends java.lang.reflect.Type&gt; parameters) {
<b class="fc">&nbsp;                return parameterizedType(rawType, UNDEFINED, parameters);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param ownerType  The owner type of the parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(Class&lt;?&gt; rawType,
&nbsp;                                                    @MaybeNull java.lang.reflect.Type ownerType,
&nbsp;                                                    List&lt;? extends java.lang.reflect.Type&gt; parameters) {
<b class="fc">&nbsp;                return parameterizedType(ForLoadedType.of(rawType),</b>
<b class="fc">&nbsp;                        ownerType == null</b>
<b class="fc">&nbsp;                                ? null</b>
<b class="fc">&nbsp;                                : Sort.describe(ownerType),</b>
&nbsp;                        new TypeList.Generic.ForLoadedTypes(parameters));
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType   A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameter The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, TypeDefinition... parameter) {
<b class="fc">&nbsp;                return parameterizedType(rawType, Arrays.asList(parameter));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type without an owner type or with a non-generic owner type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(TypeDescription rawType, Collection&lt;? extends TypeDefinition&gt; parameters) {
<b class="fc">&nbsp;                return parameterizedType(rawType, Generic.UNDEFINED, parameters);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a parameterized type.
&nbsp;             *
&nbsp;             * @param rawType    A raw version of the type to describe as a parameterized type.
&nbsp;             * @param ownerType  The owner type of the parameterized type.
&nbsp;             * @param parameters The type arguments to attach to the raw type as parameters.
&nbsp;             * @return A builder for creating a parameterized type.
&nbsp;             */
&nbsp;            public static Builder parameterizedType(TypeDescription rawType,
&nbsp;                                                    @MaybeNull Generic ownerType,
&nbsp;                                                    Collection&lt;? extends TypeDefinition&gt; parameters) {
<b class="fc">&nbsp;                TypeDescription declaringType = rawType.getDeclaringType();</b>
<b class="fc">&nbsp;                if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; rawType.isStatic()) {</b>
<b class="fc">&nbsp;                    ownerType = declaringType.asGenericType();</b>
&nbsp;                }
<b class="fc">&nbsp;                if (!rawType.represents(TargetType.class)) {</b>
<b class="fc">&nbsp;                    if (!rawType.isGenerified()) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(rawType + &quot; is not a parameterized type&quot;);</b>
<b class="fc">&nbsp;                    } else if (ownerType == null &amp;&amp; declaringType != null &amp;&amp; !rawType.isStatic()) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(rawType + &quot; requires an owner type&quot;);</b>
<b class="fc">&nbsp;                    } else if (ownerType != null &amp;&amp; !ownerType.asErasure().equals(declaringType)) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not represent required owner for &quot; + rawType);</b>
<b class="fc">&nbsp;                    } else if (ownerType != null &amp;&amp; (rawType.isStatic() ^ ownerType.getSort().isNonGeneric())) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(ownerType + &quot; does not define the correct parameters for owning &quot; + rawType);</b>
<b class="fc">&nbsp;                    } else if (rawType.getTypeVariables().size() != parameters.size()) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(parameters + &quot; does not contain number of required parameters for &quot; + rawType);</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                return new Builder.OfParameterizedType(rawType, ownerType, new TypeList.Generic.Explicit(new ArrayList&lt;TypeDefinition&gt;(parameters)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound() {
<b class="fc">&nbsp;                return asWildcardUpperBound(Collections.&lt;AnnotationDescription&gt;emptySet());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(Annotation... annotation) {
<b class="nc">&nbsp;                return asWildcardUpperBound(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                return asWildcardUpperBound(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(AnnotationDescription... annotation) {
<b class="nc">&nbsp;                return asWildcardUpperBound(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the upper bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an upper bound.
&nbsp;             */
&nbsp;            public Generic asWildcardUpperBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                return OfWildcardType.Latent.boundedAbove(build(), new Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound() {
<b class="fc">&nbsp;                return asWildcardLowerBound(Collections.&lt;AnnotationDescription&gt;emptySet());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(Annotation... annotation) {
<b class="nc">&nbsp;                return asWildcardLowerBound(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                return asWildcardLowerBound(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                return asWildcardLowerBound(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Transforms this type into the lower bound of a wildcard type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the wildcard type.
&nbsp;             * @return A generic type description of a wildcard type with this builder&#39;s type as an lower bound.
&nbsp;             */
&nbsp;            public Generic asWildcardLowerBound(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                return OfWildcardType.Latent.boundedBelow(build(), new Explicit(new ArrayList&lt;AnnotationDescription&gt;(annotations)));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents the built type into an array.
&nbsp;             *
&nbsp;             * @return A builder for creating an array of the currently built type.
&nbsp;             */
&nbsp;            public Builder asArray() {
<b class="fc">&nbsp;                return asArray(1);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Represents the built type into an array.
&nbsp;             *
&nbsp;             * @param arity The arity of the array.
&nbsp;             * @return A builder for creating an array of the currently built type.
&nbsp;             */
&nbsp;            public Builder asArray(int arity) {
<b class="fc">&nbsp;                if (arity &lt; 1) {</b>
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot define an array of a non-positive arity: &quot; + arity);</b>
&nbsp;                }
<b class="fc">&nbsp;                TypeDescription.Generic typeDescription = build();</b>
<b class="fc">&nbsp;                while (--arity &gt; 0) {</b>
<b class="fc">&nbsp;                    typeDescription = new OfGenericArray.Latent(typeDescription, Empty.INSTANCE);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new Builder.OfGenericArrayType(typeDescription);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(Annotation... annotation) {
<b class="nc">&nbsp;                return annotate(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                return annotate(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotation Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                return annotate(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Defines type annotations to be declared by the current type.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            public Builder annotate(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                return doAnnotate(new ArrayList&lt;AnnotationDescription&gt;(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new builder for the current type and the applied type annotations.
&nbsp;             *
&nbsp;             * @param annotations Type annotations to be declared by the current type.
&nbsp;             * @return A new builder where the current type declares the supplied type annotations.
&nbsp;             */
&nbsp;            protected abstract Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations);
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build() {
<b class="fc">&nbsp;                return doBuild();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotation Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(Annotation... annotation) {
<b class="nc">&nbsp;                return build(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotations Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(List&lt;? extends Annotation&gt; annotations) {
<b class="nc">&nbsp;                return build(new AnnotationList.ForLoadedAnnotations(annotations));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotation Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(AnnotationDescription... annotation) {
<b class="fc">&nbsp;                return build(Arrays.asList(annotation));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Finalizes the build and finalizes the created type as a generic type description.
&nbsp;             *
&nbsp;             * @param annotations Type annotations place for the built generic type to declare.
&nbsp;             * @return A generic type description of the built type.
&nbsp;             */
&nbsp;            public Generic build(Collection&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                return doAnnotate(new ArrayList&lt;AnnotationDescription&gt;(annotations)).doBuild();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Builds the generic type.
&nbsp;             *
&nbsp;             * @return The generic type.
&nbsp;             */
&nbsp;            protected abstract Generic doBuild();
&nbsp;
&nbsp;            /**
&nbsp;             * A visitor to resolve a generic type to a {@link Builder}.
&nbsp;             */
<b class="fc">&nbsp;            protected enum Visitor implements Generic.Visitor&lt;Builder&gt; {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public Builder onGenericArray(Generic genericArray) {
<b class="fc">&nbsp;                    return new OfGenericArrayType(genericArray.getComponentType(), genericArray.getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder onWildcard(Generic wildcard) {
<b class="fc">&nbsp;                    throw new IllegalArgumentException(&quot;Cannot resolve wildcard type &quot; + wildcard + &quot; to builder&quot;);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder onParameterizedType(Generic parameterizedType) {
<b class="fc">&nbsp;                    return new OfParameterizedType(parameterizedType.asErasure(),</b>
<b class="fc">&nbsp;                            parameterizedType.getOwnerType(),</b>
<b class="fc">&nbsp;                            parameterizedType.getTypeArguments(),</b>
<b class="fc">&nbsp;                            parameterizedType.getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Builder onTypeVariable(Generic typeVariable) {
<b class="fc">&nbsp;                    return new OfTypeVariable(typeVariable.getSymbol(), typeVariable.getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;                public Builder onNonGenericType(Generic typeDescription) {
<b class="fc">&nbsp;                    return typeDescription.isArray()</b>
<b class="fc">&nbsp;                            ? typeDescription.getComponentType().accept(this).asArray().annotate(typeDescription.getDeclaredAnnotations())</b>
<b class="fc">&nbsp;                            : new OfNonGenericType(typeDescription.asErasure(), typeDescription.getOwnerType(), typeDescription.getDeclaredAnnotations());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder for building a non-generic type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfNonGenericType extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The type&#39;s erasure.
&nbsp;                 */
&nbsp;                private final TypeDescription typeDescription;
&nbsp;
&nbsp;                /**
&nbsp;                 * The raw type&#39;s (annotated) declaring type or {@code null} if no such type is defined.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription) {
<b class="fc">&nbsp;                    this(typeDescription, typeDescription.getDeclaringType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 * @param ownerType       The raw type&#39;s raw declaring type or {@code null} if no such type is defined.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @MaybeNull TypeDescription ownerType) {
<b class="fc">&nbsp;                    this(typeDescription, ownerType == null</b>
<b class="fc">&nbsp;                            ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : ownerType.asGenericType());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 * @param ownerType       The raw type&#39;s (annotated) declaring type.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription, @MaybeNull Generic ownerType) {
<b class="fc">&nbsp;                    this(typeDescription, ownerType, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a non-generic type.
&nbsp;                 *
&nbsp;                 * @param typeDescription The type&#39;s erasure.
&nbsp;                 * @param ownerType       The raw type&#39;s (annotated) declaring type.
&nbsp;                 * @param annotations     The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfNonGenericType(TypeDescription typeDescription,
&nbsp;                                           @MaybeNull Generic ownerType,
&nbsp;                                           List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    super(annotations);</b>
<b class="fc">&nbsp;                    this.ownerType = ownerType;</b>
<b class="fc">&nbsp;                    this.typeDescription = typeDescription;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return new OfNonGenericType(typeDescription, ownerType, CompoundList.of(this.annotations, annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
<b class="fc">&nbsp;                    if (typeDescription.represents(void.class) &amp;&amp; !annotations.isEmpty()) {</b>
<b class="fc">&nbsp;                        throw new IllegalArgumentException(&quot;The void non-type cannot be annotated&quot;);</b>
&nbsp;                    }
<b class="fc">&nbsp;                    return new Generic.OfNonGenericType.Latent(typeDescription, ownerType, new Explicit(annotations));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder for building a parameterized type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfParameterizedType extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The raw base type.
&nbsp;                 */
&nbsp;                private final TypeDescription rawType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic owner type.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @HashCodeAndEqualsPlugin.ValueHandling(HashCodeAndEqualsPlugin.ValueHandling.Sort.REVERSE_NULLABILITY)
&nbsp;                private final Generic ownerType;
&nbsp;
&nbsp;                /**
&nbsp;                 * The parameter types.
&nbsp;                 */
&nbsp;                private final List&lt;? extends Generic&gt; parameterTypes;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a parameterized type.
&nbsp;                 *
&nbsp;                 * @param rawType        The raw base type.
&nbsp;                 * @param ownerType      The generic owner type.
&nbsp;                 * @param parameterTypes The parameter types.
&nbsp;                 */
&nbsp;                protected OfParameterizedType(TypeDescription rawType,
&nbsp;                                              @MaybeNull Generic ownerType,
&nbsp;                                              List&lt;? extends Generic&gt; parameterTypes) {
<b class="fc">&nbsp;                    this(rawType, ownerType, parameterTypes, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a builder for a parameterized type.
&nbsp;                 *
&nbsp;                 * @param rawType        The raw base type.
&nbsp;                 * @param ownerType      The generic owner type.
&nbsp;                 * @param parameterTypes The parameter types.
&nbsp;                 * @param annotations    The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfParameterizedType(TypeDescription rawType,
&nbsp;                                              @MaybeNull Generic ownerType,
&nbsp;                                              List&lt;? extends Generic&gt; parameterTypes,
&nbsp;                                              List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    super(annotations);</b>
<b class="fc">&nbsp;                    this.rawType = rawType;</b>
<b class="fc">&nbsp;                    this.ownerType = ownerType;</b>
<b class="fc">&nbsp;                    this.parameterTypes = parameterTypes;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return new OfParameterizedType(rawType, ownerType, parameterTypes, CompoundList.of(this.annotations, annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
<b class="fc">&nbsp;                    return new Generic.OfParameterizedType.Latent(rawType, ownerType, parameterTypes, new Explicit(annotations));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder building a generic array type.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfGenericArrayType extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The generic component type.
&nbsp;                 */
&nbsp;                private final Generic componentType;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type builder for building a generic array type.
&nbsp;                 *
&nbsp;                 * @param componentType The generic component type.
&nbsp;                 */
&nbsp;                protected OfGenericArrayType(Generic componentType) {
<b class="fc">&nbsp;                    this(componentType, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a type builder for building a generic array type.
&nbsp;                 *
&nbsp;                 * @param componentType The generic component type.
&nbsp;                 * @param annotations   The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfGenericArrayType(Generic componentType, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    super(annotations);</b>
<b class="fc">&nbsp;                    this.componentType = componentType;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return new OfGenericArrayType(componentType, CompoundList.of(this.annotations, annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
<b class="fc">&nbsp;                    return new Generic.OfGenericArray.Latent(componentType, new Explicit(annotations));</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A generic type builder building a symbolic type variable.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            protected static class OfTypeVariable extends Builder {
&nbsp;
&nbsp;                /**
&nbsp;                 * The variable&#39;s symbol.
&nbsp;                 */
&nbsp;                private final String symbol;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new builder for a symbolic type variable.
&nbsp;                 *
&nbsp;                 * @param symbol The variable&#39;s symbol.
&nbsp;                 */
&nbsp;                protected OfTypeVariable(String symbol) {
<b class="fc">&nbsp;                    this(symbol, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new builder for a symbolic type variable.
&nbsp;                 *
&nbsp;                 * @param symbol      The variable&#39;s symbol.
&nbsp;                 * @param annotations The type&#39;s type annotations.
&nbsp;                 */
&nbsp;                protected OfTypeVariable(String symbol, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    super(annotations);</b>
<b class="fc">&nbsp;                    this.symbol = symbol;</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Builder doAnnotate(List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;                    return new OfTypeVariable(symbol, CompoundList.of(this.annotations, annotations));</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                protected Generic doBuild() {
<b class="fc">&nbsp;                    return new Generic.OfTypeVariable.Symbolic(symbol, new Explicit(annotations));</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a type description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends TypeVariableSource.AbstractBase implements TypeDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@link TypeDefinition#RAW_TYPES_PROPERTY} property.
&nbsp;         */
&nbsp;        public static final boolean RAW_TYPES;
&nbsp;
&nbsp;        /*
&nbsp;         * Reads the raw type property.
&nbsp;         */
&nbsp;        static {
&nbsp;            boolean rawTypes;
&nbsp;            try {
<b class="fc">&nbsp;                rawTypes = Boolean.parseBoolean(doPrivileged(new GetSystemPropertyAction(RAW_TYPES_PROPERTY)));</b>
<b class="nc">&nbsp;            } catch (Exception ignored) {</b>
<b class="nc">&nbsp;                rawTypes = false;</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            RAW_TYPES = rawTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if a specific type is assignable to another type where the source type must be a super
&nbsp;         * type of the target type.
&nbsp;         *
&nbsp;         * @param sourceType The source type to which another type is to be assigned to.
&nbsp;         * @param targetType The target type that is to be assigned to the source type.
&nbsp;         * @return {@code true} if the target type is assignable to the source type.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        private static boolean isAssignable(TypeDescription sourceType, TypeDescription targetType) {
&nbsp;            // Means that &#39;[sourceType] var = ([targetType]) val;&#39; is a valid assignment. This is true, if:
&nbsp;            // (1) Both types are equal (implies primitive types.)
<b class="fc">&nbsp;            if (sourceType.equals(targetType)) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // (2) For arrays, there are special assignment rules.
<b class="fc">&nbsp;            if (targetType.isArray()) {</b>
<b class="fc">&nbsp;                return sourceType.isArray()</b>
<b class="fc">&nbsp;                        ? isAssignable(sourceType.getComponentType(), targetType.getComponentType())</b>
<b class="fc">&nbsp;                        : sourceType.represents(Object.class) || ARRAY_INTERFACES.contains(sourceType.asGenericType());</b>
&nbsp;            }
&nbsp;            // (3) Interfaces do not extend the Object type but are assignable to the Object type.
<b class="fc">&nbsp;            if (sourceType.represents(Object.class)) {</b>
<b class="fc">&nbsp;                return !targetType.isPrimitive();</b>
&nbsp;            }
&nbsp;            // (4) The sub type has a super type and this super type is assignable to the super type.
<b class="fc">&nbsp;            Generic superClass = targetType.getSuperClass();</b>
<b class="fc">&nbsp;            if (superClass != null &amp;&amp; sourceType.isAssignableFrom(superClass.asErasure())) {</b>
<b class="fc">&nbsp;                return true;</b>
&nbsp;            }
&nbsp;            // (5) If the target type is an interface, any of this type&#39;s interfaces might be assignable to it.
<b class="fc">&nbsp;            if (sourceType.isInterface()) {</b>
<b class="fc">&nbsp;                for (TypeDescription interfaceType : targetType.getInterfaces().asErasures()) {</b>
<b class="fc">&nbsp;                    if (sourceType.isAssignableFrom(interfaceType)) {</b>
<b class="fc">&nbsp;                        return true;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
&nbsp;            }
&nbsp;            // (6) None of these criteria are true, i.e. the types are not assignable.
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return isAssignableFrom(ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isAssignable(this, typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return isAssignableTo(ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isAssignable(typeDescription, this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInHierarchyWith(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return isAssignableTo(type) || isAssignableFrom(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInHierarchyWith(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isAssignableTo(typeDescription) || isAssignableFrom(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription asErasure() {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Generic asGenericType() {
<b class="fc">&nbsp;            return new Generic.OfNonGenericType.ForErasure(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Sort getSort() {
<b class="fc">&nbsp;            return Sort.NON_GENERIC;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInstance(Object value) {
<b class="fc">&nbsp;            return isAssignableFrom(value.getClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAnnotationValue(Object value) {
<b class="nc">&nbsp;            if ((represents(Class.class) &amp;&amp; value instanceof TypeDescription)</b>
<b class="nc">&nbsp;                    || (value instanceof AnnotationDescription &amp;&amp; ((AnnotationDescription) value).getAnnotationType().equals(this))</b>
<b class="nc">&nbsp;                    || (value instanceof EnumerationDescription &amp;&amp; ((EnumerationDescription) value).getEnumerationType().equals(this))</b>
<b class="nc">&nbsp;                    || (represents(String.class) &amp;&amp; value instanceof String)</b>
<b class="nc">&nbsp;                    || (represents(boolean.class) &amp;&amp; value instanceof Boolean)</b>
<b class="nc">&nbsp;                    || (represents(byte.class) &amp;&amp; value instanceof Byte)</b>
<b class="nc">&nbsp;                    || (represents(short.class) &amp;&amp; value instanceof Short)</b>
<b class="nc">&nbsp;                    || (represents(char.class) &amp;&amp; value instanceof Character)</b>
<b class="nc">&nbsp;                    || (represents(int.class) &amp;&amp; value instanceof Integer)</b>
<b class="nc">&nbsp;                    || (represents(long.class) &amp;&amp; value instanceof Long)</b>
<b class="nc">&nbsp;                    || (represents(float.class) &amp;&amp; value instanceof Float)</b>
<b class="nc">&nbsp;                    || (represents(double.class) &amp;&amp; value instanceof Double)</b>
<b class="nc">&nbsp;                    || (represents(String[].class) &amp;&amp; value instanceof String[])</b>
<b class="nc">&nbsp;                    || (represents(boolean[].class) &amp;&amp; value instanceof boolean[])</b>
<b class="nc">&nbsp;                    || (represents(byte[].class) &amp;&amp; value instanceof byte[])</b>
<b class="nc">&nbsp;                    || (represents(short[].class) &amp;&amp; value instanceof short[])</b>
<b class="nc">&nbsp;                    || (represents(char[].class) &amp;&amp; value instanceof char[])</b>
<b class="nc">&nbsp;                    || (represents(int[].class) &amp;&amp; value instanceof int[])</b>
<b class="nc">&nbsp;                    || (represents(long[].class) &amp;&amp; value instanceof long[])</b>
<b class="nc">&nbsp;                    || (represents(float[].class) &amp;&amp; value instanceof float[])</b>
<b class="nc">&nbsp;                    || (represents(double[].class) &amp;&amp; value instanceof double[])</b>
<b class="nc">&nbsp;                    || (represents(Class[].class) &amp;&amp; value instanceof TypeDescription[])) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[]) {</b>
<b class="nc">&nbsp;                for (AnnotationDescription annotationDescription : (AnnotationDescription[]) value) {</b>
<b class="nc">&nbsp;                    if (!annotationDescription.getAnnotationType().equals(getComponentType())) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[]) {</b>
<b class="nc">&nbsp;                for (EnumerationDescription enumerationDescription : (EnumerationDescription[]) value) {</b>
<b class="nc">&nbsp;                    if (!enumerationDescription.getEnumerationType().equals(getComponentType())) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;                return true;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return getName().replace(&#39;.&#39;, &#39;/&#39;);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getActualModifiers(boolean superFlag) {
<b class="fc">&nbsp;            int actualModifiers = getModifiers()</b>
<b class="fc">&nbsp;                    | (getDeclaredAnnotations().isAnnotationPresent(Deprecated.class) ? Opcodes.ACC_DEPRECATED : EMPTY_MASK)</b>
<b class="fc">&nbsp;                    | (isRecord() ? Opcodes.ACC_RECORD : EMPTY_MASK)</b>
<b class="fc">&nbsp;                    | (superFlag ? Opcodes.ACC_SUPER : EMPTY_MASK);</b>
<b class="fc">&nbsp;            if (isPrivate()) {</b>
<b class="fc">&nbsp;                return actualModifiers &amp; ~(Opcodes.ACC_PRIVATE | Opcodes.ACC_STATIC);</b>
<b class="fc">&nbsp;            } else if (isProtected()) {</b>
<b class="fc">&nbsp;                return actualModifiers &amp; ~(Opcodes.ACC_PROTECTED | Opcodes.ACC_STATIC) | Opcodes.ACC_PUBLIC;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return actualModifiers &amp; ~Opcodes.ACC_STATIC;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
<b class="fc">&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();</b>
<b class="fc">&nbsp;                boolean generic = false;</b>
<b class="fc">&nbsp;                for (Generic typeVariable : getTypeVariables()) {</b>
<b class="fc">&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());</b>
<b class="fc">&nbsp;                    for (Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                        upperBound.accept(new Generic.Visitor.ForSignatureVisitor(upperBound.asErasure().isInterface()</b>
<b class="fc">&nbsp;                                ? signatureWriter.visitInterfaceBound()</b>
<b class="fc">&nbsp;                                : signatureWriter.visitClassBound()));</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    generic = true;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                Generic superClass = getSuperClass();</b>
&nbsp;                // The object type itself is non generic and implicitly returns a non-generic signature
<b class="fc">&nbsp;                if (superClass == null) {</b>
<b class="fc">&nbsp;                    superClass = TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
&nbsp;                }
<b class="fc">&nbsp;                superClass.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitSuperclass()));</b>
<b class="fc">&nbsp;                generic = generic || !superClass.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                for (Generic interfaceType : getInterfaces()) {</b>
<b class="fc">&nbsp;                    interfaceType.accept(new Generic.Visitor.ForSignatureVisitor(signatureWriter.visitInterface()));</b>
<b class="fc">&nbsp;                    generic = generic || !interfaceType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return generic</b>
<b class="fc">&nbsp;                        ? signatureWriter.toString()</b>
<b class="fc">&nbsp;                        : NON_GENERIC_SIGNATURE;</b>
<b class="nc">&nbsp;            } catch (GenericSignatureFormatError ignored) {</b>
<b class="nc">&nbsp;                return NON_GENERIC_SIGNATURE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSamePackage(TypeDescription typeDescription) {
<b class="fc">&nbsp;            PackageDescription thisPackage = getPackage(), otherPackage = typeDescription.getPackage();</b>
<b class="fc">&nbsp;            return thisPackage == null || otherPackage == null</b>
<b class="nc">&nbsp;                    ? thisPackage == otherPackage</b>
<b class="fc">&nbsp;                    : thisPackage.equals(otherPackage);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isPrimitive() || (isArray()</b>
<b class="fc">&nbsp;                    ? getComponentType().isVisibleTo(typeDescription)</b>
<b class="fc">&nbsp;                    : isPublic() || isProtected() || isSamePackage(typeDescription)/* || equals(typeDescription.asErasure()) */);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isPrimitive() || (isArray()</b>
<b class="nc">&nbsp;                    ? getComponentType().isVisibleTo(typeDescription)</b>
<b class="fc">&nbsp;                    : isPublic() || isSamePackage(typeDescription)/* || equals(typeDescription.asErasure()) */);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getInheritedAnnotations() {
<b class="fc">&nbsp;            Generic superClass = getSuperClass();</b>
<b class="fc">&nbsp;            AnnotationList declaredAnnotations = getDeclaredAnnotations();</b>
<b class="fc">&nbsp;            if (superClass == null) {</b>
<b class="fc">&nbsp;                return declaredAnnotations;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                Set&lt;TypeDescription&gt; annotationTypes = new HashSet&lt;TypeDescription&gt;();</b>
<b class="fc">&nbsp;                for (AnnotationDescription annotationDescription : declaredAnnotations) {</b>
<b class="fc">&nbsp;                    annotationTypes.add(annotationDescription.getAnnotationType());</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                return new AnnotationList.Explicit(CompoundList.of(declaredAnnotations, superClass.asErasure().getInheritedAnnotations().inherited(annotationTypes)));</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public String getActualName() {
<b class="fc">&nbsp;            if (isArray()) {</b>
<b class="fc">&nbsp;                TypeDescription typeDescription = this;</b>
<b class="fc">&nbsp;                int dimensions = 0;</b>
&nbsp;                do {
<b class="fc">&nbsp;                    dimensions++;</b>
<b class="fc">&nbsp;                    typeDescription = typeDescription.getComponentType();</b>
<b class="fc">&nbsp;                } while (typeDescription.isArray());</b>
<b class="fc">&nbsp;                StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;                stringBuilder.append(typeDescription.getActualName());</b>
<b class="fc">&nbsp;                for (int i = 0; i &lt; dimensions; i++) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;                }
<b class="fc">&nbsp;                return stringBuilder.toString();</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return getName();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getLongSimpleName() {
<b class="fc">&nbsp;            TypeDescription declaringType = getDeclaringType();</b>
<b class="fc">&nbsp;            return declaringType == null</b>
<b class="fc">&nbsp;                    ? getSimpleName()</b>
<b class="fc">&nbsp;                    : declaringType.getLongSimpleName() + &quot;.&quot; + getSimpleName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isPrimitiveWrapper() {
<b class="fc">&nbsp;            return represents(Boolean.class)</b>
<b class="fc">&nbsp;                    || represents(Byte.class)</b>
<b class="fc">&nbsp;                    || represents(Short.class)</b>
<b class="fc">&nbsp;                    || represents(Character.class)</b>
<b class="fc">&nbsp;                    || represents(Integer.class)</b>
<b class="fc">&nbsp;                    || represents(Long.class)</b>
<b class="fc">&nbsp;                    || represents(Float.class)</b>
<b class="fc">&nbsp;                    || represents(Double.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public boolean isAnnotationReturnType() {
<b class="fc">&nbsp;            return isPrimitive()</b>
<b class="fc">&nbsp;                    || represents(String.class)</b>
<b class="fc">&nbsp;                    || (isAssignableTo(Enum.class) &amp;&amp; !represents(Enum.class))</b>
<b class="fc">&nbsp;                    || (isAssignableTo(Annotation.class) &amp;&amp; !represents(Annotation.class))</b>
<b class="fc">&nbsp;                    || represents(Class.class)</b>
<b class="fc">&nbsp;                    || (isArray() &amp;&amp; !getComponentType().isArray() &amp;&amp; getComponentType().isAnnotationReturnType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public boolean isAnnotationValue() {
<b class="fc">&nbsp;            return isPrimitive()</b>
<b class="fc">&nbsp;                    || represents(String.class)</b>
<b class="nc">&nbsp;                    || isAssignableTo(TypeDescription.class)</b>
<b class="nc">&nbsp;                    || isAssignableTo(AnnotationDescription.class)</b>
<b class="nc">&nbsp;                    || isAssignableTo(EnumerationDescription.class)</b>
<b class="nc">&nbsp;                    || (isArray() &amp;&amp; !getComponentType().isArray() &amp;&amp; getComponentType().isAnnotationValue());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;EC_UNRELATED_CLASS_AND_INTERFACE&quot;, justification = &quot;Fits equality contract for type definitions.&quot;)
&nbsp;        public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;            return equals(Sort.describe(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getTypeName() {
<b class="fc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeVariableSource getEnclosingSource() {
<b class="fc">&nbsp;            MethodDescription enclosingMethod = getEnclosingMethod();</b>
<b class="fc">&nbsp;            return enclosingMethod == null</b>
<b class="fc">&nbsp;                    ? (isStatic() ? TypeVariableSource.UNDEFINED : getEnclosingType()) // Top-level classes (non-static) have no enclosing type.</b>
<b class="fc">&nbsp;                    : enclosingMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInferrable() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;            return visitor.onType(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isPackageType() {
<b class="fc">&nbsp;            return getSimpleName().equals(PackageDescription.PACKAGE_CLASS_NAME);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isGenerified() {
<b class="fc">&nbsp;            if (!getTypeVariables().isEmpty()) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!isStatic()) {</b>
<b class="fc">&nbsp;                TypeDescription declaringType = getDeclaringType();</b>
<b class="fc">&nbsp;                if (declaringType != null &amp;&amp; declaringType.isGenerified()) {</b>
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;            try {
<b class="fc">&nbsp;                MethodDescription.InDefinedShape enclosingMethod = getEnclosingMethod();</b>
<b class="fc">&nbsp;                return enclosingMethod != null &amp;&amp; enclosingMethod.isGenerified();</b>
<b class="nc">&nbsp;            } catch (Throwable ignored) { // Avoid exception in case of an illegal declaration.</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getInnerClassCount() {
<b class="fc">&nbsp;            if (isStatic()) {</b>
<b class="fc">&nbsp;                return 0;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription declaringType = getDeclaringType();</b>
<b class="fc">&nbsp;            return declaringType == null</b>
<b class="fc">&nbsp;                    ? 0</b>
<b class="fc">&nbsp;                    : declaringType.getInnerClassCount() + 1;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInnerClass() {
<b class="fc">&nbsp;            return !isStatic() &amp;&amp; isNestedClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNestedClass() {
<b class="fc">&nbsp;            return getDeclaringType() != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription asBoxed() {
<b class="fc">&nbsp;            if (represents(boolean.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Boolean.class);</b>
<b class="fc">&nbsp;            } else if (represents(byte.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Byte.class);</b>
<b class="fc">&nbsp;            } else if (represents(short.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Short.class);</b>
<b class="fc">&nbsp;            } else if (represents(char.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Character.class);</b>
<b class="fc">&nbsp;            } else if (represents(int.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Integer.class);</b>
<b class="fc">&nbsp;            } else if (represents(long.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Long.class);</b>
<b class="fc">&nbsp;            } else if (represents(float.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Float.class);</b>
<b class="fc">&nbsp;            } else if (represents(double.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(Double.class);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription asUnboxed() {
<b class="fc">&nbsp;            if (represents(Boolean.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(boolean.class);</b>
<b class="fc">&nbsp;            } else if (represents(Byte.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(byte.class);</b>
<b class="fc">&nbsp;            } else if (represents(Short.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(short.class);</b>
<b class="fc">&nbsp;            } else if (represents(Character.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(char.class);</b>
<b class="fc">&nbsp;            } else if (represents(Integer.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(int.class);</b>
<b class="fc">&nbsp;            } else if (represents(Long.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(long.class);</b>
<b class="fc">&nbsp;            } else if (represents(Float.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(float.class);</b>
<b class="fc">&nbsp;            } else if (represents(Double.class)) {</b>
<b class="fc">&nbsp;                return ForLoadedType.of(double.class);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Object getDefaultValue() {
<b class="fc">&nbsp;            if (represents(boolean.class)) {</b>
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            } else if (represents(byte.class)) {</b>
<b class="fc">&nbsp;                return (byte) 0;</b>
<b class="fc">&nbsp;            } else if (represents(short.class)) {</b>
<b class="fc">&nbsp;                return (short) 0;</b>
<b class="fc">&nbsp;            } else if (represents(char.class)) {</b>
<b class="fc">&nbsp;                return (char) 0;</b>
<b class="fc">&nbsp;            } else if (represents(int.class)) {</b>
<b class="fc">&nbsp;                return 0;</b>
<b class="fc">&nbsp;            } else if (represents(long.class)) {</b>
<b class="fc">&nbsp;                return 0L;</b>
<b class="fc">&nbsp;            } else if (represents(float.class)) {</b>
<b class="fc">&nbsp;                return 0f;</b>
<b class="fc">&nbsp;            } else if (represents(double.class)) {</b>
<b class="fc">&nbsp;                return 0d;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNestHost() {
<b class="fc">&nbsp;            return equals(getNestHost());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNestMateOf(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return isNestMateOf(ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNestMateOf(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return getNestHost().equals(typeDescription.getNestHost());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isMemberType() {
<b class="fc">&nbsp;            return !isLocalType() &amp;&amp; !isAnonymousType() &amp;&amp; getDeclaringType() != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isCompileTimeConstant() {
<b class="fc">&nbsp;            return represents(int.class)</b>
<b class="fc">&nbsp;                    || represents(long.class)</b>
<b class="fc">&nbsp;                    || represents(float.class)</b>
<b class="fc">&nbsp;                    || represents(double.class)</b>
<b class="fc">&nbsp;                    || represents(String.class)</b>
<b class="nc">&nbsp;                    || represents(Class.class)</b>
<b class="nc">&nbsp;                    || equals(JavaType.METHOD_TYPE.getTypeStub())</b>
<b class="nc">&nbsp;                    || equals(JavaType.METHOD_HANDLE.getTypeStub());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSealed() {
<b class="fc">&nbsp;            return !isPrimitive() &amp;&amp; !isArray() &amp;&amp; !getPermittedSubtypes().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public ClassFileVersion getClassFileVersion() {
<b class="nc">&nbsp;            return null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="fc">&nbsp;            return new SuperClassIterator(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return getName().hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof TypeDefinition)) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDefinition typeDefinition = (TypeDefinition) other;</b>
<b class="fc">&nbsp;            return typeDefinition.getSort().isNonGeneric() &amp;&amp; getName().equals(typeDefinition.asErasure().getName());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            return (isPrimitive() ? &quot;&quot; : (isInterface() ? &quot;interface&quot; : &quot;class&quot;) + &quot; &quot;) + getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected String toSafeString() {
<b class="fc">&nbsp;            return toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * An adapter implementation of a {@link TypeDescription} that
&nbsp;         * describes any type that is not an array or a primitive type.
&nbsp;         */
<b class="fc">&nbsp;        public abstract static class OfSimpleType extends TypeDescription.AbstractBase {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isPrimitive() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isArray() {
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public TypeDescription getComponentType() {
<b class="fc">&nbsp;                return TypeDescription.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getDescriptor() {
<b class="fc">&nbsp;                return &quot;L&quot; + getInternalName() + &quot;;&quot;;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public String getCanonicalName() {
<b class="fc">&nbsp;                if (isAnonymousType() || isLocalType()) {</b>
<b class="fc">&nbsp;                    return NO_NAME;</b>
&nbsp;                }
<b class="fc">&nbsp;                String internalName = getInternalName();</b>
<b class="fc">&nbsp;                TypeDescription enclosingType = getEnclosingType();</b>
<b class="fc">&nbsp;                if (enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;)) {</b>
<b class="fc">&nbsp;                    return enclosingType.getCanonicalName() + &quot;.&quot; + internalName.substring(enclosingType.getInternalName().length() + 1);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return getName();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getSimpleName() {
<b class="fc">&nbsp;                String internalName = getInternalName();</b>
<b class="fc">&nbsp;                TypeDescription enclosingType = getEnclosingType();</b>
&nbsp;                int simpleNameIndex;
<b class="fc">&nbsp;                if (enclosingType != null &amp;&amp; internalName.startsWith(enclosingType.getInternalName() + &quot;$&quot;)) {</b>
<b class="fc">&nbsp;                    simpleNameIndex = enclosingType.getInternalName().length() + 1;</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    simpleNameIndex = internalName.lastIndexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;                    if (simpleNameIndex == -1) {</b>
<b class="fc">&nbsp;                        return internalName;</b>
&nbsp;                    }
&nbsp;                }
<b class="fc">&nbsp;                while (simpleNameIndex &lt; internalName.length() &amp;&amp; !Character.isJavaIdentifierStart(internalName.charAt(simpleNameIndex))) {</b>
<b class="fc">&nbsp;                    simpleNameIndex += 1;</b>
&nbsp;                }
<b class="fc">&nbsp;                return internalName.substring(simpleNameIndex);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public StackSize getStackSize() {
<b class="fc">&nbsp;                return StackSize.SINGLE;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * An implementation of a type description that delegates all properties but the type&#39;s name to a delegate.
&nbsp;             */
<b class="fc">&nbsp;            public abstract static class WithDelegation extends OfSimpleType {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the delegate type description to this type instance.
&nbsp;                 *
&nbsp;                 * @return The delegate type description.
&nbsp;                 */
&nbsp;                protected abstract TypeDescription delegate();
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Generic getSuperClass() {
<b class="fc">&nbsp;                    return delegate().getSuperClass();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;                    return delegate().getInterfaces();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;                    return delegate().getDeclaredFields();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;                    return delegate().getDeclaredMethods();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                    return delegate().getDeclaringType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;                    return delegate().getEnclosingMethod();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;                    return delegate().getEnclosingType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;                    return delegate().getDeclaredTypes();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isAnonymousType() {
<b class="fc">&nbsp;                    return delegate().isAnonymousType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isLocalType() {
<b class="fc">&nbsp;                    return delegate().isLocalType();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                public PackageDescription getPackage() {
<b class="fc">&nbsp;                    return delegate().getPackage();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                    return delegate().getDeclaredAnnotations();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                    return delegate().getTypeVariables();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public int getModifiers() {
<b class="fc">&nbsp;                    return delegate().getModifiers();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public String getGenericSignature() {
&nbsp;                    // Embrace use of native generic signature by direct delegation.
<b class="fc">&nbsp;                    return delegate().getGenericSignature();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public int getActualModifiers(boolean superFlag) {
&nbsp;                    // Embrace use of native actual modifiers by direct delegation.
<b class="fc">&nbsp;                    return delegate().getActualModifiers(superFlag);</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription getNestHost() {
<b class="fc">&nbsp;                    return delegate().getNestHost();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList getNestMembers() {
<b class="fc">&nbsp;                    return delegate().getNestMembers();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="fc">&nbsp;                    return delegate().getRecordComponents();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public boolean isRecord() {
<b class="fc">&nbsp;                    return delegate().isRecord();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                public boolean isSealed() {
<b class="fc">&nbsp;                    return delegate().isSealed();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeList getPermittedSubtypes() {
<b class="fc">&nbsp;                    return delegate().getPermittedSubtypes();</b>
&nbsp;                }
&nbsp;
&nbsp;                @Override
&nbsp;                @MaybeNull
&nbsp;                public ClassFileVersion getClassFileVersion() {
<b class="nc">&nbsp;                    return delegate().getClassFileVersion();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A lazy proxy for representing a {@link TypeDescription} for a loaded type. This proxy is used to
&nbsp;     * avoid locks when Byte Buddy is loaded circularly.
&nbsp;     */
&nbsp;    @HashCodeAndEqualsPlugin.Enhance
&nbsp;    class LazyProxy implements InvocationHandler {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented loaded type.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new lazy proxy.
&nbsp;         *
&nbsp;         * @param type The represented loaded type.
&nbsp;         */
<b class="fc">&nbsp;        protected LazyProxy(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Resolves a lazy proxy for a loaded type as a type description.
&nbsp;         *
&nbsp;         * @param type The represented loaded type.
&nbsp;         * @return The lazy proxy.
&nbsp;         */
&nbsp;        protected static TypeDescription of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return (TypeDescription) Proxy.newProxyInstance(TypeDescription.class.getClassLoader(),</b>
&nbsp;                    new Class&lt;?&gt;[]{TypeDescription.class},
&nbsp;                    new LazyProxy(type));
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Object invoke(Object proxy, Method method, @MaybeNull Object[] argument) throws Throwable {
&nbsp;            try {
<b class="nc">&nbsp;                return method.invoke(ForLoadedType.of(type), argument);</b>
<b class="nc">&nbsp;            } catch (InvocationTargetException exception) {</b>
<b class="nc">&nbsp;                throw exception.getTargetException();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type description implementation that represents a loaded type.
&nbsp;     */
&nbsp;    @SuppressFBWarnings(value = &quot;SE_TRANSIENT_FIELD_NOT_RESTORED&quot;, justification = &quot;Field is only used as a cache store and is implicitly recomputed&quot;)
<b class="fc">&nbsp;    class ForLoadedType extends AbstractBase implements Serializable {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The class&#39;s serial version UID.
&nbsp;         */
&nbsp;        private static final long serialVersionUID = 1L;
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for invking methods on {@link Class} reflectively.
&nbsp;         */
<b class="fc">&nbsp;        private static final Dispatcher DISPATCHER = doPrivileged(JavaDispatcher.of(Dispatcher.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A cache of type descriptions for commonly used types to avoid unnecessary allocations.
&nbsp;         */
&nbsp;        private static final Map&lt;Class&lt;?&gt;, TypeDescription&gt; TYPE_CACHE;
&nbsp;
&nbsp;        /*
&nbsp;         * Initializes the type cache.
&nbsp;         */
&nbsp;        static {
<b class="fc">&nbsp;            TYPE_CACHE = new HashMap&lt;Class&lt;?&gt;, TypeDescription&gt;();</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(TargetType.class, new ForLoadedType(TargetType.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Class.class, new ForLoadedType(Class.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Throwable.class, new ForLoadedType(Throwable.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Annotation.class, new ForLoadedType(Annotation.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Object.class, new ForLoadedType(Object.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(String.class, new ForLoadedType(String.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Boolean.class, new ForLoadedType(Boolean.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Byte.class, new ForLoadedType(Byte.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Short.class, new ForLoadedType(Short.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Character.class, new ForLoadedType(Character.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Integer.class, new ForLoadedType(Integer.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Long.class, new ForLoadedType(Long.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Float.class, new ForLoadedType(Float.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(Double.class, new ForLoadedType(Double.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(void.class, new ForLoadedType(void.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(boolean.class, new ForLoadedType(boolean.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(byte.class, new ForLoadedType(byte.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(short.class, new ForLoadedType(short.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(char.class, new ForLoadedType(char.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(int.class, new ForLoadedType(int.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(long.class, new ForLoadedType(long.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(float.class, new ForLoadedType(float.class));</b>
<b class="fc">&nbsp;            TYPE_CACHE.put(double.class, new ForLoadedType(double.class));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * The loaded type this instance represents.
&nbsp;         */
&nbsp;        private final Class&lt;?&gt; type;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable type description for a loaded type. This constructor should not normally be used.
&nbsp;         * Use {@link ForLoadedType#of(Class)} instead.
&nbsp;         *
&nbsp;         * @param type The type to be represented by this type description.
&nbsp;         */
<b class="fc">&nbsp;        public ForLoadedType(Class&lt;?&gt; type) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type&#39;s actual name where it is taken into consideration that this type might be loaded anonymously.
&nbsp;         * In this case, the remainder of the types name is suffixed by {@code /&lt;id&gt;} which is removed when using this method
&nbsp;         * but is retained when calling {@link Class#getName()}.
&nbsp;         *
&nbsp;         * @param type The type for which to resolve its name.
&nbsp;         * @return The type&#39;s actual name.
&nbsp;         */
&nbsp;        public static String getName(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            String name = type.getName();</b>
<b class="fc">&nbsp;            int anonymousLoaderIndex = name.indexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;            return anonymousLoaderIndex == -1</b>
<b class="fc">&nbsp;                    ? name</b>
<b class="nc">&nbsp;                    : name.substring(0, anonymousLoaderIndex);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a new immutable type description for a loaded type.
&nbsp;         *
&nbsp;         * @param type The type to be represented by this type description.
&nbsp;         * @return The type description representing the given type.
&nbsp;         */
&nbsp;        public static TypeDescription of(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            TypeDescription typeDescription = TYPE_CACHE.get(type);</b>
<b class="fc">&nbsp;            return typeDescription == null</b>
<b class="fc">&nbsp;                    ? new ForLoadedType(type)</b>
<b class="fc">&nbsp;                    : typeDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableFrom(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return this.type.isAssignableFrom(type) || super.isAssignableFrom(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableFrom(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; type.isAssignableFrom(((ForLoadedType) typeDescription).type) || super.isAssignableFrom(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableTo(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return type.isAssignableFrom(this.type) || super.isAssignableTo(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAssignableTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; ((ForLoadedType) typeDescription).type.isAssignableFrom(type) || super.isAssignableTo(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInHierarchyWith(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return type.isAssignableFrom(this.type) || this.type.isAssignableFrom(type) || super.isInHierarchyWith(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isInHierarchyWith(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; (((ForLoadedType) typeDescription).type.isAssignableFrom(type)</b>
<b class="fc">&nbsp;                    || type.isAssignableFrom(((ForLoadedType) typeDescription).type)) || super.isInHierarchyWith(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean represents(java.lang.reflect.Type type) {
<b class="fc">&nbsp;            return type == this.type || super.represents(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getComponentType() {
<b class="fc">&nbsp;            Class&lt;?&gt; componentType = type.getComponentType();</b>
<b class="fc">&nbsp;            return componentType == null</b>
<b class="fc">&nbsp;                    ? TypeDescription.UNDEFINED</b>
<b class="fc">&nbsp;                    : ForLoadedType.of(componentType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isArray() {
<b class="fc">&nbsp;            return type.isArray();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isPrimitive() {
<b class="fc">&nbsp;            return type.isPrimitive();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isAnnotation() {
<b class="fc">&nbsp;            return type.isAnnotation();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="fc">&nbsp;            if (RAW_TYPES) {</b>
<b class="nc">&nbsp;                return type.getSuperclass() == null</b>
<b class="nc">&nbsp;                        ? TypeDescription.Generic.UNDEFINED</b>
<b class="nc">&nbsp;                        : Generic.OfNonGenericType.ForLoadedType.of(type.getSuperclass());</b>
&nbsp;            }
<b class="fc">&nbsp;            return Generic.LazyProjection.ForLoadedSuperClass.of(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;            if (RAW_TYPES) {</b>
<b class="nc">&nbsp;                return isArray()</b>
<b class="nc">&nbsp;                        ? ARRAY_INTERFACES</b>
<b class="nc">&nbsp;                        : new TypeList.Generic.ForLoadedTypes(type.getInterfaces());</b>
&nbsp;            }
<b class="fc">&nbsp;            return isArray()</b>
<b class="fc">&nbsp;                    ? ARRAY_INTERFACES</b>
<b class="fc">&nbsp;                    : new TypeList.Generic.OfLoadedInterfaceTypes(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            Class&lt;?&gt; declaringType = type.getDeclaringClass();</b>
<b class="fc">&nbsp;            return declaringType == null</b>
<b class="fc">&nbsp;                    ? TypeDescription.UNDEFINED</b>
<b class="fc">&nbsp;                    : ForLoadedType.of(declaringType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;            Method enclosingMethod = type.getEnclosingMethod();</b>
<b class="fc">&nbsp;            Constructor&lt;?&gt; enclosingConstructor = type.getEnclosingConstructor();</b>
<b class="fc">&nbsp;            if (enclosingMethod != null) {</b>
<b class="fc">&nbsp;                return new MethodDescription.ForLoadedMethod(enclosingMethod);</b>
<b class="fc">&nbsp;            } else if (enclosingConstructor != null) {</b>
<b class="fc">&nbsp;                return new MethodDescription.ForLoadedConstructor(enclosingConstructor);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return MethodDescription.UNDEFINED;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            Class&lt;?&gt; enclosingType = type.getEnclosingClass();</b>
<b class="fc">&nbsp;            return enclosingType == null</b>
<b class="fc">&nbsp;                    ? TypeDescription.UNDEFINED</b>
<b class="fc">&nbsp;                    : ForLoadedType.of(enclosingType);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;            return new TypeList.ForLoadedTypes(type.getDeclaredClasses());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getSimpleName() {
<b class="fc">&nbsp;            String simpleName = type.getSimpleName();</b>
<b class="fc">&nbsp;            int anonymousLoaderIndex = simpleName.indexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;            if (anonymousLoaderIndex == -1) {</b>
<b class="fc">&nbsp;                return simpleName;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                StringBuilder normalized = new StringBuilder(simpleName.substring(0, anonymousLoaderIndex));</b>
<b class="nc">&nbsp;                Class&lt;?&gt; type = this.type;</b>
<b class="nc">&nbsp;                while (type.isArray()) {</b>
<b class="nc">&nbsp;                    normalized.append(&quot;[]&quot;);</b>
<b class="nc">&nbsp;                    type = type.getComponentType();</b>
&nbsp;                }
<b class="nc">&nbsp;                return normalized.toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAnonymousType() {
<b class="fc">&nbsp;            return type.isAnonymousClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isLocalType() {
<b class="fc">&nbsp;            return type.isLocalClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberType() {
<b class="fc">&nbsp;            return type.isMemberClass();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;declaredFields&quot;)
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;            return new FieldList.ForLoadedFields(GraalImageCode.getCurrent().sorted(type.getDeclaredFields(), FieldComparator.INSTANCE));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;declaredMethods&quot;)
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;            return new MethodList.ForLoadedMethods(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public PackageDescription getPackage() {
<b class="fc">&nbsp;            if (type.isArray() || type.isPrimitive()) {</b>
<b class="fc">&nbsp;                return PackageDescription.UNDEFINED;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                Package aPackage = type.getPackage();</b>
<b class="fc">&nbsp;                if (aPackage == null) {</b>
<b class="nc">&nbsp;                    String name = type.getName();</b>
<b class="nc">&nbsp;                    int index = name.lastIndexOf(&#39;.&#39;);</b>
<b class="nc">&nbsp;                    return index == -1</b>
<b class="nc">&nbsp;                            ? PackageDescription.DEFAULT</b>
<b class="nc">&nbsp;                            : new PackageDescription.Simple(name.substring(0, index));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return new PackageDescription.ForLoadedPackage(aPackage);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackSize getStackSize() {
<b class="fc">&nbsp;            return StackSize.of(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return getName(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getCanonicalName() {
<b class="fc">&nbsp;            String canonicalName = type.getCanonicalName();</b>
<b class="fc">&nbsp;            if (canonicalName == null) {</b>
<b class="fc">&nbsp;                return NO_NAME;</b>
&nbsp;            }
<b class="fc">&nbsp;            int anonymousLoaderIndex = canonicalName.indexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;            if (anonymousLoaderIndex == -1) {</b>
<b class="fc">&nbsp;                return canonicalName;</b>
&nbsp;            } else {
<b class="nc">&nbsp;                StringBuilder normalized = new StringBuilder(canonicalName.substring(0, anonymousLoaderIndex));</b>
<b class="nc">&nbsp;                Class&lt;?&gt; type = this.type;</b>
<b class="nc">&nbsp;                while (type.isArray()) {</b>
<b class="nc">&nbsp;                    normalized.append(&quot;[]&quot;);</b>
<b class="nc">&nbsp;                    type = type.getComponentType();</b>
&nbsp;                }
<b class="nc">&nbsp;                return normalized.toString();</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            String name = type.getName();</b>
<b class="fc">&nbsp;            int anonymousLoaderIndex = name.indexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;            return anonymousLoaderIndex == -1</b>
<b class="fc">&nbsp;                    ? Type.getDescriptor(type)</b>
<b class="nc">&nbsp;                    : &quot;L&quot; + name.substring(0, anonymousLoaderIndex).replace(&#39;.&#39;, &#39;/&#39;) + &quot;;&quot;;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return type.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            if (RAW_TYPES) {</b>
<b class="nc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
<b class="fc">&nbsp;            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(type.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Generic asGenericType() {
<b class="fc">&nbsp;            return Generic.OfNonGenericType.ForLoadedType.of(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getNestHost() {
<b class="fc">&nbsp;            Class&lt;?&gt; host = DISPATCHER.getNestHost(type);</b>
<b class="fc">&nbsp;            return host == null</b>
<b class="nc">&nbsp;                    ? this</b>
<b class="fc">&nbsp;                    : TypeDescription.ForLoadedType.of(host);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getNestMembers() {
<b class="fc">&nbsp;            Class&lt;?&gt;[] member = DISPATCHER.getNestMembers(type);</b>
<b class="fc">&nbsp;            return new TypeList.ForLoadedTypes(member.length == 0</b>
<b class="nc">&nbsp;                    ? new Class&lt;?&gt;[]{type}</b>
<b class="fc">&nbsp;                    : member);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNestHost() {
<b class="fc">&nbsp;            Class&lt;?&gt; host = DISPATCHER.getNestHost(type);</b>
<b class="fc">&nbsp;            return host == null || host == type;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNestMateOf(Class&lt;?&gt; type) {
<b class="fc">&nbsp;            return DISPATCHER.isNestmateOf(this.type, type) || super.isNestMateOf(ForLoadedType.of(type));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isNestMateOf(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return typeDescription instanceof ForLoadedType &amp;&amp; DISPATCHER.isNestmateOf(type, ((ForLoadedType) typeDescription).type) || super.isNestMateOf(typeDescription);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="fc">&nbsp;            Object[] recordComponent = DISPATCHER.getRecordComponents(type);</b>
<b class="fc">&nbsp;            return recordComponent == null</b>
<b class="fc">&nbsp;                    ? new RecordComponentList.Empty&lt;RecordComponentDescription.InDefinedShape&gt;()</b>
<b class="fc">&nbsp;                    : new RecordComponentList.ForLoadedRecordComponents(recordComponent);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isRecord() {
<b class="fc">&nbsp;            return DISPATCHER.isRecord(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isSealed() {
<b class="fc">&nbsp;            return DISPATCHER.isSealed(type);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getPermittedSubtypes() {
<b class="fc">&nbsp;            Class&lt;?&gt;[] permittedSubclass = DISPATCHER.getPermittedSubclasses(type);</b>
<b class="fc">&nbsp;            return permittedSubclass == null</b>
<b class="fc">&nbsp;                    ? new TypeList.Empty()</b>
<b class="fc">&nbsp;                    : new TypeList.ForLoadedTypes(permittedSubclass);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @MaybeNull
&nbsp;        @CachedReturnPlugin.Enhance(&quot;classFileVersion&quot;)
&nbsp;        public ClassFileVersion getClassFileVersion() {
&nbsp;            try {
<b class="fc">&nbsp;                return ClassFileVersion.of(type);</b>
<b class="nc">&nbsp;            } catch (Throwable ignored) {</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for using methods of {@link Class} that are not declared for Java 6.
&nbsp;         */
&nbsp;        @JavaDispatcher.Defaults
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.Class&quot;)
&nbsp;        protected interface Dispatcher {
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the annotated super class of the supplied type.
&nbsp;             *
&nbsp;             * @param type The type to resolve.
&nbsp;             * @return The annotated super class of the supplied type or {@code null} if this feature is not supported.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            AnnotatedElement getAnnotatedSuperclass(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves the annotated interfaces of the supplied type.
&nbsp;             *
&nbsp;             * @param type The type to resolve.
&nbsp;             * @return An array of the type&#39;s annotated interfaces or an empty array if this feature is not supported.
&nbsp;             */
&nbsp;            AnnotatedElement[] getAnnotatedInterfaces(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the specified class&#39;s nest host.
&nbsp;             *
&nbsp;             * @param type The class for which to locate the nest host.
&nbsp;             * @return The nest host of the specified class.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Class&lt;?&gt; getNestHost(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the nest members of the other class.
&nbsp;             *
&nbsp;             * @param type The type to get the nest members for.
&nbsp;             * @return An array containing all nest members of the specified type&#39;s nest group.
&nbsp;             */
&nbsp;            Class&lt;?&gt;[] getNestMembers(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the specified type is a nest mate of the other type.
&nbsp;             *
&nbsp;             * @param type      The type to evaluate for being a nest mate of another type.
&nbsp;             * @param candidate The candidate type.
&nbsp;             * @return {@code true} if the specified type is a nest mate of the other class.
&nbsp;             */
&nbsp;            boolean isNestmateOf(Class&lt;?&gt; type, Class&lt;?&gt; candidate);
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if this type is sealed. This will always be {@code false} if the current VM does
&nbsp;             * not support sealed classes.
&nbsp;             *
&nbsp;             * @param type The type to check
&nbsp;             * @return {@code true} if the supplied type is sealed.
&nbsp;             */
&nbsp;            boolean isSealed(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the permitted subclasses of the supplied type.
&nbsp;             *
&nbsp;             * @param type The type for which to check the permitted subclasses.
&nbsp;             * @return The permitted subclasses.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Class&lt;?&gt;[] getPermittedSubclasses(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the supplied type is a record.
&nbsp;             *
&nbsp;             * @param type The type to resolve.
&nbsp;             * @return {@code true} if the supplied type is a record.
&nbsp;             */
&nbsp;            boolean isRecord(Class&lt;?&gt; type);
&nbsp;
&nbsp;            /**
&nbsp;             * Resolves a type&#39;s record components.
&nbsp;             *
&nbsp;             * @param type The type for which to read the record components.
&nbsp;             * @return An array of all declared record components.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            Object[] getRecordComponents(Class&lt;?&gt; type);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A projection for an array type based on an existing {@link TypeDescription}.
&nbsp;     */
&nbsp;    class ArrayProjection extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * Modifiers that every array in Java implies.
&nbsp;         */
&nbsp;        private static final int ARRAY_IMPLIED = Opcodes.ACC_FINAL | Opcodes.ACC_ABSTRACT;
&nbsp;
&nbsp;        /**
&nbsp;         * Modifiers that no array in Java displays.
&nbsp;         */
&nbsp;        private static final int ARRAY_EXCLUDED = Opcodes.ACC_INTERFACE | Opcodes.ACC_ANNOTATION | Opcodes.ACC_STATIC;
&nbsp;
&nbsp;        /**
&nbsp;         * The base component type which is itself not an array.
&nbsp;         */
&nbsp;        private final TypeDescription componentType;
&nbsp;
&nbsp;        /**
&nbsp;         * The arity of this array.
&nbsp;         */
&nbsp;        private final int arity;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new array projection.
&nbsp;         *
&nbsp;         * @param componentType The base component type of the array which is itself not an array.
&nbsp;         * @param arity         The arity of this array.
&nbsp;         */
<b class="fc">&nbsp;        protected ArrayProjection(TypeDescription componentType, int arity) {</b>
<b class="fc">&nbsp;            this.componentType = componentType;</b>
<b class="fc">&nbsp;            this.arity = arity;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an array projection of an arity of one.
&nbsp;         *
&nbsp;         * @param componentType The component type of the array.
&nbsp;         * @return A projection of the component type as an array of the given value with an arity of one.
&nbsp;         */
&nbsp;        public static TypeDescription of(TypeDescription componentType) {
<b class="fc">&nbsp;            return of(componentType, 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an array projection.
&nbsp;         *
&nbsp;         * @param componentType The component type of the array.
&nbsp;         * @param arity         The arity of this array.
&nbsp;         * @return A projection of the component type as an array of the given value with the supplied arity.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public static TypeDescription of(TypeDescription componentType, int arity) {
<b class="fc">&nbsp;            if (arity &lt; 0) {</b>
<b class="fc">&nbsp;                throw new IllegalArgumentException(&quot;Arrays cannot have a negative arity&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            while (componentType.isArray()) {</b>
<b class="fc">&nbsp;                componentType = componentType.getComponentType();</b>
<b class="fc">&nbsp;                arity++;</b>
&nbsp;            }
<b class="fc">&nbsp;            return arity == 0</b>
<b class="fc">&nbsp;                    ? componentType</b>
<b class="fc">&nbsp;                    : new ArrayProjection(componentType, arity);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isArray() {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getComponentType() {
<b class="fc">&nbsp;            return arity == 1</b>
<b class="fc">&nbsp;                    ? componentType</b>
<b class="fc">&nbsp;                    : new ArrayProjection(componentType, arity - 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isPrimitive() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="fc">&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;            return ARRAY_INTERFACES;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;            return MethodDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;            return new TypeList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getSimpleName() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(componentType.getSimpleName());</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; arity; i++) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getCanonicalName() {
<b class="fc">&nbsp;            String canonicalName = componentType.getCanonicalName();</b>
<b class="fc">&nbsp;            if (canonicalName == null) {</b>
<b class="fc">&nbsp;                return NO_NAME;</b>
&nbsp;            }
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(canonicalName);</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; arity; i++) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&quot;[]&quot;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAnonymousType() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isLocalType() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isMemberType() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="nc">&nbsp;            return new FieldList.Empty&lt;FieldDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="nc">&nbsp;            return new MethodList.Empty&lt;MethodDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackSize getStackSize() {
<b class="fc">&nbsp;            return StackSize.SINGLE;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;            return new AnnotationList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getInheritedAnnotations() {
<b class="nc">&nbsp;            return new AnnotationList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public PackageDescription getPackage() {
<b class="fc">&nbsp;            return PackageDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            String descriptor = componentType.getDescriptor();</b>
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(descriptor.length() + arity);</b>
<b class="fc">&nbsp;            for (int index = 0; index &lt; arity; index++) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&#39;[&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            for (int index = 0; index &lt; descriptor.length(); index++) {</b>
<b class="fc">&nbsp;                char character = descriptor.charAt(index);</b>
<b class="fc">&nbsp;                stringBuilder.append(character == &#39;/&#39; ? &#39;.&#39; : character);</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; arity; i++) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&#39;[&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.append(componentType.getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @AlwaysNull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return (getComponentType().getModifiers() &amp; ~ARRAY_EXCLUDED) | ARRAY_IMPLIED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="nc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getNestHost() {
<b class="nc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getNestMembers() {
<b class="nc">&nbsp;            return new TypeList.Explicit(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="nc">&nbsp;            return new RecordComponentList.Empty&lt;RecordComponentDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isRecord() {
<b class="nc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getPermittedSubtypes() {
<b class="nc">&nbsp;            return new TypeList.Empty();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A latent type description for a type without methods or fields.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Important&lt;/b&gt;: This type does not define most of its properties and should only be used as a simple placeholder. For more
&nbsp;     * complex placeholders, use an {@link net.bytebuddy.dynamic.scaffold.InstrumentedType.Default}.
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    class Latent extends AbstractBase.OfSimpleType {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the type.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the type.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The super type or {@code null} if no such type exists.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final Generic superClass;
&nbsp;
&nbsp;        /**
&nbsp;         * The interfaces that this type implements.
&nbsp;         */
&nbsp;        private final List&lt;? extends Generic&gt; interfaces;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent type.
&nbsp;         *
&nbsp;         * @param name        The name of the type.
&nbsp;         * @param modifiers   The modifiers of the type.
&nbsp;         * @param superClass  The super type or {@code null} if no such type exists.
&nbsp;         * @param anInterface The interfaces that this type implements.
&nbsp;         */
&nbsp;        public Latent(String name, int modifiers, @MaybeNull Generic superClass, Generic... anInterface) {
<b class="fc">&nbsp;            this(name, modifiers, superClass, Arrays.asList(anInterface));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent type.
&nbsp;         *
&nbsp;         * @param name       The name of the type.
&nbsp;         * @param modifiers  The modifiers of the type.
&nbsp;         * @param superClass The super type or {@code null} if no such type exists.
&nbsp;         * @param interfaces The interfaces that this type implements.
&nbsp;         */
<b class="fc">&nbsp;        public Latent(String name, int modifiers, @MaybeNull Generic superClass, List&lt;? extends Generic&gt; interfaces) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.superClass = superClass;</b>
<b class="fc">&nbsp;            this.interfaces = interfaces;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="fc">&nbsp;            return superClass;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;            return new TypeList.Generic.Explicit(interfaces);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing method of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve enclosing type of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve inner types of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAnonymousType() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve anonymous type property of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isLocalType() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve local class property of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared fields of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared methods of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public PackageDescription getPackage() {
<b class="fc">&nbsp;            String name = getName();</b>
<b class="fc">&nbsp;            int index = name.lastIndexOf(&#39;.&#39;);</b>
<b class="fc">&nbsp;            return index == -1</b>
<b class="nc">&nbsp;                    ? PackageDescription.DEFAULT</b>
<b class="fc">&nbsp;                    : new PackageDescription.Simple(name.substring(0, index));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared annotations of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getDeclaringType() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve declared type of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve type variables of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getNestHost() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve nest host of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getNestMembers() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve nest mates of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve record components of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isRecord() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve record attribute of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getPermittedSubtypes() {
<b class="nc">&nbsp;            throw new IllegalStateException(&quot;Cannot resolve permitted subclasses of a latent type description: &quot; + this);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A type representation of a package description.
&nbsp;     */
&nbsp;    class ForPackageDescription extends AbstractBase.OfSimpleType {
&nbsp;
&nbsp;        /**
&nbsp;         * The package to be described as a type.
&nbsp;         */
&nbsp;        private final PackageDescription packageDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type description of a package description.
&nbsp;         *
&nbsp;         * @param packageDescription The package to be described as a type.
&nbsp;         */
<b class="fc">&nbsp;        public ForPackageDescription(PackageDescription packageDescription) {</b>
<b class="fc">&nbsp;            this.packageDescription = packageDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="fc">&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(Object.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;            return MethodDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAnonymousType() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isLocalType() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;            return new TypeList.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;            return new FieldList.Empty&lt;FieldDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;            return new MethodList.Empty&lt;MethodDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public PackageDescription getPackage() {
<b class="fc">&nbsp;            return packageDescription;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return packageDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return PackageDescription.PACKAGE_MODIFIERS;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return packageDescription.getName() + &quot;.&quot; + PackageDescription.PACKAGE_CLASS_NAME;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getNestHost() {
<b class="fc">&nbsp;            return this;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getNestMembers() {
<b class="fc">&nbsp;            return new TypeList.Explicit(this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="fc">&nbsp;            return new RecordComponentList.Empty&lt;RecordComponentDescription.InDefinedShape&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isRecord() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getPermittedSubtypes() {
<b class="fc">&nbsp;            return new TypeList.Empty();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A delegating type description that always attempts to load the super types of a delegate type.
&nbsp;     */
&nbsp;    class SuperTypeLoading extends AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The delegate type description.
&nbsp;         */
&nbsp;        private final TypeDescription delegate;
&nbsp;
&nbsp;        /**
&nbsp;         * The class loader to use for loading a super type.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final ClassLoader classLoader;
&nbsp;
&nbsp;        /**
&nbsp;         * A delegate for loading a type.
&nbsp;         */
&nbsp;        private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a super type loading type description.
&nbsp;         *
&nbsp;         * @param delegate    The delegate type description.
&nbsp;         * @param classLoader The class loader to use for loading a super type or {@code null} for using the boot loader.
&nbsp;         */
&nbsp;        public SuperTypeLoading(TypeDescription delegate, @MaybeNull ClassLoader classLoader) {
<b class="fc">&nbsp;            this(delegate, classLoader, ClassLoadingDelegate.Simple.INSTANCE);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a super type loading type description.
&nbsp;         *
&nbsp;         * @param delegate             The delegate type description.
&nbsp;         * @param classLoader          The class loader to use for loading a super type or {@code null} for using the boot loader.
&nbsp;         * @param classLoadingDelegate A delegate for loading a type.
&nbsp;         */
<b class="fc">&nbsp;        public SuperTypeLoading(TypeDescription delegate, @MaybeNull ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {</b>
<b class="fc">&nbsp;            this.delegate = delegate;</b>
<b class="fc">&nbsp;            this.classLoader = classLoader;</b>
<b class="fc">&nbsp;            this.classLoadingDelegate = classLoadingDelegate;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return delegate.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return delegate.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return delegate.getTypeVariables();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return delegate.getDescriptor();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return delegate.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Generic getSuperClass() {
<b class="fc">&nbsp;            Generic superClass = delegate.getSuperClass();</b>
<b class="fc">&nbsp;            return superClass == null</b>
<b class="fc">&nbsp;                    ? Generic.UNDEFINED</b>
<b class="fc">&nbsp;                    : new ClassLoadingTypeProjection(superClass, classLoader, classLoadingDelegate);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getInterfaces() {
<b class="fc">&nbsp;            return new ClassLoadingTypeList(delegate.getInterfaces(), classLoader, classLoadingDelegate);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public FieldList&lt;FieldDescription.InDefinedShape&gt; getDeclaredFields() {
<b class="fc">&nbsp;            return delegate.getDeclaredFields();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodList&lt;MethodDescription.InDefinedShape&gt; getDeclaredMethods() {
<b class="fc">&nbsp;            return delegate.getDeclaredMethods();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public StackSize getStackSize() {
<b class="fc">&nbsp;            return delegate.getStackSize();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isArray() {
<b class="fc">&nbsp;            return delegate.isArray();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isPrimitive() {
<b class="fc">&nbsp;            return delegate.isPrimitive();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getComponentType() {
<b class="fc">&nbsp;            return delegate.getComponentType();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return delegate.getDeclaringType();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getDeclaredTypes() {
<b class="fc">&nbsp;            return delegate.getDeclaredTypes();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public MethodDescription.InDefinedShape getEnclosingMethod() {
<b class="fc">&nbsp;            return delegate.getEnclosingMethod();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription getEnclosingType() {
<b class="fc">&nbsp;            return delegate.getEnclosingType();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getSimpleName() {
<b class="fc">&nbsp;            return delegate.getSimpleName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getCanonicalName() {
<b class="fc">&nbsp;            return delegate.getCanonicalName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAnonymousType() {
<b class="fc">&nbsp;            return delegate.isAnonymousType();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isLocalType() {
<b class="fc">&nbsp;            return delegate.isLocalType();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public PackageDescription getPackage() {
<b class="fc">&nbsp;            return delegate.getPackage();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription getNestHost() {
<b class="fc">&nbsp;            return delegate.getNestHost();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getNestMembers() {
<b class="fc">&nbsp;            return delegate.getNestMembers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public RecordComponentList&lt;RecordComponentDescription.InDefinedShape&gt; getRecordComponents() {
<b class="fc">&nbsp;            return delegate.getRecordComponents();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isRecord() {
<b class="fc">&nbsp;            return delegate.isRecord();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean isSealed() {
<b class="fc">&nbsp;            return delegate.isSealed();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList getPermittedSubtypes() {
<b class="fc">&nbsp;            return delegate.getPermittedSubtypes();</b>
&nbsp;        }
&nbsp;
&nbsp;        @MaybeNull
&nbsp;        @Override
&nbsp;        public ClassFileVersion getClassFileVersion() {
<b class="nc">&nbsp;            return delegate.getClassFileVersion();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A class loading delegate is responsible for resolving a type given a class loader and a type name.
&nbsp;         */
&nbsp;        public interface ClassLoadingDelegate {
&nbsp;
&nbsp;            /**
&nbsp;             * Loads a type.
&nbsp;             *
&nbsp;             * @param name        The type&#39;s name,
&nbsp;             * @param classLoader The class loader to load the type from which might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @return The loaded type.
&nbsp;             * @throws ClassNotFoundException If the type could not be found.
&nbsp;             */
&nbsp;            Class&lt;?&gt; load(String name, @MaybeNull ClassLoader classLoader) throws ClassNotFoundException;
&nbsp;
&nbsp;            /**
&nbsp;             * A simple class loading delegate that simply loads a type.
&nbsp;             */
<b class="fc">&nbsp;            enum Simple implements ClassLoadingDelegate {</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The singleton instance.
&nbsp;                 */
<b class="fc">&nbsp;                INSTANCE;</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Class&lt;?&gt; load(String name, @MaybeNull ClassLoader classLoader) throws ClassNotFoundException {
<b class="fc">&nbsp;                    return Class.forName(name, false, classLoader);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type projection that attempts to load any super type of the delegate type.
&nbsp;         */
&nbsp;        protected static class ClassLoadingTypeProjection extends TypeDescription.Generic.LazyProjection {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate type description.
&nbsp;             */
&nbsp;            private final Generic delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final ClassLoader classLoader;
&nbsp;
&nbsp;            /**
&nbsp;             * A delegate for loading a type.
&nbsp;             */
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class loading type description.
&nbsp;             *
&nbsp;             * @param delegate             The delegate type description.
&nbsp;             * @param classLoader          The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @param classLoadingDelegate A delegate for loading a type.
&nbsp;             */
<b class="fc">&nbsp;            protected ClassLoadingTypeProjection(Generic delegate, @MaybeNull ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
<b class="fc">&nbsp;                this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                this.classLoadingDelegate = classLoadingDelegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                return delegate.getDeclaredAnnotations();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @CachedReturnPlugin.Enhance(&quot;erasure&quot;)
&nbsp;            public TypeDescription asErasure() {
&nbsp;                try {
<b class="fc">&nbsp;                    return ForLoadedType.of(classLoadingDelegate.load(delegate.asErasure().getName(), classLoader));</b>
<b class="nc">&nbsp;                } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                    return delegate.asErasure();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            @Override
&nbsp;            protected Generic resolve() {
<b class="fc">&nbsp;                return delegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            @CachedReturnPlugin.Enhance(&quot;superClass&quot;)
&nbsp;            public Generic getSuperClass() {
<b class="fc">&nbsp;                Generic superClass = delegate.getSuperClass();</b>
<b class="fc">&nbsp;                if (superClass == null) {</b>
<b class="fc">&nbsp;                    return Generic.UNDEFINED;</b>
&nbsp;                } else {
&nbsp;                    try {
<b class="nc">&nbsp;                        return new ClassLoadingTypeProjection(superClass,</b>
<b class="nc">&nbsp;                                classLoadingDelegate.load(delegate.asErasure().getName(), classLoader).getClassLoader(),</b>
&nbsp;                                classLoadingDelegate);
<b class="nc">&nbsp;                    } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                        return superClass;</b>
&nbsp;                    }
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @CachedReturnPlugin.Enhance(&quot;interfaces&quot;)
&nbsp;            public TypeList.Generic getInterfaces() {
<b class="nc">&nbsp;                TypeList.Generic interfaces = delegate.getInterfaces();</b>
&nbsp;                try {
<b class="nc">&nbsp;                    return new ClassLoadingTypeList(interfaces,</b>
<b class="nc">&nbsp;                            classLoadingDelegate.load(delegate.asErasure().getName(), classLoader).getClassLoader(),</b>
&nbsp;                            classLoadingDelegate);
<b class="nc">&nbsp;                } catch (ClassNotFoundException ignored) {</b>
<b class="nc">&nbsp;                    return interfaces;</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Iterator&lt;TypeDefinition&gt; iterator() {
<b class="nc">&nbsp;                return new SuperClassIterator(this);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A type list that attempts loading any type.
&nbsp;         */
&nbsp;        protected static class ClassLoadingTypeList extends TypeList.Generic.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The delegate type list.
&nbsp;             */
&nbsp;            private final TypeList.Generic delegate;
&nbsp;
&nbsp;            /**
&nbsp;             * The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            private final ClassLoader classLoader;
&nbsp;
&nbsp;            /**
&nbsp;             * A delegate for loading a type.
&nbsp;             */
&nbsp;            private final ClassLoadingDelegate classLoadingDelegate;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a class loading type list.
&nbsp;             *
&nbsp;             * @param delegate             The delegate type list.
&nbsp;             * @param classLoader          The class loader to use for loading types which might be {@code null} to represent the bootstrap class loader.
&nbsp;             * @param classLoadingDelegate A delegate for loading a type.
&nbsp;             */
<b class="fc">&nbsp;            protected ClassLoadingTypeList(TypeList.Generic delegate, @MaybeNull ClassLoader classLoader, ClassLoadingDelegate classLoadingDelegate) {</b>
<b class="fc">&nbsp;                this.delegate = delegate;</b>
<b class="fc">&nbsp;                this.classLoader = classLoader;</b>
<b class="fc">&nbsp;                this.classLoadingDelegate = classLoadingDelegate;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Generic get(int index) {
<b class="fc">&nbsp;                return new ClassLoadingTypeProjection(delegate.get(index), classLoader, classLoadingDelegate);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int size() {
<b class="fc">&nbsp;                return delegate.size();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 16:00</div>
</div>
</body>
</html>
