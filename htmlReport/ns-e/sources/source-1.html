


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > FieldDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.field</a>
</div>

<h1>Coverage Summary for Class: FieldDescription (net.bytebuddy.description.field)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FieldDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FieldDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (14/14)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    93.6%
  </span>
  <span class="absValue">
    (44/47)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$ForLoadedField</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$InDefinedShape$MockitoMock$795752952</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$InDefinedShape$MockitoMock$795752952$auxiliary$4vcFS7Ux</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$InDefinedShape$MockitoMock$795752952$auxiliary$yiZZcTqP</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (16/16)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$MockitoMock$1834217395</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$MockitoMock$1834217395$auxiliary$BlkcCTqs</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$MockitoMock$1834217395$auxiliary$T4nD34B5</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$SignatureToken</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    80%
  </span>
  <span class="absValue">
    (12/15)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$SignatureToken$MockitoMock$190950178</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$SignatureToken$MockitoMock$190950178$auxiliary$C1TJ3K13</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$SignatureToken$MockitoMock$190950178$auxiliary$loJNp317</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$SignatureToken$MockitoMock$190950178$auxiliary$wUl1uBX3</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$SignatureToken$MockitoMock$190950178$auxiliary$Yt67RAr3</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    74.1%
  </span>
  <span class="absValue">
    (20/27)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$1dIyvPu0</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$7xmmpmmN</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$Ge0Msxoj</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$GJvR6UIP</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$JV9ju6uL</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$u8eQnZJw</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$z8rpwzN3</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$Token$MockitoMock$1618539261$auxiliary$zwAbISic</td>
  </tr>
  <tr>
    <td class="name">FieldDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (10/10)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    96.3%
  </span>
  <span class="absValue">
    (52/54)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.1%
  </span>
  <span class="absValue">
    (114/128)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.field;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.DeclaredByType;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.signature.SignatureWriter;
&nbsp;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.lang.reflect.GenericSignatureFormatError;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Implementations of this interface describe a Java field. Implementations of this interface must provide meaningful
&nbsp; * {@code equal(Object)} and {@code hashCode()} implementations.
&nbsp; */
&nbsp;public interface FieldDescription extends ModifierReviewable.ForFieldDescription,
&nbsp;        DeclaredByType.WithMandatoryDeclaration,
&nbsp;        ByteCodeElement.Member,
&nbsp;        ByteCodeElement.TypeDependant&lt;FieldDescription.InDefinedShape, FieldDescription.Token&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * A representative of a field&#39;s non-set default value.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    Object NO_DEFAULT_VALUE = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Nonnull
&nbsp;    TypeDefinition getDeclaringType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the type of the described field.
&nbsp;     *
&nbsp;     * @return The type of the described field.
&nbsp;     */
&nbsp;    TypeDescription.Generic getType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the field&#39;s actual modifiers as it is present in a class file, i.e. its modifiers including
&nbsp;     * a flag if this field is deprecated.
&nbsp;     *
&nbsp;     * @return The field&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a signature token representing this field.
&nbsp;     *
&nbsp;     * @return A signature token representing this field.
&nbsp;     */
&nbsp;    SignatureToken asSignatureToken();
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a field description in its generic shape, i.e. in the shape it is defined by a generic or raw type.
&nbsp;     */
&nbsp;    interface InGenericShape extends FieldDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        TypeDescription.Generic getDeclaringType();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a field in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
&nbsp;     */
&nbsp;    interface InDefinedShape extends FieldDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        TypeDescription getDeclaringType();
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a field description in its defined shape.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends FieldDescription.AbstractBase implements InDefinedShape {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InDefinedShape asDefined() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a field description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends ModifierReviewable.AbstractBase implements FieldDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getActualName() {
<b class="fc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return getType().asErasure().getDescriptor();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getGenericSignature() {
<b class="fc">&nbsp;            TypeDescription.Generic fieldType = getType();</b>
&nbsp;            try {
<b class="fc">&nbsp;                return fieldType.getSort().isNonGeneric()</b>
<b class="fc">&nbsp;                        ? NON_GENERIC_SIGNATURE</b>
<b class="fc">&nbsp;                        : fieldType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(new SignatureWriter())).toString();</b>
<b class="nc">&nbsp;            } catch (GenericSignatureFormatError ignored) {</b>
<b class="nc">&nbsp;                return NON_GENERIC_SIGNATURE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return getDeclaringType().asErasure().isVisibleTo(typeDescription)</b>
<b class="fc">&nbsp;                    &amp;&amp; (isPublic()</b>
<b class="fc">&nbsp;                    || typeDescription.equals(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || isProtected() &amp;&amp; getDeclaringType().asErasure().isAssignableFrom(typeDescription)</b>
<b class="fc">&nbsp;                    || !isPrivate() &amp;&amp; typeDescription.isSamePackage(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || isPrivate() &amp;&amp; typeDescription.isNestMateOf(getDeclaringType().asErasure()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return isPublic()</b>
<b class="fc">&nbsp;                    || typeDescription.equals(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || !isPrivate() &amp;&amp; typeDescription.isSamePackage(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || isPrivate() &amp;&amp; typeDescription.isNestMateOf(getDeclaringType().asErasure());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getActualModifiers() {
<b class="fc">&nbsp;            return getModifiers() | (getDeclaredAnnotations().isAnnotationPresent(Deprecated.class)</b>
<b class="fc">&nbsp;                    ? Opcodes.ACC_DEPRECATED</b>
<b class="fc">&nbsp;                    : EMPTY_MASK);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public FieldDescription.Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            return new FieldDescription.Token(getName(),</b>
<b class="fc">&nbsp;                    getModifiers(),</b>
<b class="fc">&nbsp;                    getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public SignatureToken asSignatureToken() {
<b class="fc">&nbsp;            return new SignatureToken(getInternalName(), getType().asErasure());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            return getDeclaringType().hashCode() + 31 * (17 + getName().hashCode());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof FieldDescription)) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            FieldDescription fieldDescription = (FieldDescription) other;</b>
<b class="fc">&nbsp;            return getName().equals(fieldDescription.getName()) &amp;&amp; getDeclaringType().equals(fieldDescription.getDeclaringType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public String toGenericString() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            if (getModifiers() != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(Modifier.toString(getModifiers())).append(&#39; &#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            stringBuilder.append(getType().getActualName()).append(&#39; &#39;);</b>
<b class="fc">&nbsp;            stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
<b class="fc">&nbsp;            return stringBuilder.append(getName()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming declaring type for type member.&quot;)
&nbsp;        public String toString() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            if (getModifiers() != EMPTY_MASK) {</b>
<b class="fc">&nbsp;                stringBuilder.append(Modifier.toString(getModifiers())).append(&#39; &#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            stringBuilder.append(getType().asErasure().getActualName()).append(&#39; &#39;);</b>
<b class="fc">&nbsp;            stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
<b class="fc">&nbsp;            return stringBuilder.append(getName()).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of a field description for a loaded field.
&nbsp;     */
&nbsp;    class ForLoadedField extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented loaded field.
&nbsp;         */
&nbsp;        private final Field field;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates an immutable field description for a loaded field.
&nbsp;         *
&nbsp;         * @param field The represented field.
&nbsp;         */
<b class="fc">&nbsp;        public ForLoadedField(Field field) {</b>
<b class="fc">&nbsp;            this.field = field;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(field.getType());</b>
&nbsp;            }
<b class="fc">&nbsp;            return new TypeDescription.Generic.LazyProjection.ForLoadedFieldType(field);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(field.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return field.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(field.getDeclaringClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return field.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSynthetic() {
<b class="fc">&nbsp;            return field.isSynthetic();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent field description describes a field that is not attached to a declaring
&nbsp;     * {@link TypeDescription}.
&nbsp;     */
&nbsp;    class Latent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type for which this field is defined.
&nbsp;         */
&nbsp;        private final TypeDescription declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the field.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The field&#39;s modifiers.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the field.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic fieldType;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of this field.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent field description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringType The declaring type of the field.
&nbsp;         * @param token         A token representing the field&#39;s shape.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType, FieldDescription.Token token) {
<b class="fc">&nbsp;            this(declaringType,</b>
<b class="fc">&nbsp;                    token.getName(),</b>
<b class="fc">&nbsp;                    token.getModifiers(),</b>
<b class="fc">&nbsp;                    token.getType(),</b>
<b class="fc">&nbsp;                    token.getAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent field description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringType       The declaring type of the field.
&nbsp;         * @param name                The name of the field.
&nbsp;         * @param fieldType           The field&#39;s modifiers.
&nbsp;         * @param modifiers           The type of the field.
&nbsp;         * @param declaredAnnotations The annotations of this field.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType,
&nbsp;                      String name,
&nbsp;                      int modifiers,
&nbsp;                      TypeDescription.Generic fieldType,
<b class="fc">&nbsp;                      List&lt;? extends AnnotationDescription&gt; declaredAnnotations) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.fieldType = fieldType;</b>
<b class="fc">&nbsp;            this.declaredAnnotations = declaredAnnotations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return fieldType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(declaredAnnotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A field description that represents a given field but with a substituted field type.
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;
&nbsp;        /**
&nbsp;         * The declaring type of the field.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented field.
&nbsp;         */
&nbsp;        private final FieldDescription fieldDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that is applied to the field type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a field description with a substituted field type.
&nbsp;         *
&nbsp;         * @param declaringType    The declaring type of the field.
&nbsp;         * @param fieldDescription The represented field.
&nbsp;         * @param visitor          A visitor that is applied to the field type.
&nbsp;         */
&nbsp;        public TypeSubstituting(TypeDescription.Generic declaringType,
&nbsp;                                FieldDescription fieldDescription,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.fieldDescription = fieldDescription;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return fieldDescription.getType().accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return fieldDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription.Generic getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return fieldDescription.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return fieldDescription.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InDefinedShape asDefined() {
<b class="fc">&nbsp;            return fieldDescription.asDefined();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a field&#39;s properties detached from a type.
&nbsp;     */
&nbsp;    class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the represented field.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the represented field.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the represented field.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic type;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of the represented field.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new field token without annotations. The field type must be represented in its detached form.
&nbsp;         *
&nbsp;         * @param name      The name of the represented field.
&nbsp;         * @param modifiers The modifiers of the represented field.
&nbsp;         * @param type      The type of the represented field.
&nbsp;         */
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic type) {
<b class="fc">&nbsp;            this(name, modifiers, type, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new field token. The field type must be represented in its detached form.
&nbsp;         *
&nbsp;         * @param name        The name of the represented field.
&nbsp;         * @param modifiers   The modifiers of the represented field.
&nbsp;         * @param type        The type of the represented field.
&nbsp;         * @param annotations The annotations of the represented field.
&nbsp;         */
<b class="fc">&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic type, List&lt;? extends AnnotationDescription&gt; annotations) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the represented field.
&nbsp;         *
&nbsp;         * @return The name of the represented field.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type of the represented field.
&nbsp;         *
&nbsp;         * @return The type of the represented field.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the modifiers of the represented field.
&nbsp;         *
&nbsp;         * @return The modifiers of the represented field.
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the annotations of the represented field.
&nbsp;         *
&nbsp;         * @return The annotations of the represented field.
&nbsp;         */
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(name,</b>
&nbsp;                    modifiers,
<b class="fc">&nbsp;                    type.accept(visitor),</b>
&nbsp;                    annotations);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a signature token that represents the method that is represented by this token.
&nbsp;         *
&nbsp;         * @param declaringType The declaring type of the field that this token represents.
&nbsp;         * @return A signature token representing this token.
&nbsp;         */
&nbsp;        public SignatureToken asSignatureToken(TypeDescription declaringType) {
<b class="fc">&nbsp;            return new SignatureToken(name, type.accept(new TypeDescription.Generic.Visitor.Reducing(declaringType)));</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + modifiers;</b>
<b class="nc">&nbsp;            result = 31 * result + type.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + annotations.hashCode();</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            Token token = (Token) other;</b>
<b class="fc">&nbsp;            return modifiers == token.modifiers</b>
<b class="fc">&nbsp;                    &amp;&amp; name.equals(token.name)</b>
<b class="fc">&nbsp;                    &amp;&amp; type.equals(token.type)</b>
<b class="fc">&nbsp;                    &amp;&amp; annotations.equals(token.annotations);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token that uniquely identifies a field by its name and type erasure.
&nbsp;     */
&nbsp;    class SignatureToken {
&nbsp;
&nbsp;        /**
&nbsp;         * The field&#39;s name.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The field&#39;s raw type.
&nbsp;         */
&nbsp;        private final TypeDescription type;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new signature token.
&nbsp;         *
&nbsp;         * @param name The field&#39;s name.
&nbsp;         * @param type The field&#39;s raw type.
&nbsp;         */
<b class="fc">&nbsp;        public SignatureToken(String name, TypeDescription type) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.type = type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the represented field.
&nbsp;         *
&nbsp;         * @return The name of the represented field.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type of the represented field.
&nbsp;         *
&nbsp;         * @return The type of the represented field.
&nbsp;         */
&nbsp;        public TypeDescription getType() {
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = name.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + type.hashCode();</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof SignatureToken)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            SignatureToken signatureToken = (SignatureToken) other;</b>
<b class="fc">&nbsp;            return name.equals(signatureToken.name) &amp;&amp; type.equals(signatureToken.type);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return type + &quot; &quot; + name;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
