


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ParameterDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: ParameterDescription (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">ParameterDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    30%
  </span>
  <span class="absValue">
    (3/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    36.1%
  </span>
  <span class="absValue">
    (13/36)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter</td>
<td class="coverageStat">
  <span class="percent">
    87.5%
  </span>
  <span class="absValue">
    (7/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$OfConstructor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$OfLegacyVmConstructor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$OfLegacyVmMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/7)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/13)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$OfMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$Parameter</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$ParameterAnnotationSource</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$ParameterAnnotationSource$ForLoadedConstructor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$ForLoadedParameter$ParameterAnnotationSource$ForLoadedMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    50%
  </span>
  <span class="absValue">
    (1/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (10/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    78.6%
  </span>
  <span class="absValue">
    (22/28)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    69.2%
  </span>
  <span class="absValue">
    (9/13)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    46.7%
  </span>
  <span class="absValue">
    (14/30)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$Token$TypeList</td>
<td class="coverageStat">
  <span class="percent">
    66.7%
  </span>
  <span class="absValue">
    (2/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (3/4)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    45.5%
  </span>
  <span class="absValue">
    (5/11)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    57.1%
  </span>
  <span class="absValue">
    (8/14)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    48.2%
  </span>
  <span class="absValue">
    (41/85)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42%
  </span>
  <span class="absValue">
    (76/181)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.build.HashCodeAndEqualsPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.NamedElement;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationSource;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.implementation.bytecode.StackSize;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.AccessibleObject;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.lang.reflect.Modifier;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.AbstractList;
&nbsp;import java.util.Collections;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Description of the parameter of a Java method or constructor.
&nbsp; */
&nbsp;public interface ParameterDescription extends AnnotationSource,
&nbsp;        NamedElement.WithRuntimeName,
&nbsp;        NamedElement.WithOptionalName,
&nbsp;        ModifierReviewable.ForParameterDescription,
&nbsp;        ByteCodeElement.TypeDependant&lt;ParameterDescription.InDefinedShape, ParameterDescription.Token&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * The prefix for names of an unnamed parameter.
&nbsp;     */
&nbsp;    String NAME_PREFIX = &quot;arg&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the type of this parameter.
&nbsp;     *
&nbsp;     * @return The type of this parameter.
&nbsp;     */
&nbsp;    TypeDescription.Generic getType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the method that declares this parameter.
&nbsp;     *
&nbsp;     * @return The method that declares this parameter.
&nbsp;     */
&nbsp;    MethodDescription getDeclaringMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this parameter&#39;s index.
&nbsp;     *
&nbsp;     * @return The index of this parameter.
&nbsp;     */
&nbsp;    int getIndex();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this parameter has an explicit modifier. A parameter without a modifier is simply treated as
&nbsp;     * if it had a modifier of zero.
&nbsp;     *
&nbsp;     * @return {@code true} if this parameter defines explicit modifiers.
&nbsp;     */
&nbsp;    boolean hasModifiers();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the offset to the parameter value within the local method variable.
&nbsp;     *
&nbsp;     * @return The offset of this parameter&#39;s value.
&nbsp;     */
&nbsp;    int getOffset();
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a parameter description in its generic shape, i.e. in the shape it is defined by a generic or raw type.
&nbsp;     */
&nbsp;    interface InGenericShape extends ParameterDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        MethodDescription.InGenericShape getDeclaringMethod();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a parameter in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
&nbsp;     */
&nbsp;    interface InDefinedShape extends ParameterDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        MethodDescription.InDefinedShape getDeclaringMethod();
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a parameter description in its defined shape.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends ParameterDescription.AbstractBase implements InDefinedShape {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InDefinedShape asDefined() {
<b class="nc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A base implementation of a method parameter description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends ModifierReviewable.AbstractBase implements ParameterDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return NAME_PREFIX.concat(String.valueOf(getIndex()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="nc">&nbsp;            return getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getActualName() {
<b class="nc">&nbsp;            return isNamed()</b>
<b class="nc">&nbsp;                    ? getName()</b>
<b class="nc">&nbsp;                    : EMPTY_NAME;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="nc">&nbsp;            return EMPTY_MASK;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;offset&quot;)
&nbsp;        public int getOffset() {
<b class="fc">&nbsp;            TypeList parameterType = getDeclaringMethod().getParameters().asTypeList().asErasures();</b>
<b class="fc">&nbsp;            int offset = getDeclaringMethod().isStatic()</b>
<b class="nc">&nbsp;                    ? StackSize.ZERO.getSize()</b>
<b class="fc">&nbsp;                    : StackSize.SINGLE.getSize();</b>
<b class="fc">&nbsp;            for (int i = 0; i &lt; getIndex(); i++) {</b>
<b class="fc">&nbsp;                offset += parameterType.get(i).getStackSize().getSize();</b>
&nbsp;            }
<b class="fc">&nbsp;            return offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            return new Token(getType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getDeclaredAnnotations(),</b>
<b class="fc">&nbsp;                    isNamed()</b>
<b class="nc">&nbsp;                            ? getName()</b>
<b class="fc">&nbsp;                            : Token.NO_NAME,</b>
<b class="fc">&nbsp;                    hasModifiers()</b>
<b class="nc">&nbsp;                            ? (Integer) getModifiers()</b>
<b class="fc">&nbsp;                            : Token.NO_MODIFIERS);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            return getDeclaringMethod().hashCode() ^ getIndex();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof ParameterDescription)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            ParameterDescription parameterDescription = (ParameterDescription) other;</b>
<b class="nc">&nbsp;            return getDeclaringMethod().equals(parameterDescription.getDeclaringMethod()) &amp;&amp; getIndex() == parameterDescription.getIndex();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder(Modifier.toString(getModifiers()));</b>
<b class="nc">&nbsp;            if (getModifiers() != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            stringBuilder.append(isVarArgs()</b>
<b class="nc">&nbsp;                    ? getType().asErasure().getName().replaceFirst(&quot;\\[]$&quot;, &quot;...&quot;)</b>
<b class="nc">&nbsp;                    : getType().asErasure().getName());</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39; &#39;).append(getName()).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Description of a loaded parameter with support for the information exposed by {@code java.lang.reflect.Parameter}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the {@code java.lang.reflect.Executable} that this list represents.
&nbsp;     */
&nbsp;    abstract class ForLoadedParameter&lt;T extends AccessibleObject&gt; extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for reading properties from {@code java.lang.reflect.Parameter} instances.
&nbsp;         */
<b class="fc">&nbsp;        private static final Parameter PARAMETER = doPrivileged(JavaDispatcher.of(Parameter.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The {@code java.lang.reflect.Executable} for which the parameter types are described.
&nbsp;         */
&nbsp;        protected final T executable;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter&#39;s index.
&nbsp;         */
&nbsp;        protected final int index;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter annotation source to query.
&nbsp;         */
&nbsp;        protected final ParameterAnnotationSource parameterAnnotationSource;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description for a loaded parameter.
&nbsp;         *
&nbsp;         * @param executable                The {@code java.lang.reflect.Executable} for which the parameter types are described.
&nbsp;         * @param index                     The parameter&#39;s index.
&nbsp;         * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;         */
<b class="fc">&nbsp;        protected ForLoadedParameter(T executable, int index, ParameterAnnotationSource parameterAnnotationSource) {</b>
<b class="fc">&nbsp;            this.executable = executable;</b>
<b class="fc">&nbsp;            this.index = index;</b>
<b class="fc">&nbsp;            this.parameterAnnotationSource = parameterAnnotationSource;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return PARAMETER.getName(ParameterList.ForLoadedExecutable.EXECUTABLE.getParameters(executable)[index]);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getIndex() {
<b class="fc">&nbsp;            return index;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNamed() {
<b class="fc">&nbsp;            return PARAMETER.isNamePresent(ParameterList.ForLoadedExecutable.EXECUTABLE.getParameters(executable)[index]);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return PARAMETER.getModifiers(ParameterList.ForLoadedExecutable.EXECUTABLE.getParameters(executable)[index]);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasModifiers() {
&nbsp;            // Rational: If a parameter is not named despite the information being attached,
&nbsp;            // it is synthetic, i.e. it has non-default modifiers.
<b class="fc">&nbsp;            return isNamed() || getModifiers() != EMPTY_MASK;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A source for querying parameter annotations.
&nbsp;         */
&nbsp;        public interface ParameterAnnotationSource {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the parameter annotations represented by this source.
&nbsp;             *
&nbsp;             * @return The parameter annotations as an array indexed by parameter index.
&nbsp;             */
&nbsp;            Annotation[][] getParameterAnnotations();
&nbsp;
&nbsp;            /**
&nbsp;             * A source for a loaded constructor.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForLoadedConstructor implements ParameterAnnotationSource {
&nbsp;
&nbsp;                /**
&nbsp;                 * The constructor to query for annotations.
&nbsp;                 */
&nbsp;                private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new parameter annotation source for a constructor.
&nbsp;                 *
&nbsp;                 * @param constructor The constructor to query for annotations.
&nbsp;                 */
<b class="nc">&nbsp;                public ForLoadedConstructor(Constructor&lt;?&gt; constructor) {</b>
<b class="nc">&nbsp;                    this.constructor = constructor;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Annotation[][] getParameterAnnotations() {
<b class="nc">&nbsp;                    return constructor.getParameterAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A source for a loaded method.
&nbsp;             */
&nbsp;            @HashCodeAndEqualsPlugin.Enhance
&nbsp;            class ForLoadedMethod implements ParameterAnnotationSource {
&nbsp;
&nbsp;                /**
&nbsp;                 * The method to query for annotations.
&nbsp;                 */
&nbsp;                private final Method method;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new parameter annpotation source for a method.
&nbsp;                 *
&nbsp;                 * @param method The method to query for annotations.
&nbsp;                 */
<b class="nc">&nbsp;                public ForLoadedMethod(Method method) {</b>
<b class="nc">&nbsp;                    this.method = method;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public Annotation[][] getParameterAnnotations() {
<b class="nc">&nbsp;                    return method.getParameterAnnotations();</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for a {@code java.lang.reflect.Parameter}.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.reflect.Parameter&quot;)
&nbsp;        protected interface Parameter {
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the given parameter&#39;s modifiers.
&nbsp;             *
&nbsp;             * @param value The parameter to introspect.
&nbsp;             * @return The parameter&#39;s modifiers.
&nbsp;             */
&nbsp;            int getModifiers(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns {@code true} if the given parameter has an explicit name.
&nbsp;             *
&nbsp;             * @param value The parameter to introspect.
&nbsp;             * @return {@code true} if the given parameter has an explicit name.
&nbsp;             */
&nbsp;            boolean isNamePresent(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the given parameter&#39;s implicit or explicit name.
&nbsp;             *
&nbsp;             * @param value The parameter to introspect.
&nbsp;             * @return The parameter&#39;s name.
&nbsp;             */
&nbsp;            String getName(Object value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of a loaded {@link Method} parameter for a modern VM.
&nbsp;         */
&nbsp;        protected static class OfMethod extends ForLoadedParameter&lt;Method&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description for a loaded method.
&nbsp;             *
&nbsp;             * @param method                    The method for which a parameter is represented.
&nbsp;             * @param index                     The index of the parameter.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
&nbsp;            protected OfMethod(Method method, int index, ParameterAnnotationSource parameterAnnotationSource) {
<b class="fc">&nbsp;                super(method, index, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs.&quot;)
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="fc">&nbsp;                return new MethodDescription.ForLoadedMethod(executable);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs.&quot;)
&nbsp;            public TypeDescription.Generic getType() {
<b class="fc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(executable.getParameterTypes()[index]);</b>
&nbsp;                }
<b class="fc">&nbsp;                return new TypeDescription.Generic.LazyProjection.OfMethodParameter(executable, index, executable.getParameterTypes());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs.&quot;)
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                return new AnnotationList.ForLoadedAnnotations(parameterAnnotationSource.getParameterAnnotations()[index]);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A description of a loaded {@link Constructor} parameter for a modern VM.
&nbsp;         */
&nbsp;        protected static class OfConstructor extends ForLoadedParameter&lt;Constructor&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description for a loaded constructor.
&nbsp;             *
&nbsp;             * @param constructor               The constructor for which a parameter is represented.
&nbsp;             * @param index                     The index of the parameter.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
&nbsp;            protected OfConstructor(Constructor&lt;?&gt; constructor, int index, ParameterAnnotationSource parameterAnnotationSource) {
<b class="nc">&nbsp;                super(constructor, index, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs.&quot;)
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="nc">&nbsp;                return new MethodDescription.ForLoadedConstructor(executable);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs.&quot;)
&nbsp;            public TypeDescription.Generic getType() {
<b class="nc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(executable.getParameterTypes()[index]);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new TypeDescription.Generic.LazyProjection.OfConstructorParameter(executable, index, executable.getParameterTypes());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @SuppressFBWarnings(value = &quot;BC_UNCONFIRMED_CAST&quot;, justification = &quot;The implicit field type casting is not understood by Findbugs&quot;)
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                Annotation[][] annotation = parameterAnnotationSource.getParameterAnnotations();</b>
<b class="nc">&nbsp;                MethodDescription.InDefinedShape declaringMethod = getDeclaringMethod();</b>
<b class="nc">&nbsp;                if (annotation.length != declaringMethod.getParameters().size() &amp;&amp; declaringMethod.getDeclaringType().isInnerClass()) {</b>
<b class="nc">&nbsp;                    return index == 0</b>
<b class="nc">&nbsp;                            ? new AnnotationList.Empty()</b>
<b class="nc">&nbsp;                            : new AnnotationList.ForLoadedAnnotations(annotation[index - 1]);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new AnnotationList.ForLoadedAnnotations(annotation[index]);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Description of a loaded method&#39;s parameter on a virtual machine where {@code java.lang.reflect.Parameter}
&nbsp;         * is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmMethod extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The method that declares this parameter.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * The index of this parameter.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * The type erasures of the represented method.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter annotation source to query.
&nbsp;             */
&nbsp;            private final ParameterAnnotationSource parameterAnnotationSource;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a method&#39;s parameter.
&nbsp;             *
&nbsp;             * @param method                    The method that declares this parameter.
&nbsp;             * @param index                     The index of this parameter.
&nbsp;             * @param parameterType             The type erasures of the represented method.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
<b class="nc">&nbsp;            protected OfLegacyVmMethod(Method method, int index, Class&lt;?&gt;[] parameterType, ParameterAnnotationSource parameterAnnotationSource) {</b>
<b class="nc">&nbsp;                this.method = method;</b>
<b class="nc">&nbsp;                this.index = index;</b>
<b class="nc">&nbsp;                this.parameterType = parameterType;</b>
<b class="nc">&nbsp;                this.parameterAnnotationSource = parameterAnnotationSource;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription.Generic getType() {
<b class="nc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(parameterType[index]);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new TypeDescription.Generic.LazyProjection.OfMethodParameter(method, index, parameterType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="nc">&nbsp;                return new MethodDescription.ForLoadedMethod(method);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getIndex() {
<b class="nc">&nbsp;                return index;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isNamed() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean hasModifiers() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                return new AnnotationList.ForLoadedAnnotations(parameterAnnotationSource.getParameterAnnotations()[index]);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Description of a loaded constructor&#39;s parameter on a virtual machine where {@code java.lang.reflect.Parameter}
&nbsp;         * is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmConstructor extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The method that declares this parameter.
&nbsp;             */
&nbsp;            private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;            /**
&nbsp;             * The index of this parameter.
&nbsp;             */
&nbsp;            private final int index;
&nbsp;
&nbsp;            /**
&nbsp;             * The type erasures of the represented method.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter annotation source to query.
&nbsp;             */
&nbsp;            private final ParameterAnnotationSource parameterAnnotationSource;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a method&#39;s parameter.
&nbsp;             *
&nbsp;             * @param constructor               The constructor that declares this parameter.
&nbsp;             * @param index                     The index of this parameter.
&nbsp;             * @param parameterType             The type erasures of the represented method.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
<b class="nc">&nbsp;            protected OfLegacyVmConstructor(Constructor&lt;?&gt; constructor, int index, Class&lt;?&gt;[] parameterType, ParameterAnnotationSource parameterAnnotationSource) {</b>
<b class="nc">&nbsp;                this.constructor = constructor;</b>
<b class="nc">&nbsp;                this.index = index;</b>
<b class="nc">&nbsp;                this.parameterType = parameterType;</b>
<b class="nc">&nbsp;                this.parameterAnnotationSource = parameterAnnotationSource;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription.Generic getType() {
<b class="nc">&nbsp;                if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                    return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(parameterType[index]);</b>
&nbsp;                }
<b class="nc">&nbsp;                return new TypeDescription.Generic.LazyProjection.OfConstructorParameter(constructor, index, parameterType);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="nc">&nbsp;                return new MethodDescription.ForLoadedConstructor(constructor);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getIndex() {
<b class="nc">&nbsp;                return index;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean isNamed() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public boolean hasModifiers() {
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;                MethodDescription.InDefinedShape declaringMethod = getDeclaringMethod();</b>
<b class="nc">&nbsp;                Annotation[][] parameterAnnotation = parameterAnnotationSource.getParameterAnnotations();</b>
<b class="nc">&nbsp;                if (parameterAnnotation.length != declaringMethod.getParameters().size() &amp;&amp; declaringMethod.getDeclaringType().isInnerClass()) {</b>
<b class="nc">&nbsp;                    return index == 0</b>
<b class="nc">&nbsp;                            ? new AnnotationList.Empty()</b>
<b class="nc">&nbsp;                            : new AnnotationList.ForLoadedAnnotations(parameterAnnotation[index - 1]);</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return new AnnotationList.ForLoadedAnnotations(parameterAnnotation[index]);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent description of a parameter that is not attached to a method or constructor.
&nbsp;     */
&nbsp;    class Latent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is declaring the parameter.
&nbsp;         */
&nbsp;        private final MethodDescription.InDefinedShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the parameter.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic parameterType;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of the parameter.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the parameter or {@code null} if no name is explicitly defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the parameter or {@code null} if no modifiers are explicitly defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final Integer modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * The index of the parameter.
&nbsp;         */
&nbsp;        private final int index;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter&#39;s offset in the local method variables array.
&nbsp;         */
&nbsp;        private final int offset;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a latent parameter description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringMethod The method that is declaring the parameter.
&nbsp;         * @param token           The token describing the shape of the parameter.
&nbsp;         * @param index           The index of the parameter.
&nbsp;         * @param offset          The parameter&#39;s offset in the local method variables array.
&nbsp;         */
&nbsp;        public Latent(MethodDescription.InDefinedShape declaringMethod, Token token, int index, int offset) {
<b class="fc">&nbsp;            this(declaringMethod,</b>
<b class="fc">&nbsp;                    token.getType(),</b>
<b class="fc">&nbsp;                    token.getAnnotations(),</b>
<b class="fc">&nbsp;                    token.getName(),</b>
<b class="fc">&nbsp;                    token.getModifiers(),</b>
&nbsp;                    index,
&nbsp;                    offset);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent parameter descriptions for a parameter without explicit meta data or annotations.
&nbsp;         *
&nbsp;         * @param declaringMethod The method declaring this parameter.
&nbsp;         * @param parameterType   The type of the parameter.
&nbsp;         * @param index           The index of the parameter.
&nbsp;         * @param offset          The offset of the parameter.
&nbsp;         */
&nbsp;        public Latent(MethodDescription.InDefinedShape declaringMethod,
&nbsp;                      TypeDescription.Generic parameterType,
&nbsp;                      int index,
&nbsp;                      int offset) {
<b class="fc">&nbsp;            this(declaringMethod,</b>
&nbsp;                    parameterType,
<b class="fc">&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                    Token.NO_NAME,
&nbsp;                    Token.NO_MODIFIERS,
&nbsp;                    index,
&nbsp;                    offset);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a latent parameter description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringMethod     The method that is declaring the parameter.
&nbsp;         * @param parameterType       The parameter&#39;s type.
&nbsp;         * @param declaredAnnotations The annotations of the parameter.
&nbsp;         * @param name                The name of the parameter or {@code null} if no name is explicitly defined.
&nbsp;         * @param modifiers           The modifiers of the parameter or {@code null} if no modifiers are explicitly defined.
&nbsp;         * @param index               The index of the parameter.
&nbsp;         * @param offset              The parameter&#39;s offset in the local method variables array.
&nbsp;         */
&nbsp;        public Latent(MethodDescription.InDefinedShape declaringMethod,
&nbsp;                      TypeDescription.Generic parameterType,
&nbsp;                      List&lt;? extends AnnotationDescription&gt; declaredAnnotations,
&nbsp;                      @MaybeNull String name,
&nbsp;                      @MaybeNull Integer modifiers,
&nbsp;                      int index,
<b class="fc">&nbsp;                      int offset) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.parameterType = parameterType;</b>
<b class="fc">&nbsp;            this.declaredAnnotations = declaredAnnotations;</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.index = index;</b>
<b class="fc">&nbsp;            this.offset = offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return parameterType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDescription.InDefinedShape getDeclaringMethod() {
<b class="fc">&nbsp;            return declaringMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getIndex() {
<b class="fc">&nbsp;            return index;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getOffset() {
<b class="fc">&nbsp;            return offset;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNamed() {
<b class="fc">&nbsp;            return name != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasModifiers() {
<b class="fc">&nbsp;            return modifiers != null;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return name == null</b>
<b class="nc">&nbsp;                    ? super.getName()</b>
<b class="nc">&nbsp;                    : name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="nc">&nbsp;            return modifiers == null</b>
<b class="nc">&nbsp;                    ? super.getModifiers()</b>
<b class="nc">&nbsp;                    : modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(declaredAnnotations);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * &lt;p&gt;
&nbsp;     * A parameter description that represents a given parameter but with a substituted parameter type.
&nbsp;     * &lt;/p&gt;
&nbsp;     * &lt;p&gt;
&nbsp;     * &lt;b&gt;Note&lt;/b&gt;: The supplied visitor must assure to not substitute
&nbsp;     * &lt;/p&gt;
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that declares this type-substituted parameter.
&nbsp;         */
&nbsp;        private final MethodDescription.InGenericShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented parameter.
&nbsp;         */
&nbsp;        private final ParameterDescription parameterDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that is applied to the parameter type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type substituting parameter.
&nbsp;         *
&nbsp;         * @param declaringMethod      The method that declares this type-substituted parameter.
&nbsp;         * @param parameterDescription The represented parameter.
&nbsp;         * @param visitor              A visitor that is applied to the parameter type.
&nbsp;         */
&nbsp;        public TypeSubstituting(MethodDescription.InGenericShape declaringMethod,
&nbsp;                                ParameterDescription parameterDescription,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.parameterDescription = parameterDescription;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return parameterDescription.getType().accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDescription.InGenericShape getDeclaringMethod() {
<b class="nc">&nbsp;            return declaringMethod;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getIndex() {
<b class="fc">&nbsp;            return parameterDescription.getIndex();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isNamed() {
<b class="fc">&nbsp;            return parameterDescription.isNamed();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasModifiers() {
<b class="nc">&nbsp;            return parameterDescription.hasModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getOffset() {
<b class="fc">&nbsp;            return parameterDescription.getOffset();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="nc">&nbsp;            return parameterDescription.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="nc">&nbsp;            return parameterDescription.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="nc">&nbsp;            return parameterDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InDefinedShape asDefined() {
<b class="nc">&nbsp;            return parameterDescription.asDefined();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a parameter&#39;s properties detached from a type.
&nbsp;     */
&nbsp;    class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * Indicator for a method parameter without an explicit name.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        public static final String NO_NAME = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * Indicator for a method parameter without explicit modifiers.
&nbsp;         */
&nbsp;        @AlwaysNull
<b class="fc">&nbsp;        public static final Integer NO_MODIFIERS = null;</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The type of the represented parameter.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic type;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of parameter annotations.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final Integer modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter token without an explicit name, an explicit modifier or annotations.
&nbsp;         * The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type The type of the represented parameter.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type) {
<b class="fc">&nbsp;            this(type, Collections.&lt;AnnotationDescription&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter token without an explicit name or an explicit modifier. The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type        The type of the represented parameter.
&nbsp;         * @param annotations The annotations of the parameter.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type, List&lt;? extends AnnotationDescription&gt; annotations) {
<b class="fc">&nbsp;            this(type, annotations, NO_NAME, NO_MODIFIERS);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a parameter token without annotations. The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type      The type of the represented parameter.
&nbsp;         * @param name      The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         * @param modifiers The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type, @MaybeNull String name, @MaybeNull Integer modifiers) {
<b class="nc">&nbsp;            this(type, Collections.&lt;AnnotationDescription&gt;emptyList(), name, modifiers);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter token. The parameter type must be represented in its detached format.
&nbsp;         *
&nbsp;         * @param type        The type of the represented parameter.
&nbsp;         * @param annotations The annotations of the parameter.
&nbsp;         * @param name        The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         * @param modifiers   The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        public Token(TypeDescription.Generic type,
&nbsp;                     List&lt;? extends AnnotationDescription&gt; annotations,
&nbsp;                     @MaybeNull String name,
<b class="fc">&nbsp;                     @MaybeNull Integer modifiers) {</b>
<b class="fc">&nbsp;            this.type = type;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The type of the represented method parameter.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getType() {
<b class="fc">&nbsp;            return type;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the annotations of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The annotations of the represented method parameter.
&nbsp;         */
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the name of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The name of the parameter or {@code null} if no explicit name is defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the modifiers of the represented method parameter.
&nbsp;         *
&nbsp;         * @return The modifiers of the parameter or {@code null} if no explicit modifiers is defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public Integer getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(type.accept(visitor),</b>
&nbsp;                    annotations,
&nbsp;                    name,
&nbsp;                    modifiers);
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = type.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + annotations.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + (name != null ? name.hashCode() : 0);</b>
<b class="nc">&nbsp;            result = 31 * result + (modifiers != null ? modifiers.hashCode() : 0);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="nc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="nc">&nbsp;            } else if (!(other instanceof Token)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="nc">&nbsp;            Token token = (Token) other;</b>
<b class="nc">&nbsp;            return type.equals(token.type)</b>
<b class="nc">&nbsp;                    &amp;&amp; annotations.equals(token.annotations)</b>
<b class="nc">&nbsp;                    &amp;&amp; (name != null ? name.equals(token.name) : token.name == null)</b>
<b class="nc">&nbsp;                    &amp;&amp; (modifiers != null ? modifiers.equals(token.modifiers) : token.modifiers == null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;ParameterDescription.Token{&quot; +</b>
&nbsp;                    &quot;type=&quot; + type +
&nbsp;                    &quot;, annotations=&quot; + annotations +
&nbsp;                    &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
&nbsp;                    &quot;, modifiers=&quot; + modifiers +
&nbsp;                    &#39;}&#39;;
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A list of types represented as a list of parameter tokens.
&nbsp;         */
&nbsp;        public static class TypeList extends AbstractList&lt;Token&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The list of types to represent as parameter tokens.
&nbsp;             */
&nbsp;            private final List&lt;? extends TypeDefinition&gt; typeDescriptions;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new list of types that represent parameters.
&nbsp;             *
&nbsp;             * @param typeDescriptions The types to represent.
&nbsp;             */
<b class="fc">&nbsp;            public TypeList(List&lt;? extends TypeDefinition&gt; typeDescriptions) {</b>
<b class="fc">&nbsp;                this.typeDescriptions = typeDescriptions;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public Token get(int index) {
<b class="nc">&nbsp;                return new Token(typeDescriptions.get(index).asGenericType());</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int size() {
<b class="fc">&nbsp;                return typeDescriptions.size();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 10:47</div>
</div>
</body>
</html>
