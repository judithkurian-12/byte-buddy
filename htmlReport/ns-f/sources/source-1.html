


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > MethodDescription</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: MethodDescription (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">MethodDescription</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
</tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    93.2%
  </span>
  <span class="absValue">
    (41/44)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.8%
  </span>
  <span class="absValue">
    (247/272)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$04HJHJxQ</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$0dhacocu</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$0nn1Iq9M</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$1vxGHlJt</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$6fA6GDAD</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$6qHHymQN</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$7bhUC2Jr</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$9KHD4zcj</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$9oTrEnyz</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$bZVHC2MZ</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$C8A2Jv4U</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$CanqMJYr</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$dBD6vdLY</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$dn1vPBBE</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$dq24zYmB</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$DQSkxNM2</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$dYv7FXsV</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$eclmla3j</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$eIVElfrw</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$elVM0VIv</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$f0duK15I</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$FKTM3Str</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$fZmdP2hM</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$gf0LRX0a</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$GLIDP7qx</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$gP3yzH64</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$gQheqtSM</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$GQXWLGTO</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$gtlMuj9V</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$GvlaQmlk</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$I5KGOZhk</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$iF17yVfd</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$Ih5Zp4er</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$Ik2rGHFj</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$IrSVrmqY</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$J2eCX6p6</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$jceqvOiN</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$jEumYcZ2</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$jjFmWbze</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$JoZ8tJjb</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$kKPKm7su</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$ME3SAwyW</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$MnYizR4q</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$OKe0HluC</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$p6KQhCrh</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$QezgLTAd</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$qMdWVc8G</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$QrySUgu9</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$QxfSZIZA</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$R6kTMAmU</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$rPhhQGjn</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$s4wg15IA</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$tActaU78</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$ulIxbksu</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$Un2jMylZ</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$vDVLGnXc</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$vRaIWamy</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$Wh7ei1zc</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$Xew7JIzC</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$xh4pCHR1</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$XK09oabm</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$xqPDe1IU</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$XYRMbURS</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$XzjRCZej</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$Y6HIyC13</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$YaN3Vqij</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$ygBdnSOh</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$yPv3PTSc</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$zHColGPL</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$zsKI9sul</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$zVawjrUT</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$AbstractBase$MockitoMock$711141147$auxiliary$zWNa9XvC</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (18/18)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$ForLoadedMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (20/20)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    89.7%
  </span>
  <span class="absValue">
    (26/29)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase$Executable</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$AbstractBase$ForLoadedExecutable</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (8/8)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$MockitoMock$1700100065</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$MockitoMock$1700100065$auxiliary$IocHeeIj</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InDefinedShape$MockitoMock$1700100065$auxiliary$TbdTryFR</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InGenericShape</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InGenericShape$MockitoMock$1487989318</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InGenericShape$MockitoMock$1487989318$auxiliary$af24g5QE</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$InGenericShape$MockitoMock$1487989318$auxiliary$reGO4K0q</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (12/12)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (33/33)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Latent$TypeInitializer</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    90.9%
  </span>
  <span class="absValue">
    (10/11)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$MockitoMock$787590321</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$MockitoMock$787590321$auxiliary$sGTPLR3I</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$MockitoMock$787590321$auxiliary$uxMYW22A</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken</td>
<td class="coverageStat">
  <span class="percent">
    90%
  </span>
  <span class="absValue">
    (9/10)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    68.6%
  </span>
  <span class="absValue">
    (24/35)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$1hNlTB66</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$51nblQ31</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$hF2jhLRz</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$NxbektLE</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$PkJMKrJk</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$suSx1Fh2</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$SignatureToken$MockitoMock$1659317321$auxiliary$zpRHut82</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token</td>
<td class="coverageStat">
  <span class="percent">
    88.9%
  </span>
  <span class="absValue">
    (16/18)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    79.7%
  </span>
  <span class="absValue">
    (51/64)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$2HRjpL3n</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$564SHeuO</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$8skSIhTr</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$c7v0Ix32</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$FwSIOsVs</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$gZ7E4cuv</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$ID68Ih3U</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$IV5LS1uA</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$LYJ18PUJ</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$pOVR99m8</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$SLKwpd7x</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$uZMbs1ae</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$Token$MockitoMock$1657921757$auxiliary$vH7sIojg</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (15/15)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    95.2%
  </span>
  <span class="absValue">
    (20/21)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken</td>
<td class="coverageStat">
  <span class="percent">
    83.3%
  </span>
  <span class="absValue">
    (5/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    63.2%
  </span>
  <span class="absValue">
    (12/19)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken$MockitoMock$1246284000</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken$MockitoMock$1246284000$auxiliary$hqyoHZGy</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken$MockitoMock$1246284000$auxiliary$P1ORKjkd</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken$MockitoMock$1246284000$auxiliary$uKT3ARV0</td>
  </tr>
  <tr>
    <td class="name">MethodDescription$TypeToken$MockitoMock$1246284000$auxiliary$vhN8883y</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    95%
  </span>
  <span class="absValue">
    (153/161)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    88.3%
  </span>
  <span class="absValue">
    (462/523)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.build.CachedReturnPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.DeclaredByType;
&nbsp;import net.bytebuddy.description.ModifierReviewable;
&nbsp;import net.bytebuddy.description.TypeVariableSource;
&nbsp;import net.bytebuddy.description.annotation.AnnotationDescription;
&nbsp;import net.bytebuddy.description.annotation.AnnotationList;
&nbsp;import net.bytebuddy.description.annotation.AnnotationValue;
&nbsp;import net.bytebuddy.description.enumeration.EnumerationDescription;
&nbsp;import net.bytebuddy.description.modifier.ModifierContributor;
&nbsp;import net.bytebuddy.description.modifier.Visibility;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.description.type.TypeVariableToken;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.ElementMatchers;
&nbsp;import net.bytebuddy.utility.JavaType;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;import net.bytebuddy.utility.nullability.AlwaysNull;
&nbsp;import net.bytebuddy.utility.nullability.MaybeNull;
&nbsp;import org.objectweb.asm.Opcodes;
&nbsp;import org.objectweb.asm.Type;
&nbsp;import org.objectweb.asm.signature.SignatureWriter;
&nbsp;
&nbsp;import javax.annotation.Nonnull;
&nbsp;import java.lang.annotation.Annotation;
&nbsp;import java.lang.reflect.*;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.*;
&nbsp;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.not;
&nbsp;import static net.bytebuddy.matcher.ElementMatchers.ofSort;
&nbsp;
&nbsp;/**
&nbsp; * Implementations of this interface describe a Java method, i.e. a method or a constructor. Implementations of this
&nbsp; * interface must provide meaningful {@code equal(Object)} and {@code hashCode()} implementations.
&nbsp; */
&nbsp;public interface MethodDescription extends TypeVariableSource,
&nbsp;        ModifierReviewable.ForMethodDescription,
&nbsp;        DeclaredByType.WithMandatoryDeclaration,
&nbsp;        ByteCodeElement.Member,
&nbsp;        ByteCodeElement.TypeDependant&lt;MethodDescription.InDefinedShape, MethodDescription.Token&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * The internal name of a Java constructor.
&nbsp;     */
&nbsp;    String CONSTRUCTOR_INTERNAL_NAME = &quot;&lt;init&gt;&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The internal name of a Java static initializer.
&nbsp;     */
&nbsp;    String TYPE_INITIALIZER_INTERNAL_NAME = &quot;&lt;clinit&gt;&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * The type initializer of any representation of a type initializer.
&nbsp;     */
&nbsp;    int TYPE_INITIALIZER_MODIFIER = Opcodes.ACC_STATIC;
&nbsp;
&nbsp;    /**
&nbsp;     * Represents any undefined property of a type description that is instead represented as {@code null} in order
&nbsp;     * to resemble the Java reflection API which returns {@code null} and is intuitive to many Java developers.
&nbsp;     */
&nbsp;    @AlwaysNull
<b class="fc">&nbsp;    InDefinedShape UNDEFINED = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * {@inheritDoc}
&nbsp;     */
&nbsp;    @Nonnull
&nbsp;    TypeDefinition getDeclaringType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the return type of the described method.
&nbsp;     *
&nbsp;     * @return The return type of the described method.
&nbsp;     */
&nbsp;    TypeDescription.Generic getReturnType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a list of this method&#39;s parameters.
&nbsp;     *
&nbsp;     * @return A list of this method&#39;s parameters.
&nbsp;     */
&nbsp;    ParameterList&lt;?&gt; getParameters();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the exception types of the described method.
&nbsp;     *
&nbsp;     * @return The exception types of the described method.
&nbsp;     */
&nbsp;    TypeList.Generic getExceptionTypes();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this method&#39;s actual modifiers as it is present in a class file, i.e. includes a flag if this method
&nbsp;     * is marked {@link Deprecated}.
&nbsp;     *
&nbsp;     * @return The method&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this method&#39;s actual modifiers as it is present in a class file, i.e. includes a flag if this method
&nbsp;     * is marked {@link Deprecated} and adjusts the modifiers for being abstract or not.
&nbsp;     *
&nbsp;     * @param manifest {@code true} if the method should be treated as non-abstract.
&nbsp;     * @return The method&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers(boolean manifest);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this method&#39;s actual modifiers as it is present in a class file, i.e. includes a flag if this method
&nbsp;     * is marked {@link Deprecated} and adjusts the modifiers for being abstract or not. Additionally, this method
&nbsp;     * resolves a required minimal visibility.
&nbsp;     *
&nbsp;     * @param manifest   {@code true} if the method should be treated as non-abstract.
&nbsp;     * @param visibility The minimal visibility to enforce for this method.
&nbsp;     * @return The method&#39;s actual modifiers.
&nbsp;     */
&nbsp;    int getActualModifiers(boolean manifest, Visibility visibility);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method description represents a constructor.
&nbsp;     *
&nbsp;     * @return {@code true} if this method description represents a constructor.
&nbsp;     */
&nbsp;    boolean isConstructor();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method description represents a method, i.e. not a constructor or a type initializer.
&nbsp;     *
&nbsp;     * @return {@code true} if this method description represents a Java method.
&nbsp;     */
&nbsp;    boolean isMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is a type initializer.
&nbsp;     *
&nbsp;     * @return {@code true} if this method description represents a type initializer.
&nbsp;     */
&nbsp;    boolean isTypeInitializer();
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies if a method description represents a given loaded method.
&nbsp;     *
&nbsp;     * @param method The method to be checked.
&nbsp;     * @return {@code true} if this method description represents the given loaded method.
&nbsp;     */
&nbsp;    boolean represents(Method method);
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies if a method description represents a given loaded constructor.
&nbsp;     *
&nbsp;     * @param constructor The constructor to be checked.
&nbsp;     * @return {@code true} if this method description represents the given loaded constructor.
&nbsp;     */
&nbsp;    boolean represents(Constructor&lt;?&gt; constructor);
&nbsp;
&nbsp;    /**
&nbsp;     * Verifies if this method describes a virtual method, i.e. a method that is inherited by a sub type of this type.
&nbsp;     *
&nbsp;     * @return {@code true} if this method is virtual.
&nbsp;     */
&nbsp;    boolean isVirtual();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the size of the local variable array that is required for this method, i.e. the size of all parameters
&nbsp;     * if they were loaded on the stack including a reference to {@code this} if this method represented a non-static
&nbsp;     * method.
&nbsp;     *
&nbsp;     * @return The size of this method on the operand stack.
&nbsp;     */
&nbsp;    int getStackSize();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method represents a default (defender) method.
&nbsp;     *
&nbsp;     * @return {@code true} if this method is a default method.
&nbsp;     */
&nbsp;    boolean isDefaultMethod();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method can be called using the {@code INVOKESPECIAL} for a given type.
&nbsp;     *
&nbsp;     * @param typeDescription The type o
&nbsp;     * @return {@code true} if this method can be called using the {@code INVOKESPECIAL} instruction
&nbsp;     * using the given type.
&nbsp;     */
&nbsp;    boolean isSpecializableFor(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the method&#39;s default annotation value or {@code null} if no default value is defined for this method.
&nbsp;     *
&nbsp;     * @return The method&#39;s default annotation value or {@code null} if no default value is defined for this method.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    AnnotationValue&lt;?, ?&gt; getDefaultValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the default value but casts it to the given type. If the type differs from the value, a
&nbsp;     * {@link java.lang.ClassCastException} is thrown.
&nbsp;     *
&nbsp;     * @param type The type to cast the default value to.
&nbsp;     * @param &lt;T&gt;  The type to cast the default value to.
&nbsp;     * @return The casted default value.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    &lt;T&gt; T getDefaultValue(Class&lt;T&gt; type);
&nbsp;
&nbsp;    /**
&nbsp;     * Asserts if this method is invokable on an instance of the given type, i.e. the method is an instance method or
&nbsp;     * a constructor and the method is visible to the type and can be invoked on the given instance.
&nbsp;     *
&nbsp;     * @param typeDescription The type to check.
&nbsp;     * @return {@code true} if this method is invokable on an instance of the given type.
&nbsp;     */
&nbsp;    boolean isInvokableOn(TypeDescription typeDescription);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is a valid bootstrap method for an invokedynamic call.
&nbsp;     *
&nbsp;     * @return {@code true} if this method is a valid bootstrap method for an invokedynamic call.
&nbsp;     */
&nbsp;    boolean isInvokeBootstrap();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is a valid bootstrap method for an invokedynamic call.
&nbsp;     *
&nbsp;     * @param arguments The types of the explicit arguments that are supplied to the bootstrap method.
&nbsp;     * @return {@code true} if this method is a valid bootstrap method for an &lt;i&gt;invokedynamic&lt;/i&gt; call.
&nbsp;     */
&nbsp;    boolean isInvokeBootstrap(List&lt;? extends TypeDefinition&gt; arguments);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is a valid bootstrap method for an constantdynamic call.
&nbsp;     *
&nbsp;     * @return {@code true} if this method is a valid bootstrap method for an constantdynamic call.
&nbsp;     */
&nbsp;    boolean isConstantBootstrap();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is a valid bootstrap method for a constantdynamic call.
&nbsp;     *
&nbsp;     * @param arguments The types of the explicit arguments that are supplied to the bootstrap method.
&nbsp;     * @return {@code true} if this method is a valid bootstrap method for an &lt;i&gt;constantdynamic&lt;/i&gt; call.
&nbsp;     */
&nbsp;    boolean isConstantBootstrap(List&lt;? extends TypeDefinition&gt; arguments);
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if this method is capable of defining a default annotation value.
&nbsp;     *
&nbsp;     * @return {@code true} if it is possible to define a default annotation value for this method.
&nbsp;     */
&nbsp;    boolean isDefaultValue();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if the given value can describe a default annotation value for this method.
&nbsp;     *
&nbsp;     * @param annotationValue The value that describes the default annotation value for this method.
&nbsp;     * @return {@code true} if the given value can describe a default annotation value for this method.
&nbsp;     */
&nbsp;    boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; annotationValue);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this methods receiver type. A receiver type is undefined for {@code static} methods
&nbsp;     * where {@code null} is returned. Other than a receiver type that is provided by the Java reflection
&nbsp;     * API, Byte Buddy is capable of extracting annotations on type parameters of receiver types when
&nbsp;     * directly accessing a class file. Therefore, a receiver type might be parameterized.
&nbsp;     *
&nbsp;     * @return This method&#39;s (annotated) receiver type.
&nbsp;     */
&nbsp;    @MaybeNull
&nbsp;    TypeDescription.Generic getReceiverType();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a signature token representing this method.
&nbsp;     *
&nbsp;     * @return A signature token representing this method.
&nbsp;     */
&nbsp;    SignatureToken asSignatureToken();
&nbsp;
&nbsp;    /**
&nbsp;     * Returns a type token that represents this method&#39;s raw return and parameter types.
&nbsp;     *
&nbsp;     * @return A type token that represents this method&#39;s raw return and parameter types.
&nbsp;     */
&nbsp;    TypeToken asTypeToken();
&nbsp;
&nbsp;    /**
&nbsp;     * Validates that the supplied type token can implement a bridge method to this method.
&nbsp;     *
&nbsp;     * @param typeToken A type token representing a potential bridge method to this method.
&nbsp;     * @return {@code true} if the supplied type token can represent a bridge method to this method.
&nbsp;     */
&nbsp;    boolean isBridgeCompatible(TypeToken typeToken);
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a method description in its generic shape, i.e. in the shape it is defined by a generic or raw type.
&nbsp;     */
&nbsp;    interface InGenericShape extends MethodDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        TypeDescription.Generic getDeclaringType();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters();
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a method in its defined shape, i.e. in the form it is defined by a class without its type variables being resolved.
&nbsp;     */
&nbsp;    interface InDefinedShape extends MethodDescription {
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        TypeDescription getDeclaringType();
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters();
&nbsp;
&nbsp;        /**
&nbsp;         * An abstract base implementation of a method description in its defined shape.
&nbsp;         */
<b class="fc">&nbsp;        abstract class AbstractBase extends MethodDescription.AbstractBase implements InDefinedShape {</b>
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public InDefinedShape asDefined() {
<b class="fc">&nbsp;                return this;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @MaybeNull
&nbsp;            public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;                if (isStatic()) {</b>
<b class="fc">&nbsp;                    return TypeDescription.Generic.UNDEFINED;</b>
<b class="fc">&nbsp;                } else if (isConstructor()) {</b>
<b class="fc">&nbsp;                    TypeDescription declaringType = getDeclaringType(), enclosingDeclaringType = getDeclaringType().getEnclosingType();</b>
<b class="fc">&nbsp;                    if (enclosingDeclaringType == null) {</b>
<b class="fc">&nbsp;                        return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(declaringType);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        return declaringType.isStatic()</b>
<b class="fc">&nbsp;                                ? enclosingDeclaringType.asGenericType()</b>
<b class="fc">&nbsp;                                : TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(enclosingDeclaringType);</b>
&nbsp;                    }
&nbsp;                } else {
<b class="fc">&nbsp;                    return TypeDescription.Generic.OfParameterizedType.ForGenerifiedErasure.of(getDeclaringType());</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A base implementation for a loaded instance representation for a {@code java.lang.reflect.Executable}.
&nbsp;             *
&nbsp;             * @param &lt;T&gt; The type of the executable.
&nbsp;             */
&nbsp;            protected abstract static class ForLoadedExecutable&lt;T extends AnnotatedElement&gt; extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;                /**
&nbsp;                 * A dispatcher for interacting with {@code java.lang.reflect.Executable}.
&nbsp;                 */
<b class="fc">&nbsp;                protected static final Executable EXECUTABLE = doPrivileged(JavaDispatcher.of(Executable.class));</b>
&nbsp;
&nbsp;                /**
&nbsp;                 * The represented {@code java.lang.reflect.Executable}.
&nbsp;                 */
&nbsp;                protected final T executable;
&nbsp;
&nbsp;                /**
&nbsp;                 * Creates a new method description for a loaded executable.
&nbsp;                 *
&nbsp;                 * @param executable The represented {@code java.lang.reflect.Executable}.
&nbsp;                 */
<b class="fc">&nbsp;                protected ForLoadedExecutable(T executable) {</b>
<b class="fc">&nbsp;                    this.executable = executable;</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;                 *
&nbsp;                 * @param action The action to execute from a privileged context.
&nbsp;                 * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;                 * @return The action&#39;s resolved value.
&nbsp;                 */
&nbsp;                @AccessControllerPlugin.Enhance
&nbsp;                private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;                    return action.run();</b>
&nbsp;                }
&nbsp;
&nbsp;                /**
&nbsp;                 * {@inheritDoc}
&nbsp;                 */
&nbsp;                public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;                    AnnotatedElement element = EXECUTABLE.getAnnotatedReceiverType(executable);</b>
<b class="fc">&nbsp;                    return element == null</b>
<b class="fc">&nbsp;                            ? super.getReceiverType()</b>
<b class="fc">&nbsp;                            : TypeDefinition.Sort.describeAnnotated(element);</b>
&nbsp;                }
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * A proxy type for invoking methods of {@code java.lang.reflect.Executable}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;            protected interface Executable {
&nbsp;
&nbsp;                /**
&nbsp;                 * Returns the annotated receiver type.
&nbsp;                 *
&nbsp;                 * @param value The {@code java.lang.reflect.Executable} to resolve.
&nbsp;                 * @return An instance of {@code java.lang.reflect.AnnotatedType} that represents the receiver of the supplied executable.
&nbsp;                 */
&nbsp;                @MaybeNull
&nbsp;                @JavaDispatcher.Defaults
&nbsp;                AnnotatedElement getAnnotatedReceiverType(Object value);
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An abstract base implementation of a method description.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase extends TypeVariableSource.AbstractBase implements MethodDescription {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * A merger of all method modifiers that are visible in the Java source code.
&nbsp;         */
&nbsp;        private static final int SOURCE_MODIFIERS = Modifier.PUBLIC
&nbsp;                | Modifier.PROTECTED
&nbsp;                | Modifier.PRIVATE
&nbsp;                | Modifier.ABSTRACT
&nbsp;                | Modifier.STATIC
&nbsp;                | Modifier.FINAL
&nbsp;                | Modifier.SYNCHRONIZED
&nbsp;                | Modifier.NATIVE;
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getStackSize() {
<b class="fc">&nbsp;            return getParameters().asTypeList().getStackSize() + (isStatic() ? 0 : 1);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isMethod() {
<b class="fc">&nbsp;            return !isConstructor() &amp;&amp; !isTypeInitializer();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return CONSTRUCTOR_INTERNAL_NAME.equals(getInternalName());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return TYPE_INITIALIZER_INTERNAL_NAME.equals(getInternalName());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean represents(Method method) {
<b class="fc">&nbsp;            return equals(new ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;            return equals(new ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return isMethod()</b>
<b class="fc">&nbsp;                    ? getInternalName()</b>
<b class="fc">&nbsp;                    : getDeclaringType().asErasure().getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getActualName() {
<b class="fc">&nbsp;            return isMethod()</b>
<b class="fc">&nbsp;                    ? getName()</b>
<b class="fc">&nbsp;                    : EMPTY_NAME;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            StringBuilder descriptor = new StringBuilder().append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            for (TypeDescription parameterType : getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                descriptor.append(parameterType.getDescriptor());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return descriptor.append(&#39;)&#39;).append(getReturnType().asErasure().getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public String getGenericSignature() {
&nbsp;            try {
<b class="fc">&nbsp;                SignatureWriter signatureWriter = new SignatureWriter();</b>
<b class="fc">&nbsp;                boolean generic = false;</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic typeVariable : getTypeVariables()) {</b>
<b class="fc">&nbsp;                    signatureWriter.visitFormalTypeParameter(typeVariable.getSymbol());</b>
<b class="fc">&nbsp;                    boolean classBound = true;</b>
<b class="fc">&nbsp;                    for (TypeDescription.Generic upperBound : typeVariable.getUpperBounds()) {</b>
<b class="fc">&nbsp;                        upperBound.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(classBound</b>
<b class="fc">&nbsp;                                ? signatureWriter.visitClassBound()</b>
<b class="fc">&nbsp;                                : signatureWriter.visitInterfaceBound()));</b>
<b class="fc">&nbsp;                        classBound = false;</b>
<b class="fc">&nbsp;                    }</b>
<b class="fc">&nbsp;                    generic = true;</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic parameterType : getParameters().asTypeList()) {</b>
<b class="fc">&nbsp;                    parameterType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitParameterType()));</b>
<b class="fc">&nbsp;                    generic = generic || !parameterType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                TypeDescription.Generic returnType = getReturnType();</b>
<b class="fc">&nbsp;                returnType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitReturnType()));</b>
<b class="fc">&nbsp;                generic = generic || !returnType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                TypeList.Generic exceptionTypes = getExceptionTypes();</b>
<b class="fc">&nbsp;                if (!exceptionTypes.filter(not(ofSort(TypeDefinition.Sort.NON_GENERIC))).isEmpty()) {</b>
<b class="fc">&nbsp;                    for (TypeDescription.Generic exceptionType : exceptionTypes) {</b>
<b class="fc">&nbsp;                        exceptionType.accept(new TypeDescription.Generic.Visitor.ForSignatureVisitor(signatureWriter.visitExceptionType()));</b>
<b class="fc">&nbsp;                        generic = generic || !exceptionType.getSort().isNonGeneric();</b>
<b class="fc">&nbsp;                    }</b>
&nbsp;                }
<b class="fc">&nbsp;                return generic</b>
<b class="fc">&nbsp;                        ? signatureWriter.toString()</b>
<b class="fc">&nbsp;                        : NON_GENERIC_SIGNATURE;</b>
<b class="nc">&nbsp;            } catch (GenericSignatureFormatError ignored) {</b>
<b class="nc">&nbsp;                return NON_GENERIC_SIGNATURE;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getActualModifiers() {
<b class="fc">&nbsp;            return getModifiers() | (getDeclaredAnnotations().isAnnotationPresent(Deprecated.class)</b>
<b class="fc">&nbsp;                    ? Opcodes.ACC_DEPRECATED</b>
<b class="fc">&nbsp;                    : EMPTY_MASK);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getActualModifiers(boolean manifest) {
<b class="fc">&nbsp;            int modifiers = getActualModifiers();</b>
<b class="fc">&nbsp;            if (manifest) {</b>
<b class="fc">&nbsp;                return modifiers &amp; ~(Opcodes.ACC_ABSTRACT | Opcodes.ACC_NATIVE);</b>
<b class="fc">&nbsp;            } else if ((modifiers &amp; (Opcodes.ACC_NATIVE | Opcodes.ACC_ABSTRACT)) == 0) {</b>
<b class="fc">&nbsp;                return modifiers | Opcodes.ACC_ABSTRACT;</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return modifiers;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getActualModifiers(boolean manifest, Visibility visibility) {
<b class="fc">&nbsp;            return ModifierContributor.Resolver.of(Collections.singleton(getVisibility().expandTo(visibility))).resolve(getActualModifiers(manifest));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isVisibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return (isVirtual() || getDeclaringType().asErasure().isVisibleTo(typeDescription))</b>
<b class="fc">&nbsp;                    &amp;&amp; (isPublic()</b>
<b class="fc">&nbsp;                    || typeDescription.equals(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || isProtected() &amp;&amp; getDeclaringType().asErasure().isAssignableFrom(typeDescription)</b>
<b class="fc">&nbsp;                    || !isPrivate() &amp;&amp; typeDescription.isSamePackage(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || isPrivate() &amp;&amp; typeDescription.isNestMateOf(getDeclaringType().asErasure()));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isAccessibleTo(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return (isVirtual() || getDeclaringType().asErasure().isVisibleTo(typeDescription))</b>
<b class="fc">&nbsp;                    &amp;&amp; (isPublic()</b>
<b class="fc">&nbsp;                    || typeDescription.equals(getDeclaringType().asErasure())</b>
<b class="fc">&nbsp;                    || !isPrivate() &amp;&amp; typeDescription.isSamePackage(getDeclaringType().asErasure()))</b>
<b class="fc">&nbsp;                    || isPrivate() &amp;&amp; typeDescription.isNestMateOf(getDeclaringType().asErasure());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isVirtual() {
<b class="fc">&nbsp;            return !(isConstructor() || isPrivate() || isStatic() || isTypeInitializer());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isDefaultMethod() {
<b class="fc">&nbsp;            return !isAbstract() &amp;&amp; !isBridge() &amp;&amp; getDeclaringType().isInterface();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSpecializableFor(TypeDescription targetType) {
<b class="fc">&nbsp;            if (isStatic()) { // Static private methods are never specializable, check static property first</b>
<b class="fc">&nbsp;                return false;</b>
<b class="fc">&nbsp;            } else if (isPrivate() || isConstructor()) {</b>
<b class="fc">&nbsp;                return getDeclaringType().equals(targetType);</b>
&nbsp;            } else {
<b class="fc">&nbsp;                return !isAbstract() &amp;&amp; getDeclaringType().asErasure().isAssignableFrom(targetType);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public &lt;T&gt; T getDefaultValue(Class&lt;T&gt; type) {
<b class="nc">&nbsp;            return type.cast(getDefaultValue());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInvokableOn(TypeDescription typeDescription) {
<b class="fc">&nbsp;            return !isStatic()</b>
<b class="fc">&nbsp;                    &amp;&amp; !isTypeInitializer()</b>
<b class="fc">&nbsp;                    &amp;&amp; isVisibleTo(typeDescription)</b>
<b class="fc">&nbsp;                    &amp;&amp; (isVirtual()</b>
<b class="fc">&nbsp;                    ? getDeclaringType().asErasure().isAssignableFrom(typeDescription)</b>
<b class="fc">&nbsp;                    : getDeclaringType().asErasure().equals(typeDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if this method is a bootstrap method while expecting the supplied type as a type representation.
&nbsp;         *
&nbsp;         * @param bootstrapped The type of the bootstrap method&#39;s type representation.
&nbsp;         * @return {@code true} if this method is a bootstrap method assuming the supplied type representation.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        private boolean isBootstrap(TypeDescription bootstrapped) {
<b class="fc">&nbsp;            TypeList parameterTypes = getParameters().asTypeList().asErasures();</b>
<b class="fc">&nbsp;            switch (parameterTypes.size()) {</b>
&nbsp;                case 0:
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                case 1:
<b class="fc">&nbsp;                    return parameterTypes.getOnly().represents(Object[].class);</b>
&nbsp;                case 2:
<b class="fc">&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo(parameterTypes.get(0))</b>
<b class="fc">&nbsp;                            &amp;&amp; parameterTypes.get(1).represents(Object[].class);</b>
&nbsp;                case 3:
<b class="fc">&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo(parameterTypes.get(0))</b>
<b class="fc">&nbsp;                            &amp;&amp; (parameterTypes.get(1).represents(Object.class) || parameterTypes.get(1).represents(String.class))</b>
<b class="fc">&nbsp;                            &amp;&amp; (parameterTypes.get(2).isArray() &amp;&amp; parameterTypes.get(2).getComponentType().isAssignableFrom(bootstrapped) || parameterTypes.get(2).isAssignableFrom(bootstrapped));</b>
&nbsp;                default:
<b class="fc">&nbsp;                    return JavaType.METHOD_HANDLES_LOOKUP.getTypeStub().isAssignableTo(parameterTypes.get(0))</b>
<b class="fc">&nbsp;                            &amp;&amp; (parameterTypes.get(1).represents(Object.class) || parameterTypes.get(1).represents(String.class))</b>
<b class="fc">&nbsp;                            &amp;&amp; parameterTypes.get(2).isAssignableFrom(bootstrapped);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if this method is a bootstrap method given the supplied arguments. This method does not implement a full check but assumes that
&nbsp;         * {@link MethodDescription.AbstractBase#isBootstrap(TypeDescription)} is invoked, as well.
&nbsp;         *
&nbsp;         * @param arguments The types of the explicit arguments that are supplied to the bootstrap method.
&nbsp;         * @return {@code true} if this method is a bootstrap method for the supplied arguments.
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        private boolean isBootstrapping(List&lt;? extends TypeDefinition&gt; arguments) {
<b class="fc">&nbsp;            TypeList targets = getParameters().asTypeList().asErasures();</b>
<b class="fc">&nbsp;            if (targets.size() &lt; 4) {</b>
<b class="fc">&nbsp;                if (arguments.isEmpty()) {</b>
<b class="fc">&nbsp;                    return true;</b>
<b class="nc">&nbsp;                } else if (targets.get(targets.size() - 1).isArray()) {</b>
<b class="nc">&nbsp;                    for (TypeDefinition argument : arguments) {</b>
<b class="nc">&nbsp;                        if (!argument.asErasure().isAssignableTo(targets.get(targets.size() - 1).getComponentType())) {</b>
<b class="nc">&nbsp;                            return false;</b>
&nbsp;                        }
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                    return true;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            } else {
<b class="fc">&nbsp;                Iterator&lt;TypeDescription&gt; iterator = targets.subList(3, targets.size()).iterator();</b>
<b class="fc">&nbsp;                for (TypeDefinition type : arguments) {</b>
<b class="fc">&nbsp;                    if (!iterator.hasNext()) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    TypeDescription target = iterator.next();</b>
<b class="fc">&nbsp;                    if (!iterator.hasNext() &amp;&amp; target.isArray()) {</b>
<b class="fc">&nbsp;                        return true;</b>
<b class="fc">&nbsp;                    } else if (!type.asErasure().isAssignableTo(target)) {</b>
<b class="nc">&nbsp;                        return false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                }</b>
<b class="fc">&nbsp;                if (iterator.hasNext()) {</b>
<b class="fc">&nbsp;                    return iterator.next().isArray() &amp;&amp; !iterator.hasNext();</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    return true;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInvokeBootstrap() {
<b class="fc">&nbsp;            TypeDescription returnType = getReturnType().asErasure();</b>
<b class="fc">&nbsp;            if ((isMethod() &amp;&amp; (!isStatic()</b>
<b class="fc">&nbsp;                    || !(JavaType.CALL_SITE.getTypeStub().isAssignableFrom(returnType) || JavaType.CALL_SITE.getTypeStub().isAssignableTo(returnType))))</b>
<b class="fc">&nbsp;                    || (isConstructor() &amp;&amp; !JavaType.CALL_SITE.getTypeStub().isAssignableFrom(getDeclaringType().asErasure()))) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            return isBootstrap(JavaType.METHOD_TYPE.getTypeStub());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInvokeBootstrap(List&lt;? extends TypeDefinition&gt; arguments) {
<b class="fc">&nbsp;            return isInvokeBootstrap() &amp;&amp; isBootstrapping(arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isConstantBootstrap() {
<b class="fc">&nbsp;            return isBootstrap(TypeDescription.ForLoadedType.of(Class.class));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isConstantBootstrap(List&lt;? extends TypeDefinition&gt; arguments) {
<b class="fc">&nbsp;            return isConstantBootstrap() &amp;&amp; isBootstrapping(arguments);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isDefaultValue() {
<b class="fc">&nbsp;            return !isConstructor()</b>
<b class="fc">&nbsp;                    &amp;&amp; !isStatic()</b>
<b class="fc">&nbsp;                    &amp;&amp; getReturnType().asErasure().isAnnotationReturnType()</b>
<b class="fc">&nbsp;                    &amp;&amp; getParameters().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressFBWarnings(value = &quot;NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE&quot;, justification = &quot;Assuming component type for array type.&quot;)
&nbsp;        public boolean isDefaultValue(AnnotationValue&lt;?, ?&gt; annotationValue) {
<b class="fc">&nbsp;            if (!isDefaultValue()) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription returnType = getReturnType().asErasure();</b>
<b class="fc">&nbsp;            Object value = annotationValue.resolve();</b>
<b class="fc">&nbsp;            return (returnType.represents(boolean.class) &amp;&amp; value instanceof Boolean)</b>
<b class="fc">&nbsp;                    || (returnType.represents(byte.class) &amp;&amp; value instanceof Byte)</b>
<b class="fc">&nbsp;                    || (returnType.represents(char.class) &amp;&amp; value instanceof Character)</b>
<b class="fc">&nbsp;                    || (returnType.represents(short.class) &amp;&amp; value instanceof Short)</b>
<b class="fc">&nbsp;                    || (returnType.represents(int.class) &amp;&amp; value instanceof Integer)</b>
<b class="fc">&nbsp;                    || (returnType.represents(long.class) &amp;&amp; value instanceof Long)</b>
<b class="fc">&nbsp;                    || (returnType.represents(float.class) &amp;&amp; value instanceof Float)</b>
<b class="fc">&nbsp;                    || (returnType.represents(double.class) &amp;&amp; value instanceof Double)</b>
<b class="fc">&nbsp;                    || (returnType.represents(String.class) &amp;&amp; value instanceof String)</b>
<b class="fc">&nbsp;                    || (returnType.isAssignableTo(Enum.class) &amp;&amp; value instanceof EnumerationDescription &amp;&amp; isEnumerationType(returnType, (EnumerationDescription) value))</b>
<b class="fc">&nbsp;                    || (returnType.isAssignableTo(Annotation.class) &amp;&amp; value instanceof AnnotationDescription &amp;&amp; isAnnotationType(returnType, (AnnotationDescription) value))</b>
<b class="fc">&nbsp;                    || (returnType.represents(Class.class) &amp;&amp; value instanceof TypeDescription)</b>
<b class="fc">&nbsp;                    || (returnType.represents(boolean[].class) &amp;&amp; value instanceof boolean[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(byte[].class) &amp;&amp; value instanceof byte[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(char[].class) &amp;&amp; value instanceof char[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(short[].class) &amp;&amp; value instanceof short[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(int[].class) &amp;&amp; value instanceof int[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(long[].class) &amp;&amp; value instanceof long[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(float[].class) &amp;&amp; value instanceof float[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(double[].class) &amp;&amp; value instanceof double[])</b>
<b class="fc">&nbsp;                    || (returnType.represents(String[].class) &amp;&amp; value instanceof String[])</b>
<b class="fc">&nbsp;                    || (returnType.isAssignableTo(Enum[].class) &amp;&amp; value instanceof EnumerationDescription[] &amp;&amp; isEnumerationType(returnType.getComponentType(), (EnumerationDescription[]) value))</b>
<b class="fc">&nbsp;                    || (returnType.isAssignableTo(Annotation[].class) &amp;&amp; value instanceof AnnotationDescription[] &amp;&amp; isAnnotationType(returnType.getComponentType(), (AnnotationDescription[]) value))</b>
<b class="fc">&nbsp;                    || (returnType.represents(Class[].class) &amp;&amp; value instanceof TypeDescription[]);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the supplied enumeration descriptions describe the correct enumeration type.
&nbsp;         *
&nbsp;         * @param enumerationType        The enumeration type to check for.
&nbsp;         * @param enumerationDescription The enumeration descriptions to check.
&nbsp;         * @return {@code true} if all enumeration descriptions represent the enumeration type in question.
&nbsp;         */
&nbsp;        private static boolean isEnumerationType(TypeDescription enumerationType, EnumerationDescription... enumerationDescription) {
<b class="fc">&nbsp;            for (EnumerationDescription anEnumerationDescription : enumerationDescription) {</b>
<b class="fc">&nbsp;                if (!anEnumerationDescription.getEnumerationType().equals(enumerationType)) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Checks if the supplied enumeration descriptions describe the correct annotation type.
&nbsp;         *
&nbsp;         * @param annotationType        The annotation type to check for.
&nbsp;         * @param annotationDescription The annotation descriptions to check.
&nbsp;         * @return {@code true} if all annotation descriptions represent the annotation type in question.
&nbsp;         */
&nbsp;        private static boolean isAnnotationType(TypeDescription annotationType, AnnotationDescription... annotationDescription) {
<b class="fc">&nbsp;            for (AnnotationDescription anAnnotationDescription : annotationDescription) {</b>
<b class="fc">&nbsp;                if (!anAnnotationDescription.getAnnotationType().equals(annotationType)) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeVariableSource getEnclosingSource() {
<b class="fc">&nbsp;            return isStatic()</b>
<b class="fc">&nbsp;                    ? TypeVariableSource.UNDEFINED</b>
<b class="fc">&nbsp;                    : getDeclaringType().asErasure();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isInferrable() {
<b class="nc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public &lt;T&gt; T accept(TypeVariableSource.Visitor&lt;T&gt; visitor) {
<b class="fc">&nbsp;            return visitor.onMethod(this.asDefined());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isGenerified() {
<b class="fc">&nbsp;            return !getTypeVariables().isEmpty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public MethodDescription.Token asToken(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            TypeDescription.Generic receiverType = getReceiverType();</b>
<b class="fc">&nbsp;            return new MethodDescription.Token(getInternalName(),</b>
<b class="fc">&nbsp;                    getModifiers(),</b>
<b class="fc">&nbsp;                    getTypeVariables().asTokenList(matcher),</b>
<b class="fc">&nbsp;                    getReturnType().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getParameters().asTokenList(matcher),</b>
<b class="fc">&nbsp;                    getExceptionTypes().accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)),</b>
<b class="fc">&nbsp;                    getDeclaredAnnotations(),</b>
<b class="fc">&nbsp;                    getDefaultValue(),</b>
<b class="fc">&nbsp;                    receiverType == null</b>
<b class="fc">&nbsp;                            ? TypeDescription.Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : receiverType.accept(new TypeDescription.Generic.Visitor.Substitutor.ForDetachment(matcher)));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public SignatureToken asSignatureToken() {
<b class="fc">&nbsp;            return new SignatureToken(getInternalName(), getReturnType().asErasure(), getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeToken asTypeToken() {
<b class="fc">&nbsp;            return new TypeToken(getReturnType().asErasure(), getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isBridgeCompatible(TypeToken typeToken) {
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; types = getParameters().asTypeList().asErasures(), bridgeTypes = typeToken.getParameterTypes();</b>
<b class="fc">&nbsp;            if (types.size() != bridgeTypes.size()) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            for (int index = 0; index &lt; types.size(); index++) {</b>
<b class="fc">&nbsp;                if (!types.get(index).equals(bridgeTypes.get(index)) &amp;&amp; (types.get(index).isPrimitive() || bridgeTypes.get(index).isPrimitive())) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;            TypeDescription returnType = getReturnType().asErasure(), bridgeReturnType = typeToken.getReturnType();</b>
<b class="fc">&nbsp;            return returnType.equals(bridgeReturnType) || (!returnType.isPrimitive() &amp;&amp; !bridgeReturnType.isPrimitive());</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int hashCode = 17 + getDeclaringType().hashCode();</b>
<b class="fc">&nbsp;            hashCode = 31 * hashCode + getInternalName().hashCode();</b>
<b class="fc">&nbsp;            hashCode = 31 * hashCode + getReturnType().asErasure().hashCode();</b>
<b class="fc">&nbsp;            return 31 * hashCode + getParameters().asTypeList().asErasures().hashCode();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="fc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof MethodDescription)) {</b>
<b class="fc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            MethodDescription methodDescription = (MethodDescription) other;</b>
<b class="fc">&nbsp;            return getInternalName().equals(methodDescription.getInternalName())</b>
<b class="fc">&nbsp;                    &amp;&amp; getDeclaringType().equals(methodDescription.getDeclaringType())</b>
<b class="fc">&nbsp;                    &amp;&amp; getReturnType().asErasure().equals(methodDescription.getReturnType().asErasure())</b>
<b class="fc">&nbsp;                    &amp;&amp; getParameters().asTypeList().asErasures().equals(methodDescription.getParameters().asTypeList().asErasures());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String toGenericString() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            int modifiers = getModifiers() &amp; SOURCE_MODIFIERS;</b>
<b class="fc">&nbsp;            if (modifiers != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (isMethod()) {</b>
<b class="fc">&nbsp;                stringBuilder.append(getReturnType().getActualName()).append(&#39; &#39;);</b>
<b class="fc">&nbsp;                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            stringBuilder.append(getName()).append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            boolean first = true;</b>
<b class="fc">&nbsp;            for (TypeDescription.Generic typeDescription : getParameters().asTypeList()) {</b>
<b class="fc">&nbsp;                if (!first) {</b>
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    first = false;</b>
&nbsp;                }
<b class="fc">&nbsp;                stringBuilder.append(typeDescription.getActualName());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            stringBuilder.append(&#39;)&#39;);</b>
<b class="fc">&nbsp;            TypeList.Generic exceptionTypes = getExceptionTypes();</b>
<b class="fc">&nbsp;            if (!exceptionTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&quot; throws &quot;);</b>
<b class="fc">&nbsp;                first = true;</b>
<b class="fc">&nbsp;                for (TypeDescription.Generic typeDescription : exceptionTypes) {</b>
<b class="fc">&nbsp;                    if (!first) {</b>
<b class="nc">&nbsp;                        stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        first = false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    stringBuilder.append(typeDescription.getActualName());</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="fc">&nbsp;            int modifiers = getModifiers() &amp; SOURCE_MODIFIERS;</b>
<b class="fc">&nbsp;            if (modifiers != EMPTY_MASK) {</b>
<b class="fc">&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            if (isMethod()) {</b>
<b class="fc">&nbsp;                stringBuilder.append(getReturnType().asErasure().getActualName()).append(&#39; &#39;);</b>
<b class="fc">&nbsp;                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
&nbsp;            }
<b class="fc">&nbsp;            stringBuilder.append(getName()).append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            boolean first = true;</b>
<b class="fc">&nbsp;            for (TypeDescription typeDescription : getParameters().asTypeList().asErasures()) {</b>
<b class="fc">&nbsp;                if (!first) {</b>
<b class="fc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    first = false;</b>
&nbsp;                }
<b class="fc">&nbsp;                stringBuilder.append(typeDescription.getActualName());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            stringBuilder.append(&#39;)&#39;);</b>
<b class="fc">&nbsp;            TypeList exceptionTypes = getExceptionTypes().asErasures();</b>
<b class="fc">&nbsp;            if (!exceptionTypes.isEmpty()) {</b>
<b class="fc">&nbsp;                stringBuilder.append(&quot; throws &quot;);</b>
<b class="fc">&nbsp;                first = true;</b>
<b class="fc">&nbsp;                for (TypeDescription typeDescription : exceptionTypes) {</b>
<b class="fc">&nbsp;                    if (!first) {</b>
<b class="fc">&nbsp;                        stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                    } else {
<b class="fc">&nbsp;                        first = false;</b>
&nbsp;                    }
<b class="fc">&nbsp;                    stringBuilder.append(typeDescription.getActualName());</b>
<b class="fc">&nbsp;                }</b>
&nbsp;            }
<b class="fc">&nbsp;            return stringBuilder.toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected String toSafeString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder();</b>
<b class="nc">&nbsp;            int modifiers = getModifiers() &amp; SOURCE_MODIFIERS;</b>
<b class="nc">&nbsp;            if (modifiers != EMPTY_MASK) {</b>
<b class="nc">&nbsp;                stringBuilder.append(Modifier.toString(modifiers)).append(&#39; &#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (isMethod()) {</b>
<b class="nc">&nbsp;                stringBuilder.append(getReturnType().asErasure().getActualName()).append(&#39; &#39;);</b>
<b class="nc">&nbsp;                stringBuilder.append(getDeclaringType().asErasure().getActualName()).append(&#39;.&#39;);</b>
&nbsp;            }
<b class="nc">&nbsp;            return stringBuilder.append(getName()).append(&quot;(?)&quot;).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of a method description for a loaded constructor.
&nbsp;     */
&nbsp;    class ForLoadedConstructor extends InDefinedShape.AbstractBase.ForLoadedExecutable&lt;Constructor&lt;?&gt;&gt; implements ParameterDescription.ForLoadedParameter.ParameterAnnotationSource {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable method description for a loaded constructor.
&nbsp;         *
&nbsp;         * @param constructor The loaded constructor to be represented by this method description.
&nbsp;         */
&nbsp;        public ForLoadedConstructor(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;            super(constructor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(executable.getDeclaringClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;parameters&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;            return ParameterList.ForLoadedExecutable.of(executable, this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return new TypeList.Generic.OfConstructorExceptionTypes(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean represents(Method method) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;            return executable.equals(constructor) || equals(new MethodDescription.ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return executable.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return executable.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSynthetic() {
<b class="fc">&nbsp;            return executable.isSynthetic();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return CONSTRUCTOR_INTERNAL_NAME;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return Type.getConstructorDescriptor(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @AlwaysNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return AnnotationValue.UNDEFINED;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(executable.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;parameterAnnotations&quot;)
&nbsp;        public Annotation[][] getParameterAnnotations() {
<b class="fc">&nbsp;            return executable.getParameterAnnotations();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An implementation of a method description for a loaded method.
&nbsp;     */
&nbsp;    class ForLoadedMethod extends InDefinedShape.AbstractBase.ForLoadedExecutable&lt;Method&gt; implements ParameterDescription.ForLoadedParameter.ParameterAnnotationSource {
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new immutable method description for a loaded method.
&nbsp;         *
&nbsp;         * @param method The loaded method to be represented by this method description.
&nbsp;         */
&nbsp;        public ForLoadedMethod(Method method) {
<b class="fc">&nbsp;            super(method);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return TypeDescription.ForLoadedType.of(executable.getDeclaringClass());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(executable.getReturnType());</b>
&nbsp;            }
<b class="fc">&nbsp;            return new TypeDescription.Generic.LazyProjection.ForLoadedReturnType(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;parameters&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;            return ParameterList.ForLoadedExecutable.of(executable, this);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return new TypeList.Generic.ForLoadedTypes(executable.getExceptionTypes());</b>
&nbsp;            }
<b class="fc">&nbsp;            return new TypeList.Generic.OfMethodExceptionTypes(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isBridge() {
<b class="fc">&nbsp;            return executable.isBridge();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean represents(Method method) {
<b class="fc">&nbsp;            return executable.equals(method) || equals(new MethodDescription.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean represents(Constructor&lt;?&gt; constructor) {
<b class="fc">&nbsp;            return false;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return executable.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return executable.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isSynthetic() {
<b class="fc">&nbsp;            return executable.isSynthetic();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return executable.getName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            return Type.getMethodDescriptor(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the loaded method that is represented by this method description.
&nbsp;         *
&nbsp;         * @return The loaded method that is represented by this method description.
&nbsp;         */
&nbsp;        public Method getLoadedMethod() {
<b class="fc">&nbsp;            return executable;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;declaredAnnotations&quot;)
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.ForLoadedAnnotations(executable.getDeclaredAnnotations());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            Object value = executable.getDefaultValue();</b>
<b class="fc">&nbsp;            return value == null</b>
<b class="fc">&nbsp;                    ? AnnotationValue.UNDEFINED</b>
<b class="fc">&nbsp;                    : AnnotationDescription.ForLoadedAnnotation.asValue(value, executable.getReturnType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            if (TypeDescription.AbstractBase.RAW_TYPES) {</b>
<b class="nc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
<b class="fc">&nbsp;            return TypeList.Generic.ForLoadedTypes.OfTypeVariables.of(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @CachedReturnPlugin.Enhance(&quot;parameterAnnotations&quot;)
&nbsp;        public Annotation[][] getParameterAnnotations() {
<b class="fc">&nbsp;            return executable.getParameterAnnotations();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A latent method description describes a method that is not attached to a declaring
&nbsp;     * {@link TypeDescription}.
&nbsp;     */
&nbsp;    class Latent extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;        /**
&nbsp;         * The type that is declaring this method.
&nbsp;         */
&nbsp;        private final TypeDescription declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The internal name of this method.
&nbsp;         */
&nbsp;        private final String internalName;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of this method.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * A tokenized list representing the method&#39;s type variables.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariables;
&nbsp;
&nbsp;        /**
&nbsp;         * The return type of this method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter tokens describing this method.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * This method&#39;s exception types.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of this method.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; declaredAnnotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The default value of this method or {@code null} if no default annotation value is defined.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;        /**
&nbsp;         * The receiver type of this method or {@code null} if the receiver type is defined implicitly.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final TypeDescription.Generic receiverType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent method description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringType The declaring type of the method.
&nbsp;         * @param token         A token representing the method&#39;s shape.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType, MethodDescription.Token token) {
<b class="fc">&nbsp;            this(declaringType,</b>
<b class="fc">&nbsp;                    token.getName(),</b>
<b class="fc">&nbsp;                    token.getModifiers(),</b>
<b class="fc">&nbsp;                    token.getTypeVariableTokens(),</b>
<b class="fc">&nbsp;                    token.getReturnType(),</b>
<b class="fc">&nbsp;                    token.getParameterTokens(),</b>
<b class="fc">&nbsp;                    token.getExceptionTypes(),</b>
<b class="fc">&nbsp;                    token.getAnnotations(),</b>
<b class="fc">&nbsp;                    token.getDefaultValue(),</b>
<b class="fc">&nbsp;                    token.getReceiverType());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new latent method description. All provided types are attached to this instance before they are returned.
&nbsp;         *
&nbsp;         * @param declaringType       The type that is declaring this method.
&nbsp;         * @param internalName        The internal name of this method.
&nbsp;         * @param modifiers           The modifiers of this method.
&nbsp;         * @param typeVariables       The type variables of the described method.
&nbsp;         * @param returnType          The return type of this method.
&nbsp;         * @param parameterTokens     The parameter tokens describing this method.
&nbsp;         * @param exceptionTypes      This method&#39;s exception types.
&nbsp;         * @param declaredAnnotations The annotations of this method.
&nbsp;         * @param defaultValue        The default value of this method or {@code null} if no default annotation value is defined.
&nbsp;         * @param receiverType        The receiver type of this method or {@code null} if the receiver type is defined implicitly.
&nbsp;         */
&nbsp;        public Latent(TypeDescription declaringType,
&nbsp;                      String internalName,
&nbsp;                      int modifiers,
&nbsp;                      List&lt;? extends TypeVariableToken&gt; typeVariables,
&nbsp;                      TypeDescription.Generic returnType,
&nbsp;                      List&lt;? extends ParameterDescription.Token&gt; parameterTokens,
&nbsp;                      List&lt;? extends TypeDescription.Generic&gt; exceptionTypes,
&nbsp;                      List&lt;? extends AnnotationDescription&gt; declaredAnnotations,
&nbsp;                      @MaybeNull AnnotationValue&lt;?, ?&gt; defaultValue,
<b class="fc">&nbsp;                      @MaybeNull TypeDescription.Generic receiverType) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.internalName = internalName;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.typeVariables = typeVariables;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTokens = parameterTokens;</b>
<b class="fc">&nbsp;            this.exceptionTypes = exceptionTypes;</b>
<b class="fc">&nbsp;            this.declaredAnnotations = declaredAnnotations;</b>
<b class="fc">&nbsp;            this.defaultValue = defaultValue;</b>
<b class="fc">&nbsp;            this.receiverType = receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return TypeList.Generic.ForDetachedTypes.attachVariables(this, typeVariables);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return returnType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;            return new ParameterList.ForTokens(this, parameterTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return TypeList.Generic.ForDetachedTypes.attach(this, exceptionTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(declaredAnnotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return internalName;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return defaultValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;            return receiverType == null</b>
<b class="fc">&nbsp;                    ? super.getReceiverType()</b>
<b class="fc">&nbsp;                    : receiverType.accept(TypeDescription.Generic.Visitor.Substitutor.ForAttachment.of(this));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A method description that represents the type initializer.
&nbsp;         */
&nbsp;        public static class TypeInitializer extends InDefinedShape.AbstractBase {
&nbsp;
&nbsp;            /**
&nbsp;             * The type for which the type initializer should be represented.
&nbsp;             */
&nbsp;            private final TypeDescription typeDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new method description representing the type initializer.
&nbsp;             *
&nbsp;             * @param typeDescription The type for which the type initializer should be represented.
&nbsp;             */
<b class="fc">&nbsp;            public TypeInitializer(TypeDescription typeDescription) {</b>
<b class="fc">&nbsp;                this.typeDescription = typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;                return TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ParameterList&lt;ParameterDescription.InDefinedShape&gt; getParameters() {
<b class="fc">&nbsp;                return new ParameterList.Empty&lt;ParameterDescription.InDefinedShape&gt;();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @AlwaysNull
&nbsp;            public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="nc">&nbsp;                return AnnotationValue.UNDEFINED;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;                return new TypeList.Generic.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;                return new AnnotationList.Empty();</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            @Nonnull
&nbsp;            public TypeDescription getDeclaringType() {
<b class="fc">&nbsp;                return typeDescription;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int getModifiers() {
<b class="fc">&nbsp;                return TYPE_INITIALIZER_MODIFIER;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public String getInternalName() {
<b class="fc">&nbsp;                return MethodDescription.TYPE_INITIALIZER_INTERNAL_NAME;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A method description that represents a given method but with substituted method types.
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase implements InGenericShape {
&nbsp;
&nbsp;        /**
&nbsp;         * The type that declares this type-substituted method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic declaringType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method description.
&nbsp;         */
&nbsp;        private final MethodDescription methodDescription;
&nbsp;
&nbsp;        /**
&nbsp;         * A visitor that is applied to the method type.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a method description with substituted method types.
&nbsp;         *
&nbsp;         * @param declaringType     The type that is declaring the substituted method.
&nbsp;         * @param methodDescription The represented method description.
&nbsp;         * @param visitor           A visitor that is applied to the method type.
&nbsp;         */
&nbsp;        public TypeSubstituting(TypeDescription.Generic declaringType,
&nbsp;                                MethodDescription methodDescription,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringType = declaringType;</b>
<b class="fc">&nbsp;            this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return methodDescription.getReturnType().accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getTypeVariables() {
<b class="fc">&nbsp;            return methodDescription.getTypeVariables().accept(visitor).filter(ElementMatchers.ofSort(TypeDefinition.Sort.VARIABLE));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ParameterList&lt;ParameterDescription.InGenericShape&gt; getParameters() {
<b class="fc">&nbsp;            return new ParameterList.TypeSubstituting(this, methodDescription.getParameters(), visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return new TypeList.Generic.ForDetachedTypes(methodDescription.getExceptionTypes(), visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return methodDescription.getDefaultValue();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;            TypeDescription.Generic receiverType = methodDescription.getReceiverType();</b>
<b class="fc">&nbsp;            return receiverType == null</b>
<b class="nc">&nbsp;                    ? TypeDescription.Generic.UNDEFINED</b>
<b class="fc">&nbsp;                    : receiverType.accept(visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public AnnotationList getDeclaredAnnotations() {
<b class="fc">&nbsp;            return methodDescription.getDeclaredAnnotations();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @Nonnull
&nbsp;        public TypeDescription.Generic getDeclaringType() {
<b class="fc">&nbsp;            return declaringType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return methodDescription.getModifiers();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public String getInternalName() {
<b class="fc">&nbsp;            return methodDescription.getInternalName();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public InDefinedShape asDefined() {
<b class="fc">&nbsp;            return methodDescription.asDefined();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isConstructor() {
<b class="fc">&nbsp;            return methodDescription.isConstructor();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isMethod() {
<b class="fc">&nbsp;            return methodDescription.isMethod();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean isTypeInitializer() {
<b class="fc">&nbsp;            return methodDescription.isTypeInitializer();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a method&#39;s properties detached from a type.
&nbsp;     */
&nbsp;    class Token implements ByteCodeElement.Token&lt;Token&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The internal name of the represented method.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The modifiers of the represented method.
&nbsp;         */
&nbsp;        private final int modifiers;
&nbsp;
&nbsp;        /**
&nbsp;         * A list of tokens representing the method&#39;s type variables.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeVariableToken&gt; typeVariableTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * The return type of the represented method.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter tokens of the represented method.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; parameterTokens;
&nbsp;
&nbsp;        /**
&nbsp;         * The exception types of the represented method.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription.Generic&gt; exceptionTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * The annotations of the represented method.
&nbsp;         */
&nbsp;        private final List&lt;? extends AnnotationDescription&gt; annotations;
&nbsp;
&nbsp;        /**
&nbsp;         * The default value of the represented method or {@code null} if no such value exists.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final AnnotationValue&lt;?, ?&gt; defaultValue;
&nbsp;
&nbsp;        /**
&nbsp;         * The receiver type of the represented method or {@code null} if the receiver type is implicit.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        private final TypeDescription.Generic receiverType;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method token representing a constructor without any parameters, exception types, type variables or annotations.
&nbsp;         * All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param modifiers The constructor&#39;s modifiers.
&nbsp;         */
&nbsp;        public Token(int modifiers) {
<b class="fc">&nbsp;            this(MethodDescription.CONSTRUCTOR_INTERNAL_NAME, modifiers, TypeDescription.Generic.OfNonGenericType.ForLoadedType.of(void.class));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method token representing a method without any parameters, exception types, type variables or annotations.
&nbsp;         * All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param name       The name of the method.
&nbsp;         * @param modifiers  The modifiers of the method.
&nbsp;         * @param returnType The return type of the method.
&nbsp;         */
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType) {
<b class="fc">&nbsp;            this(name, modifiers, returnType, Collections.&lt;TypeDescription.Generic&gt;emptyList());</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new method token with simple values. All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param name           The internal name of the represented method.
&nbsp;         * @param modifiers      The modifiers of the represented method.
&nbsp;         * @param returnType     The return type of the represented method.
&nbsp;         * @param parameterTypes The parameter types of this method.
&nbsp;         */
&nbsp;        public Token(String name, int modifiers, TypeDescription.Generic returnType, List&lt;? extends TypeDescription.Generic&gt; parameterTypes) {
<b class="fc">&nbsp;            this(name,</b>
&nbsp;                    modifiers,
<b class="fc">&nbsp;                    Collections.&lt;TypeVariableToken&gt;emptyList(),</b>
&nbsp;                    returnType,
&nbsp;                    new ParameterDescription.Token.TypeList(parameterTypes),
<b class="fc">&nbsp;                    Collections.&lt;TypeDescription.Generic&gt;emptyList(),</b>
<b class="fc">&nbsp;                    Collections.&lt;AnnotationDescription&gt;emptyList(),</b>
&nbsp;                    AnnotationValue.UNDEFINED,
&nbsp;                    TypeDescription.Generic.UNDEFINED);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new token for a method description. All types must be represented in an detached format.
&nbsp;         *
&nbsp;         * @param name               The internal name of the represented method.
&nbsp;         * @param modifiers          The modifiers of the represented method.
&nbsp;         * @param typeVariableTokens The type variables of the the represented method.
&nbsp;         * @param returnType         The return type of the represented method.
&nbsp;         * @param parameterTokens    The parameter tokens of the represented method.
&nbsp;         * @param exceptionTypes     The exception types of the represented method.
&nbsp;         * @param annotations        The annotations of the represented method.
&nbsp;         * @param defaultValue       The default value of the represented method or {@code null} if no such value exists.
&nbsp;         * @param receiverType       The receiver type of the represented method or {@code null} if the receiver type is implicit.
&nbsp;         */
&nbsp;        public Token(String name,
&nbsp;                     int modifiers,
&nbsp;                     List&lt;? extends TypeVariableToken&gt; typeVariableTokens,
&nbsp;                     TypeDescription.Generic returnType,
&nbsp;                     List&lt;? extends ParameterDescription.Token&gt; parameterTokens,
&nbsp;                     List&lt;? extends TypeDescription.Generic&gt; exceptionTypes,
&nbsp;                     List&lt;? extends AnnotationDescription&gt; annotations,
&nbsp;                     @MaybeNull AnnotationValue&lt;?, ?&gt; defaultValue,
<b class="fc">&nbsp;                     @MaybeNull TypeDescription.Generic receiverType) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.modifiers = modifiers;</b>
<b class="fc">&nbsp;            this.typeVariableTokens = typeVariableTokens;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTokens = parameterTokens;</b>
<b class="fc">&nbsp;            this.exceptionTypes = exceptionTypes;</b>
<b class="fc">&nbsp;            this.annotations = annotations;</b>
<b class="fc">&nbsp;            this.defaultValue = defaultValue;</b>
<b class="fc">&nbsp;            this.receiverType = receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the internal name of the represented method.
&nbsp;         *
&nbsp;         * @return The internal name of the represented method.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the modifiers of the represented method.
&nbsp;         *
&nbsp;         * @return The modifiers of the represented method.
&nbsp;         */
&nbsp;        public int getModifiers() {
<b class="fc">&nbsp;            return modifiers;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the type variables of this method token.
&nbsp;         *
&nbsp;         * @return A a list of tokens representing the method&#39;s type variables.
&nbsp;         */
&nbsp;        public TokenList&lt;TypeVariableToken&gt; getTypeVariableTokens() {
<b class="fc">&nbsp;            return new TokenList&lt;TypeVariableToken&gt;(typeVariableTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the return type of the represented method.
&nbsp;         *
&nbsp;         * @return The return type of the represented method.
&nbsp;         */
&nbsp;        public TypeDescription.Generic getReturnType() {
<b class="fc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the parameter tokens of the represented method.
&nbsp;         *
&nbsp;         * @return The parameter tokens of the represented method.
&nbsp;         */
&nbsp;        public TokenList&lt;ParameterDescription.Token&gt; getParameterTokens() {
<b class="fc">&nbsp;            return new TokenList&lt;ParameterDescription.Token&gt;(parameterTokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the exception types of the represented method.
&nbsp;         *
&nbsp;         * @return The exception types of the represented method.
&nbsp;         */
&nbsp;        public TypeList.Generic getExceptionTypes() {
<b class="fc">&nbsp;            return new TypeList.Generic.Explicit(exceptionTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the annotations of the represented method.
&nbsp;         *
&nbsp;         * @return The annotations of the represented method.
&nbsp;         */
&nbsp;        public AnnotationList getAnnotations() {
<b class="fc">&nbsp;            return new AnnotationList.Explicit(annotations);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the default value of the represented method.
&nbsp;         *
&nbsp;         * @return The default value of the represented method or {@code null} if no such value exists.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public AnnotationValue&lt;?, ?&gt; getDefaultValue() {
<b class="fc">&nbsp;            return defaultValue;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the receiver type of this token or {@code null} if the receiver type is implicit.
&nbsp;         *
&nbsp;         * @return The receiver type of this token or {@code null} if the receiver type is implicit.
&nbsp;         */
&nbsp;        @MaybeNull
&nbsp;        public TypeDescription.Generic getReceiverType() {
<b class="fc">&nbsp;            return receiverType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public Token accept(TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {
<b class="fc">&nbsp;            return new Token(name,</b>
&nbsp;                    modifiers,
<b class="fc">&nbsp;                    getTypeVariableTokens().accept(visitor),</b>
<b class="fc">&nbsp;                    returnType.accept(visitor),</b>
<b class="fc">&nbsp;                    getParameterTokens().accept(visitor),</b>
<b class="fc">&nbsp;                    getExceptionTypes().accept(visitor),</b>
&nbsp;                    annotations,
&nbsp;                    defaultValue,
<b class="fc">&nbsp;                    receiverType == null</b>
<b class="fc">&nbsp;                            ? TypeDescription.Generic.UNDEFINED</b>
<b class="fc">&nbsp;                            : receiverType.accept(visitor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a signature token that represents the method that is represented by this token.
&nbsp;         *
&nbsp;         * @param declaringType The declaring type of the method that this token represents.
&nbsp;         * @return A signature token representing this token.
&nbsp;         */
&nbsp;        public SignatureToken asSignatureToken(TypeDescription declaringType) {
<b class="fc">&nbsp;            TypeDescription.Generic.Visitor&lt;TypeDescription&gt; visitor = new TypeDescription.Generic.Visitor.Reducing(declaringType, typeVariableTokens);</b>
<b class="fc">&nbsp;            List&lt;TypeDescription&gt; parameters = new ArrayList&lt;TypeDescription&gt;(parameterTokens.size());</b>
<b class="fc">&nbsp;            for (ParameterDescription.Token parameter : parameterTokens) {</b>
<b class="fc">&nbsp;                parameters.add(parameter.getType().accept(visitor));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new SignatureToken(name, returnType.accept(visitor), parameters);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="nc">&nbsp;            int result = name.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + modifiers;</b>
<b class="nc">&nbsp;            result = 31 * result + typeVariableTokens.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + returnType.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + parameterTokens.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + exceptionTypes.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + annotations.hashCode();</b>
<b class="nc">&nbsp;            result = 31 * result + (defaultValue != null ? defaultValue.hashCode() : 0);</b>
<b class="nc">&nbsp;            result = 31 * result + (receiverType != null ? receiverType.hashCode() : 0);</b>
<b class="nc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (other == null || getClass() != other.getClass()) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            Token token = (Token) other;</b>
<b class="fc">&nbsp;            return modifiers == token.modifiers</b>
<b class="fc">&nbsp;                    &amp;&amp; name.equals(token.name)</b>
<b class="fc">&nbsp;                    &amp;&amp; typeVariableTokens.equals(token.typeVariableTokens)</b>
<b class="fc">&nbsp;                    &amp;&amp; returnType.equals(token.returnType)</b>
<b class="fc">&nbsp;                    &amp;&amp; parameterTokens.equals(token.parameterTokens)</b>
<b class="fc">&nbsp;                    &amp;&amp; exceptionTypes.equals(token.exceptionTypes)</b>
<b class="fc">&nbsp;                    &amp;&amp; annotations.equals(token.annotations)</b>
<b class="fc">&nbsp;                    &amp;&amp; (defaultValue != null ? defaultValue.equals(token.defaultValue) : token.defaultValue == null)</b>
<b class="fc">&nbsp;                    &amp;&amp; (receiverType != null ? receiverType.equals(token.receiverType) : token.receiverType == null);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            return &quot;MethodDescription.Token{&quot; +</b>
&nbsp;                    &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
&nbsp;                    &quot;, modifiers=&quot; + modifiers +
&nbsp;                    &quot;, typeVariableTokens=&quot; + typeVariableTokens +
&nbsp;                    &quot;, returnType=&quot; + returnType +
&nbsp;                    &quot;, parameterTokens=&quot; + parameterTokens +
&nbsp;                    &quot;, exceptionTypes=&quot; + exceptionTypes +
&nbsp;                    &quot;, annotations=&quot; + annotations +
&nbsp;                    &quot;, defaultValue=&quot; + defaultValue +
&nbsp;                    &quot;, receiverType=&quot; + receiverType +
&nbsp;                    &#39;}&#39;;
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a method&#39;s name and raw return and parameter types.
&nbsp;     */
&nbsp;    class SignatureToken {
&nbsp;
&nbsp;        /**
&nbsp;         * The internal name of the represented method.
&nbsp;         */
&nbsp;        private final String name;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw return type.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw parameter types.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type token.
&nbsp;         *
&nbsp;         * @param name          The internal name of the represented method.
&nbsp;         * @param returnType    The represented method&#39;s raw return type.
&nbsp;         * @param parameterType The represented method&#39;s raw parameter types.
&nbsp;         */
&nbsp;        public SignatureToken(String name, TypeDescription returnType, TypeDescription... parameterType) {
<b class="fc">&nbsp;            this(name, returnType, Arrays.asList(parameterType));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type token.
&nbsp;         *
&nbsp;         * @param name           The internal name of the represented method.
&nbsp;         * @param returnType     The represented method&#39;s raw return type.
&nbsp;         * @param parameterTypes The represented method&#39;s raw parameter types.
&nbsp;         */
<b class="fc">&nbsp;        public SignatureToken(String name, TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
<b class="fc">&nbsp;            this.name = name;</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns the internal name of the represented method.
&nbsp;         *
&nbsp;         * @return The internal name of the represented method.
&nbsp;         */
&nbsp;        public String getName() {
<b class="fc">&nbsp;            return name;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s return type.
&nbsp;         *
&nbsp;         * @return This token&#39;s return type.
&nbsp;         */
&nbsp;        public TypeDescription getReturnType() {
<b class="fc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s parameter types.
&nbsp;         *
&nbsp;         * @return This token&#39;s parameter types.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
<b class="fc">&nbsp;            return (List&lt;TypeDescription&gt;) parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this signature token as a type token.
&nbsp;         *
&nbsp;         * @return This signature token as a type token.
&nbsp;         */
&nbsp;        public TypeToken asTypeToken() {
<b class="fc">&nbsp;            return new TypeToken(returnType, parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns a method descriptor for this token.
&nbsp;         *
&nbsp;         * @return A method descriptor for this token.
&nbsp;         */
&nbsp;        public String getDescriptor() {
<b class="fc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(&#39;(&#39;);</b>
<b class="fc">&nbsp;            for (TypeDescription typeDescription : parameterTypes) {</b>
<b class="fc">&nbsp;                stringBuilder.append(typeDescription.getDescriptor());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(returnType.getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = name.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + returnType.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + parameterTypes.hashCode();</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof SignatureToken)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            SignatureToken signatureToken = (SignatureToken) other;</b>
<b class="fc">&nbsp;            return name.equals(signatureToken.name)</b>
<b class="fc">&nbsp;                    &amp;&amp; returnType.equals(signatureToken.returnType)</b>
<b class="fc">&nbsp;                    &amp;&amp; parameterTypes.equals(signatureToken.parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(returnType).append(&#39; &#39;).append(name).append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            boolean first = true;</b>
<b class="nc">&nbsp;            for (TypeDescription parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                if (first) {</b>
<b class="nc">&nbsp;                    first = false;</b>
&nbsp;                } else {
<b class="nc">&nbsp;                    stringBuilder.append(&#39;,&#39;);</b>
&nbsp;                }
<b class="nc">&nbsp;                stringBuilder.append(parameterType);</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A token representing a method&#39;s erased return and parameter types.
&nbsp;     */
&nbsp;    class TypeToken {
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw return type.
&nbsp;         */
&nbsp;        private final TypeDescription returnType;
&nbsp;
&nbsp;        /**
&nbsp;         * The represented method&#39;s raw parameter types.
&nbsp;         */
&nbsp;        private final List&lt;? extends TypeDescription&gt; parameterTypes;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type token.
&nbsp;         *
&nbsp;         * @param returnType     The represented method&#39;s raw return type.
&nbsp;         * @param parameterTypes The represented method&#39;s raw parameter types.
&nbsp;         */
<b class="fc">&nbsp;        public TypeToken(TypeDescription returnType, List&lt;? extends TypeDescription&gt; parameterTypes) {</b>
<b class="fc">&nbsp;            this.returnType = returnType;</b>
<b class="fc">&nbsp;            this.parameterTypes = parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s return type.
&nbsp;         *
&nbsp;         * @return This token&#39;s return type.
&nbsp;         */
&nbsp;        public TypeDescription getReturnType() {
<b class="fc">&nbsp;            return returnType;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Returns this token&#39;s parameter types.
&nbsp;         *
&nbsp;         * @return This token&#39;s parameter types.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public List&lt;TypeDescription&gt; getParameterTypes() {
<b class="fc">&nbsp;            return (List&lt;TypeDescription&gt;) parameterTypes;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        @CachedReturnPlugin.Enhance(&quot;hashCode&quot;)
&nbsp;        public int hashCode() {
<b class="fc">&nbsp;            int result = returnType.hashCode();</b>
<b class="fc">&nbsp;            result = 31 * result + parameterTypes.hashCode();</b>
<b class="fc">&nbsp;            return result;</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public boolean equals(@MaybeNull Object other) {
<b class="fc">&nbsp;            if (this == other) {</b>
<b class="nc">&nbsp;                return true;</b>
<b class="fc">&nbsp;            } else if (!(other instanceof TypeToken)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
<b class="fc">&nbsp;            TypeToken typeToken = (TypeToken) other;</b>
<b class="fc">&nbsp;            return returnType.equals(typeToken.returnType) &amp;&amp; parameterTypes.equals(typeToken.parameterTypes);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        public String toString() {
<b class="nc">&nbsp;            StringBuilder stringBuilder = new StringBuilder().append(&#39;(&#39;);</b>
<b class="nc">&nbsp;            for (TypeDescription parameterType : parameterTypes) {</b>
<b class="nc">&nbsp;                stringBuilder.append(parameterType.getDescriptor());</b>
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;            return stringBuilder.append(&#39;)&#39;).append(returnType.getDescriptor()).toString();</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
