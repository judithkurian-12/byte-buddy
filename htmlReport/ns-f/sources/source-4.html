


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=windows-1252"> 
  <title>Coverage Report > ParameterList</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">net.bytebuddy.description.method</a>
</div>

<h1>Coverage Summary for Class: ParameterList (net.bytebuddy.description.method)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
  <tr>
    <td class="name">ParameterList$AbstractBase</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (22/22)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$Empty</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$Explicit</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (5/5)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$Explicit$ForTypes</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (4/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable</td>
<td class="coverageStat">
  <span class="percent">
    75%
  </span>
  <span class="absValue">
    (6/8)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    71.4%
  </span>
  <span class="absValue">
    (10/14)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$Executable</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$OfConstructor</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$OfLegacyVmConstructor</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$OfLegacyVmMethod</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/6)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForLoadedExecutable$OfMethod</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (2/2)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$ForTokens</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (9/9)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$0UqiQIcR</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$68zHNVxe</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$AiQyAc2x</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$cDwGTQPZ</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$j2KxIJ5q</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$JPqRQRQP</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$nGG4Bycw</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$vy3NBcLp</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$Wx8Qs88P</td>
  </tr>
  <tr>
    <td class="name">ParameterList$MockitoMock$1727531334$auxiliary$ZiixVfQu</td>
  </tr>
  <tr>
    <td class="name">ParameterList$TypeSubstituting</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (3/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (6/6)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    81.4%
  </span>
  <span class="absValue">
    (35/43)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    81.4%
  </span>
  <span class="absValue">
    (70/86)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * Copyright 2014 - Present Rafael Winterhalter
&nbsp; *
&nbsp; * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
&nbsp; * you may not use this file except in compliance with the License.
&nbsp; * You may obtain a copy of the License at
&nbsp; *
&nbsp; *     http://www.apache.org/licenses/LICENSE-2.0
&nbsp; *
&nbsp; * Unless required by applicable law or agreed to in writing, software
&nbsp; * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
&nbsp; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
&nbsp; * See the License for the specific language governing permissions and
&nbsp; * limitations under the License.
&nbsp; */
&nbsp;package net.bytebuddy.description.method;
&nbsp;
&nbsp;import net.bytebuddy.build.AccessControllerPlugin;
&nbsp;import net.bytebuddy.description.ByteCodeElement;
&nbsp;import net.bytebuddy.description.type.TypeDefinition;
&nbsp;import net.bytebuddy.description.type.TypeDescription;
&nbsp;import net.bytebuddy.description.type.TypeList;
&nbsp;import net.bytebuddy.matcher.ElementMatcher;
&nbsp;import net.bytebuddy.matcher.FilterableList;
&nbsp;import net.bytebuddy.utility.dispatcher.JavaDispatcher;
&nbsp;
&nbsp;import java.lang.reflect.Constructor;
&nbsp;import java.lang.reflect.Method;
&nbsp;import java.security.PrivilegedAction;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.List;
&nbsp;
&nbsp;/**
&nbsp; * Represents a list of parameters of a method or a constructor.
&nbsp; *
&nbsp; * @param &lt;T&gt; The type of parameter descriptions represented by this list.
&nbsp; */
&nbsp;public interface ParameterList&lt;T extends ParameterDescription&gt; extends FilterableList&lt;T, ParameterList&lt;T&gt;&gt; {
&nbsp;
&nbsp;    /**
&nbsp;     * Transforms this list of parameters into a list of the types of the represented parameters.
&nbsp;     *
&nbsp;     * @return A list of types representing the parameters of this list.
&nbsp;     */
&nbsp;    TypeList.Generic asTypeList();
&nbsp;
&nbsp;    /**
&nbsp;     * Transforms the list of parameter descriptions into a list of detached tokens. All types that are matched by the provided
&nbsp;     * target type matcher are substituted by {@link net.bytebuddy.dynamic.TargetType}.
&nbsp;     *
&nbsp;     * @param matcher A matcher that indicates type substitution.
&nbsp;     * @return The transformed token list.
&nbsp;     */
&nbsp;    ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher);
&nbsp;
&nbsp;    /**
&nbsp;     * Returns this list of these parameter descriptions resolved to their defined shape.
&nbsp;     *
&nbsp;     * @return A list of parameters in their defined shape.
&nbsp;     */
&nbsp;    ParameterList&lt;ParameterDescription.InDefinedShape&gt; asDefined();
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if all parameters in this list define both an explicit name and an explicit modifier.
&nbsp;     *
&nbsp;     * @return {@code true} if all parameters in this list define both an explicit name and an explicit modifier.
&nbsp;     */
&nbsp;    boolean hasExplicitMetaData();
&nbsp;
&nbsp;    /**
&nbsp;     * An base implementation for a {@link ParameterList}.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of parameter descriptions represented by this list.
&nbsp;     */
<b class="fc">&nbsp;    abstract class AbstractBase&lt;S extends ParameterDescription&gt; extends FilterableList.AbstractBase&lt;S, ParameterList&lt;S&gt;&gt; implements ParameterList&lt;S&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasExplicitMetaData() {
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="fc">&nbsp;                if (!parameterDescription.isNamed() || !parameterDescription.hasModifiers()) {</b>
<b class="fc">&nbsp;                    return false;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            List&lt;ParameterDescription.Token&gt; tokens = new ArrayList&lt;ParameterDescription.Token&gt;(size());</b>
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="fc">&nbsp;                tokens.add(parameterDescription.asToken(matcher));</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt;(tokens);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic asTypeList() {
<b class="fc">&nbsp;            List&lt;TypeDescription.Generic&gt; types = new ArrayList&lt;TypeDescription.Generic&gt;(size());</b>
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="fc">&nbsp;                types.add(parameterDescription.getType());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new TypeList.Generic.Explicit(types);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; asDefined() {
<b class="fc">&nbsp;            List&lt;ParameterDescription.InDefinedShape&gt; declaredForms = new ArrayList&lt;ParameterDescription.InDefinedShape&gt;(size());</b>
<b class="fc">&nbsp;            for (ParameterDescription parameterDescription : this) {</b>
<b class="fc">&nbsp;                declaredForms.add(parameterDescription.asDefined());</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new Explicit&lt;ParameterDescription.InDefinedShape&gt;(declaredForms);</b>
&nbsp;        }
&nbsp;
&nbsp;        @Override
&nbsp;        protected ParameterList&lt;S&gt; wrap(List&lt;S&gt; values) {
<b class="fc">&nbsp;            return new Explicit&lt;S&gt;(values);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Represents a list of parameters for an executable, i.e. a {@link java.lang.reflect.Method} or {@link java.lang.reflect.Constructor}.
&nbsp;     *
&nbsp;     * @param &lt;T&gt; The type of the {@code java.lang.reflect.Executable} that this list represents.
&nbsp;     */
&nbsp;    abstract class ForLoadedExecutable&lt;T&gt; extends AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The dispatcher used creating parameter list instances and for accessing {@code java.lang.reflect.Executable} instances.
&nbsp;         */
<b class="fc">&nbsp;        protected static final Executable EXECUTABLE = doPrivileged(JavaDispatcher.of(Executable.class));</b>
&nbsp;
&nbsp;        /**
&nbsp;         * The executable for which a parameter list is represented.
&nbsp;         */
&nbsp;        protected final T executable;
&nbsp;
&nbsp;        /**
&nbsp;         * The parameter annotation source to query.
&nbsp;         */
&nbsp;        protected final ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new description for a loaded executable.
&nbsp;         *
&nbsp;         * @param executable                The executable for which a parameter list is represented.
&nbsp;         * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;         */
<b class="fc">&nbsp;        protected ForLoadedExecutable(T executable, ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {</b>
<b class="fc">&nbsp;            this.executable = executable;</b>
<b class="fc">&nbsp;            this.parameterAnnotationSource = parameterAnnotationSource;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A proxy for {@code java.security.AccessController#doPrivileged} that is activated if available.
&nbsp;         *
&nbsp;         * @param action The action to execute from a privileged context.
&nbsp;         * @param &lt;T&gt;    The type of the action&#39;s resolved value.
&nbsp;         * @return The action&#39;s resolved value.
&nbsp;         */
&nbsp;        @AccessControllerPlugin.Enhance
&nbsp;        private static &lt;T&gt; T doPrivileged(PrivilegedAction&lt;T&gt; action) {
<b class="fc">&nbsp;            return action.run();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list that describes the parameters of the given {@link Constructor}.
&nbsp;         *
&nbsp;         * @param constructor The constructor for which the parameters should be described.
&nbsp;         * @return A list describing the constructor&#39;s parameters.
&nbsp;         */
&nbsp;        public static ParameterList&lt;ParameterDescription.InDefinedShape&gt; of(Constructor&lt;?&gt; constructor) {
<b class="nc">&nbsp;            return of(constructor, new ParameterDescription.ForLoadedParameter.ParameterAnnotationSource.ForLoadedConstructor(constructor));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list that describes the parameters of the given {@link Constructor}.
&nbsp;         *
&nbsp;         * @param constructor               The constructor for which the parameters should be described.
&nbsp;         * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;         * @return A list describing the constructor&#39;s parameters.
&nbsp;         */
&nbsp;        public static ParameterList&lt;ParameterDescription.InDefinedShape&gt; of(Constructor&lt;?&gt; constructor,
&nbsp;                                                                            ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {
<b class="fc">&nbsp;            return EXECUTABLE.isInstance(constructor)</b>
<b class="fc">&nbsp;                    ? new OfConstructor(constructor, parameterAnnotationSource)</b>
<b class="nc">&nbsp;                    : new OfLegacyVmConstructor(constructor, parameterAnnotationSource);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list that describes the parameters of the given {@link Method}.
&nbsp;         *
&nbsp;         * @param method The method for which the parameters should be described.
&nbsp;         * @return A list describing the method&#39;s parameters.
&nbsp;         */
&nbsp;        public static ParameterList&lt;ParameterDescription.InDefinedShape&gt; of(Method method) {
<b class="nc">&nbsp;            return of(method, new ParameterDescription.ForLoadedParameter.ParameterAnnotationSource.ForLoadedMethod(method));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list that describes the parameters of the given {@link Method}.
&nbsp;         *
&nbsp;         * @param method                    The method for which the parameters should be described.
&nbsp;         * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;         * @return A list describing the method&#39;s parameters.
&nbsp;         */
&nbsp;        public static ParameterList&lt;ParameterDescription.InDefinedShape&gt; of(Method method,
&nbsp;                                                                            ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {
<b class="fc">&nbsp;            return EXECUTABLE.isInstance(method)</b>
<b class="fc">&nbsp;                    ? new OfMethod(method, parameterAnnotationSource)</b>
<b class="nc">&nbsp;                    : new OfLegacyVmMethod(method, parameterAnnotationSource);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int size() {
<b class="fc">&nbsp;            return EXECUTABLE.getParameterCount(executable);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A dispatcher for creating descriptions of parameter lists and for evaluating the size of an {@code java.lang.reflect.Executable}&#39;s parameters.
&nbsp;         */
&nbsp;        @JavaDispatcher.Proxied(&quot;java.lang.reflect.Executable&quot;)
&nbsp;        protected interface Executable {
&nbsp;
&nbsp;            /**
&nbsp;             * Checks if the supplied instance is a {@code java.lang.reflect.Executable}.
&nbsp;             *
&nbsp;             * @param value The value to check for being a {@code java.lang.reflect.Executable}.
&nbsp;             * @return {@code true} if the supplied instance is a {@code java.lang.reflect.Executable}.
&nbsp;             */
&nbsp;            @JavaDispatcher.Instance
&nbsp;            boolean isInstance(Object value);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the amount of parameters of a given executable..
&nbsp;             *
&nbsp;             * @param executable The executable for which the amount of parameters should be found.
&nbsp;             * @return The amount of parameters of the given executable.
&nbsp;             */
&nbsp;            int getParameterCount(Object executable);
&nbsp;
&nbsp;            /**
&nbsp;             * Returns the parameters of an executable.
&nbsp;             *
&nbsp;             * @param value The executable to introspect.
&nbsp;             * @return An array of the parameters of the supplied executable.
&nbsp;             */
&nbsp;            Object[] getParameters(Object value);
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes the list of {@link Constructor} parameters on a modern VM.
&nbsp;         */
&nbsp;        protected static class OfConstructor extends ForLoadedExecutable&lt;Constructor&lt;?&gt;&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description of the parameters of a constructor.
&nbsp;             *
&nbsp;             * @param constructor               The constructor that is represented by this instance.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
&nbsp;            protected OfConstructor(Constructor&lt;?&gt; constructor, ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {
<b class="fc">&nbsp;                super(constructor, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                return new ParameterDescription.ForLoadedParameter.OfConstructor(executable, index, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Describes the list of {@link Method} parameters on a modern VM.
&nbsp;         */
&nbsp;        protected static class OfMethod extends ForLoadedExecutable&lt;Method&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new description of the parameters of a method.
&nbsp;             *
&nbsp;             * @param method                    The method that is represented by this instance.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
&nbsp;            protected OfMethod(Method method, ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {
<b class="fc">&nbsp;                super(method, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                return new ParameterDescription.ForLoadedParameter.OfMethod(executable, index, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a list of constructor parameters on virtual machines where the {@code java.lang.reflect.Parameter}
&nbsp;         * type is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmConstructor extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented constructor.
&nbsp;             */
&nbsp;            private final Constructor&lt;?&gt; constructor;
&nbsp;
&nbsp;            /**
&nbsp;             * An array of this method&#39;s parameter types.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter annotation source to query.
&nbsp;             */
&nbsp;            private final ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a constructor&#39;s parameters.
&nbsp;             *
&nbsp;             * @param constructor               The constructor to represent.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
<b class="nc">&nbsp;            protected OfLegacyVmConstructor(Constructor&lt;?&gt; constructor, ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {</b>
<b class="nc">&nbsp;                this.constructor = constructor;</b>
<b class="nc">&nbsp;                this.parameterType = constructor.getParameterTypes();</b>
<b class="nc">&nbsp;                this.parameterAnnotationSource = parameterAnnotationSource;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="nc">&nbsp;                return new ParameterDescription.ForLoadedParameter.OfLegacyVmConstructor(constructor, index, parameterType, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int size() {
<b class="nc">&nbsp;                return parameterType.length;</b>
&nbsp;            }
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Represents a list of method parameters on virtual machines where the {@code java.lang.reflect.Parameter}
&nbsp;         * type is not available.
&nbsp;         */
&nbsp;        protected static class OfLegacyVmMethod extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The represented method.
&nbsp;             */
&nbsp;            private final Method method;
&nbsp;
&nbsp;            /**
&nbsp;             * An array of this method&#39;s parameter types.
&nbsp;             */
&nbsp;            private final Class&lt;?&gt;[] parameterType;
&nbsp;
&nbsp;            /**
&nbsp;             * The parameter annotation source to query.
&nbsp;             */
&nbsp;            private final ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a legacy representation of a method&#39;s parameters.
&nbsp;             *
&nbsp;             * @param method                    The method to represent.
&nbsp;             * @param parameterAnnotationSource The parameter annotation source to query.
&nbsp;             */
<b class="nc">&nbsp;            protected OfLegacyVmMethod(Method method, ParameterDescription.ForLoadedParameter.ParameterAnnotationSource parameterAnnotationSource) {</b>
<b class="nc">&nbsp;                this.method = method;</b>
<b class="nc">&nbsp;                this.parameterType = method.getParameterTypes();</b>
<b class="nc">&nbsp;                this.parameterAnnotationSource = parameterAnnotationSource;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="nc">&nbsp;                return new ParameterDescription.ForLoadedParameter.OfLegacyVmMethod(method, index, parameterType, parameterAnnotationSource);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int size() {
<b class="nc">&nbsp;                return parameterType.length;</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of explicitly provided parameter descriptions.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of parameter descriptions represented by this list.
&nbsp;     */
&nbsp;    class Explicit&lt;S extends ParameterDescription&gt; extends AbstractBase&lt;S&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The list of parameter descriptions that are represented by this list.
&nbsp;         */
&nbsp;        private final List&lt;? extends S&gt; parameterDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list of explicit parameter descriptions.
&nbsp;         *
&nbsp;         * @param parameterDescription The list of parameter descriptions that are represented by this list.
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public Explicit(S... parameterDescription) {
<b class="fc">&nbsp;            this(Arrays.asList(parameterDescription));</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new list of explicit parameter descriptions.
&nbsp;         *
&nbsp;         * @param parameterDescriptions The list of parameter descriptions that are represented by this list.
&nbsp;         */
<b class="fc">&nbsp;        public Explicit(List&lt;? extends S&gt; parameterDescriptions) {</b>
<b class="fc">&nbsp;            this.parameterDescriptions = parameterDescriptions;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public S get(int index) {
<b class="fc">&nbsp;            return parameterDescriptions.get(index);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int size() {
<b class="fc">&nbsp;            return parameterDescriptions.size();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * A parameter list representing parameters without meta data or annotations.
&nbsp;         */
&nbsp;        public static class ForTypes extends ParameterList.AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;            /**
&nbsp;             * The method description that declares the parameters.
&nbsp;             */
&nbsp;            private final MethodDescription.InDefinedShape methodDescription;
&nbsp;
&nbsp;            /**
&nbsp;             * A list of detached types representing the parameters.
&nbsp;             */
&nbsp;            private final List&lt;? extends TypeDefinition&gt; typeDefinitions;
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new parameter type list.
&nbsp;             *
&nbsp;             * @param methodDescription The method description that declares the parameters.
&nbsp;             * @param typeDefinition    A list of detached types representing the parameters.
&nbsp;             */
&nbsp;            public ForTypes(MethodDescription.InDefinedShape methodDescription, TypeDefinition... typeDefinition) {
<b class="fc">&nbsp;                this(methodDescription, Arrays.asList(typeDefinition));</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * Creates a new parameter type list.
&nbsp;             *
&nbsp;             * @param methodDescription The method description that declares the parameters.
&nbsp;             * @param typeDefinitions   A list of detached types representing the parameters.
&nbsp;             */
<b class="fc">&nbsp;            public ForTypes(MethodDescription.InDefinedShape methodDescription, List&lt;? extends TypeDefinition&gt; typeDefinitions) {</b>
<b class="fc">&nbsp;                this.methodDescription = methodDescription;</b>
<b class="fc">&nbsp;                this.typeDefinitions = typeDefinitions;</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;                int offset = methodDescription.isStatic() ? 0 : 1;</b>
<b class="fc">&nbsp;                for (int previous = 0; previous &lt; index; previous++) {</b>
<b class="fc">&nbsp;                    offset += typeDefinitions.get(previous).getStackSize().getSize();</b>
&nbsp;                }
<b class="fc">&nbsp;                return new ParameterDescription.Latent(methodDescription, typeDefinitions.get(index).asGenericType(), index, offset);</b>
&nbsp;            }
&nbsp;
&nbsp;            /**
&nbsp;             * {@inheritDoc}
&nbsp;             */
&nbsp;            public int size() {
<b class="fc">&nbsp;                return typeDefinitions.size();</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of parameter descriptions for a list of detached tokens. For the returned parameter, each token is attached to its parameter representation.
&nbsp;     */
&nbsp;    class ForTokens extends AbstractBase&lt;ParameterDescription.InDefinedShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is declaring the represented token.
&nbsp;         */
&nbsp;        private final MethodDescription.InDefinedShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The list of tokens to represent.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription.Token&gt; tokens;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new parameter list for the provided tokens.
&nbsp;         *
&nbsp;         * @param declaringMethod The method that is declaring the represented token.
&nbsp;         * @param tokens          The list of tokens to represent.
&nbsp;         */
<b class="fc">&nbsp;        public ForTokens(MethodDescription.InDefinedShape declaringMethod, List&lt;? extends ParameterDescription.Token&gt; tokens) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.tokens = tokens;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ParameterDescription.InDefinedShape get(int index) {
<b class="fc">&nbsp;            int offset = declaringMethod.isStatic() ? 0 : 1;</b>
<b class="fc">&nbsp;            for (ParameterDescription.Token token : tokens.subList(0, index)) {</b>
<b class="fc">&nbsp;                offset += token.getType().getStackSize().getSize();</b>
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            return new ParameterDescription.Latent(declaringMethod, tokens.get(index), index, offset);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int size() {
<b class="fc">&nbsp;            return tokens.size();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * A list of parameter descriptions that yields {@link net.bytebuddy.description.method.ParameterDescription.TypeSubstituting}.
&nbsp;     */
&nbsp;    class TypeSubstituting extends AbstractBase&lt;ParameterDescription.InGenericShape&gt; {
&nbsp;
&nbsp;        /**
&nbsp;         * The method that is declaring the transformed parameters.
&nbsp;         */
&nbsp;        private final MethodDescription.InGenericShape declaringMethod;
&nbsp;
&nbsp;        /**
&nbsp;         * The untransformed parameters that are represented by this list.
&nbsp;         */
&nbsp;        private final List&lt;? extends ParameterDescription&gt; parameterDescriptions;
&nbsp;
&nbsp;        /**
&nbsp;         * The visitor to apply to the parameter types before returning them.
&nbsp;         */
&nbsp;        private final TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor;
&nbsp;
&nbsp;        /**
&nbsp;         * Creates a new type substituting parameter list.
&nbsp;         *
&nbsp;         * @param declaringMethod       The method that is declaring the transformed parameters.
&nbsp;         * @param parameterDescriptions The untransformed parameters that are represented by this list.
&nbsp;         * @param visitor               The visitor to apply to the parameter types before returning them.
&nbsp;         */
&nbsp;        public TypeSubstituting(MethodDescription.InGenericShape declaringMethod,
&nbsp;                                List&lt;? extends ParameterDescription&gt; parameterDescriptions,
<b class="fc">&nbsp;                                TypeDescription.Generic.Visitor&lt;? extends TypeDescription.Generic&gt; visitor) {</b>
<b class="fc">&nbsp;            this.declaringMethod = declaringMethod;</b>
<b class="fc">&nbsp;            this.parameterDescriptions = parameterDescriptions;</b>
<b class="fc">&nbsp;            this.visitor = visitor;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ParameterDescription.InGenericShape get(int index) {
<b class="fc">&nbsp;            return new ParameterDescription.TypeSubstituting(declaringMethod, parameterDescriptions.get(index), visitor);</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public int size() {
<b class="fc">&nbsp;            return parameterDescriptions.size();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * An empty list of parameters.
&nbsp;     *
&nbsp;     * @param &lt;S&gt; The type of parameter descriptions represented by this list.
&nbsp;     */
<b class="fc">&nbsp;    class Empty&lt;S extends ParameterDescription&gt; extends FilterableList.Empty&lt;S, ParameterList&lt;S&gt;&gt; implements ParameterList&lt;S&gt; {</b>
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public boolean hasExplicitMetaData() {
<b class="fc">&nbsp;            return true;</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public TypeList.Generic asTypeList() {
<b class="fc">&nbsp;            return new TypeList.Generic.Empty();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        public ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt; asTokenList(ElementMatcher&lt;? super TypeDescription&gt; matcher) {
<b class="fc">&nbsp;            return new ByteCodeElement.Token.TokenList&lt;ParameterDescription.Token&gt;();</b>
&nbsp;        }
&nbsp;
&nbsp;        /**
&nbsp;         * {@inheritDoc}
&nbsp;         */
&nbsp;        @SuppressWarnings(&quot;unchecked&quot;)
&nbsp;        public ParameterList&lt;ParameterDescription.InDefinedShape&gt; asDefined() {
<b class="fc">&nbsp;            return (ParameterList&lt;ParameterDescription.InDefinedShape&gt;) this;</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-03 11:00</div>
</div>
</body>
</html>
